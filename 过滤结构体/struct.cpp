



typedef struct tagNET_DVR_TIME_V30
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE    byISO8601;      /*是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 */
    WORD	wMilliSec;       //毫秒，精度不够，默认为0
    char    cTimeDifferenceH;  		//与UTC的时差（小时），-12 ... +14，+表示东区, byISO8601为1时有效
    char    cTimeDifferenceM;         	//与UTC的时差（分钟），-30, 30, 45，+表示东区，byISO8601为1时有效
}NET_DVR_TIME_V30, *LPNET_DVR_TIME_V30;

typedef struct tagNET_DVR_TIME_SEARCH
{
    WORD     wYear;        //年，设备OSD时间
    BYTE    byMonth;        //月，设备OSD时间
    BYTE     byDay;        //日，设备OSD时间
    BYTE     byHour;        //时，设备OSD时间
    BYTE     byMinute;    //分，设备OSD时间
    BYTE     bySecond;    //秒，设备OSD时间
    char cTimeDifferenceH;        //与国际标准时间的时差（小时），-12 ... +14
    char cTimeDifferenceM;        //与国际标准时间的时差（分钟），-30, 0, 30, 45
    BYTE     byLocalOrUTC;      //0-时差无效，设备本地时间，即设备OSD时间  1-时差有效
    WORD     wMillisecond;      //毫秒，精度不够，默认为0
}NET_DVR_TIME_SEARCH, *LPNET_DVR_TIME_SEARCH;

typedef struct tagNET_DVR_TIME_SEARCH_COND
{
    WORD wYear; //年 
    BYTE byMonth; //月
    BYTE byDay; //日
    BYTE byHour; //时
    BYTE byMinute; //分
    BYTE bySecond; //秒
    BYTE byLocalOrUTC; //0-时差无效，设备本地时间，即设备OSD时间  1-时差有效
    WORD wMillisecond;       //毫秒，精度不够，默认为0
    char cTimeDifferenceH;   //与UTC的时差（小时），-12 ... +14，+表示东区，byLocalOrUTC为1时有效
    char cTimeDifferenceM;   //与UTC的时差（分钟），-30, 0, 30, 45，+表示东区，byLocalOrUTC为1时有效
}NET_DVR_TIME_SEARCH_COND, *LPNET_DVR_TIME_SEARCH_COND;

typedef struct tagNET_DVR_TIME_V50
{
    WORD 		wYear;		//年 
    BYTE		byMonth;    //月
    BYTE 		byDay;		//日
    BYTE 		byHour;		//时
    BYTE 		byMinute;	//分
    BYTE 		bySecond;	//秒
    BYTE   	    byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    WORD  	    wMillisecond;       //毫秒，精度不够，默认为0
    char cTimeDifferenceH;   //与UTC的时差（小时），-12 ... +14，+表示东区，byISO8601为1时有效
    char cTimeDifferenceM;   //与UTC的时差（分钟），-30, 0, 30, 45，+表示东区，byISO8601为1时有效
}NET_DVR_TIME_V50, *LPNET_DVR_TIME_V50;

typedef struct  tagNET_DVR_CALIBRATE_TIME
{
    DWORD  dwSize;
    NET_DVR_TIME struTime;
    WORD wMilliSec;
    BYTE byRes[14];
}NET_DVR_CALIBRATE_TIME,*LPNET_DVR_CALIBRATE_TIME;


typedef struct tagNET_DVR_TIME_EX
{
    WORD wYear;
    BYTE byMonth;
    BYTE byDay;
    BYTE byHour;
    BYTE byMinute;
    BYTE bySecond;
    BYTE byRes;
}NET_DVR_TIME_EX,*LPNET_DVR_TIME_EX;


typedef struct tagNET_DVR_STRUCTHEAD
{
    WORD    wLength;        //结构长度
    BYTE    byVersion ;    /*高低4位分别代表高低版本，后续根据版本和长度进行扩展，不同的版本的长度进行限制*/
    BYTE    byRes;
}NET_DVR_STRUCTHEAD, *LPNET_DVR_STRUCTHEAD;

typedef struct tagNET_DVR_HANDLEEXCEPTION_V41
{    
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/
    /*0x400: 虚交侦测 联动 聚焦模式（提供可配置项，原先设备自动完成）IPC5.1.0*/
    /*0x800: PTZ联动跟踪(球机跟踪目标)*/
    /*0x4000:白光灯报警*/
    /*0x10000:短信报警*/
    /*0x20000:指示灯报警*/
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //触发报警通道  
    BYTE    byRes[64];           //保留
}NET_DVR_HANDLEEXCEPTION_V41, *LPNET_DVR_HANDLEEXCEPTION_V41;

typedef struct tagNET_DVR_HANDLEEXCEPTION_V40
{    
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x80: 报警触发录像(目前只有PCNVR支持) */
    /*0x100: 报警触发云台预置点 (目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/ 
    /*0x400: 虚交侦测 联动 聚焦模式（提供可配置项，原先设备自动完成）IPC5.1.0*/
    /*0x800: PTZ联动跟踪(球机跟踪目标)*/ 
    /*0x1000:抓图上传到云*/
    /*0x2000:短信报警*/
    /*0x4000:白光灯报警*/
    /*0x8000:语音报警*/
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数量
    DWORD   dwRelAlarmOutChanNum; //触发的报警输出通道数 实际支持数
    DWORD   dwRelAlarmOut[MAX_CHANNUM_V30]; //触发报警通道  
    BYTE    byWhiteLightDurationTime;//白光灯闪烁持续时长，1~60s(当开启了白光灯报警时生效)
    BYTE    byBrightness;//白光灯亮度，范围0-100，默认50
    BYTE    byAudioType;//声音报警类型
    BYTE    byTimes;//声音报警次数，范围：0-9，默认2, 0xff-持续
    BYTE    byRes[60];           //保留
}NET_DVR_HANDLEEXCEPTION_V40, *LPNET_DVR_HANDLEEXCEPTION_V40;






typedef struct tagNET_DVR_ADDRESS
{
    NET_DVR_IPADDR struIP; //IP地址
    WORD wPort;    //端口号
    BYTE byRes[2];
}NET_DVR_ADDRESS, *LPNET_DVR_ADDRESS;

typedef struct 
{
    NET_DVR_IPADDR    struDVRIP;                              //DVR IP地址
    NET_DVR_IPADDR    struDVRIPMask;  //DVR IP地址掩码
    DWORD    dwNetInterface;                                   //网络接口1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M自适应
    WORD    wDVRPort;                                        //端口号
    WORD    wMTU;                                            //增加MTU设置，默认1500。
    BYTE    byMACAddr[MACADDR_LEN];                            // 物理地址
    BYTE    byEthernetPortNo;                                  //网口号，0-无效，1-网口0，2-网口1以此类推，只读
    BYTE    byRes[1];              //保留
}NET_DVR_ETHERNET_V30, *LPNET_DVR_ETHERNET_V30;


typedef struct 
{
    DWORD    dwPPPOE;                                        //0-不启用,1-启用
    BYTE    sPPPoEUser[NAME_LEN];                            //PPPoE用户名
    char    sPPPoEPassword[PASSWD_LEN];                        // PPPoE密码
    NET_DVR_IPADDR    struPPPoEIP;                            //PPPoE IP地址
}NET_DVR_PPPOECFG, *LPNET_DVR_PPPOECFG;


typedef struct 
{
    NET_DVR_IPADDR struDVRIP;           //DVR IP地址
    NET_DVR_IPADDR struDVRIPMask;           //DVR IP地址掩码
    DWORD dwNetInterface;    //网络接口1-10MBase-T 2-10MBase-T全双工 3-100MBase-TX 4-100M全双工 5-10M/100M/1000M自适应
    BYTE byCardType;  //网卡类型，0-普通网卡，1-内网网卡，2-外网网卡
    BYTE    byEnableDNS; //DNS是否自动使能，0-保留，1-打开, 0-关闭
    WORD wMTU;             //增加MTU设置，默认1500。
    BYTE byMACAddr[MACADDR_LEN]; //物理地址，只用于显示
    BYTE byEthernetPortNo;        //网口号，0-无效，1-网口0，2-网口1以此类推，只读
    BYTE bySilkScreen; //丝印信息，0-无效，1-GE1，2-GE2，3-G1，4-G2，只读
    BYTE byUseDhcp;                          /* 是否启用DHCP */
    BYTE byRes3[3];
    NET_DVR_IPADDR struGatewayIpAddr;     /* 网关地址 */
    NET_DVR_IPADDR struDnsServer1IpAddr; /* 域名服务器1的IP地址 */
    NET_DVR_IPADDR struDnsServer2IpAddr; /* 域名服务器2的IP地址 */
}NET_DVR_ETHERNET_MULTI, *LPNET_DVR_ETHERNET_MULTI;



typedef struct tagNET_DVR_NETCFG_V50
{
    DWORD dwSize;
    NET_DVR_ETHERNET_V30    struEtherNet[MAX_ETHERNET];        //以太网口
    NET_DVR_IPADDR    struRes1[2];                    /*保留*/
    NET_DVR_IPADDR    struAlarmHostIpAddr;                    /* 报警主机IP地址 */
    BYTE    byRes2[4];                                /* 保留 */
    WORD    wAlarmHostIpPort;                                /* 报警主机端口号 */
    BYTE    byUseDhcp;                                      /* 是否启用DHCP 0xff-无效 0-不启用 1-启用*/
    BYTE    byIPv6Mode;                                //IPv6分配方式，0-路由公告，1-手动设置，2-启用DHCP分配
    NET_DVR_IPADDR    struDnsServer1IpAddr;                    /* 域名服务器1的IP地址 */
    NET_DVR_IPADDR    struDnsServer2IpAddr;                    /* 域名服务器2的IP地址 */
    BYTE    byIpResolver[MAX_DOMAIN_NAME];                    /* IP解析服务器域名或IP地址 */
    WORD    wIpResolverPort;                                /* IP解析服务器端口号 */
    WORD    wHttpPortNo;                                    /* HTTP端口号 */
    NET_DVR_IPADDR    struMulticastIpAddr;                    /* 多播组地址 */
    NET_DVR_IPADDR    struGatewayIpAddr;                        /* 网关地址 */
    NET_DVR_PPPOECFG struPPPoE;
    BYTE    byEnablePrivateMulticastDiscovery;  //私有多播搜索，0~默认，1~启用，2-禁用
    BYTE    byEnableOnvifMulticastDiscovery;  //Onvif多播搜索，0~默认，1~启用，2-禁用
    WORD    wAlarmHost2IpPort;                                /* 报警主机2端口号 */
    NET_DVR_IPADDR    struAlarmHost2IpAddr;                    /* 报警主机2 IP地址 */
    BYTE    byEnableDNS; //DNS使能, 0-关闭，1-打开
    BYTE    byRes[599];
}NET_DVR_NETCFG_V50, *LPNET_DVR_NETCFG_V50;

typedef struct tagNET_DVR_SIP_CFG
{
    DWORD dwSize;
    BYTE byEnableAutoLogin;    //使能自动注册，0-不使能，1-使能
    BYTE byLoginStatus;  //注册状态，0-未注册，1-已注册，此参数只能获取
    BYTE byRes1[2];
    NET_DVR_IPADDR stuServerIP;  //SIP服务器IP
    WORD wServerPort;    //SIP服务器端口
    BYTE byRes2[2];
    BYTE byUserName[NAME_LEN];  //注册用户名
    BYTE byPassWord[PASSWD_LEN]; //注册密码
    BYTE byLocalNo[MAX_NUMBER_LEN];
    BYTE byDispalyName[MAX_NAME_LEN]; //设备显示名称
    WORD wLocalPort;     //本地端口
    BYTE byLoginCycle;   //注册周期，1-99分钟
    BYTE byType;//0-IP/IPV6,1-域名
    BYTE byDomainName[MAX_DOMAIN_NAME]; //域名
    BYTE byRes[64];
}NET_DVR_SIP_CFG, *LPNET_DVR_SIP_CFG;

typedef struct tagNET_DVR_SIP_CFG_V50
{
    DWORD dwSize;
    BYTE byEnableAutoLogin;    //使能自动注册，0-不使能，1-使能
    BYTE byLoginStatus;  //注册状态，0-未注册，1-已注册，此参数只能获取
    BYTE byRes1[2];
    NET_DVR_IPADDR stuServerIP;  //SIP服务器IP
    WORD wServerPort;    //SIP服务器端口
    BYTE byRes2[2];
    BYTE byUserName[NAME_LEN];  //注册用户名
    BYTE byPassWord[PASSWD_LEN]; //注册密码
    BYTE byLocalNo[MAX_NUMBER_LEN];
    BYTE byDispalyName[MAX_NAME_LEN]; //设备显示名称
    WORD wLocalPort;     //本地端口
    BYTE byLoginCycle;   //注册周期，1-99分钟
    BYTE byRes3;
    BYTE bySIPServerDomain[MAX_DOMAIN_NAME];  //sip服务器域名（IP和域名只需要填其一，都有值时IP优先）
    NET_DVR_IPADDR stuSTUNServerIP;  // STUN服务器IP
    BYTE bySTUNServerDomain[MAX_DOMAIN_NAME];  //STUN服务器域名 （IP和域名只需要填其一，都有值时IP优先）
    WORD wSTUNServerPort;    // STUN服务器端口
    BYTE byRes4[2];
    NET_DVR_IPADDR stuProxyServerIP;  //代理服务器IP
    BYTE byProxyServerDomain[MAX_DOMAIN_NAME];  //代理服务器域名 （IP和域名只需要填其一，都有值时IP优先）
    WORD wProxyServerPort;    // 代理服务器端口
    BYTE byNetWork; //表示网络类型，0-无效，1-有线网络1， 2-有线网络2，3-无线网络
    BYTE byRes5;
    BYTE byCalledTargetName[NET_SDK_MAX_CALLEDTARGET_NAME];
    BYTE byRes[224];
}NET_DVR_SIP_CFG_V50, *LPNET_DVR_SIP_CFG_V50;

typedef struct tagNET_DVR_IP_VIEW_DEVCFG
{
    DWORD dwSize;
    BYTE  byDefaultRing; //默认铃音，范围1-6
    BYTE  byRingVolume;  //铃音音量，范围0-9
    BYTE  byInputVolume; //输入音量值，范围0-6
    BYTE  byOutputVolume; //输出音量值，范围0-9    
    WORD  wRtpPort;  //Rtp端口
    BYTE  byRes1[2];
    DWORD dwPreviewDelayTime; //预览延时配置，0-30秒
    BYTE  byRes2[64];
}NET_DVR_IP_VIEW_DEVCFG,*LPNET_DVR_IP_VIEW_DEVCFG;

typedef struct tagNET_DVR_IP_VIEW_AUDIO_CFG
{
    DWORD dwSize;    
    BYTE  byAudioEncPri1; //音频编码优先级1，0-G722，1-G711_U，2-G711_A， 5-MPEG2,6-G726，7-AAC
    BYTE  byAudioEncPri2; //音频编码优先级2，当sip服务器不支持音频编码1时会使用音频编码2，0-G722，1-G711_U，2-G711_A， 5-MPEG2,6-G726，7-AAC
    WORD  wAudioPacketLen1; //音频编码1数据包长度
    WORD  wAudioPacketLen2; //音频编码2数据包长度
    BYTE  byRes[30];
}NET_DVR_IP_VIEW_AUDIO_CFG,*LPNET_DVR_IP_VIEW_AUDIO_CFG;

typedef struct tagNET_DVR_IP_VIEW_CALL_CFG
{
    DWORD dwSize ;
    BYTE  byEnableAutoResponse; //使能自动应答,0-不使能，1-使能
    BYTE  byAudoResponseTime; //自动应答时间，0-30秒
    BYTE  byRes1[2];
    BYTE  byEnableAlarmNumber1; //启动报警号码1，0-不启动，1-启动
    BYTE  byRes2[3];
    BYTE  byAlarmNumber1[MAX_NUMBER_LEN]; //呼叫号码1
    BYTE  byEnableAlarmNumber2; //启动报警号码2，0-不启动，1-启动
    BYTE  byRes3[3];
    BYTE  byAlarmNumber2[MAX_NUMBER_LEN]; //呼叫号码2，呼叫号码1失败会尝试呼叫号码2
    BYTE  byRes4[72];
}NET_DVR_IP_VIEW_CALL_CFG,*LPNET_DVR_IP_VIEW_CALL_CFG;


typedef struct 
{
    BYTE byMotionScope[64][96];                                    /*侦测区域,0-96位,表示64行,共有96*64个小宏块,为1表示是移动侦测区域,0-表示不是*/
    BYTE byMotionSensitive;                                        /*移动侦测灵敏度, 0 - 5,越高越灵敏,oxff关闭*/
    BYTE byEnableHandleMotion;                                    /* 是否处理移动侦测 0－否 1－是*/ 
    BYTE byEnableDisplay;    /*启用移动侦测高亮显示，0-否，1-是*/
    char reservedData;    
    NET_DVR_HANDLEEXCEPTION_V30 struMotionHandleType;                /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    BYTE byRelRecordChan[MAX_CHANNUM_V30];                                    /* 报警触发的录象通道*/
}NET_DVR_MOTION_V30, *LPNET_DVR_MOTION_V30;

typedef struct 
{
    BYTE byMotionScope[18][22];    /*侦测区域,共有22*18个小宏块,为1表示改宏块是移动侦测区域,0-表示不是*/
    BYTE byMotionSensitive;        /*移动侦测灵敏度, 0 - 5,越高越灵敏,0xff关闭*/
    BYTE byEnableHandleMotion;    /* 是否处理移动侦测 */
    BYTE byEnableDisplay;    /*启用移动侦测高亮显示，0-否，1-是*/
    char reservedData;
    NET_DVR_HANDLEEXCEPTION strMotionHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//布防时间
    BYTE byRelRecordChan[MAX_CHANNUM]; //报警触发的录象通道,为1表示触发该通道
}NET_DVR_MOTION, *LPNET_DVR_MOTION;

typedef struct 
{
    DWORD dwEnableHideAlarm;                /* 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度*/
    WORD wHideAlarmAreaTopLeftX;            /* 遮挡区域的x坐标 */
    WORD wHideAlarmAreaTopLeftY;            /* 遮挡区域的y坐标 */
    WORD wHideAlarmAreaWidth;                /* 遮挡区域的宽 */
    WORD wHideAlarmAreaHeight;                /*遮挡区域的高*/
    NET_DVR_HANDLEEXCEPTION_V30 strHideAlarmHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
}NET_DVR_HIDEALARM_V30, *LPNET_DVR_HIDEALARM_V30;

typedef struct 
{
    DWORD dwEnableHideAlarm;                /* 是否启动遮挡报警 ,0-否,1-低灵敏度 2-中灵敏度 3-高灵敏度*/
    WORD wHideAlarmAreaTopLeftX;            /* 遮挡区域的x坐标 */
    WORD wHideAlarmAreaTopLeftY;            /* 遮挡区域的y坐标 */
    WORD wHideAlarmAreaWidth;                /* 遮挡区域的宽 */
    WORD wHideAlarmAreaHeight;                /*遮挡区域的高*/
    NET_DVR_HANDLEEXCEPTION strHideAlarmHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//布防时间
}NET_DVR_HIDEALARM, *LPNET_DVR_HIDEALARM;

typedef struct 
{
    BYTE byEnableHandleVILost;    /* 是否处理信号丢失报警 */
    NET_DVR_HANDLEEXCEPTION_V30 strVILostHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
}NET_DVR_VILOST_V30, *LPNET_DVR_VILOST_V30;

typedef struct 
{
    BYTE byEnableHandleVILost;    /* 是否处理信号丢失报警 */
    NET_DVR_HANDLEEXCEPTION strVILostHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//布防时间
}NET_DVR_VILOST, *LPNET_DVR_VILOST;

typedef struct 
{
    WORD wHideAreaTopLeftX;                /* 遮挡区域的x坐标 */
    WORD wHideAreaTopLeftY;                /* 遮挡区域的y坐标 */
    WORD wHideAreaWidth;                /* 遮挡区域的宽 */
    WORD wHideAreaHeight;                /*遮挡区域的高*/
}NET_DVR_SHELTER, *LPNET_DVR_SHELTER;



typedef struct tagNET_VCA_POINT
{    
    float fX;                                // X轴坐标, 0.000~1
    float fY;                                //Y轴坐标, 0.000~1
}NET_VCA_POINT, *LPNET_VCA_POINT;


typedef struct 
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;    /* 只读 视频制式 1-NTSC 2-PAL*/
    BYTE byBrightness;      /*亮度,0-255*/
    BYTE byContrast;        /*对比度,0-255*/    
    BYTE bySaturation;      /*饱和度,0-255 */
    BYTE byHue;                /*色调,0-255*/
    //显示通道名
    DWORD dwShowChanName; // 预览的图象上是否显示通道名称,0-不显示,1-显示 区域大小704*576
    WORD wShowNameTopLeftX;                /* 通道名称显示位置的x坐标 */
    WORD wShowNameTopLeftY;                /* 通道名称显示位置的y坐标 */
    //信号丢失报警
    NET_DVR_VILOST struVILost;
    //移动侦测
    NET_DVR_MOTION struMotion;
    //遮挡报警
    NET_DVR_HIDEALARM struHideAlarm;
    //遮挡  区域大小704*576
    DWORD dwEnableHide;        /* 是否启动遮挡 ,0-否,1-是*/
    NET_DVR_SHELTER struShelter[MAX_SHELTERNUM];
    //OSD
    DWORD dwShowOsd;// 预览的图象上是否显示OSD,0-不显示,1-显示 区域大小704*576
    WORD wOSDTopLeftX;                /* OSD的x坐标 */
    WORD wOSDTopLeftY;                /* OSD的y坐标 */
    BYTE byOSDType;                    /* OSD类型(主要是年月日格式) */
    /* 0: XXXX-XX-XX 年月日 */
    /* 1: XX-XX-XXXX 月日年 */
    /* 2: XXXX年XX月XX日 */
    /* 3: XX月XX日XXXX年 */
    /* 4: XX-XX-XXXX 日月年*/
    /* 5: XX日XX月XXXX年 */
    /*6: xx/xx/xxxx(月/日/年) */
    /*7: xxxx/xx/xx(年/月/日) */
    /*8: xx/xx/xxxx(日/月/年)*/
    BYTE byDispWeek;                /* 是否显示星期 */
    BYTE byOSDAttrib;                /* OSD属性:透明，闪烁 */
    /* 1: 透明,闪烁 */
    /* 2: 透明,不闪烁 */
    /* 3: 闪烁,不透明 */
    /* 4: 不透明,不闪烁 */
    BYTE byHourOsdType;        /* OSD小时制:0-24小时制,1-12小时制 */
}NET_DVR_PICCFG_EX, *LPNET_DVR_PICCFG_EX;

typedef struct 
{
    DWORD dwSize;
    BYTE sChanName[NAME_LEN];
    DWORD dwVideoFormat;    /* 只读 视频制式 1-NTSC 2-PAL*/
    BYTE byBrightness;      /*亮度,0-255*/
    BYTE byContrast;        /*对比度,0-255*/    
    BYTE bySaturation;      /*饱和度,0-255 */
    BYTE byHue;                /*色调,0-255*/
    //显示通道名
    DWORD dwShowChanName; // 预览的图象上是否显示通道名称,0-不显示,1-显示 区域大小704*576
    WORD wShowNameTopLeftX;                /* 通道名称显示位置的x坐标 */
    WORD wShowNameTopLeftY;                /* 通道名称显示位置的y坐标 */
    //信号丢失报警
    NET_DVR_VILOST struVILost;
    //移动侦测
    NET_DVR_MOTION struMotion;
    //遮挡报警
    NET_DVR_HIDEALARM struHideAlarm;
    //遮挡  区域大小704*576
    DWORD dwEnableHide;        /* 是否启动遮挡 ,0-否,1-是*/
    WORD wHideAreaTopLeftX;                /* 遮挡区域的x坐标 */
    WORD wHideAreaTopLeftY;                /* 遮挡区域的y坐标 */
    WORD wHideAreaWidth;                /* 遮挡区域的宽 */
    WORD wHideAreaHeight;                /*遮挡区域的高*/
    //OSD
    DWORD dwShowOsd;// 预览的图象上是否显示OSD,0-不显示,1-显示 区域大小704*576
    WORD wOSDTopLeftX;                /* OSD的x坐标 */
    WORD wOSDTopLeftY;                /* OSD的y坐标 */
    BYTE byOSDType;                    /* OSD类型(主要是年月日格式) */
    /* 0: XXXX-XX-XX 年月日 */
    /* 1: XX-XX-XXXX 月日年 */
    /* 2: XXXX年XX月XX日 */
    /* 3: XX月XX日XXXX年 */
    /* 4: XX-XX-XXXX 日月年*/
    /* 5: XX日XX月XXXX年 */
    /*6: xx/xx/xxxx(月/日/年) */
    /*7: xxxx/xx/xx(年/月/日) */
    /*8: xx/xx/xxxx(日/月/年)*/
    BYTE byDispWeek;                /* 是否显示星期 */
    BYTE byOSDAttrib;                /* OSD属性:透明，闪烁 */
    /* 1: 透明,闪烁 */
    /* 2: 透明,不闪烁 */
    /* 3: 闪烁,不透明 */
    /* 4: 不透明,不闪烁 */
    char reservedData2;
}NET_DVR_PICCFG, *LPNET_DVR_PICCFG;


typedef struct 
{
    BYTE byStreamType;        //码流类型 0-视频流, 1-复合流, 表示事件压缩参数时最高位表示是否启用压缩参数
                            /*分辨率0-DCIF                      1-CIF,                     2-QCIF,                 3-4CIF,             
                            4-2CIF                      5（保留）,                 6-QVGA(320*240),        7-QQVGA(160*120),  
                            12-384*288                  13-576*576,                   
                            16-VGA（640*480）,          17-UXGA（1600*1200）,      18-SVGA(800*600),       19-HD720p(1280*720）,   
                            20-XVGA,                    21-HD900p,                 22-1360*1024,           23-1536*1536,              
                            24-1920*1920,               27-HD1080i,                   
                            28-2560*1920,               29-1600*304,               30-2048*1536,           31-2448*2048,                
                            32-2448*1200,               33-2448*800,               34-XGA（1024*768），    35-SXGA（1280*1024）,         
                            36-WD1(960*576/960*480),    37-1080i,                  38-WSXGA(1440*900),     39-HD_F(1920*1080/1280*720),  
                            40-HD_H(1920*540/1280*360), 41-HD_Q(960*540/630*360),  42-2336*1744,           43-1920*1456,                 
                            44-2592*2048,               45-3296*2472,              46-1376*768,            47-1366*768,                 
                            48-1360*768,                49-WSXGA+,                 50-720*720,             51-1280*1280,                 
                            52-2048*768,                53-2048*2048,              54-2560*2048,           55-3072*2048,
                            56-2304*1296                57-WXGA(1280*800),         58-1600*600,               59-1600*900,
                            60-2752*2208,                61-保留,                   62-4000*3000,           63-4096*2160,
                            64-3840*2160,                65-4000*2250,              66-3072*1728,           67-2592*1944,
                            68-2464*1520,               69-1280*1920,              70-2560*1440,           71-1024*1024,
                            72-160*128,                 73-324*240,                74-324*256,             75-336*256,             
                            76-640*512,                 77-2720*2048,              78-384*256,             79-384*216, 
                            80-320*256,                 81-320*180,                82-320*192,             83-512*384,
                            84-325*256,                 85-256*192,                86-640*360,               87-1776x1340,
                            88-1936x1092,                89-2080x784,               90-2144x604,            91-1920*1200,
                            92-4064*3040,               93-3040*3040,              94-3072*2304,           95-3072*1152,
                            96-2560*2560,               97-2688*1536,              98-2688*1520,           99-3072*3072,
                            100-3392*2008,              101-4000*3080,             102-960*720,            103-1024*1536,
                            104-704*1056,               105-352*528,               106-2048*1530,          107-2560*1600,
                            108-2800*2100,              109-4088*4088,             110-4000*3072,           111-960*1080(1080p Lite)
                            112-640*720(half 720p),     113-640*960,               114-320*480,             115-3840*2400,
                            116-3840*1680,              117-2560*1120,             118-704*320,             119-1200*1920,
                            120-480*768,                121-768*480,               122-320*512,             123-512*320,
                            124-4096*1800,              125-1280*560,              126-2400*3840,          127-480*272,
                            128-512*272,                129-2592*2592,             130-1792*2880,          131-1600*2560,
                            132-2720*1192,              133-3MP(1920*1536/2048*1536)，                     134-5MP(2560*1944)，
                            135-2560*960,               136-2064*1544              137-4096*1200,
                            138-3840*1080               139-2720*800               140-512*232             141-704*200,
                            142-512*152,                143-2048*896               144-2048*600            145-1280*376,
                            146-2592*1520,              147-2592*1536,             148-3072*8192,          149-768*2048,
                            150-8208*3072,              151-4096*1536,             152-6912*2800,          153-3456*1400
                            154-480*720,                155-800*450,               156-480*270,            157-2560*1536,
                            160-3264*2448,              161-288*320,               162-144*176,            163-480*640,  
                            164-240*320,                165-120*160,               166-576*720,            167-720*1280,
                            168-576*960,                169-2944*1656,             170-432*240,            171-2160*3840,
                            172-1080*1920,              173-7008*1080,             174-3504*540,           175-1752*270,
                            176-876*135,                177-4096*1440,             178-4096*1080,          179-1536*864,
                            180-180*240,                181-360*480,               182-540*720,            183-720*960,  
                            184-960*1280,               185-1080*1440,
                            186-3200*1800,              187-1752*272,              188-872*136,            189-1280*1440,
                            190-3520*544,               191-1728*256,              192-864*128,            193-5470*3684,
                            194-2560*750,               195-1600*480,              196-1024*300,           197-848*480,
							198-8160*3616,				199-8160*2304,             200-4064*2560,          201-1400*1050,
                            202-2688*1512,              203-704*288,               204-1560*656,           205-3072*1280,
                            206-4320*1808,              207-6120*2560,              208-1280*960,          209-3000*3000,
                            210-2032*3616,              211-7680*4320,             212-5760*3240,          213-3264*1836,
                            214-2712*1536,              215-1080*720(占位，未测试),  216-360x640(占位，未测试),217-1440*812,
                            218-8160*2416,              219-5760*1712,               220-4080*1200,          221-6144*2560,
                            222-1568*656,               223-4096*1808,               224-2720*1200,          225-2896*848
                            226-2048*608                227-3840*1120                228-2720*784            229-1920*560,
                            230-1360*400                231-704*208                  232-496*144             233-352*128,
                            234-512*240                 235-512*160                  236-368*128            237-256*128
                            238-2048*592                239-1456*416                 240-1024*304            241-1280*368
                            242-912*256                 243-640*192                  244-252*112 （未使用）            245-(576*704[P制]/480*704[N制])
                            
                            254-表示超出该字段范围，使用NET_DVR_MULTI_STREAM_COMPRESSIONCFG中的dwResolution表示分辨率
                            0xff-Auto(使用当前码流分辨率)
                            256-3888*1696                257-2784*1200               258-496*224              259-352*160
                            260-912*400                  261-640*288                 262-1456*640             263-1024*448
                            264-2896*1280                265-2544*1080               266-2736*768             267-1920*544
                            268-3840*1696                269-2880*848                270-5424*2400            271-5520*1600
                            272-848*376                  273-912*272                 274-1360*600             275-1456*432
                            276-2736*1200                277-5760*1696               278-8160*2400            279-5520*2400
                            280-4608*2592                281-4944*3280               282-6016*4008            283-720*480
                            284-3200*2400                285-2784*800                286-1968*848             287-1392*608
                            288-2736*1184                289-1920*848                290-2560*2880            291-1944*1212
                            292-1920*2400                293-384*384                 294-768*768              295-4800*2688
                            296-6480*1080                297-8640*1440               298-4800*800             299-6720*1200
                            300-3600*600                 301-4800*840                302-2400*400             303-3072*540
                            304-1440*810                 305-1920*320                306-2688*480             307-1440*240
                            308-4800*1792                309-3360*1264               310-2304*880             311-3840*1440
                            312-2688*1008                313-1824*704                314-1248*496             315-1920*720
                            316-1344*496                 317-912*336                 318-1280*480             319-864*336
                            320-576*224                  321-2704*1008               322-1904*704             323-1808*672
                            324-1264*464                 325-944*336                 326-2400*1344            327-2032*1440
                            328-4064*1792                329-304*112                 330-960*360              331-672*240
                            332-464*160                  333-896*336                 334-624*224              335-640*240
                            336-448*160                  337-4976*1452               338-1968*560             339-2736*784
                            340-3888*1136                341-6120*1800               342-4320*1280            343-3056*896
                            344-1776*528                 345-1392*400                346-7256*1520            347-512*288   
                            348-1936*1210                349-640*400                 350-2688*1792            351-2464*2056
                            352-2720*1600                353-4800*1600               354-3600*1200            355-未定义
                            356-2400*800                 357-1200*400                358-4096*3008            359-7680*4096
                            360-1080*1520                361-6656*3744               362-5120*1400            363-2560*704
                            364-2688*3040                365-1280*352                366-3376*1008            367-1688*504
                            368-5120*1440                369-1920*2160               370-4080*1808            371-4080*1152
                            372-2688*3888                373-3840*2880               374-2464*3520            375-4416*1696
                            376-1408*540                 377-3456*1080               378-1728*540             379-704*1152
                            380-1408*1152                381-5120*2880               382-720*576              383-3984*1168
                            384-1920*1440                385-3840*4096               386-1920*536             387-1536*432
                            388-3072*864                 389-1440*1080               390-720*540              391-960*544
                            392-720*544                  393-5430*3054               394-8000*6000            395-6560*3690
    */
    BYTE byResolution;      
    BYTE byBitrateType;        //码率类型 0:变码率, 1:定码率,0xfe:自动，和源一致
    BYTE byPicQuality;        //图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差,自动，和源一致
                            /*视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K 
								13 - 384K 14 - 448K 15 - 512K 16 - 640K 17 - 768K 18 - 896K 19 - 1024K 20 - 1280K 21 - 1536K 22 - 1792K 23 - 2048K
								24 - 2560K 25 - 3072K 26 - 4096K 27 - 5120K 28 - 6144K 29 - 7168K 30 - 8192K*/
    DWORD dwVideoBitrate;      
    DWORD dwVideoFrameRate;    //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; V2.0版本中新加14-15; 15-18; 16-22;
    //17-25；18-30；19-35；20-40；21-45；22-50；23-55；24-60；25-3;26-5;27-7;28-9;29-100; 30-120;31-24;32-48,33-8.3,0xfffffffe-自动，和源一致
    WORD  wIntervalFrameI;  //I帧间隔,0xfffe 自动，和源一致
    BYTE  byIntervalBPFrame;//0-BBP帧; 1-BP帧; 2-单P帧(2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题)；0xfe-自动，和源一致
    BYTE  byres1;        //保留
    BYTE  byVideoEncType;   //视频编码类型 0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，8-MPEG2，9-SVAC, 10-标准h265, 0xfe-自动（和源一致），0xff-无效 
    BYTE  byAudioEncType;   //音频编码类型 0-G722;1-G711_U;2-G711_A;5-MP2L2;6-G276;7-AAC;8-PCM;12-AAC_LC;13-AAC_LD;14-Opus;15-MP3;0xff-无效
    BYTE  byVideoEncComplexity; //视频编码复杂度，0-低，1-中，2高,0xfe:自动，和源一致
    BYTE  byEnableSvc; //0 - 不启用SVC功能；1- 启用SVC功能; 2-自动启用SVC功能
    BYTE  byFormatType; //封装类型，1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP,9-RTP+PS（国标：GB28181），0xff-无效
    BYTE  byAudioBitRate; //音频码率 参考 BITRATE_ENCODE_INDEX
    BYTE  byStreamSmooth;//码流平滑 1～100（1等级表示清晰(Clear)，100表示平滑(Smooth)）
    BYTE  byAudioSamplingRate;//音频采样率0-默认,1- 16kHZ, 2-32kHZ, 3-48kHZ, 4- 44.1kHZ,5-8kHZ
    BYTE  bySmartCodec;///*bit0-高性能编码 0-关闭，1-打开，bit1 - 低码率模式 0 - 关闭，1 - 打开*/
    BYTE  byDepthMapEnable;// 深度图使能开关，0-关闭，1-打开；如果开启后，第二通道的子码流（双目）的视频参数都不能配置，默认输出 960*540 的深度图；
    //平均码率（在SmartCodec使能开启下生效）, 0-0K 1-16K 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K 24-2560K 25-3072K 26-4096K 27-5120K 28-6144K 29-7168K 30-8192K
    //最高位(15位)置成1表示是自定义码流, 0-14位表示码流值(MIN- 0 K)。
    WORD  wAverageVideoBitrate; 
}NET_DVR_COMPRESSION_INFO_V30, *LPNET_DVR_COMPRESSION_INFO_V30;


typedef struct 
{
    BYTE byStreamType;        //码流类型0-视频流,1-复合流,表示压缩参数时最高位表示是否启用压缩参数
    BYTE byResolution;      //分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(车载专用)
    BYTE byBitrateType;        //码率类型0:变码率，1:定码率，2：低码率
    BYTE  byPicQuality;        //图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差
    DWORD dwVideoBitrate;     /*视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K 
								13 - 384K 14 - 448K 15 - 512K 16 - 640K 17 - 768K 18 - 896K 19 - 1024K 20 - 1280K 21 - 1536K 22 - 1792K 23 - 2048K
								24 - 2560K 25 - 3072K 26 - 4096K 27 - 5120K 28 - 6144K 29 - 7168K 30 - 8192K*/
    DWORD dwVideoFrameRate;    //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20;
}NET_DVR_COMPRESSION_INFO, *LPNET_DVR_COMPRESSION_INFO;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO struRecordPara; //录像/事件触发录像
    NET_DVR_COMPRESSION_INFO struNetPara;    //网传/保留
}NET_DVR_COMPRESSIONCFG, *LPNET_DVR_COMPRESSIONCFG;

typedef struct 
{
    BYTE byStreamType;        //码流类型0-视频流, 1-复合流
    BYTE byResolution;      //分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF, 5-2QCIF(352X144)(车载专用)
    BYTE byBitrateType;        //码率类型0:变码率，1:定码率，2：低码率
    BYTE  byPicQuality;        //图象质量 0-最好 1-次好 2-较好 3-一般 4-较差 5-差
    DWORD dwVideoBitrate;     /*视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K 
								13 - 384K 14 - 448K 15 - 512K 16 - 640K 17 - 768K 18 - 896K 19 - 1024K 20 - 1280K 21 - 1536K 22 - 1792K 23 - 2048K
								24 - 2560K 25 - 3072K 26 - 4096K 27 - 5120K 28 - 6144K 29 - 7168K 30 - 8192K*/
    DWORD dwVideoFrameRate;    //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20, //V2.0增加14-15, 15-18, 16-22;
    WORD  wIntervalFrameI;  //I帧间隔
    //2006-08-11 增加单P帧的配置接口，可以改善实时流延时问题
    BYTE  byIntervalBPFrame;//0-BBP帧; 1-BP帧; 2-单P帧
    BYTE  byRes;
}NET_DVR_COMPRESSION_INFO_EX, *LPNET_DVR_COMPRESSION_INFO_EX;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX struRecordPara; //录像
    NET_DVR_COMPRESSION_INFO_EX struNetPara;    //网传
}NET_DVR_COMPRESSIONCFG_EX, *LPNET_DVR_COMPRESSIONCFG_EX;

typedef struct 
{
    NET_DVR_SCHEDTIME struRecordTime;
    BYTE byRecordType;    //0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警, 5:命令触发, 6: 智能录像,10-PIR报警，11-无线报警，12-呼救报警，13-所有报警,14-智能交通事件，15越界侦测，16区域入侵侦测，17音频异常侦测
    char reservedData[3];
}NET_DVR_RECORDSCHED, *LPNET_DVR_RECORDSCHED;

typedef struct 
{
    WORD wAllDayRecord;                /* 是否全天录像 0-否 1-是*/
                                    BYTE byRecordType;                /* 录象类型 0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发, 6: 智能录像,
                                                                    10-PIR报警，11-无线报警，12-呼救报警，13-移动|报警输入|PIR|无线报警|呼救报警,14-智能交通事件,15-越界侦测,16-区域入侵,17-声音异常,
                                    18-场景变更侦测,19-智能侦测（越界侦测|区域入侵|进入区域|离开区域|人脸识别）,20－人脸侦测, 21-POS录像*/
                                    char reservedData;
}NET_DVR_RECORDDAY, *LPNET_DVR_RECORDDAY;

typedef struct 
{
    DWORD    dwSize;
    DWORD    dwRecord;                          /*是否录像 0-否 1-是*/
    NET_DVR_RECORDDAY    struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED    struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwRecordTime;                    /* 录象延时长度 0-5秒， 1-10秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟*/
    DWORD    dwPreRecordTime;                /* 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) */
    DWORD    dwRecorderDuration;                /* 录像保存的最长时间 */
    BYTE    byRedundancyRec;    /*是否冗余录像,重要数据双备份：0/1*/
    BYTE    byAudioRec;        /*录像时复合流编码时是否记录音频数据：国外有此法规*/
    BYTE    byStreamType;  // 0-主码流，1-子码流，2-主子码流同时 3-三码流
    BYTE    byPassbackRecord;  // 0:不回传录像 1：回传录像
    WORD    wLockDuration;  // 录像锁定时长，单位小时 0表示不锁定，0xffff表示永久锁定，录像段的时长大于锁定的持续时长的录像，将不会锁定
    BYTE    byRecordBackup;  // 0:录像不存档 1：录像存档
    BYTE     bySVCLevel;    //SVC抽帧类型：0-不抽，1-抽二分之一 2-抽四分之三
    BYTE    byRecordManage;   //录像调度，0-启用， 1-不启用; 启用时进行定时录像；不启用时不进行定时录像，但是录像计划仍在使用，比如移动侦测，回传都还在按这条录像计划进行
    BYTE    byExtraSaveAudio;        //音频单独另存0-非单独另存，1-单独另存
    /*开启智能录像功能后，算法库是自动启用智能录像算法，其功能为若录像中无目标出现，会降低码率、帧率，而目标出现时又恢复全码率及帧率，从而达到减少资源消耗的目的*/
    BYTE   byIntelligentRecord;//是否开启智能录像功能 0-否 1-是
    BYTE    byReserve;
}NET_DVR_RECORD_V30, *LPNET_DVR_RECORD_V30;

typedef struct 
{
    NET_DVR_SCHEDTIME  struRecordTime;
    /*录像类型，0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发, 
    6-智能报警录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件,14-智能交通事件, 
    15-越界侦测,16-区域入侵,17-声音异常,18-场景变更侦测,
    19-智能侦测(越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测),20－人脸侦测,21-POS录像,
    22-进入区域侦测, 23-离开区域侦测,24-徘徊侦测,25-人员聚集侦测,26-快速运动侦测,27-停车侦测,
    28-物品遗留侦测,29-物品拿取侦测,30-火点检测，31-防破坏检测,32-打架斗殴事件(司法),33-起身事件(司法), 34-瞌睡事件(司法)
    35-船只检测, 36-测温预警，37-测温报警，38-温差报警，39-离线测温报警,40-防区报警，41-紧急求助,42-业务咨询,43-起身检测,44-折线攀高,45-如厕超时，46-人脸抓拍，47-非法摆摊,48-目标抓拍,
    49-剧烈运动，50离岗检测，51-起立，52人数变化 53-废气排放监测 54-灰度报警*/
    BYTE byRecordType; 
    BYTE byRes[31];
}NET_DVR_RECORDSCHED_V40, *LPNET_DVR_RECORDSCHED_V40;

typedef struct 
{
    BYTE byAllDayRecord; /* 是否全天录像 0-否 1-是*/
                         /*录像类型，0:定时录像，1:移动侦测，2:报警录像，3:动测|报警，4:动测&报警 5:命令触发, 
                         6-智能报警录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件,14-智能交通事件, 
                         15-越界侦测,16-区域入侵,17-声音异常,18-场景变更侦测,
                         19-智能侦测(越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测),20－人脸侦测,21-POS录像,
                         22-进入区域侦测, 23-离开区域侦测,24-徘徊侦测,25-人员聚集侦测,26-快速运动侦测,27-停车侦测,
                         28-物品遗留侦测,29-物品拿取侦测,30-火点检测，31-防破坏检测,32-打架斗殴事件(司法),33-起身事件(司法), 34-瞌睡事件(司法)
                         35-船只检测, 36-测温预警，37-测温报警，38-温差报警，39-离线测温报警,40-防区报警，41-紧急求助,42-业务咨询,43-起身检测,44-折线攀高,45-如厕超时,46-人脸抓拍,47-非法摆摊,48-目标抓拍,
                         49-剧烈运动，50离岗检测，51-起立，52人数变化  53-废气排放监测  54-灰度报警*/
    BYTE byRecordType; 
    BYTE byRes[62];
}NET_DVR_RECORDDAY_V40, *LPNET_DVR_RECORDDAY_V40;

typedef struct 
{
    DWORD    dwSize;
    DWORD    dwRecord;                          /*是否录像 0-否 1-是*/
    NET_DVR_RECORDDAY_V40    struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED_V40 struRecordSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwRecordTime;                    /* 录象延时长度 0-5秒， 1-10秒， 2-30秒， 3-1分钟， 4-2分钟， 5-5分钟， 6-10分钟*/
    DWORD    dwPreRecordTime;                /* 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) */
    DWORD    dwRecorderDuration;                /* 录像保存的最长时间 */
    BYTE    byRedundancyRec;    /*是否冗余录像,重要数据双备份：0/1*/
    BYTE    byAudioRec;        /*录像时复合流编码时是否记录音频数据：国外有此法规*/
    BYTE    byStreamType;  // 0-主码流，1-子码流，2-主子码流同时 3-三码流
    BYTE    byPassbackRecord;  // 0:不回传录像 1：回传录像
    WORD    wLockDuration;  // 录像锁定时长，单位小时 0表示不锁定，0xffff表示永久锁定，录像段的时长大于锁定的持续时长的录像，将不会锁定
    BYTE    byRecordBackup;  // 0:录像不存档 1：录像存档
    BYTE     bySVCLevel;    //SVC抽帧类型：0-不抽，1-抽二分之一 2-抽四分之三
    BYTE    byRecordManage;   //录像调度，0-启用， 1-不启用; 启用时进行定时录像；不启用时不进行定时录像，但是录像计划仍在使用，比如移动侦测，回传都还在按这条录像计划进行
    BYTE    byExtraSaveAudio;//音频单独存储
    /*开启智能录像功能后，算法库是自动启用智能录像算法，其功能为若录像中无目标出现，会降低码率、帧率，而目标出现时又恢复全码率及帧率，从而达到减少资源消耗的目的*/
    BYTE   byIntelligentRecord;//是否开启智能录像功能 0-否 1-是
    BYTE    byRes[125];
}NET_DVR_RECORD_V40, *LPNET_DVR_RECORD_V40;

typedef struct 
{
    DWORD dwSize;
    DWORD dwRecord;  /*是否录像 0-否 1-是*/
    NET_DVR_RECORDDAY struRecAllDay[MAX_DAYS];
    NET_DVR_RECORDSCHED struRecordSched[MAX_DAYS][MAX_TIMESEGMENT];
    DWORD dwRecordTime;    /* 录象时间长度 */
    DWORD dwPreRecordTime;    /* 预录时间 0-不预录 1-5秒 2-10秒 3-15秒 4-20秒 5-25秒 6-30秒 7-0xffffffff(尽可能预录) */
}NET_DVR_RECORD, *LPNET_DVR_RECORD;



typedef struct tagNET_DVR_SERIALSTART_V40   //透明通道
{
    DWORD  dwSize;         //结构体大小
    DWORD  dwSerialType;    //串口号（1-232串口，2-485串口）
    BYTE   bySerialNum;   //串口编号
    BYTE   byRes[255];
}NET_DVR_SERIALSTART_V40,*LPNET_DVR_SERIALSTART_V40;

typedef struct tagNET_DVR_DECODERCFG_V40
{
    DWORD    dwSize;       //结构体大小
    DWORD     dwBaudRate;       //波特率 0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k; 
    BYTE     byDataBit;       //数据有几位 0－5位，1－6位，2－7位，3－8位;
    BYTE     byStopBit;       //停止位 0－1位，1－2位
    BYTE     byParity;       //校验 0－无校验，1－奇校验，2－偶校验
    BYTE     byFlowcontrol;  //0－无，1－软流控,2-硬流控
    WORD     wDecoderType;    //解码器类型*/
    WORD     wDecoderAddress;    //解码器地址，0-255
    BYTE     bySetPreset [MAX_PRESET_V30];  //预置点是否设置,0-没有设置,1-设置
    BYTE     bySetCruise[MAX_CRUISE_V30];  //巡航是否设置: 0-没有设置,1-设置
    BYTE     bySetTrack [MAX_TRACK_V30];    //轨迹是否设置,0-没有设置,1-设置
    BYTE     bySerialNO;          //串口编号
    BYTE     byWorkMode;          /*工作模式， 1-矩阵串口控制，2-屏幕控制，3-透明通道模式 4-PPP模式 5-控制台模式 6-串口直连 7-键盘控制 8-监控板管理 9-控制云台 12-LED显示，13-触发抓拍数据传输*/
    BYTE     byRes[254];         //保留
}NET_DVR_DECODERCFG_V40,*LPNET_DVR_DECODERCFG_V40;


typedef struct 
{
    DWORD dwSize;
    DWORD dwBaudRate;//波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    BYTE byDataBit;// 数据有几位 0－5位，1－6位，2－7位，3－8位;
    BYTE byStopBit;// 停止位 0－1位，1－2位;
    BYTE byParity;// 校验 0－无校验，1－奇校验，2－偶校验;
    BYTE byFlowcontrol;// 0－无，1－软流控,2-硬流控
    WORD wDecoderType;//解码器类型, 从0开始，对应ptz协议列表从NET_DVR_IPC_PROTO_LIST得到
    WORD wDecoderAddress;    /*解码器地址:0 - 255*/
    BYTE bySetPreset[MAX_PRESET_V30];        /* 预置点是否设置,0-没有设置,1-设置*/
    BYTE bySetCruise[MAX_CRUISE_V30];        /* 巡航是否设置: 0-没有设置,1-设置 */
    BYTE bySetTrack[MAX_TRACK_V30];            /* 轨迹是否设置,0-没有设置,1-设置*/
}NET_DVR_DECODERCFG_V30, *LPNET_DVR_DECODERCFG_V30;

typedef struct 
{
    DWORD dwSize;
    DWORD dwBaudRate;       //波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    BYTE byDataBit;         // 数据有几位 0－5位，1－6位，2－7位，3－8位;
    BYTE byStopBit;         // 停止位 0－1位，1－2位;
    BYTE byParity;          // 校验 0－无校验，1－奇校验，2－偶校验;
    BYTE byFlowcontrol;     // 0－无，1－软流控,2-硬流控
    WORD wDecoderType;      //解码器类型  NET_DVR_IPC_PROTO_LIST中得到
    WORD wDecoderAddress;    /*解码器地址:0 - 255*/
    BYTE bySetPreset[MAX_PRESET];        /* 预置点是否设置,0-没有设置,1-设置*/
    BYTE bySetCruise[MAX_CRUISE];        /* 巡航是否设置: 0-没有设置,1-设置 */
    BYTE bySetTrack[MAX_TRACK];        /* 轨迹是否设置,0-没有设置,1-设置*/
}NET_DVR_DECODERCFG, *LPNET_DVR_DECODERCFG;

typedef struct 
{
    NET_DVR_IPADDR struRemoteIP;    //远端IP地址
    NET_DVR_IPADDR struLocalIP;        //本地IP地址
    char sLocalIPMask[16];            //本地IP地址掩码
    BYTE sUsername[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */
    BYTE byPPPMode;                    //PPP模式, 0－主动，1－被动
    BYTE byRedial;                    //是否回拨 ：0-否,1-是
    BYTE byRedialMode;                //回拨模式,0-由拨入者指定,1-预置回拨号码
    BYTE byDataEncrypt;                //数据加密,0-否,1-是
    DWORD dwMTU;                    //MTU
    char sTelephoneNumber[PHONENUMBER_LEN];   //电话号码
}NET_DVR_PPPCFG_V30, *LPNET_DVR_PPPCFG_V30;

typedef struct 
{
    char sRemoteIP[16];                //远端IP地址
    char sLocalIP[16];                //本地IP地址
    char sLocalIPMask[16];            //本地IP地址掩码
    BYTE sUsername[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */
    BYTE byPPPMode;                    //PPP模式, 0－主动，1－被动
    BYTE byRedial;                    //是否回拨 ：0-否,1-是
    BYTE byRedialMode;                //回拨模式,0-由拨入者指定,1-预置回拨号码
    BYTE byDataEncrypt;                //数据加密,0-否,1-是
    DWORD dwMTU;                    //MTU
    char sTelephoneNumber[PHONENUMBER_LEN];   //电话号码
}NET_DVR_PPPCFG, *LPNET_DVR_PPPCFG;


typedef struct tagNET_DVR_USB_RS232
{
    DWORD dwBaudRate;   /*波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;*/
    BYTE byDataBit;     /* 数据有几位 0－5位，1－6位，2－7位，3－8位 */
    BYTE byStopBit;     /* 停止位 0－1位，1－2位 */
    BYTE byParity;      /* 校验 0－无校验，1－奇校验，2－偶校验 */
    BYTE byFlowcontrol; /* 0－无，1－软流控,2-硬流控 */
    BYTE byVirtualSerialPort;  //虚拟串口编号
    BYTE byRes[3];
}NET_DVR_USB_RS232,*LPNET_DVR_USB_RS232;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_SINGLE_RS232 struRs232[MAX_SERIAL_PORT];/*注意：此结构修改了，原来是单个结构，现在修改为了数组结构*/
    NET_DVR_PPPCFG_V30 struPPPConfig;
}NET_DVR_RS232CFG_V30, *LPNET_DVR_RS232CFG_V30;

typedef struct 
{
    DWORD dwSize;
    DWORD dwBaudRate;//波特率(bps)，0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    BYTE byDataBit;// 数据有几位 0－5位，1－6位，2－7位，3－8位;
    BYTE byStopBit;// 停止位 0－1位，1－2位;
    BYTE byParity;// 校验 0－无校验，1－奇校验，2－偶校验;
    BYTE byFlowcontrol;// 0－无，1－软流控,2-硬流控
    DWORD dwWorkMode;// 工作模式，0－窄带传输(232串口用于PPP拨号)，1－控制台(232串口用于参数控制)，2－透明通道
    NET_DVR_PPPCFG struPPPConfig;
}NET_DVR_RS232CFG, *LPNET_DVR_RS232CFG;

typedef struct 
{
    DWORD dwEnablePresetChan;    /*启用预置点的通道, 0xfffffff表示不调用预置点*/
    DWORD dwPresetPointNo;        /*调用预置点通道对应的预置点序号, 0xfffffff表示不调用预置点。*/
}NET_DVR_PRESETCHAN_INFO, LPNET_DVR_PRESETCHAN_INFO;

typedef struct 
{
    DWORD dwEnableCruiseChan;    /*启用巡航的通道*/
    DWORD dwCruiseNo;        /*巡航通道对应的巡航编号, 0xfffffff表示无效*/
}NET_DVR_CRUISECHAN_INFO, LPNET_DVR_CRUISECHAN_INFO;

typedef struct 
{
    DWORD dwEnablePtzTrackChan;    /*启用云台轨迹的通道*/
    DWORD dwPtzTrackNo;        /*云台轨迹通道对应的编号, 0xfffffff表示无效*/
}NET_DVR_PTZTRACKCHAN_INFO, LPNET_DVR_PTZTRACKCHAN_INFO;

typedef struct tagNET_DVR_PTZ_NOTIFICATION_COND
{
    DWORD   dwSize;
    /*
    0-facedetection,
    1-vehicleDetection,
    2-scenechangedetection,
    3-LineDetection,
    4-regionEntrance,
    5-regionExiting,
    6-loitering,
    7-group,
    8-rapidMove,
    9-parking,
    10-unattendedBaggage,
    11-attendedBaggage,
    12-audioDetection,
    13-PIR,
    14-defocusDetection
    15-temperature,
    16-fireDetection,
    17-thermometry,
    18-shipsDetection
    19-fieldDetection
    20-blockListFaceContrast
    21-allowListFaceContrast
    22- humanRecognition
    23- faceContrast
    */
    WORD    byEventType;
    BYTE    byRes[2];
    DWORD   dwChannel;
    BYTE    byRes1[128];
}NET_DVR_PTZ_NOTIFICATION_COND, *LPNET_DVR_PTZ_NOTIFICATION_COND;

typedef struct tagNET_DVR_PTZ_NOTIFICATION_CFG
{
    DWORD   dwSize;
    DWORD   dwEnablePresetChanNum;  //当前已启用预置点的数目
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //启用的预置点信息(关联联动类型 ptz)
    DWORD   dwEnableCruiseChanNum;  //当前已启用巡航的通道数目
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //启用巡航功能通道的信息(关联联动类型 ptz)
    DWORD   dwEnablePtzTrackChanNum;  //当前已启用云台轨迹的通道数目
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //调用云台轨迹的通道信息(关联联动类型 ptz)
    BYTE      byRes1[1024];
}NET_DVR_PTZ_NOTIFICATION_CFG, *LPNET_DVR_PTZ_NOTIFICATION_CFG;

typedef struct tagNET_DVR_PTZ_NOTIFICATION
{
    DWORD   dwSize;
    /*
    0-facedetection,
    1-vehicleDetection,
    2-scenechangedetection,
    3-LineDetection,
    4-regionEntrance,
    5-regionExiting,
    6-loitering,
    7-group,
    8-rapidMove,
    9-parking,
    10-unattendedBaggage,
    11-attendedBaggage,
    12-audioDetection,
    13-PIR,
    14-defocusDetection，
    15-temperature,
    16-fireDetection,
    17-thermometry,
    18-shipsDetection
    19-fieldDetection
    20-blockListFaceContrast
    21-allowListFaceContrast
    22- humanRecognition
    */
    WORD    byEventType;
    BYTE    byRes[62];
    DWORD   dwEnablePresetChanNum;  //当前已启用预置点的数目
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //启用的预置点信息(关联联动类型 ptz)
    DWORD   dwEnableCruiseChanNum;  //当前已启用巡航的通道数目
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //启用巡航功能通道的信息(关联联动类型 ptz)
    DWORD   dwEnablePtzTrackChanNum;  //当前已启用云台轨迹的通道数目
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //调用云台轨迹的通道信息(关联联动类型 ptz)
    BYTE      byRes1[1024];
}NET_DVR_PTZ_NOTIFICATION, *LPNET_DVR_PTZ_NOTIFICATION;

typedef struct tagNET_DVR_ALARMINCFG_V40
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];    /* 名称 */
    BYTE byAlarmType;                //报警器类型,0：常开,1：常闭
    BYTE byAlarmInHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byChannel;                 // 报警输入触发智能识别通道
    BYTE byInputType;                //输入类型  0-开关量方式  1-信号量方式
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/ 
    /*0x1000:抓图上传到云*/
    /*0x2000:短信报警*/
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数量
    DWORD   dwRelAlarmOutChanNum; //触发的报警输出通道数 实际支持数
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //触发报警通道
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    /*触发的录像通道*/
    DWORD   dwMaxRecordChanNum;   //设备支持的最大关联录像通道数-只读
    DWORD   dwCurRecordChanNum;    //当前实际已配置的关联录像通道数
    DWORD   dwRelRecordChan[MAX_CHANNUM_V40];     /* 实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - dwCurRecordChanNum -1有效，如果中间遇到0xffffffff,则后续无效*/ 
    DWORD   dwMaxEnablePtzCtrlNun; //最大可启用的云台控制总数(只读)
    DWORD   dwEnablePresetChanNum;  //当前已启用预置点的数目
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40]; //启用的预置点信息
    BYTE    byPresetDurationTime[MAX_CHANNUM_V40];//预置点停留时间 范围0-20s，默认10s；
    BYTE    byRes2[4];                    /*保留*/
    DWORD   dwEnableCruiseChanNum;  //当前已启用巡航的通道数目
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40]; //启用巡航功能通道的信息
    DWORD   dwEnablePtzTrackChanNum;  //当前已启用巡航的通道数目
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40]; //调用云台轨迹的通道信息
    WORD   wEventType[NET_SDK_MAX_EVENT_NUM/*64*/]; /*组合事件类型，每一个位对应一个事件类型*/
    BYTE    byRes[128];
}NET_DVR_ALARMINCFG_V40, *LPNET_DVR_ALARMINCFG_V40;

typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];    /* 名称 */
    BYTE byAlarmType;                //报警器类型,0：常开,1：常闭
    BYTE byAlarmInHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byChannel;                 // 报警输入触发智能识别通道
    BYTE byInputType;                //输入类型  0-开关量方式  1-信号量方式    
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道
    BYTE byEnablePreset[MAX_CHANNUM_V30];        /* 是否调用预置点 0-否,1-是*/
    BYTE byPresetNo[MAX_CHANNUM_V30];            /* 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。*/
    BYTE byRes2[192];                    /*保留*/
    BYTE byEnableCruise[MAX_CHANNUM_V30];        /* 是否调用巡航 0-否,1-是*/
    BYTE byCruiseNo[MAX_CHANNUM_V30];            /* 巡航 */
    BYTE byEnablePtzTrack[MAX_CHANNUM_V30];        /* 是否调用轨迹 0-否,1-是*/
    BYTE byPTZTrack[MAX_CHANNUM_V30];            /* 调用的云台的轨迹序号 */
    BYTE byRes3[16];
}NET_DVR_ALARMINCFG_V30, *LPNET_DVR_ALARMINCFG_V30;

typedef struct tagNET_DVR_ALARMINFO_FIXED_HEADER
{
    /*0-信号量报警,1-硬盘满,2-信号丢失，3－移动侦测，4－硬盘未格式化,5-写硬盘出错,6-遮挡报警，
    7-制式不匹配, 8-非法访问，9-视频信号异常，10-录像异常，11-智能场景变化，12-阵列异常，13-前端/录像分辨率不匹配, 
    14-申请解码资源失败,15-智能侦测报警, 16-热备异常，17-录播主机报警，18-语音对讲请求报警,19-音频丢失，20-开启录像，
    21-关闭录像，22-车辆检测算法异常，23-脉冲报警,24-人脸库硬盘异常,25-人脸库变更,26-人脸库图片变更,27-POC异常,28-相机视角异常，
    30-缺少SD卡,32-云台堵转异常，34-异常重启*/
    DWORD dwAlarmType;//报警类型
    NET_DVR_TIME_EX struAlarmTime;    //发生报警的时间
    union
    {
        BYTE    byUnionLen[116];  //分出去8个字节用于扩展时区
        struct
        {
            DWORD    dwAlarmInputNo;        //发生报警的报警输入通道号，一次只有一个
            DWORD    dwTrigerAlarmOutNum;    /*触发的报警输出个数，用于后面计算变长数据部分中所有触发的报警输出通道号，四字节表示一个*/
            DWORD    dwTrigerRecordChanNum;    /*触发的录像通道个数，用于后面计算变长数据部分中所有触发的录像通道号，四字节表示一个*/
        }struIOAlarm;    // 报警类型dwAlarmType为0时有效
        struct
        {
            DWORD    dwAlarmChanNum;    /*发生报警通道数据个数，用于后面计算变长数据部分中所有发生的报警通道号，四字节表示一个*/
            DWORD    dwPicLen;//Jpeg图片长度
            BYTE     byPicURL; //图片数据采用URL方式 0-二进制图片数据，1-图片数据走URL方式
            BYTE    byTarget; /*0-不区分识别目标，1-识别目标为人，2-识别目标为车*/
            BYTE    byRes1[2]; //保留
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
            char*  pDataBuff; //报警图片或者图片URL
#else
            char*   pDataBuff; //报警图片或者图片URL	
            BYTE  byRes3[4];
#endif
        }struAlarmChannel;    // dwAlarmType为2，3，6，9，10、13或28时有效
        struct
        {
            DWORD    dwAlarmHardDiskNum;    /*发生报警的硬盘数据长度，用于后面计算变长数据部分中所有发生报警的硬盘号，四节表示一个*/
        }struAlarmHardDisk;    // dwAlarmType为1,4,5时有效
        struct
        {
            BYTE       bySubAlarmType;  //报警子类型，1-一键延迟录像； 
            BYTE       byRes1[3]; //保留
            NET_DVR_TIME_EX  struRecordEndTime; //录播结束时间
        }struRecordingHost;  //录播主机专用报警
        struct
        {
            float          fVoltageValue;//电源电压值,单位V,精确到0.1
            BYTE       byVoltageAlarmType;  //电源电压报警类型，0-电源电压过高，1-电源电压过低 
            BYTE       byRes1[3]; //保留字节
        }struVoltageInstable;  //dwAlarmType=31时有效

        struct
        {
            float      fTemperature;//传感器温度，精确到小数点后1位
            DWORD      dwCustomInfoLength; //自定义信息长度
            BYTE*      pCustomInfo; //自定义信息
            BYTE       byType;  //云台堵转类型 1-水平堵转 2-垂直堵转
            BYTE       byDeicingEnabled;  // 云台除冰加热使能 0-关闭 1-开启
            BYTE       byRes2[2]; //保留
            DWORD      dwChannel; //通道号
        }struPTLocking;  //云台堵转异常 dwAlarmType=32时有效

        struct
        {
            BYTE       byExceptionType;	//异常类型,0-保留, 1- 日志存储异常，2-日志盘满
        }struLogException;  //dwAlarmType=33时有效,日志异常信息

        struct
        {
            NET_DVR_TIME_EX struAlarmTime;    //重启时间，设备本地时间
            BYTE            byExceptionType;  //重启具体类型 0-保留 1- 线程 2-无码流  当前0、1、2 以外为其他
            BYTE            byRes1[3];        //保留字节
        }struAbnormalReboot;  //异常重启 dwAlarmType=34时有效

    }uStruAlarm;
    DWORD*  pRes;    //用于兼容64位下结构体字节不对齐问题
    BYTE    byTimeDiffFlag;      /*时差字段是否有效  0-时差无效， 1-时差有效 */
    char    cTimeDifferenceH;         /*与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效*/
    char    cTimeDifferenceM;      	/*与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效*/
    BYTE    byRes; //保留
    WORD    wDevInfoIvmsChannel; //增加后端透传前端时的通道号
    BYTE    byRes2[2]; //保留
}NET_DVR_ALRAM_FIXED_HEADER, *LPNET_DVR_ALARM_FIXED_HEADER;

typedef struct NET_DVR_ALARMINFO_V40
{
    NET_DVR_ALRAM_FIXED_HEADER     struAlarmFixedHeader;    //报警固定部分
    DWORD*                        pAlarmData;    //报警可变部分内容
}NET_DVR_ALARMINFO_V40, *LPNET_DVR_ALARMINFO_V40;

typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmInName[NAME_LEN];    /* 名称 */
    BYTE byAlarmType;    //报警器类型,0：常开,1：常闭
    BYTE byAlarmInHandle;    /* 是否处理 0-不处理 1-处理*/
    BYTE byChannel;                 // 报警输入触发智能识别通道
    BYTE byRes;                     
    NET_DVR_HANDLEEXCEPTION struAlarmHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//布防时间
    BYTE byRelRecordChan[MAX_CHANNUM]; //报警触发的录象通道,为1表示触发该通道
    BYTE byEnablePreset[MAX_CHANNUM];        /* 是否调用预置点 0-否,1-是*/
    BYTE byPresetNo[MAX_CHANNUM];            /* 调用的云台预置点序号,一个报警输入可以调用多个通道的云台预置点, 0xff表示不调用预置点。*/
    BYTE byEnableCruise[MAX_CHANNUM];        /* 是否调用巡航 0-否,1-是*/
    BYTE byCruiseNo[MAX_CHANNUM];            /* 巡航 */
    BYTE byEnablePtzTrack[MAX_CHANNUM];        /* 是否调用轨迹 0-否,1-是*/
    BYTE byPTZTrack[MAX_CHANNUM];            /* 调用的云台的轨迹序号 */
}NET_DVR_ALARMINCFG, *LPNET_DVR_ALARMINCFG;


typedef struct 
{
    DWORD dwAlarmType;/*0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常,
                      10-录像异常,11- 智能场景变化,12-阵列异常,13-前端/录像分辨率不匹配,14-申请解码资源失败,15-智能侦测, 16-POE供电异常报警,17-闪光灯异常,
    18-磁盘满负荷异常报警,19-音频丢失，20-开启录像，21-关闭录像，22-车辆检测算法异常，23-脉冲报警,24-人脸库硬盘异常,25-人脸库变更,26-人脸库图片变更,27-POC异常
    28-相机视角异常,29-电量低，30-缺少SD卡*/
    DWORD dwAlarmInputNumber;/*报警输入端口*/
    BYTE byAlarmOutputNumber[MAX_ALARMOUT_V30];/*触发的输出端口，为1表示对应输出*/
    BYTE byAlarmRelateChannel[MAX_CHANNUM_V30];/*触发的录像通道，为1表示对应录像, dwAlarmRelateChannel[0]对应第1个通道*/
    BYTE byChannel[MAX_CHANNUM_V30];/*dwAlarmType为2或3,6,9,10,14,19,28时，表示哪个通道，dwChannel[0]对应第1个通道*/
    BYTE byDiskNumber[MAX_DISKNUM_V30];/*dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]对应第1个硬盘*/
    #ifdef SDK_CHEZAI
    NET_DVR_ADDIT_POSITION GPS_pos;  /* GPS定位信息 */
    #endif
}NET_DVR_ALARMINFO_V30, *LPNET_DVR_ALARMINFO_V30;

typedef struct tagNET_DVR_ALARM_HOT_SPARE
{
    DWORD  dwSize;   //结构体
    DWORD  dwExceptionCase;   //报警原因   0-网络异常
    NET_DVR_IPADDR  struDeviceIP;    //产生异常的设备IP地址
    BYTE    byRes[256];         //保留
}NET_DVR_ALARM_HOT_SPARE, *LPNET_DVR_ALARM_HOT_SPARE;

typedef struct 
{
    DWORD dwAlarmType;/*0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常，10-录像异常 11- 智能场景变化*/
    DWORD dwAlarmInputNumber;/*报警输入端口*/
    DWORD dwAlarmOutputNumber[MAX_ALARMOUT];/*触发的输出端口，哪一位为1表示对应哪一个输出*/
    DWORD dwAlarmRelateChannel[MAX_CHANNUM];/*触发的录像通道，哪一位为1表示对应哪一路录像, dwAlarmRelateChannel[0]对应第1个通道*/
    DWORD dwChannel[MAX_CHANNUM];/*dwAlarmType为2或3,6,9,10时，表示哪个通道，dwChannel[0]位对应第1个通道*/
    DWORD dwDiskNumber[MAX_DISKNUM];/*dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]位对应第1个硬盘*/
}NET_DVR_ALARMINFO, *LPNET_DVR_ALARMINFO;

typedef struct 
{
    DWORD dwEnable;                    /* 该IP设备是否启用 */
    BYTE sUserName[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */ 
    NET_DVR_IPADDR struIP;            /* IP地址 */
    WORD wDVRPort;                     /* 端口号 */
    BYTE byRes[34];                /* 保留 */
}NET_DVR_IPDEVINFO, *LPNET_DVR_IPDEVINFO;

typedef struct tagNET_DVR_IPDEVINFO_V31
{
    BYTE byEnable;                    //该IP设备是否有效
    BYTE byProType;                    //协议类型，0-私有协议，1-松下协议，2-索尼
    BYTE byEnableQuickAdd;        // 0 不支持快速添加  1 使用快速添加 
    // 快速添加需要设备IP和协议类型，其他信息由设备默认指定
    BYTE byCameraType;    //通道接入的相机类型，值为 0-无意义，1-老师跟踪，2-学生跟踪，3-老师全景，4-学生全景，5-多媒体，6–教师定位,7-学生定位,8-板书定位,9-板书相机
    BYTE sUserName[NAME_LEN];        //用户名
    BYTE sPassword[PASSWD_LEN];        //密码
    BYTE byDomain[MAX_DOMAIN_NAME];    //设备域名
    NET_DVR_IPADDR struIP;            //IP地址
    WORD wDVRPort;                     // 端口号
    BYTE  szDeviceID[DEV_ID_LEN];  //设备ID
    BYTE byEnableTiming;  //0-保留，1-不启用NVR对IPC自动校时，2-启用NVR对IPC自动校时
    BYTE byCertificateValidation;//证书验证
    // byCertificateValidation:bit0: 0-不启用证书验证 1-启用证书验证
    // byCertificateValidation:bit1: 0-不启用默认通信端口 1-启用默认通信端口
}NET_DVR_IPDEVINFO_V31, *LPNET_DVR_IPDEVINFO_V31;

typedef struct 
{
    BYTE byEnable;                    /* 该通道是否在线 */
    BYTE byIPID;                    //IP设备ID低8位，当设备ID为0时表示通道不可用
    BYTE byChannel;                    /* 通道号 */
    BYTE byIPIDHigh;                // IP设备ID的高8位
    BYTE byTransProtocol;            //传输协议类型0-TCP/auto(具体有设备决定)，1-UDP 2-多播 3-仅TCP 4-auto
    BYTE byGetStream;         /* 是否对该通道取流，0-是，1-否*/
    BYTE byres[30];                    /* 保留 */
} NET_DVR_IPCHANINFO, *LPNET_DVR_IPCHANINFO;

typedef struct 
{
    DWORD dwSize;                                        /* 结构大小 */
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];    /* IP设备 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];        /* 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效 */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];    /* IP通道 */    
}NET_DVR_IPPARACFG, *LPNET_DVR_IPPARACFG;

typedef struct tagNET_DVR_IPPARACFG_V31
{
    DWORD dwSize;                                        /* 结构大小 */
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE];    /* IP设备 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];        /* 模拟通道是否启用，从低到高表示1-32通道，0表示无效 1有效 */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];    /* IP通道 */    
}NET_DVR_IPPARACFG_V31, *LPNET_DVR_IPPARACFG_V31;


typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG
{
    BYTE    byValid;            /*是否可用*/
    BYTE    byRes1[3];
    NET_DVR_IPADDR  struDevIP;      
    WORD    wDevPort;            /*流媒体服务器端口*/    
    BYTE    byTransmitType;        /*传输协议类型 0-TCP，1-UDP*/
    BYTE    byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG;

typedef struct tagNET_DVR_DEV_CHAN_INFO
{
    NET_DVR_IPADDR     struIP;            //DVR IP地址
    WORD     wDVRPort;                 //端口号
    BYTE     byChannel;                //通道号
    BYTE    byTransProtocol;        //传输协议类型0-TCP，1-UDP
    BYTE    byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE    byFactoryType;            /*前端设备厂家类型,通过接口获取*/
    BYTE    byDeviceType; //设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
    BYTE    byDispChan;//显示通道号,智能配置使用
    BYTE    bySubDispChan;//显示通道子通道号，智能配置时使用
    BYTE    byResolution;    //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
    BYTE    byRes[2];
    BYTE    byDomain[MAX_DOMAIN_NAME];    //设备域名
    BYTE    sUserName[NAME_LEN];    //监控主机登陆帐号
    BYTE    sPassword[PASSWD_LEN];    //监控主机密码
}NET_DVR_DEV_CHAN_INFO,*LPNET_DVR_DEV_CHAN_INFO;

typedef struct tagNET_DVR_PU_STREAM_CFG
{
    DWORD                                dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO                struDevChanInfo;
}NET_DVR_PU_STREAM_CFG,*LPNET_DVR_PU_STREAM_CFG;

typedef struct tagNET_DVR_DDNS_STREAM_CFG
{
    BYTE   byEnable;   // 是否启用
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struStreamServer;            //流媒体服务器地址
    WORD   wStreamServerPort;           //流媒体服务器端口   
    BYTE   byStreamServerTransmitType;  //流媒体传输协议类型 0-TCP，1-UDP
    BYTE   byRes2;
    NET_DVR_IPADDR   struIPServer;          //IPSERVER地址
    WORD   wIPServerPort;        //IPserver端口号
    BYTE   byRes3[2];           
    BYTE   sDVRName[NAME_LEN];   //DVR名称
    WORD   wDVRNameLen;            // DVR名称长度
    WORD   wDVRSerialLen;          // 序列号长度
    BYTE   sDVRSerialNumber[SERIALNO_LEN];    // DVR序列号
    BYTE   sUserName[NAME_LEN];   // DVR 登陆用户名
    BYTE   sPassWord[PASSWD_LEN]; // DVR登陆密码
    WORD   wDVRPort;   //DVR端口号
    BYTE   byRes4[2];    
    BYTE   byChannel;              // DVR 通道
    BYTE   byTransProtocol; //传输协议类型0-TCP，1-UDP
    BYTE   byTransMode; //传输码流模式 0－主码流 1－子码流
    BYTE   byFactoryType; //前端设备厂家类型,通过接口获取
}NET_DVR_DDNS_STREAM_CFG, *LPNET_DVR_DDNS_STREAM_CFG;

typedef struct tagNET_DVR_PU_STREAM_URL
{
    BYTE    byEnable; 
    BYTE    strURL[URL_LEN];
    BYTE    byTransPortocol ; // 传输协议类型 0-tcp  1-UDP
    WORD    wIPID;  //设备ID号，wIPID = iDevInfoIndex + iGroupNO*64 +1
    BYTE    byChannel;  //通道号
    BYTE    byRes[7];   
}NET_DVR_PU_STREAM_URL, *LPNET_DVR_PU_STREAM_URL;

typedef struct tagNET_DVR_HKDDNS_STREAM
{
    BYTE    byEnable;                 // 是否在线
    BYTE    byRes[3];               // 保留字节
    BYTE    byDDNSDomain[64];        // hiDDNS服务器
    WORD    wPort;                  // hiDDNS 端口
    WORD    wAliasLen;              // 别名长度
    BYTE    byAlias[NAME_LEN];         // 别名
    WORD    wDVRSerialLen;          // 序列号长度
    BYTE    byRes1[2];              // 保留字节
    BYTE    byDVRSerialNumber[SERIALNO_LEN];    // DVR序列号
    BYTE    byUserName[NAME_LEN];   // DVR 登陆用户名
    BYTE    byPassWord[PASSWD_LEN]; // DVR登陆密码
    BYTE    byChannel;              // DVR通道
    BYTE    byRes2[11];             // 保留字    
}NET_DVR_HKDDNS_STREAM, *LPNET_DVR_HKDDNS_STREAM;

typedef struct tagNET_DVR_IPCHANINFO_V40
{
    BYTE    byEnable;                /* 该通道是否在线 */
    BYTE    byRes1;
    WORD    wIPID;                  //IP设备ID
    DWORD     dwChannel;                //通道号
    BYTE    byTransProtocol;        //传输协议类型0-TCP，1-UDP，2- 多播，3-RTSP，0xff- auto(自动)
    BYTE    byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE    byFactoryType;            /*前端设备厂家类型,通过接口获取*/
    BYTE    byRes;
    BYTE    strURL[URL_LEN/*240*/];   /*RTSP协议取流URL （仅RTSP协议时有效）*/
}NET_DVR_IPCHANINFO_V40,*LPNET_DVR_IPCHANINFO_V40;

typedef struct tagNET_DVR_STREAM_INFO 
{
    DWORD dwSize;
    BYTE  byID[STREAM_ID_LEN];      //ID数据
    DWORD dwChannel;                //关联设备通道，等于0xffffffff时，表示不关联
    BYTE  byRes[32];                //保留
}NET_DVR_STREAM_INFO, *LPNET_DVR_STREAM_INFO;

typedef struct tagNET_DVR_RTSP_PROTOCAL_CFG
{ 
    BYTE    byEnable;
    BYTE    byLocalBackUp; //是否本地备份 
    BYTE    byRes[2]; 
    BYTE    strURL[URL_LEN_V40];
    DWORD   dwProtocalType;   //协议类型
    BYTE    sUserName[NAME_LEN];   //设备登陆用户名
    BYTE    sPassWord[PASSWD_LEN]; // 设备登陆密码
    BYTE    byAddress[MAX_DOMAIN_NAME];  //前端IP或者域名,需要设备解析
    //解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    WORD    wPort;
    BYTE    byRes1[122];             //保留
}NET_DVR_RTSP_PROTOCAL_CFG, *LPNET_DVR_RTSP_PROTOCAL_CFG;



typedef struct tagNET_DVR_STREAM_MODE
{
    BYTE    byGetStreamType; //取流方式GET_STREAM_TYPE，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流,3.通过IPServer找到设备，再通过流媒体去设备的流
    //4-通过流媒体由URL去取流,5-通过hkDDNS取流，6-直接从设备取流(扩展)，使用NET_DVR_IPCHANINFO_V40结构, 7-通过RTSP协议方式进行取流
    BYTE    byRes[3];        //保留字节
    NET_DVR_GET_STREAM_UNION uGetStream;    // 不同取流方式结构体
}NET_DVR_STREAM_MODE, *LPNET_DVR_STREAM_MODE;

typedef struct tagNET_DVR_IPPARACFG_V40
{
    DWORD      dwSize;                            /* 结构大小 */
    DWORD       dwGroupNum;                    //     设备支持的总组数    
    DWORD      dwAChanNum;                    //最大模拟通道个数
    DWORD      dwDChanNum;                  //数字通道个数
    DWORD      dwStartDChan;                    //起始数字通道
    BYTE       byAnalogChanEnable[MAX_CHANNUM_V30];    /* 模拟通道是否启用，从低到高表示1-64通道，0表示无效 1有效 */
    NET_DVR_IPDEVINFO_V31   struIPDevInfo[MAX_IP_DEVICE_V40];      /* IP设备 */
    NET_DVR_STREAM_MODE  struStreamMode[MAX_CHANNUM_V30];
    BYTE            byRes2[20];                 // 保留字节
}NET_DVR_IPPARACFG_V40, *LPNET_DVR_IPPARACFG_V40;

typedef struct tagNET_DVR_ALARMINFO_DEV
{
    DWORD     dwAlarmType;  //0-编码器(通道)信号量报警；1-私有卷二损坏；2- NVR服务退出；
    //3-编码器状态异常；4-系统时钟异常；5-录像卷剩余容量过低；
    //6-编码器(通道)移动侦测报警；7-编码器(通道)遮挡报警。；8-录像丢失报警; 9-视频实时监测报警; 10-资源使用率告警; 11- CVR自动修复异常， 12-录像异常
    NET_DVR_TIME   struTime;     //报警时间
    BYTE       byRes[32];    //保留
    DWORD      dwNumber;     //数目
    WORD       *pNO;         //dwNumber个WORD; 每个WORD表示一个通道号，或者磁盘号, 无效时为0
}NET_DVR_ALARMINFO_DEV, *LPNET_DVR_ALARMINFO_DEV;

typedef struct 
{
    BYTE byIPID;                    /* IP设备ID取值1- MAX_IP_DEVICE */
    BYTE byAlarmOut;                /* 报警输出号 */
    BYTE byRes[18];                    /* 保留 */
}NET_DVR_IPALARMOUTINFO, *LPNET_DVR_IPALARMOUTINFO;

typedef struct 
{
    DWORD dwSize;                                    /* 结构大小 */    
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT];/* IP报警输出 */
}NET_DVR_IPALARMOUTCFG, *LPNET_DVR_IPALARMOUTCFG;

typedef struct tagNET_DVR_IPALARMOUTINFO_V40
{
    DWORD dwIPID;                    /* IP设备ID */
    DWORD dwAlarmOut;                /* IP设备ID对应的报警输出号 */
    BYTE  byRes[32];                /* 保留 */
}NET_DVR_IPALARMOUTINFO_V40, *LPNET_DVR_IPALARMOUTINFO_V40;/*报警输出参数*/

typedef struct tagNET_DVR_IPALARMOUTCFG_V40
{
    DWORD   dwSize;  //结构体长度
    DWORD   dwCurIPAlarmOutNum;
    NET_DVR_IPALARMOUTINFO_V40 struIPAlarmOutInfo[MAX_IP_ALARMOUT_V40];/*IP报警输出*/
    BYTE     byRes[256];
}NET_DVR_IPALARMOUTCFG_V40, *LPNET_DVR_IPALARMOUTCFG_V40; /*IP报警输出*/

typedef struct 
{
    BYTE byIPID;                    /* IP设备ID取值1- MAX_IP_DEVICE */
    BYTE byAlarmIn;                    /* 报警输入号 */
    BYTE byRes[18];                    /* 保留 */
}NET_DVR_IPALARMININFO, *LPNET_DVR_IPALARMININFO;

typedef struct 
{
    DWORD dwSize;                                    /* 结构大小 */    
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];/* IP报警输入 */
}NET_DVR_IPALARMINCFG, *LPNET_DVR_IPALARMINCFG;

typedef struct tagNET_DVR_IPALARMININFO_V40
{
    DWORD dwIPID;                    /* IP设备ID */
    DWORD dwAlarmIn;                /* IP设备ID对应的报警输入号 */
    BYTE  byRes[32];                /* 保留 */
}NET_DVR_IPALARMININFO_V40, *LPNET_DVR_IPALARMININFO_V40;   /* 报警输入参数 */

typedef struct tagNET_DVR_IPALARMINCFG_V40
{
    DWORD   dwSize;  //结构体长度
    DWORD   dwCurIPAlarmInNum;  //当前报警输入口数
    NET_DVR_IPALARMININFO_V40 struIPAlarmInInfo[MAX_IP_ALARMIN_V40];/* IP报警输入*/
    BYTE     byRes[256];
}NET_DVR_IPALARMINCFG_V40, *LPNET_DVR_IPALARMINCFG_V40; /*IP报警输入资源*/

typedef struct tagNET_DVR_IPALARMINFO
{
    NET_DVR_IPDEVINFO  struIPDevInfo[MAX_IP_DEVICE];            /* IP设备 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                /* 模拟通道是否启用，0-未启用 1-启用 */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];            /* IP通道 */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP报警输入 */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP报警输出 */
}NET_DVR_IPALARMINFO, *LPNET_DVR_IPALARMINFO;

typedef struct tagNET_DVR_IPALARMINFO_V31
{
    NET_DVR_IPDEVINFO_V31  struIPDevInfo[MAX_IP_DEVICE];            /* IP设备 */
    BYTE byAnalogChanEnable[MAX_ANALOG_CHANNUM];                /* 模拟通道是否启用，0-未启用 1-启用 */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_IP_CHANNEL];            /* IP通道 */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP报警输入 */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP报警输出 */   
}NET_DVR_IPALARMINFO_V31, *LPNET_DVR_IPALARMINFO_V31;

typedef struct tagNET_DVR_IPALARMINFO_V40
{
    NET_DVR_IPDEVINFO_V31 struIPDevInfo[MAX_IP_DEVICE_V40];           // IP设备
    BYTE     byAnalogChanEnable[MAX_CHANNUM_V30];           /* 模拟通道是否启用，0-未启用 1-启用 */
    NET_DVR_IPCHANINFO struIPChanInfo[MAX_CHANNUM_V30];            /* IP通道 */
    NET_DVR_IPALARMININFO struIPAlarmInInfo[MAX_IP_ALARMIN];    /* IP报警输入 */
    NET_DVR_IPALARMOUTINFO struIPAlarmOutInfo[MAX_IP_ALARMOUT]; /* IP报警输出 */   
    BYTE                    byRes[20];                          // 保留字节
}NET_DVR_IPALARMINFO_V40, *LPNET_DVR_IPALARMINFO_V40;






typedef struct tagNET_DVR_HARD_DISK_SINGLE_VOLUME_INFO
{
    DWORD  dwSize;
    BYTE  byHDVolumeNo;      /*硬盘卷ID(不可设置)*/
    BYTE  byType;       /*硬盘卷类型:0-录像卷（用于保存录像），1-存档卷（用于存档录像，下发录像计划时，不能关联存档卷）,
                        2-文件卷（只用于存储客户端上传的文件，下发录像计划时，不能关联文件卷，需要过滤掉）3-图片卷（只用于存储客户端上传的图片）*/
    BYTE  byRes1[2];
    DWORD  dwCapacity;     /*硬盘卷容量，单位MB(不可设置)*/
    DWORD  dwFreeSpace;    /*硬盘卷剩余空间，单位MB(不可设置) */
    BYTE  byHDVolumeName[NET_SDK_DISK_VOLUME_LEN/*36*/];  /*硬盘卷名称(不可设置)*/
    BYTE  byLoopCover;    /*是否循环覆盖：0-非循环覆盖，1-循环覆盖（硬盘卷满了之后，循环覆盖最老的录像）*/
    BYTE  byRes[63];
}NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO, *LPNET_DVR_HARD_DISK_SINGLE_VOLUME_INFO;

typedef struct tagNET_DVR_HARD_DISK_VOLUME_INFO
{
    DWORD  dwSize;
    DWORD  dwHDVolumeCount;      /*当前硬盘卷总数(不可设置)*/
    NET_DVR_HARD_DISK_SINGLE_VOLUME_INFO struSingleVolumeInfo[NET_SDK_MAX_DISK_VOLUME/*33*/];    /*单个硬盘卷信息*/
    BYTE  byRes[128];
}NET_DVR_HARD_DISK_VOLUME_INFO, *LPNET_DVR_HARD_DISK_VOLUME_INFO;

typedef struct tagNET_DVR_SINGLE_HDGROUP_V40
{
    DWORD     dwHDGroupNo;       /*盘组号(不可设置) 1-MAX_HD_GROUP*/        
    DWORD      dwRelRecordChan[MAX_CHANNUM_V40];  //触发的录像通道，按值表示，遇到0xffffffff时后续视为无效     
    BYTE       byRes[64];                /* 保留 */
}NET_DVR_SINGLE_HDGROUP_V40, *LPNET_DVR_SINGLE_HDGROUP_V40;

typedef struct tagNET_DVR_HDGROUP_CFG_V40
{
    DWORD      dwSize;                //结构体大小
    DWORD     dwMaxHDGroupNum;           //设备支持的最大盘组数-只读
    DWORD     dwCurHDGroupNum;       /*当前配置的盘组数*/
    NET_DVR_SINGLE_HDGROUP_V40 struHDGroupAttr[MAX_HD_GROUP]; //硬盘相关操作都需要重启才能生效；
    BYTE       byRes[128]; //保留
}NET_DVR_HDGROUP_CFG_V40, *LPNET_DVR_HDGROUP_CFG_V40;




typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];    /* 名称 */
    DWORD dwAlarmOutDelay;    /* 输出保持时间(-1为无限，手动关闭) */
    //0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动,8-1秒,9-2秒,10-3秒,11-4秒
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT_V30];/* 报警输出激活时间段 */
    BYTE byAlarmOutHandle;            /* 是否处理 0-处理 1-不处理*/
    BYTE byNormalSatus;            /* 常态 0-常开 1-常闭*/
    BYTE byRes[14];
}NET_DVR_ALARMOUTCFG_V30, *LPNET_DVR_ALARMOUTCFG_V30;

typedef struct 
{
    DWORD dwSize;
    BYTE sAlarmOutName[NAME_LEN];    /* 名称 */
    DWORD dwAlarmOutDelay;    /* 输出保持时间(-1为无限，手动关闭) */
    //0-5秒,1-10秒,2-30秒,3-1分钟,4-2分钟,5-5分钟,6-10分钟,7-手动, 8-1秒, 9-3秒
    NET_DVR_SCHEDTIME struAlarmOutTime[MAX_DAYS][MAX_TIMESEGMENT];/* 报警输出激活时间段 */
}NET_DVR_ALARMOUTCFG, *LPNET_DVR_ALARMOUTCFG;

typedef struct 
{
    DWORD dwSize;
    BYTE byPreviewNumber;//预览模式,0-1画面,1-4画面,2-9画面,3-16画面,0xff:最大画面
    BYTE byEnableAudio;//是否声音预览,0-不预览,1-预览
    WORD wSwitchTime;//切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
    BYTE bySwitchSeq[MAX_PREVIEW_MODE][MAX_WINDOW_V30];//切换顺序,如果lSwitchSeq[i]为 0xff表示不用
    BYTE byRes[24];
}NET_DVR_PREVIEWCFG_V30, *LPNET_DVR_PREVIEWCFG_V30;

typedef struct 
{
    DWORD dwSize;
    BYTE byPreviewNumber;//预览数目,0-1画面,1-4画面,2-9画面,3-16画面,0xff:最大画面
    BYTE byEnableAudio;//是否声音预览,0-不预览,1-预览
    WORD wSwitchTime;//切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s
    BYTE bySwitchSeq[MAX_WINDOW];//切换顺序,如果lSwitchSeq[i]为 0xff表示不用
}NET_DVR_PREVIEWCFG, *LPNET_DVR_PREVIEWCFG;

typedef struct 
{
    WORD wResolution;                            /* 分辨率 */
    WORD wFreq;                                    /* 刷新频率 */
    DWORD dwBrightness;                            /* 亮度 */
}NET_DVR_VGAPARA;


typedef struct 
{
    WORD wDisplayLogo;                        /* 显示视频通道号 */
    WORD wDisplayOsd;                        /* 显示时间 */
}NET_DVR_MATRIXPARA;

typedef struct 
{
    BYTE byVideoFormat;                        /* 输出制式,0-PAL,1-NTSC */
    BYTE byMenuAlphaValue;                    /* 菜单与背景图象对比度 */
    WORD wScreenSaveTime;                    /* 屏幕保护时间 0-从不,1-1分钟,2-2分钟,3-5分钟,4-10分钟,5-20分钟,6-30分钟 */
    WORD wVOffset;                            /* 视频输出偏移 */
    WORD wBrightness;                        /* 视频输出亮度 */
    BYTE byStartMode;                        /* 启动后视频输出模式(0:菜单,1:预览)*/
    BYTE byEnableScaler;                    /* 是否启动缩放 (0-不启动, 1-启动)*/
}NET_DVR_VOOUT;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT_V30];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA_V30];    /* VGA参数 */
    NET_DVR_MATRIXPARA_V30 struMatrixPara[MAX_MATRIXOUT];        /* MATRIX参数 */
    BYTE byRes[16];
}NET_DVR_VIDEOOUT_V30, *LPNET_DVR_VIDEOOUT_V30;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_VOOUT struVOOut[MAX_VIDEOOUT];
    NET_DVR_VGAPARA struVGAPara[MAX_VGA];    /* VGA参数 */
    NET_DVR_MATRIXPARA struMatrixPara;        /* MATRIX参数 */
}NET_DVR_VIDEOOUT, *LPNET_DVR_VIDEOOUT;

typedef struct tagNET_DVR_USER_INFO_V40
{
    BYTE    sUserName[NAME_LEN];            /* 用户名只能用16字节 */
    BYTE    sPassword[PASSWD_LEN];            /* 密码 */
    BYTE    byLocalRight[MAX_RIGHT];    /* 本地权限 */
    /*数组0: 本地控制云台*/
    /*数组1: 本地手动录象*/
    /*数组2: 本地回放*/
    /*数组3: 本地设置参数*/
    /*数组4: 本地查看状态、日志*/
    /*数组5: 本地高级操作(升级，格式化，重启，关机)*/
    /*数组6: 本地查看参数 */
    /*数组7: 本地管理模拟和IP camera */
    /*数组8: 本地备份 */
    /*数组9: 本地关机/重启 */    
    BYTE    byRemoteRight[MAX_RIGHT];/* 远程权限 */    
    /*数组0: 远程控制云台*/
    /*数组1: 远程手动录象*/
    /*数组2: 远程回放 */
    /*数组3: 远程设置参数*/
    /*数组4: 远程查看状态、日志*/
    /*数组5: 远程高级操作(升级，格式化，重启，关机)*/
    /*数组6: 远程发起语音对讲*/
    /*数组7: 远程预览*/
    /*数组8: 远程请求报警上传、报警输出*/
    /*数组9: 远程控制，本地输出*/
    /*数组10: 远程控制串口*/    
    /*数组11: 远程查看参数 */
    /*数组12: 远程管理模拟和IP camera */
    /*数组13: 远程关机/重启 */    
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40];            /* 远程可以预览的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40];            /* 本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40];            /* 远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40];            /* 本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40];            /* 远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40];                /* 本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40];                /* 远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40];            /* 本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    NET_DVR_IPADDR    struUserIP;                /* 用户IP地址(为0时表示允许任何地址) */
    BYTE     byMACAddr[MACADDR_LEN];    /* 物理地址 */
    BYTE     byPriority;                /* 优先级，0xff-无，0--低，1--中，2--高 */
                                        /* 无……表示不支持优先级的设置
                                        低……默认权限:包括本地和远程回放,本地和远程查看日志和
                                        状态,本地和远程关机/重启
                                        中……包括本地和远程控制云台,本地和远程手动录像,本地和
                                        远程回放,语音对讲和远程预览、本地备份,本地/远程关机/重启
    高……管理员 */
    BYTE    byAlarmOnRight;         // 报警输入口布防权限 1-有权限，0-无权限
    BYTE    byAlarmOffRight;         // 报警输入口撤防权限 1-有权限，0-无权限
    BYTE    byBypassRight;           // 报警输入口旁路权限 1-有权限，0-无权限 
    BYTE    byRes1[2];               //四字节对齐
    BYTE    byPublishRight[MAX_RIGHT];  //信息发布专有权限
    /*数组0: 素材审核权限*/
    /*数组1: 节目审核权限*/
    /*数组2: 日程审核权限*/
    /*数组3: 上传素材权限*/
    /*数组4: 新建节目权限*/
    /*数组5: 新建日程权限*/
    /*数组6: 信息播放权限*/
    /*数组7: 终端管理权限*/
    /*数组8: 商业智能权限*/    
    BYTE    byRes[84];    
}NET_DVR_USER_INFO_V40, *LPNET_DVR_USER_INFO_V40;

typedef struct tagNET_DVR_USER_INFO_V51
{
    BYTE    sUserName[NAME_LEN/*32*/];            /* 用户名只能用16字节 */
    BYTE    sPassword[PASSWD_LEN/*16*/];            /* 密码 */
    BYTE    byLocalRight[MAX_RIGHT/*32*/];    /* 本地权限 */
    /*数组0: 本地控制云台*/
    /*数组1: 本地手动录象*/
    /*数组2: 本地回放*/
    /*数组3: 本地设置参数*/
    /*数组4: 本地查看状态、日志*/
    /*数组5: 本地高级操作(升级，格式化，重启，关机)*/
    /*数组6: 本地查看参数 */
    /*数组7: 本地管理模拟和IP camera */
    /*数组8: 本地备份 */
    /*数组9: 本地关机/重启 */
    /*数组10: 本地预览 */
    BYTE    byRemoteRight[MAX_RIGHT/*32*/];/* 远程权限 */
    /*数组0: 远程控制云台*/
    /*数组1: 远程手动录象*/
    /*数组2: 远程回放 */
    /*数组3: 远程设置参数*/
    /*数组4: 远程查看状态、日志*/
    /*数组5: 远程高级操作(升级，格式化，重启，关机)*/
    /*数组6: 远程发起语音对讲*/
    /*数组7: 远程预览*/
    /*数组8: 远程请求报警上传、报警输出*/
    /*数组9: 远程控制，本地输出*/
    /*数组10: 远程控制串口*/
    /*数组11: 远程查看参数 */
    /*数组12: 远程管理模拟和IP camera */
    /*数组13: 远程关机/重启 */
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40/*512*/];            /* 远程可以预览的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40/*512*/];            /* 本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40/*512*/];            /* 远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* 本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* 远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40/*512*/];                /* 本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40/*512*/];                /* 远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40/*512*/];            /* 本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalPreviewRight[MAX_CHANNUM_V40/*512*/];		/* 本地预览权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    NET_DVR_IPADDR    struUserIP;                /* 用户IP地址(为0时表示允许任何地址) */
    BYTE     byMACAddr[MACADDR_LEN/*6*/];    /* 物理地址 */
    BYTE     byPriority;                /* 优先级，0xff-无，0--低，1--中，2--高 */
    /* 无……表示不支持优先级的设置
    低……默认权限:包括本地和远程回放,本地和远程查看日志和
    状态,本地和远程关机/重启
    中……包括本地和远程控制云台,本地和远程手动录像,本地和
    远程回放,语音对讲和远程预览、本地备份,本地/远程关机/重启高……管理员 */
    BYTE    byAlarmOnRight;         // 报警输入口布防权限 1-有权限，0-无权限
    BYTE    byAlarmOffRight;         // 报警输入口撤防权限 1-有权限，0-无权限
    BYTE    byBypassRight;           // 报警输入口旁路权限 1-有权限，0-无权限 
    BYTE    byRes1[2];               //四字节对齐
    BYTE    byPublishRight[MAX_RIGHT/*32*/];  //信息发布专有权限
    /*数组0: 素材审核权限*/
    /*数组1: 节目审核权限*/
    /*数组2: 日程审核权限*/
    /*数组3: 上传素材权限*/
    /*数组4: 新建节目权限*/
    /*数组5: 新建日程权限*/
    /*数组6: 信息播放权限*/
    /*数组7: 终端管理权限*/
    /*数组8: 商业智能权限*/
    DWORD    dwPasswordValidity;   //密码有效期,仅管理员用户可以修改,单位：天，填0表示永久生效
    BYTE    byKeypadPassword[PASSWD_LEN/*16*/];    //键盘密码
    BYTE    byUserOperateType;    //用户操作类型，1-网络用户，2-键盘用户，3-网络用户+键盘用户
    BYTE    byRes[1007];
}NET_DVR_USER_INFO_V51, *LPNET_DVR_USER_INFO_V51;

typedef struct  tagNET_DVR_USER_V51
{
    DWORD dwSize;  //结构体大小
    DWORD dwMaxUserNum; //设备支持的最大用户数-只读
    NET_DVR_USER_INFO_V51 struUser[MAX_USERNUM_V30/*32*/];  /* 用户参数 */
    char    sloginPassword[PASSWD_LEN/*16*/];          /* 登陆密码确认 */
    BYTE     byRes[240]; //保留
}NET_DVR_USER_V51, *LPNET_DVR_USER_V51;

typedef struct tagNET_DVR_USER_INFO_V52
{
    BYTE    sUserName[NAME_LEN/*32*/];            /* 用户名只能用16字节 */
    BYTE    sPassword[PASSWD_LEN/*16*/];            /* 密码 */
    BYTE    byLocalRight[MAX_RIGHT/*32*/];    /* 本地权限 */
    /*数组0: 本地控制云台*/
    /*数组1: 本地手动录象*/
    /*数组2: 本地回放*/
    /*数组3: 本地设置参数*/
    /*数组4: 本地查看状态、日志*/
    /*数组5: 本地高级操作(升级，格式化，重启，关机)*/
    /*数组6: 本地查看参数 */
    /*数组7: 本地管理模拟和IP camera */
    /*数组8: 本地备份 */
    /*数组9: 本地关机/重启 */
    /*数组10: 本地预览 */
    BYTE    byRemoteRight[MAX_RIGHT/*32*/];/* 远程权限 */
    /*数组0: 远程控制云台*/
    /*数组1: 远程手动录象*/
    /*数组2: 远程回放 */
    /*数组3: 远程设置参数*/
    /*数组4: 远程查看状态、日志*/
    /*数组5: 远程高级操作(升级，格式化，重启，关机)*/
    /*数组6: 远程发起语音对讲*/
    /*数组7: 远程预览*/
    /*数组8: 远程请求报警上传、报警输出*/
    /*数组9: 远程控制，本地输出*/
    /*数组10: 远程控制串口*/
    /*数组11: 远程查看参数 */
    /*数组12: 远程管理模拟和IP camera */
    /*数组13: 远程关机/重启 */
    DWORD    dwNetPreviewRight[MAX_CHANNUM_V40/*512*/];            /* 远程可以预览的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalRecordRight[MAX_CHANNUM_V40/*512*/];            /* 本地可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetRecordRight[MAX_CHANNUM_V40/*512*/];            /* 远程可以录像的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* 本地可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* 远程可以回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalPTZRight[MAX_CHANNUM_V40/*512*/];                /* 本地可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetPTZRight[MAX_CHANNUM_V40/*512*/];                /* 远程可以PTZ的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalBackupRight[MAX_CHANNUM_V40/*512*/];            /* 本地备份权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalPreviewRight[MAX_CHANNUM_V40/*512*/];		/* 本地预览权限通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalDoubleVerificationPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* 本地可以二次认证回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwLocalDoubleVerificationBackupRight[MAX_CHANNUM_V40/*512*/];            /* 本地可以二次认证备份的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    DWORD    dwNetDoubleVerificationPlaybackRight[MAX_CHANNUM_V40/*512*/];            /* 远程可以二次认证回放的通道，从前往后顺序排列，遇到0xffffffff后续均为无效*/
    NET_DVR_IPADDR    struUserIP;                /* 用户IP地址(为0时表示允许任何地址) */
    BYTE     byMACAddr[MACADDR_LEN/*6*/];    /* 物理地址 */
    BYTE     byPriority;                /* 优先级，0xff-无，0--低，1--中，2--高 */
    /* 无……表示不支持优先级的设置
    低……默认权限:包括本地和远程回放,本地和远程查看日志和
    状态,本地和远程关机/重启
    中……包括本地和远程控制云台,本地和远程手动录像,本地和
    远程回放,语音对讲和远程预览、本地备份,本地/远程关机/重启高……管理员 */
    BYTE    byAlarmOnRight;         // 报警输入口布防权限 1-有权限，0-无权限
    BYTE    byAlarmOffRight;         // 报警输入口撤防权限 1-有权限，0-无权限
    BYTE    byBypassRight;           // 报警输入口旁路权限 1-有权限，0-无权限 
    BYTE    byRes1[2];               //四字节对齐
    BYTE    byPublishRight[MAX_RIGHT/*32*/];  //信息发布专有权限
    /*数组0: 素材审核权限*/
    /*数组1: 节目审核权限*/
    /*数组2: 日程审核权限*/
    /*数组3: 上传素材权限*/
    /*数组4: 新建节目权限*/
    /*数组5: 新建日程权限*/
    /*数组6: 信息播放权限*/
    /*数组7: 终端管理权限*/
    /*数组8: 商业智能权限*/
    DWORD    dwPasswordValidity;   //密码有效期,仅管理员用户可以修改,单位：天，填0表示永久生效
    BYTE    byKeypadPassword[PASSWD_LEN/*16*/];    //键盘密码
    BYTE    byUserOperateType;    //用户操作类型，1-网络用户，2-键盘用户，3-网络用户+键盘用户
    BYTE    byRes[1007];
}NET_DVR_USER_INFO_V52, *LPNET_DVR_USER_INFO_V52;

typedef struct  tagNET_DVR_USER_V52
{
    DWORD dwSize;  //结构体大小
    DWORD dwMaxUserNum; //设备支持的最大用户数-只读
    NET_DVR_USER_INFO_V52 struUser[MAX_USERNUM_V30/*32*/];  /* 用户参数 */
    char    sloginPassword[PASSWD_LEN/*16*/];          /* 登陆密码确认 */
    BYTE     byRes[240]; //保留
}NET_DVR_USER_V52, *LPNET_DVR_USER_V52;


typedef struct 
{
    BYTE sUserName[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */
    DWORD dwLocalRight[MAX_RIGHT];    /* 权限 */
    /*数组0: 本地控制云台*/
    /*数组1: 本地手动录象*/
    /*数组2: 本地回放*/
    /*数组3: 本地设置参数*/
    /*数组4: 本地查看状态、日志*/
    /*数组5: 本地高级操作(升级，格式化，重启，关机)*/
    DWORD dwLocalPlaybackRight;        /* 本地可以回放的通道 bit0 -- channel 1*/
    DWORD dwRemoteRight[MAX_RIGHT];    /* 权限 */
    /*数组0: 远程控制云台*/
    /*数组1: 远程手动录象*/
    /*数组2: 远程回放 */
    /*数组3: 远程设置参数*/
    /*数组4: 远程查看状态、日志*/
    /*数组5: 远程高级操作(升级，格式化，重启，关机)*/
    /*数组6: 远程发起语音对讲*/
    /*数组7: 远程预览*/
    /*数组8: 远程请求报警上传、报警输出*/
    /*数组9: 远程控制，本地输出*/
    /*数组10: 远程控制串口*/
    DWORD dwNetPreviewRight;        /* 远程可以预览的通道 bit0 -- channel 1*/
    DWORD dwNetPlaybackRight;        /* 远程可以回放的通道 bit0 -- channel 1*/
    char sUserIP[16];                /* 用户IP地址(为0时表示允许任何地址) */
    BYTE byMACAddr[MACADDR_LEN];    /* 物理地址 */
}NET_DVR_USER_INFO_EX, *LPNET_DVR_USER_INFO_EX;

typedef struct 
{
    BYTE sUserName[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */
    DWORD dwLocalRight[MAX_RIGHT];    /* 权限 */
    /*数组0: 本地控制云台*/
    /*数组1: 本地手动录象*/
    /*数组2: 本地回放*/
    /*数组3: 本地设置参数*/
    /*数组4: 本地查看状态、日志*/
    /*数组5: 本地高级操作(升级，格式化，重启，关机)*/
    DWORD dwRemoteRight[MAX_RIGHT];    /* 权限 */
    /*数组0: 远程控制云台*/
    /*数组1: 远程手动录象*/
    /*数组2: 远程回放 */
    /*数组3: 远程设置参数*/
    /*数组4: 远程查看状态、日志*/
    /*数组5: 远程高级操作(升级，格式化，重启，关机)*/
    /*数组6: 远程发起语音对讲*/
    /*数组7: 远程预览*/
    /*数组8: 远程请求报警上传、报警输出*/
    /*数组9: 远程控制，本地输出*/
    /*数组10: 远程控制串口*/
    char sUserIP[16];                /* 用户IP地址(为0时表示允许任何地址) */
    BYTE byMACAddr[MACADDR_LEN];    /* 物理地址 */
}NET_DVR_USER_INFO, *LPNET_DVR_USER_INFO;

typedef struct  tagNET_DVR_USER_V40
{
    DWORD dwSize;  //结构体大小
    DWORD dwMaxUserNum; //设备支持的最大用户数-只读
    NET_DVR_USER_INFO_V40 struUser[MAX_USERNUM_V30];  /* 用户参数 */
}NET_DVR_USER_V40,*LPNET_DVR_USER_V40;

typedef struct  tagNET_DVR_USER_V50
{
    DWORD dwSize;  //结构体大小
    DWORD dwMaxUserNum; //设备支持的最大用户数-只读
    NET_DVR_USER_INFO_V40 struUser[MAX_USERNUM_V30];  /* 用户参数 */
    char    sloginPassword[PASSWD_LEN/*16*/];          /* 登陆密码确认 */
    BYTE     byRes[240]; //保留
}NET_DVR_USER_V50, *LPNET_DVR_USER_V50;


typedef struct 
{
    DWORD dwSize;
    NET_DVR_USER_INFO_EX struUser[MAX_USERNUM];
}NET_DVR_USER_EX, *LPNET_DVR_USER_EX;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_USER_INFO struUser[MAX_USERNUM];
}NET_DVR_USER, *LPNET_DVR_USER;

typedef struct tagNET_DVR_EXCEPTION_V40
{
    DWORD             dwSize ;             //结构体大小
    DWORD             dwMaxGroupNum ;    //设备支持的最大组数
    NET_DVR_HANDLEEXCEPTION_V41 struExceptionHandle[MAX_EXCEPTIONNUM_V30];    
    BYTE                byRes[128];          //保留
}NET_DVR_EXCEPTION_V40,*LPNET_DVR_EXCEPTION_V40; /*异常参数配置扩展结构体*/

typedef struct 
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION_V30 struExceptionHandleType[MAX_EXCEPTIONNUM_V30];
    /*数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突, 4-非法访问, 5-输入/输出视频制式不匹配, 6-视频信号异常, 7-录像异常 8-阵列异常，9-前端/录像分辨率不匹配异常，10-行车超速(车载专用) 11-热备异常（N+1使用）12-温度，13-子系统异常，14-风扇异常, 15-POE供电异常, 16-POC异常,数组17-电源电压波动异常*/
}NET_DVR_EXCEPTION_V30, *LPNET_DVR_EXCEPTION_V30;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_HANDLEEXCEPTION struExceptionHandleType[MAX_EXCEPTIONNUM];
    /*数组0-盘满,1- 硬盘出错,2-网线断,3-局域网内IP 地址冲突,4-非法访问, 5-输入/输出视频制式不匹配, 6-视频信号异常*/
}NET_DVR_EXCEPTION, *LPNET_DVR_EXCEPTION;

typedef struct 
{
    BYTE byRecordStatic; //通道是否在录像,0-不录像,1-录像
    BYTE bySignalStatic; //连接的信号状态,0-正常,1-信号丢失
    BYTE byHardwareStatic;//通道硬件状态,0-正常,1-异常,例如DSP死掉
    BYTE byRes1;        //保留
    DWORD dwBitRate;//实际码率
    DWORD dwLinkNum;//客户端连接的个数
    NET_DVR_IPADDR struClientIP[MAX_LINK];//客户端的IP地址
    DWORD dwIPLinkNum;//如果该通道为IP接入，那么表示IP接入当前的连接数
    BYTE byExceedMaxLink;        // 是否超出了单路6路连接数 0 - 未超出, 1-超出
    BYTE byRes[3];        // 保留字节
    DWORD dwAllBitRate;      //所有实际码率之和
    DWORD dwChannelNo;    //当前的通道号，0xffffffff表示无效
}NET_DVR_CHANNELSTATE_V30, *LPNET_DVR_CHANNELSTATE_V30;

typedef struct 
{
    BYTE byRecordStatic; //通道是否在录像,0-不录像,1-录像
    BYTE bySignalStatic; //连接的信号状态,0-正常,1-信号丢失
    BYTE byHardwareStatic;//通道硬件状态,0-正常,1-异常,例如DSP死掉
    char reservedData;        //保留
    DWORD dwBitRate;//实际码率
    DWORD dwLinkNum;//客户端连接的个数
    DWORD dwClientIP[MAX_LINK];//客户端的IP地址
}NET_DVR_CHANNELSTATE, *LPNET_DVR_CHANNELSTATE;

typedef struct 
{
    DWORD dwVolume;//硬盘的容量
    DWORD dwFreeSpace;//硬盘的剩余空间
    DWORD dwHardDiskStatic; //硬盘的状态,按位:1-休眠,2-不正常,3-休眠硬盘出错,4-未格式化, 5-未连接状态(网络硬盘),6-硬盘正在格式化,7-硬盘满(未开启循环覆盖的情况下),8-其他异常（待设备端统计）
}NET_DVR_DISKSTATE, *LPNET_DVR_DISKSTATE;

typedef struct tagNET_DVR_WORKSTATE_V40
{ 
    DWORD   dwSize ;            //结构体大小
    DWORD   dwDeviceStatic;      //设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //硬盘状态,一次最多只能获取33个硬盘信息
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V40/*512*/];//通道的状态，从前往后顺序排列
    DWORD   dwHasAlarmInStatic[MAX_ALARMIN_V40/*512*/]; //有报警的报警输入口，按值表示，按下标值顺序排列，值为0xffffffff时当前及后续值无效
    DWORD   dwHasAlarmOutStatic[MAX_ALARMOUT_V40/*512*/]; //有报警输出的报警输出口，按值表示，按下标值顺序排列，值为0xffffffff时当前及后续值无效
    DWORD   dwLocalDisplay;            //本地显示状态,0-正常,1-不正常
    BYTE    byAudioInChanStatus[MAX_AUDIO_V30/*2*/];        //按位表示语音通道的状态 0-未使用，1-使用中，第0位表示第1个语音通道
    BYTE    byRes1[2];
    float    fHumidity;    //传感器获知的湿度,范围:0.0 ~100.0
    float    fTemperature;    //传感器获知的温度，范围：-20.0 ~ 90.0
    BYTE    byRes[116];                 //保留
}NET_DVR_WORKSTATE_V40, *LPNET_DVR_WORKSTATE_V40; /*设备工作状态扩展结构体*/

typedef struct tagNET_DVR_GETWORKSTATE_COND
{
    DWORD   dwSize ;  //结构体长度
    BYTE    byFindHardByCond; /*0-查找全部磁盘(但一次最多只能查找33个)，此时dwFindHardStatusNum无效*/
    BYTE    byFindChanByCond ;  /*0-查找全部通道，此时dwFindChanNum无效*/
    BYTE    byRes1[2] ;//保留    
    DWORD   dwFindHardStatus[MAX_DISKNUM_V30/*33*/] ; /*要查找的硬盘号，按值表示，该值采用顺序排列， 遇到0xffffffff则认为后续无效 */
    DWORD   dwFindChanNo[MAX_CHANNUM_V40/*512*/] ; /*要查找的通道号，按值表示，该值采用顺序排列， 遇到0xffffffff则认为后续无效 */
    BYTE     byRes[64] ; //保留
}NET_DVR_GETWORKSTATE_COND, *LPNET_DVR_GETWORKSTATE_COND;

typedef struct 
{
    DWORD dwDeviceStatic;     //设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];
    NET_DVR_CHANNELSTATE_V30 struChanStatic[MAX_CHANNUM_V30];//通道的状态
    BYTE  byAlarmInStatic[MAX_ALARMIN_V30]; //报警端口的状态,0-没有报警,1-有报警
    BYTE  byAlarmOutStatic[MAX_ALARMOUT_V30]; //报警输出端口的状态,0-没有输出,1-有报警输出
    DWORD  dwLocalDisplay;//本地显示状态,0-正常,1-不正常
    BYTE  byAudioChanStatus[MAX_AUDIO_V30];//表示语音通道的状态 0-未使用，1-使用中, 0xff无效
    BYTE  byRes[10];
}NET_DVR_WORKSTATE_V30, *LPNET_DVR_WORKSTATE_V30;

typedef struct 
{
    DWORD dwDeviceStatic;     //设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM];
    NET_DVR_CHANNELSTATE struChanStatic[MAX_CHANNUM];//通道的状态
    BYTE  byAlarmInStatic[MAX_ALARMIN]; //报警端口的状态,0-没有报警,1-有报警
    BYTE  byAlarmOutStatic[MAX_ALARMOUT]; //报警输出端口的状态,0-没有输出,1-有报警输出
    DWORD  dwLocalDisplay;//本地显示状态,0-正常,1-不正常
}NET_DVR_WORKSTATE, *LPNET_DVR_WORKSTATE;

typedef struct 
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;    //主类型 1-报警; 2-异常; 3-操作; 0xff-全部
    DWORD    dwMinorType;//次类型 0-全部;
    BYTE    sPanelUser[MAX_NAMELEN]; //操作面板的用户名
    BYTE    sNetUser[MAX_NAMELEN];//网络操作的用户名
    NET_DVR_IPADDR    struRemoteHostAddr;//远程主机地址
    DWORD    dwParaType;//参数类型,9000设备MINOR_START_VT/MINOR_STOP_VT时，表示语音对讲的端子号
    DWORD    dwChannel;//通道号
    DWORD    dwDiskNumber;//硬盘号
    DWORD    dwAlarmInPort;//报警输入端口
    DWORD    dwAlarmOutPort;//报警输出端口
    DWORD   dwInfoLen;
    char    sInfo[LOG_INFO_LEN];
}NET_DVR_LOG_V30, *LPNET_DVR_LOG_V30;

typedef struct 
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;    //主类型 1-报警; 2-异常; 3-操作; 0xff-全部
    DWORD    dwMinorType;//次类型 0-全部;
    BYTE    sPanelUser[MAX_NAMELEN]; //操作面板的用户名
    BYTE    sNetUser[MAX_NAMELEN];//网络操作的用户名
    char    sRemoteHostAddr[16];//远程主机地址
    DWORD    dwParaType;//参数类型
    DWORD    dwChannel;//通道号
    DWORD    dwDiskNumber;//硬盘号
    DWORD    dwAlarmInPort;//报警输入端口
    DWORD    dwAlarmOutPort;//报警输出端口
}NET_DVR_LOG, *LPNET_DVR_LOG;

typedef struct tagNET_DVR_FIND_LOG_COND
{
    DWORD            dwSelectMode;  // 0－全部；1－按类型；2－按时间；3－按时间和类型            
    DWORD            dwMainType;	//日志主类型
    DWORD            dwSubType;		//日志次类型
    NET_DVR_TIME_V50 struStartTime; //开始时间
    NET_DVR_TIME_V50 struEndTime;   //结束时间
    BOOL 		     bOnlySmart;    //是否只搜索带S.M.A.R.T信息的日志
    BYTE             byRes[128];
}NET_DVR_FIND_LOG_COND, *LPNET_DVR_FIND_LOG_COND;


typedef struct tagNET_DVR_ALARMHOST_SEARCH_LOG_PARAM
{
    WORD            wMajorType;        // 主类型
    WORD            wMinorType;        // 次类型 
    NET_DVR_TIME    struStartTime;    // 开始时间 
    NET_DVR_TIME    struEndTime;    // 结束时间
    BYTE            byRes[8];        // 保留字节
}NET_DVR_ALARMHOST_SEARCH_LOG_PARAM, LPNET_DVR_ALARMHOST_SEARCH_LOG_PARAM;

typedef struct tagNET_DVR_ALARMHOST_LOG_RET
{
    NET_DVR_TIME    struLogTime;                //  日志时间
    BYTE            sUserName[NAME_LEN];     // 操作用户
    NET_DVR_IPADDR    struIPAddr;                 // 操作IP地址
    WORD            wMajorType;                 // 主类型 
    WORD            wMinorType;                 // 次类型
    WORD            wParam;                        // 操作参数
    BYTE            byRes[10];
    DWORD            dwInfoLen;                    // 描述信息长度
    char            sInfo[LOG_INFO_LEN];       // 描述信息
}NET_DVR_ALARMHOST_LOG_RET, *LPNET_DVR_ALARMHOST_LOG_RET;

typedef struct 
{
    BYTE Output[MAX_ALARMOUT_V30];
}NET_DVR_ALARMOUTSTATUS_V30, *LPNET_DVR_ALARMOUTSTATUS_V30;

typedef struct 
{
    BYTE Output[MAX_ALARMOUT];
}NET_DVR_ALARMOUTSTATUS, *LPNET_DVR_ALARMOUTSTATUS;

typedef struct 
{
    USHORT m_Year;
    USHORT m_Month;
    USHORT m_Day;
    USHORT m_Hour;
    USHORT m_Minute;
    USHORT m_Second;
    BYTE DeviceName[24];    //设备名称
    DWORD dwChannelNumer;    //通道号
    BYTE CardNumber[32];    //卡号
    char cTradeType[12];    //交易类型
    DWORD dwCash;            //交易金额
}NET_DVR_TRADEINFO, *LPNET_DVR_TRADEINFO;

typedef struct 
{
    BYTE code[12];        /* 代码 */
}NET_DVR_FRAMETYPECODE;

typedef struct 
{
    DWORD dwSize;
    char sATMIP[16];                        /* ATM IP地址 */
    DWORD dwATMType;                        /* ATM类型 */
    DWORD dwInputMode;                        /* 输入方式    0-网络侦听 1-网络接收 2-串口直接输入 3-串口ATM命令输入*/
    DWORD dwFrameSignBeginPos;              /* 报文标志位的起始位置*/
    DWORD dwFrameSignLength;                /* 报文标志位的长度 */
    BYTE  byFrameSignContent[12];            /* 报文标志位的内容 */
    DWORD dwCardLengthInfoBeginPos;            /* 卡号长度信息的起始位置 */
    DWORD dwCardLengthInfoLength;            /* 卡号长度信息的长度 */
    DWORD dwCardNumberInfoBeginPos;            /* 卡号信息的起始位置 */
    DWORD dwCardNumberInfoLength;            /* 卡号信息的长度 */
    DWORD dwBusinessTypeBeginPos;           /* 交易类型的起始位置 */
    DWORD dwBusinessTypeLength;                /* 交易类型的长度 */
    NET_DVR_FRAMETYPECODE frameTypeCode[10];/* 类型 */
}NET_DVR_FRAMEFORMAT, *LPNET_DVR_FRAMEFORMAT;


typedef struct    tagNET_DVR_FILTER
{    
    BYTE                    byEnable;            //0,不启用;1,启用
    BYTE                    byMode;                //0,ASCII;1,HEX    
    BYTE                    byFrameBeginPos;    // 需要过滤目标字符串起始位置     
    BYTE                    byRes;           // 保留字节
    BYTE                     byFilterText[16];    //过滤字符串
    BYTE                    byRes2[12];         // 保留字节
}NET_DVR_FILTER, *LPNET_DVR_FILTER;

typedef struct    tagNET_DVR_IDENTIFICAT
{    
    BYTE                    byStartMode;        //起始字符模式:0,ASCII;1,HEX
    BYTE                    byEndMode;            //结束字符模式：0,ASCII;1,HEX
    BYTE                    byRes[2];           //保留字节
    NET_DVR_FRAMETYPECODE    struStartCode;        //数据包起始标识字符
    NET_DVR_FRAMETYPECODE    struEndCode;        //数据包结束标识字符
    BYTE                    byRes1[12];         //保留字节
}NET_DVR_IDENTIFICAT, *LPNET_DVR_IDENTIFICAT;

typedef struct    tagNET_DVR_PACKAGE_LOCATION/*报文信息位置*/
{    
    BYTE                     byOffsetMode;            /*报文位置信息模式 0,token(字符标志模式);1,fix（固定模式）*/
    BYTE                    byRes1[3];                // 保留字节
    DWORD                      dwOffsetPos;            /*mode为1的时候使用,固定偏移大小*/
    NET_DVR_FRAMETYPECODE    struTokenCode;            /*标志位*/
    BYTE                    byMultiplierValue;        /*标志位多少次出现*/
    BYTE                    byEternOffset;            /*附加字符偏移量*/
    BYTE                    byCodeMode;                /*0,ASCII;1,HEX*/
    BYTE                     byRes2[9];                //保留字节
}NET_DVR_PACKAGE_LOCATION, *LPNET_DVR_PACKAGE_LOCATION;

typedef struct    tagNET_DVR_PACKAGE_LENGTH//报文信息长度
{    
    BYTE                    byLengthMode;            //长度类型，0,可变长度;1,固定长度;2,自助长度(从卡号中获取)
    BYTE                    byRes1[3];              // 保留字节
    DWORD                      dwFixLength;                //mode为1的时候使用,固定长度大小
    DWORD                    dwMaxLength;            //报文信息最大长度  byLengthMode为0时使用
    DWORD                    dwMinLength;            //报文信息最小长度  byLengthMode为0时使用
    BYTE                    byEndMode;                //可变长度 终结符模式 0,ASCII;1,HEX    
    BYTE                    byRes2[3];              //保留字节
    NET_DVR_FRAMETYPECODE    struEndCode;        //可变长度终结符
    DWORD                    dwLengthPos;            //lengthMode为2的时候使用，卡号长度在报文中的位置
    DWORD                    dwLengthLen;            //lengthMode为2的时候使用，卡号长度的长度
    BYTE                    byRes3[8];              // 保留字节
}NET_DVR_PACKAGE_LENGTH,* LPNET_DVR_PACKAGE_LENGTH;

typedef struct    tagNET_DVR_OSD_POSITION//OSD 叠加的位置
{    
    BYTE                    byPositionMode;        //叠加风格，共2种；0，不显示；1，自定义
    BYTE                    byRes1[3];          // 保留字节
    DWORD                     dwPosX;                //x坐标，叠加风格为自定义时使用
    DWORD                    dwPosY;                //y坐标，叠加风格为自定义时使用
    BYTE                    byRes2[8];          //保留字节
}NET_DVR_OSD_POSITION, *LPNET_DVR_OSD_POSITION;

typedef struct    tagNET_DVR_DATE_FORMAT//日期显示格式
{    
    BYTE                    byMonth;                //Month,0.mm;1.mmm;2.mmmm                            
    BYTE                     byDay;                    //Day,0.dd;                                    
    BYTE                     byYear;                    //Year,0.yy;1.yyyy    
    BYTE                    byDateForm;                //0~5，年月日的排列组合
    BYTE                    byRes[20];              // 保留字节
    char                    chSeprator[4];            //分隔符
    char                    chDisplaySeprator[4];    //显示分隔符
    BYTE                    byDisplayForm;            //0~5，3个item的排列组合
    BYTE                    res[27];                // 保留字节
}NET_DVR_DATE_FORMAT, *LPNET_DVR_DATE_FORMAT;

typedef struct    tagNET_DVRT_TIME_FORMAT//时间显示格式
{    
    BYTE                    byTimeForm;                //1. HH MM SS;0. HH MM
    BYTE                     byRes1[23];             // 保留字节
    BYTE                    byHourMode;             //0,12;1,24 
    BYTE                    byRes2[3];              // 保留字节
    char                    chSeprator[4];             //报文分隔符，暂时没用
    char                    chDisplaySeprator[4];    //显示分隔符
    BYTE                    byDisplayForm;            //0~5，3个item的排列组合
    BYTE                    byRes3[3];              // 保留字节
    BYTE                    byDisplayHourMode;        //0,12;1,24 
    BYTE                    byRes4[19];             // 保留字节
}NET_DVR_TIME_FORMAT, *LPNET_DVR_TIME_FORMAT;

typedef struct tagNET_DVR_OVERLAY_CHANNEL
{    
    BYTE                    byChannel[64];//叠加的通道 每个字节标识一个通道， 例如byChannel[0]值为1对应叠加通道1，0表示不叠加通道1。
    DWORD                    dwDelayTime;            //叠加延时时间
    BYTE                    byEnableDelayTime;        //是否启用叠加延时
    BYTE                    byRes[11];          // 保留字节
}NET_DVR_OVERLAY_CHANNEL, *LPNET_DVR_OVERLAY_CHANNEL;

typedef struct tagNET_DVR_ATM_PACKAGE_ACTION
{    
    NET_DVR_PACKAGE_LOCATION    struPackageLocation;// 报文位置信息
    NET_DVR_OSD_POSITION        struOsdPosition;    // OSD 叠加位置
    NET_DVR_FRAMETYPECODE        struActionCode;        //交易类型行为码
    NET_DVR_FRAMETYPECODE        struPreCode;        //叠加字符前的字符
    BYTE                    byActionCodeMode;        //交易类型行为码模式0,ASCII;1,HEX
    BYTE                    byRes[7];               // 保留字节
}NET_DVR_ATM_PACKAGE_ACTION, *LPNET_DVR_ATM_PACKAGE_ACTION;

typedef struct tagNET_DVR_ATM_PACKAGE_DATE
{    
    NET_DVR_PACKAGE_LOCATION    struPackageLocation;// 日期在报文中的位置信息
    NET_DVR_DATE_FORMAT            struDateForm;        //日期显示格式
    NET_DVR_OSD_POSITION        struOsdPosition;    // OSD叠加位置信息
    BYTE                        res[8];             // 保留字节
}NET_DVR_ATM_PACKAGE_DATE, *LPNET_DVR_ATM_PACKAGE_DATE;

typedef struct tagNET_DVR_ATM_PACKAGE_TIME
{    
    NET_DVR_PACKAGE_LOCATION    location;        // 时间在报文中的位置信息
    NET_DVR_TIME_FORMAT            struTimeForm;    // 时间显示格式
    NET_DVR_OSD_POSITION        struOsdPosition;// OSD 叠加位置信息
    BYTE                        byRes[8];        // 保留字节
}NET_DVR_ATM_PACKAGE_TIME, *LPNET_DVR_ATM_PACKAGE_TIME;

typedef struct tagNET_DVR_ATM_PACKAGE_OTHERS
{    
    NET_DVR_PACKAGE_LOCATION    struPackageLocation; //报文位置信息
    NET_DVR_PACKAGE_LENGTH    struPackageLength;        //长度信息
    NET_DVR_OSD_POSITION        struOsdPosition;    // OSD叠加位置信息
    NET_DVR_FRAMETYPECODE        struPreCode;        //叠加字符前的字符
    BYTE                    res[8];                    //保留字节
}NET_DVR_ATM_PACKAGE_OTHERS, *LPNET_DVR_ATM_PACKAGE_OTHERS;

typedef struct tagNET_DVR_ATM_USER_DEFINE_PROTOCOL
{
    NET_DVR_IDENTIFICAT        struIdentification;  //报文标志
    NET_DVR_FILTER             struFilter; //数据包过滤设置
    NET_DVR_ATM_PACKAGE_OTHERS struCardNoPara; //叠加卡号设置
    NET_DVR_ATM_PACKAGE_ACTION struTradeActionPara[MAX_ACTION_TYPE]; //叠加交易行为设置 0-9 依次对应InCard OutCard OverLay SetTime GetStatus Query WithDraw Deposit ChanPass Transfer
    NET_DVR_ATM_PACKAGE_OTHERS struAmountPara; //叠加交易金额设置
    NET_DVR_ATM_PACKAGE_OTHERS struSerialNoPara; //叠加交易序号设置
    NET_DVR_OVERLAY_CHANNEL    struOverlayChan; //叠加通道设置
    NET_DVR_ATM_PACKAGE_DATE   struRes1; //叠加日期，保留
    NET_DVR_ATM_PACKAGE_TIME   struRes2; //叠加时间，保留
    BYTE                       byRes3[124];        //保留
}NET_DVR_ATM_USER_DEFINE_PROTOCOL, *LPNET_DVR_ATM_USER_DEFINE_PROTOCOL;

typedef struct tagNET_DVR_ATM_FRAMEFORMAT_V30
{        
    DWORD                        dwSize;                 //结构大小
    BYTE                        byEnable;                /*是否启用0,不启用;1,启用*/
    BYTE                        byInputMode;            /**输入方式:0-网络监听、1网络协议、2-串口监听、3-串口协议*/
    BYTE                        byRes1[34];              //保留字节 
    NET_DVR_IPADDR                struAtmIp;                /*ATM 机IP 网络监听时使用 */
    WORD                        wAtmPort;                /* 网络协议方式时是使用*/
    BYTE                        byRes2[2];              // 保留字节
    DWORD                        dwAtmType;                /*ATM协议类型，从NET_DVR_ATM_PROTOCOL结构中获取，如果类型为自定义时使用用户自定义协议*/
    NET_DVR_ATM_USER_DEFINE_PROTOCOL   struAtmUserDefineProtocol; //用户自定义协议，当ATM类型为自定时需要使用该定义
    BYTE                        byRes3[8];
}NET_DVR_ATM_FRAMEFORMAT_V30, *LPNET_DVR_ATM_FRAMEFORMAT_V30;


typedef struct  tagNET_DVR_ATM_PROTO_TYPE
{
    DWORD dwAtmType; //ATM协议类型，同时作为索引序号 ATM 配置中的dwAtmType 自定义时为1025
    char chDesc[ATM_DESC_LEN]; //ATM协议简单描述
}NET_DVR_ATM_PROTO_TYPE, *LPNET_DVR_ATM_PROTO_TYPE; //协议信息数据结构

typedef struct tagNET_DVR_ATM_PROTO_LIST    //ATM 协议列表
{
    DWORD                  dwAtmProtoNum;           // 协议列表的个数
    NET_DVR_ATM_PROTO_TYPE struAtmProtoType[MAX_ATM_PROTOCOL_NUM]; //协议列表信息
}NET_DVR_ATM_PROTO_LIST, *LPNET_DVR_ATM_PROTO_LIST;

typedef struct tagNET_DVR_ATM_PROTOCOL
{
    DWORD dwSize;
    NET_DVR_ATM_PROTO_LIST struNetListenList; // 网络监听协议描述
    NET_DVR_ATM_PROTO_LIST struSerialListenList; //串口监听协议描述
    NET_DVR_ATM_PROTO_LIST struNetProtoList;     //网络协议描述
    NET_DVR_ATM_PROTO_LIST struSerialProtoList;   //串口协议描述
    NET_DVR_ATM_PROTO_TYPE struCustomProto;        //自定义协议
}NET_DVR_ATM_PROTOCOL, *LPNET_DVR_ATM_PROTOCOL;

typedef struct 
{
    BYTE byEncoderIP[16];        //解码设备连接的服务器IP
    BYTE byEncoderUser[16];        //解码设备连接的服务器的用户名
    BYTE byEncoderPasswd[16];    //解码设备连接的服务器的密码
    BYTE bySendMode;            //解码设备连接服务器的连接模式
    BYTE byEncoderChannel;        //解码设备连接的服务器的通道号
    WORD wEncoderPort;            //解码设备连接的服务器的端口号
    BYTE reservedData[4];        //保留
}NET_DVR_DECODERINFO, *LPNET_DVR_DECODERINFO;

typedef struct 
{
    BYTE byEncoderIP[16];        //解码设备连接的服务器IP
    BYTE byEncoderUser[16];        //解码设备连接的服务器的用户名
    BYTE byEncoderPasswd[16];    //解码设备连接的服务器的密码
    BYTE byEncoderChannel;        //解码设备连接的服务器的通道号
    BYTE bySendMode;            //解码设备连接的服务器的连接模式
    WORD wEncoderPort;            //解码设备连接的服务器的端口号
    DWORD dwConnectState;        //解码设备连接服务器的状态
    BYTE reservedData[4];        //保留
}NET_DVR_DECODERSTATE, *LPNET_DVR_DECODERSTATE;

typedef struct 
{
    char sDVRIP[16];                /* DVR IP地址 */
    WORD wDVRPort;                     /* 端口号 */
    BYTE sUserName[NAME_LEN];        /* 用户名 */
    BYTE sPassword[PASSWD_LEN];        /* 密码 */
    BYTE byChannel;                    /* 通道号 */
    BYTE byLinkMode;                /* 连接模式 */
    BYTE byLinkType;                /* 连接类型 0－主码流 1－子码流 */
}NET_DVR_DECCHANINFO, *LPNET_DVR_DECCHANINFO;

typedef struct 
{
    BYTE    byPoolChans;            /*每路解码通道上的循环通道数量, 最多4通道 0表示没有解码*/
    NET_DVR_DECCHANINFO struchanConInfo[MAX_DECPOOLNUM];
    BYTE    byEnablePoll;            /*是否轮巡 0-否 1-是*/
    BYTE    byPoolTime;                /*轮巡时间 0-保留 1-10秒 2-15秒 3-20秒 4-30秒 5-45秒 6-1分钟 7-2分钟 8-5分钟 */
}NET_DVR_DECINFO, *LPNET_DVR_DECINFO;

typedef struct 
{
    DWORD    dwSize;
    DWORD    dwDecChanNum;         /*解码通道的数量*/
    NET_DVR_DECINFO struDecInfo[MAX_DECNUM];
}NET_DVR_DECCFG, *LPNET_DVR_DECCFG;

typedef struct 
{
    DWORD dwEnableTransPort;    /* 是否启动透明通道 0－不启用 1－启用*/
    char sDecoderIP[16];        /* DVR IP地址 */
    WORD wDecoderPort;            /* 端口号 */
    WORD wDVRTransPort;            /* 配置前端DVR是从485/232输出，1表示232串口,2表示485串口 */
    char cReserve[4];
}NET_DVR_PORTINFO, *LPNET_DVR_PORTINFO;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_PORTINFO struTransPortInfo[MAX_TRANSPARENTNUM]; /* 数组0表示232 数组1表示485 */
}NET_DVR_PORTCFG, *LPNET_DVR_PORTCFG;

typedef struct 
{
    DWORD dwSize;
    char sDecoderIP[16];        /* DVR IP地址 */
    WORD wDecoderPort;            /* 端口号 */
    WORD wLoadMode;                /* 回放下载模式 1－按名字 2－按时间 */
    union
    {
        BYTE byFile[100];        /* 回放的文件名 */
        struct
        {
            DWORD dwChannel;
            BYTE sUserName[NAME_LEN];    /*请求视频用户名*/
            BYTE sPassword[PASSWD_LEN];    /* 密码 */
            NET_DVR_TIME struStartTime;    /* 按时间回放的开始时间 */
            NET_DVR_TIME struStopTime;    /* 按时间回放的结束时间 */
        }bytime;
    }mode_size;
}NET_DVR_PLAYREMOTEFILE, *LPNET_DVR_PLAYREMOTEFILE;

typedef struct 
{
    DWORD dwWorkType;        /*工作方式：1：轮巡、2：动态连接解码、3：文件回放下载 4：按时间回放下载*/
    char sDVRIP[16];        /*连接的设备ip*/
    WORD wDVRPort;            /*连接端口号*/
    BYTE byChannel;            /* 通道号 */
    BYTE byLinkMode;        /* 连接模式 */
    DWORD    dwLinkType;        /*连接类型 0－主码流 1－子码流*/
    union
    {
        struct
        {
            BYTE sUserName[NAME_LEN];    /*请求视频用户名*/
            BYTE sPassword[PASSWD_LEN];    /* 密码 */
            char cReserve[52];
        }userInfo;
        struct
        {
            BYTE   fileName[100];
        }fileInfo;
        struct
        {
            DWORD    dwChannel;
            BYTE    sUserName[NAME_LEN];    /*请求视频用户名*/
            BYTE    sPassword[PASSWD_LEN];    /* 密码 */
            NET_DVR_TIME struStartTime;        /* 按时间回放的开始时间 */
            NET_DVR_TIME struStopTime;        /* 按时间回放的结束时间 */
        }timeInfo;
    }objectInfo;
}NET_DVR_DECCHANSTATUS, *LPNET_DVR_DECCHANSTATUS;

typedef struct 
{
    DWORD   dwSize;
    NET_DVR_DECCHANSTATUS struDecState[MAX_DECNUM];
}NET_DVR_DECSTATUS, *LPNET_DVR_DECSTATUS;

typedef struct 
{
    WORD wShowString;                // 预览的图象上是否显示字符,0-不显示,1-显示 整个预览画面大小704*576,单个字符的大小为32*32
    WORD wStringSize;                /* 该行字符的长度，不能大于44个字符 */
    WORD wShowStringTopLeftX;        /* 字符显示位置的x坐标 */
    WORD wShowStringTopLeftY;        /* 字符名称显示位置的y坐标 */
    char sString[44];                /* 要显示的字符内容 */
}NET_DVR_SHOWSTRINGINFO, *LPNET_DVR_SHOWSTRINGINFO;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_V30];                /* 要显示的字符内容 */
}NET_DVR_SHOWSTRING_V30, *LPNET_DVR_SHOWSTRING_V30;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM_EX];                /* 要显示的字符内容 */
}NET_DVR_SHOWSTRING_EX, *LPNET_DVR_SHOWSTRING_EX;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_SHOWSTRINGINFO struStringInfo[MAX_STRINGNUM];                /* 要显示的字符内容 */
}NET_DVR_SHOWSTRING, *LPNET_DVR_SHOWSTRING;



typedef struct 
{
    DWORD dwMonth;        //月 0-11表示1-12个月
    DWORD dwWeekNo;        //第几周 0－第1周 1－第2周 2－第3周 3－第4周 4－最后一周
    DWORD dwWeekDate;    //星期几 0－星期日 1－星期一 2－星期二 3－星期三 4－星期四 5－星期五 6－星期六
    DWORD dwHour;        //小时    开始时间0－23 结束时间1－23
    DWORD dwMin;        //分    0－59
}NET_DVR_TIMEPOINT;

typedef struct 
{
    DWORD dwSize;
    DWORD dwZoneIndex; //应用层软件使用NET_DVR_NTPPARA 中的cTimeDifferenceH 或cTimeDifferenceM 来设置时区，此处用获取的值填充，不对用户提供输入编辑框
    BYTE byRes1[12];            //保留
    DWORD dwEnableDST;        //是否启用夏时制 0－不启用 1－启用
    BYTE byDSTBias;    //夏令时偏移值，30min, 60min, 90min, 120min, 以分钟计，传递原始数值
    BYTE byRes2[3];
    NET_DVR_TIMEPOINT struBeginPoint;    //夏时制开始时间
    NET_DVR_TIMEPOINT struEndPoint;    //夏时制停止时间
}NET_DVR_ZONEANDDST, *LPNET_DVR_ZONEANDDST;

typedef struct 
{
/*注意：当图像压缩分辨率为VGA时，支持0=CIF, 1=QCIF, 2=D1抓图，
当分辨率为3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA,7=XVGA, 8=HD900p
    仅支持当前分辨率的抓图*/
    
    /* 可以通过能力集获取
       0-CIF，           1-QCIF，           2-D1，         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)，
       6-VGA，           7-XVGA，           8-HD900p，     9-HD1080，     10-2560*1920，
       11-1600*304，     12-2048*1536，     13-2448*2048,  14-2448*1200， 15-2448*800，
       16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576，     
       21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
       26-1280*1280,     27-1600*600,       28-2048*768,   29-160*120,    55-3072*2048,
       64-3840*2160,     70-2560*1440,      75-336*256,
       78-384*256,         79-384*216,        80-320*256,    82-320*192,    83-512*384,
       127-480*272,      128-512*272,       161-288*320,   162-144*176,   163-480*640,
       164-240*320,      165-120*160,       166-576*720,   167-720*1280,  168-576*960,
       180-180*240,      181-360*480,       182-540*720,    183-720*960,  184-960*1280,
       185-1080*1440,      215-1080*720(占位，未测试),  216-360x640(占位，未测试),245-576*704(占位，未测试)
       500-384*288,
       0xff-Auto(使用当前码流分辨率)
    */
    WORD    wPicSize;            
    WORD    wPicQuality;            /* 图片质量系数 0-最好 1-较好 2-一般 */
}NET_DVR_JPEGPARA, *LPNET_DVR_JPEGPARA;

typedef struct tagNET_VCA_RECT
{
    float fX;               //边界框左上角点的X轴坐标, 0.000~1
    float fY;               //边界框左上角点的Y轴坐标, 0.000~1
    float fWidth;           //边界框的宽度, 0.000~1
    float fHeight;          //边界框的高度, 0.000~1
}NET_VCA_RECT, *LPNET_VCA_RECT;

typedef struct tagNET_DVR_JPEGPICTURE_WITH_APPENDDATA
{
    DWORD   dwSize;
    DWORD   dwChannel;//通道号
    DWORD   dwJpegPicLen;//Jpeg图片长度
    char    *pJpegPicBuff;//Jpeg图片指针
    DWORD   dwJpegPicWidth;  // 图像宽度
    DWORD   dwJpegPicHeight;  //图像高度
    DWORD   dwP2PDataLen;//全屏测温数据长度
    char    *pP2PDataBuff; //全屏测温数据指针   
    BYTE    byIsFreezedata;//是否数据冻结 0-否 1-是
    BYTE    byRes1[3];
    DWORD   dwVisiblePicLen;//可见光图片长度
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    char    *pVisiblePicBuff;//可见光图片指针
#else
    char    *pVisiblePicBuff;//可见光图片指针
    BYTE    byRes2[4];
#endif 
    NET_VCA_RECT struThermalValidRect;//热成像有效区域
    NET_VCA_RECT struVisibleValidRect;//可见光有效区域
    BYTE    byRes[208];
}NET_DVR_JPEGPICTURE_WITH_APPENDDATA, *LPNET_DVR_JPEGPICTURE_WITH_APPENDDATA;


typedef struct 
{
    DWORD dwSize;
    DWORD dwAlarmOutChan;                       /* 选择报警弹出大报警通道切换时间：1画面的输出通道: 0:主输出/1:辅1/2:辅2/3:辅3/4:辅4 */
    DWORD dwAlarmChanSwitchTime;                /* :1秒 - 10:10秒 */
    DWORD dwAuxSwitchTime[MAX_AUXOUT];            /* 辅助输出切换时间: 0-不切换,1-5s,2-10s,3-20s,4-30s,5-60s,6-120s,7-300s */
    BYTE  byAuxOrder[MAX_AUXOUT][MAX_WINDOW];    /* 辅助输出预览顺序, 0xff表示相应的窗口不预览 */
}NET_DVR_AUXOUTCFG, *LPNET_DVR_AUXOUTCFG;

typedef struct 
{
    BYTE sNTPServer[64];   /* Domain Name or IP addr of NTP server */
    WORD wInterval;         /* adjust time interval(hours) */
    BYTE byEnableNTP;    /* enable NPT client 0-no，1-yes*/
    signed char cTimeDifferenceH; /* 与国际标准时间的 小时偏移-12 ... +13 */
    signed char cTimeDifferenceM;/* 与国际标准时间的 分钟偏移0, 30, 45*/
    BYTE res1;
    WORD wNtpPort;         /* ntp server port 9000新增 设备默认为123*/
    BYTE res2[8];
}NET_DVR_NTPPARA, *LPNET_DVR_NTPPARA;

typedef struct 
{
    BYTE sUsername[NAME_LEN];  /* DDNS账号用户名/密码 */
    BYTE sPassword[PASSWD_LEN];
    BYTE sDomainName[64];       /* 域名 */
    BYTE byEnableDDNS;            /*是否应用 0-否，1-是*/
    BYTE res[15];
}NET_DVR_DDNSPARA, *LPNET_DVR_DDNSPARA;



typedef struct 
{
    BYTE sUsername[64];  /* 邮件账号/密码 */
    BYTE sPassword[64];
    BYTE sSmtpServer[64];
    BYTE sPop3Server[64];
    BYTE sMailAddr[64];   /* email */
    BYTE sEventMailAddr1[64];  /* 上传报警/异常等的email */
    BYTE sEventMailAddr2[64];
    BYTE res[16];
}NET_DVR_EMAILPARA, *LPNET_DVR_EMAILPARA;

typedef struct 
{
    DWORD  dwSize;
    char  sDNSIp[16];                /* DNS服务器地址 */
    NET_DVR_NTPPARA  struNtpClientParam;      /* NTP参数 */
    NET_DVR_DDNSPARA struDDNSClientParam;     /* DDNS参数 */
    BYTE res[464];            /* 保留 */
}NET_DVR_NETAPPCFG, *LPNET_DVR_NETAPPCFG;


typedef struct 
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NFS struNfsDiskParam[MAX_NFS_DISK];
}NET_DVR_NFSCFG, *LPNET_DVR_NFSCFG;

typedef struct tagNET_DVR_ISCSI_CFG
{   
    DWORD dwSize;                   // 结构大小
    WORD wVrmPort;                  // VRM 监听端口
    BYTE byEnable;                  // 是否启用 ISCSI存储
    BYTE byRes[69];                 // 保留字节
    NET_DVR_IPADDR struVrmAddr;          // VRM ip地址 16位
    char chNvtIndexCode[64];        //nvt index Code 
}NET_DVR_ISCSI_CFG, *LPNET_DVR_ISCSI_CFG;  


typedef struct 
{
    NET_DVR_CRUISE_POINT struCruisePoint[32];            //最大支持32个巡航点
}NET_DVR_CRUISE_RET, *LPNET_DVR_CRUISE_RET;

typedef struct 
{
    DWORD    dwSize;
    char    sFirstDNSIP[16];
    char    sSecondDNSIP[16];
    char    sRes[32];
}NET_DVR_NETCFG_OTHER, *LPNET_DVR_NETCFG_OTHER;

typedef struct 
{
    char     sDVRIP[16];                /* DVR IP地址 */
    WORD     wDVRPort;                 /* 端口号 */
    BYTE     byChannel;                /* 通道号 */
    BYTE    byTransProtocol;            /* 传输协议类型 0-TCP, 1-UDP */
    BYTE    byTransMode;                /* 传输码流模式 0－主码流 1－子码流*/
    BYTE    byRes[3];
    BYTE    sUserName[NAME_LEN];            /* 监控主机登陆帐号 */
    BYTE    sPassword[PASSWD_LEN];            /* 监控主机密码 */
}NET_DVR_MATRIX_DECINFO, *LPNET_DVR_MATRIX_DECINFO;

typedef struct 
{
    DWORD    dwSize;                
    NET_DVR_MATRIX_DECINFO struDecChanInfo;        /* 动态解码通道信息 */
}NET_DVR_MATRIX_DYNAMIC_DEC, *LPNET_DVR_MATRIX_DYNAMIC_DEC;

typedef struct  
{
    DWORD     dwSize;
    DWORD   dwIsLinked;         /* 解码通道状态 0－休眠 1－正在连接 2－已连接 3-正在解码 */
    DWORD   dwStreamCpRate;     /* Stream copy rate, X kbits/second */
    char    cRes[64];        /* 保留 */
}NET_DVR_MATRIX_DEC_CHAN_STATUS, *LPNET_DVR_MATRIX_DEC_CHAN_STATUS;

typedef struct 
{
    DWORD    dwSize;
    NET_DVR_MATRIX_DECINFO struDecChanInfo;        /* 解码通道信息 */
    DWORD    dwDecState;    /* 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放 */
    NET_DVR_TIME StartTime;        /* 按时间回放开始时间 */
    NET_DVR_TIME StopTime;        /* 按时间回放停止时间 */
    char    sFileName[128];        /* 按文件回放文件名 */
}NET_DVR_MATRIX_DEC_CHAN_INFO, *LPNET_DVR_MATRIX_DEC_CHAN_INFO;

typedef struct 
{
    DWORD dwEnable;                    /* 是否启用 0－否 1－启用*/
    NET_DVR_MATRIX_DECINFO struDecChanInfo;        /* 轮巡解码通道信息 */
}NET_DVR_MATRIX_DECCHANINFO, *LPNET_DVR_MATRIX_DECCHANINFO;

typedef struct 
{
    DWORD    dwSize;
    DWORD    dwPoolTime;            /*轮巡时间 */
    NET_DVR_MATRIX_DECCHANINFO struchanConInfo[MAX_CYCLE_CHAN];
}NET_DVR_MATRIX_LOOP_DECINFO, *LPNET_DVR_MATRIX_LOOP_DECINFO;

typedef struct 
{
    BYTE    baudrate;     /* 波特率 */
    BYTE    databits;        /* 数据位 */
    BYTE    stopbits;        /* 停止位 */
    BYTE    parity;        /* 奇偶校验位 */
    BYTE    flowcontrol;    /* 流控 */
    BYTE    res[3];
}TTY_CONFIG, *LPTTY_CONFIG;

typedef struct  
{
    BYTE byTranChanEnable;    /* 当前透明通道是否打开 0：关闭 1：打开 */    
                            /*
                            *    多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下：
                            *    0 RS485
                            *    1 RS232 Console
    */
    BYTE    byLocalSerialDevice;            /* Local serial device */
                                            /*
                                            *    远程串口输出还是两个,一个RS232，一个RS485
                                            *    1表示232串口
                                            *    2表示485串口
    */
    BYTE    byRemoteSerialDevice;            /* Remote output serial device */
    BYTE    res1;                            /* 保留 */
    char    sRemoteDevIP[16];                /* Remote Device IP */
    WORD    wRemoteDevPort;                /* Remote Net Communication Port */
    BYTE    res2[2];                        /* 保留 */
    TTY_CONFIG RemoteSerialDevCfg;
}NET_DVR_MATRIX_TRAN_CHAN_INFO, *LPNET_DVR_MATRIX_TRAN_CHAN_INFO;

typedef struct  
{
    DWORD dwSize;
    BYTE     by232IsDualChan; /* 设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM */
    BYTE    by485IsDualChan; /* 设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM */
    BYTE    res[2];    /* 保留 */
    NET_DVR_MATRIX_TRAN_CHAN_INFO struTranInfo[MAX_SERIAL_NUM];/*同时支持建立MAX_SERIAL_NUM个透明通道*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG, *LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG;

typedef struct 
{
    DWORD    dwSize;
    char    sDVRIP[16];        /* DVR IP地址 */    
    WORD    wDVRPort;            /* 端口号 */    
    BYTE    byChannel;            /* 通道号 */
    BYTE     byReserve;
    BYTE    sUserName[NAME_LEN];        /* 用户名 */
    BYTE    sPassword[PASSWD_LEN];        /* 密码 */
    DWORD    dwPlayMode;       /* 0－按文件 1－按时间*/            
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY;

typedef struct 
{
    DWORD    dwSize;
    DWORD    dwPlayCmd;        /* 播放命令 见文件播放命令*/
    DWORD    dwCmdParam;        /* 播放命令参数 */
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_CONTROL;

typedef struct  
{
    DWORD dwSize;
    DWORD dwCurMediaFileLen;        /* 当前播放的媒体文件长度 */       
    DWORD dwCurMediaFilePosition;    /* 当前播放文件的播放位置 */        
    DWORD dwCurMediaFileDuration;    /* 当前播放文件的总时间 */        
    DWORD dwCurPlayTime;            /* 当前已经播放的时间 */        
    DWORD dwCurMediaFIleFrames;        /* 当前播放文件的总帧数 */        
    DWORD dwCurDataType;            /* 当前传输的数据类型，19-文件头，20-流数据， 21-播放结束标志 */        
    BYTE res[72];    
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_STATUS;

typedef struct tagNET_MATRIX_PASSIVEMODE
{
    WORD    wTransProtol;        //传输协议，0-TCP, 1-UDP, 2-MCAST
    WORD    wPassivePort;        //UDP端口, TCP时默认
    NET_DVR_IPADDR  struMcastIP;    //TCP,UDP时无效, MCAST时为多播地址
    BYTE    byStreamType;/* 数据播放模式:REAL_TIME_STREAM(1)实时流,RECORD_STREAM(2)文件流 */
    BYTE    byRes[7];
}NET_DVR_MATRIX_PASSIVEMODE, *LPNET_DVR_MATRIX_PASSIVEMODE;

typedef struct tagNET_DVR_MATRIX_TRAN_CHAN_INFO_V30 
{
    BYTE  byTranChanEnable;            /* 当前透明通道是否打开 0：关闭 1：打开 */    
    BYTE  byLocalSerialDevice;      /* Local serial device */
                                    /*
                                    *  多路解码器本地有1个485串口，1个232串口都可以作为透明通道,设备号分配如下：
                                    *  0 RS485
                                    *  1 RS232 Console
                                    *  2 Dual Scom
                                    */
    BYTE  byRemoteSerialDevice;        /* Remote output serial device */
                                    /*
                                    *  远程串口输出还是两个,一个RS232，一个RS485
                                    *  1 表示232串口
                                    *  2 表示485串口
                                    */
    BYTE  byRes1;                    /* 保留 */        
    NET_DVR_IPADDR struRemoteDevIP; /* Remote Device IP */
    WORD  wRemoteDevPort;            /* Remote Net Communication Port */
    BYTE  byIsEstablished;            /* 透明通道建立成功标志，0-没有成功，1-建立成功 */
    BYTE  byRes2;                    /* 保留 */
    TTY_CONFIG RemoteSerialDevCfg;
    BYTE  byUsername[NAME_LEN];
    BYTE  byPassword[PASSWD_LEN];
    DWORD dwLocalSerialNo;          /* 本地串口 */
    DWORD dwRemoteSerialNo;         /* 远程串口 */
    BYTE  byRes3[8];
} NET_DVR_MATRIX_TRAN_CHAN_INFO_V30,*LPNET_DVR_MATRIX_TRAN_CHAN_INFO_V30;

typedef struct tagMATRIX_TRAN_CHAN_CONFIG 
{
    DWORD dwSize;
    BYTE  by232IsDualChan; /* 设置哪路232透明通道是全双工的 取值1到MAX_SERIAL_NUM */
    BYTE  by485IsDualChan; /* 设置哪路485透明通道是全双工的 取值1到MAX_SERIAL_NUM */
    BYTE  byRes[2];           /* 保留 */
    NET_DVR_MATRIX_TRAN_CHAN_INFO_V30 struTranInfo[MAX_SERIAL_NUM]; /*同时支持建立MAX_SERIAL_NUM个透明通道*/
}NET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30,*LPNET_DVR_MATRIX_TRAN_CHAN_CONFIG_V30;

typedef struct  
{
    DWORD                                dwEnable;    /* 是否启用 0－否 1－启用*/
    NET_DVR_STREAM_MEDIA_SERVER_CFG    streamMediaServerCfg;    
    NET_DVR_DEV_CHAN_INFO         struDevChanInfo;        /* 轮巡解码通道信息 */
}NET_DVR_MATRIX_CHAN_INFO_V30,*LPNET_DVR_CYC_SUR_CHAN_ELE_V30;

typedef struct  tagMATRIX_LOOP_DECINFO_V30
{
    DWORD                            dwSize;
    DWORD                            dwPoolTime;        /*轮巡间隔*/
    NET_DVR_MATRIX_CHAN_INFO_V30    struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                               byRes[16];
} NET_DVR_MATRIX_LOOP_DECINFO_V30,*LPNET_DVR_MATRIX_LOOP_DECINFO_V30;

typedef struct tagDEC_MATRIX_CHAN_INFO_V30
{
    DWORD    dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg;    /*流媒体服务器配置*/
    NET_DVR_DEV_CHAN_INFO               struDevChanInfo;        /* 解码通道信息 */
    DWORD    dwDecState;        /* 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放 */
    NET_DVR_TIME StartTime;        /* 按时间回放开始时间 */
    NET_DVR_TIME StopTime;        /* 按时间回放停止时间 */
    char    sFileName[128];        /* 按文件回放文件名 */
    DWORD   dwGetStreamMode;    /*取流模式:1-主动，2-被动*/
    NET_DVR_MATRIX_PASSIVEMODE      struPassiveMode;
    BYTE    byRes[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V30,*LPNET_DVR_MATRIX_DEC_CHAN_INFO_V30;

typedef struct tagNET_DVR_MATRIX_ABILITY
{
    DWORD dwSize;
    BYTE  byDecNums;
    BYTE  byStartChan;
    BYTE  byVGANums;
    BYTE  byBNCNums;
    BYTE  byVGAWindowMode[8][12];     /*VGA支持的窗口模式，VGA1可能由混合输出*/
    BYTE  byBNCWindowMode[4];           /*BNC支持的窗口模式*/
    BYTE  byDspNums;   
    BYTE  byHDMINums;//HDMI显示通道个数（从25开始）
    BYTE  byDVINums;//DVI显示通道个数（从29开始）
    BYTE  byRes1[13];
    BYTE  bySupportResolution[MAX_RESOLUTIONNUM];//按照上面的枚举定义,一个字节代表一个分辨率是//否支持，1：支持，0：不支持
    BYTE  byHDMIWindowMode[4][8];//HDMI支持的窗口模式
    BYTE  byDVIWindowMode[4][8];//DVI支持的窗口模式
    BYTE  byRes2[24];
}NET_DVR_MATRIX_ABILITY, *LPNET_DVR_MATRIX_ABILITY;

typedef struct tagNET_DVR_DISP_LOGOCFG
{
    DWORD        dwCorordinateX;    //图片显示区域X坐标
    DWORD        dwCorordinateY;    //图片显示区域Y坐标
    WORD        wPicWidth; //图片宽
    WORD        wPicHeight; //图片高
    BYTE        byRes1[4];
    BYTE        byFlash;  //是否闪烁1-闪烁，0-不闪烁
    BYTE        byTranslucent; //是否半透明1-半透明，0-不半透明
    BYTE        byRes2[6];                //保留
    DWORD        dwLogoSize;//LOGO大小，包括BMP的文件头
}NET_DVR_DISP_LOGOCFG,*LPNET_DVR_DISP_LOGOCFG;




typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG
{        
    DWORD    dwSize; 
    BYTE    byAudio;            /*音频是否开启,0-否，1-是*/
    BYTE    byAudioWindowIdx;      /*音频开启子窗口*/
    BYTE     byVgaResolution;      /*VGA的分辨率*/
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL,0-NULL*/
    DWORD    dwWindowMode;        /*画面模式,从能力集获取,目前支持1,2,4,9,16*/       
    BYTE    byJoinDecChan[MAX_WINDOWS];/*各个子窗口关联的解码通道*/
    BYTE    byEnlargeStatus;          /*是否处于放大状态，0：不放大，1：放大*/
    BYTE    byEnlargeSubWindowIndex;//放大的子窗口号
    union
    {
        BYTE byRes[16];
        struct
        {
            /*各个子窗口对应解码通道所对应的解码子系统的槽位号(对于视频综合平台中解码子系统有效)*/
            BYTE     byJoinDecoderId[MAX_WINDOWS];
        }struVideoPlatform;
        struct
        {
            BYTE     byRes[16];
        }struNotVideoPlatform;
    }struDiff;
    /*区分共用体，0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置*/
    BYTE        byUnionType;
    BYTE        byScale; /*显示模式，0---真实显示，1---缩放显示( 针对BNC )*/
}NET_DVR_VGA_DISP_CHAN_CFG,*LPNET_DVR_VGA_DISP_CHAN_CFG;


typedef struct tagNET_DVR_DECODER_WORK_STATUS
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[MAX_DECODECHANNUM]; /*解码通道状态*/
    NET_DVR_DISP_CHAN_STATUS   struDispChanStatus[MAX_DISPCHANNUM];  /*显示通道状态*/
    BYTE byAlarmInStatus[MAX_ANALOG_ALARMIN];         /*报警输入状态*/
    BYTE byAlarmOutStatus[MAX_ANALOG_ALARMOUT];       /*报警输出状态*/
    BYTE byAudioInChanStatus;          /*语音对讲状态*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS,*LPNET_DVR_DECODER_WORK_STATUS;

typedef struct tagNET_DVR_PASSIVEDECODE_CONTROL
{
    DWORD    dwSize;
    DWORD    dwPlayCmd;        /* 播放命令 见文件播放命令*/
    DWORD    dwCmdParam;        /* 播放命令参数 */
    BYTE    byRes[16];//Reverse
}NET_DVR_PASSIVEDECODE_CONTROL,*LPNET_DVR_PASSIVEDECODE_CONTROL;

typedef struct tagNET_DVR_MATRIX_DECCHAN_CONTROL
{        
    DWORD    dwSize;
    BYTE    byDecChanScaleStatus;/*解码通道显示缩放控制,1表示缩放显示，0表示真实显示*/
    BYTE    byDecodeDelay;//解码延时，0-默认，1-实时性好，2-实时性较好，3-实时性中，流畅性中，4-流畅性较好，5-流畅性好，0xff-自动调整   
    BYTE    byEnableSpartan;//畅显使能，0-关，1-开
    BYTE    byLowLight;      //低照度。0-关，1-8代表低照度等级，等级越高强度越大
    BYTE    byNoiseReduction; //3D降噪，0-关，1-开，2-自动
    BYTE    byDefog;         //透雾，0-关，1-7代表透雾等级，等级越高强度越大
    BYTE    byEnableVcaDec; //是否启用智能解码，0-不启用，非0-启用
    BYTE    byEnableAudio; //是否开启音频，0-无效，1-开启，2-关闭
    DWORD   dwAllCtrlType;    //所有子窗口一起操作的类型，设置时有效，按位表示
    //dwAllCtrlType & 0x01,开启关闭智能解码
    BYTE    byVolume; //volume,[0-100]
    BYTE    byRes[55];
}NET_DVR_MATRIX_DECCHAN_CONTROL,*LPNET_DVR_MATRIX_DECCHAN_CONTROL;

typedef struct tagNET_DVR_SUBSYSTEMINFO
{
    BYTE        bySubSystemType;//子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，0-NULL（此参数只能获取）        
    BYTE        byChan;//子系统通道数，对于码分子系统，代表485串口数量（此参数只能获取）                    
    BYTE        byLoginType;//注册类型，1-直连，2-DNS，3-花生壳
    BYTE        byRes1[5];
    NET_DVR_IPADDR   struSubSystemIP;        /*IP地址（可修改）*/
    WORD        wSubSystemPort;        //子系统端口号（可修改）
    BYTE        byRes2[6];
    NET_DVR_IPADDR  struSubSystemIPMask;//子网掩码
    NET_DVR_IPADDR    struGatewayIpAddr;    /* 网关地址*/   
    BYTE        sUserName[NAME_LEN];    /* 用户名 （此参数只能获取）*/
    BYTE        sPassword[PASSWD_LEN];    /*密码（此参数只能获取）*/
    char        sDomainName[MAX_DOMAIN_NAME];//域名(可修改)
    char         sDnsAddress[MAX_DOMAIN_NAME];/*DNS域名或IP地址*/
    BYTE        sSerialNumber[SERIALNO_LEN];//序列号（此参数只能获取）
}NET_DVR_SUBSYSTEMINFO, *LPNET_DVR_SUBSYSTEMINFO;

typedef struct tagNET_DVR_ALLSUBSYSTEMINFO
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO struSubSystemInfo[MAX_SUBSYSTEM_NUM];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO, *LPNET_DVR_ALLSUBSYSTEMINFO;

typedef struct  tagNET_DVR_LOOPPLAN_SUBCFG
{
    DWORD                             dwSize;
    DWORD                            dwPoolTime;        /*轮巡间隔，单位：秒*/      
    NET_DVR_MATRIX_CHAN_INFO_V30 struChanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                               byRes[16];
}NET_DVR_LOOPPLAN_SUBCFG,*LPNET_DVR_LOOPPLAN_SUBCFG;

typedef struct tagNET_DVR_ALARMMODECFG
{
    DWORD     dwSize;
    BYTE    byAlarmMode;//报警触发类型，1-轮巡，2-保持        
    WORD    wLoopTime;//轮巡时间, 单位：秒            
    BYTE    byRes[9];
}NET_DVR_ALARMMODECFG,*LPNET_DVR_ALARMMODECFG;

typedef struct  tagNET_DVR_CODESPLITTERINFO
{
    DWORD            dwSize;
    NET_DVR_IPADDR   struIP;        /*码分器IP地址*/
    WORD        wPort;                    //码分器端口号
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];    /* 用户名 */
    BYTE        sPassword[PASSWD_LEN];    /*密码 */
    BYTE        byChan;//码分器485号
    BYTE        by485Port;//485口地址
    BYTE        byRes2[14];
} NET_DVR_CODESPLITTERINFO, *LPNET_DVR_CODESPLITTERINFO;

typedef struct tagNET_DVR_ASSOCIATECFG
{
    BYTE    byAssociateType;//关联类型，1-报警
    WORD    wAlarmDelay;//报警延时，0－5秒；1－10秒；2－30秒；3－1分钟；4－2分钟；5－5分钟；6－10分钟；
    BYTE    byAlarmNum;//报警号，具体的值由应用赋，相同的报警赋相同的值
    BYTE    byRes[8];
} NET_DVR_ASSOCIATECFG,*LPNET_DVR_ASSOCIATECFG;

typedef struct tagNET_DVR_DYNAMICDECODE
{
    DWORD                            dwSize;
    NET_DVR_ASSOCIATECFG           struAssociateCfg;//触发动态解码关联结构
    NET_DVR_PU_STREAM_CFG        struPuStreamCfg;//动态解码结构
    BYTE                            byRes[8];
}NET_DVR_DYNAMICDECODE,*LPNET_DVR_DYNAMICDECODE;

typedef struct  tagNET_DVR_DECODESCHED
{
    NET_DVR_SCHEDTIME  struSchedTime;//
    BYTE  byDecodeType;/*0-无，1-轮巡解码，2-动态解码*/
    BYTE  byLoopGroup;//轮巡组号
    BYTE  byRes[6];
    NET_DVR_PU_STREAM_CFG struDynamicDec;//动态解码
} NET_DVR_DECODESCHED, *LPNET_DVR_DECODESCHED;

typedef struct tagNET_DVR_PLANDECODE
{
    DWORD dwSize;
    NET_DVR_DECODESCHED struDecodeSched[MAX_DAYS][DECODE_TIMESEGMENT];//周一作为开始，和9000一致
    BYTE byRes[8];
} NET_DVR_PLANDECODE,*LPNET_DVR_PLANDECODE;

typedef struct 
{    /* 12 bytes */
    DWORD    dwSize;
    char    sUserName[32];
    char     sPassWord[32];
    char     sFromName[32];            /* Sender *///字符串中的第一个字符和最后一个字符不能是"@",并且字符串中要有"@"字符
    char     sFromAddr[48];            /* Sender address */
    char     sToName1[32];            /* Receiver1 */
    char     sToName2[32];            /* Receiver2 */
    char     sToAddr1[48];            /* Receiver address1 */
    char     sToAddr2[48];            /* Receiver address2 */
    char    sEmailServer[32];        /* Email server address */
    BYTE    byServerType;            /* Email server type: 0-SMTP, 1-POP, 2-IMTP…*/
    BYTE    byUseAuthen;            /* Email server authentication method: 1-enable, 0-disable */
    BYTE    byAttachment;            /* enable attachment */
    BYTE    byMailinterval;            /* mail interval 0-2s, 1-3s, 2-4s. 3-5s*/
} NET_DVR_EMAILCFG, *LPNET_DVR_EMAILCFG;

typedef struct 
{
    DWORD dwSize;
    NET_DVR_COMPRESSION_INFO_EX  struLowCompression;    //定时录像
    NET_DVR_COMPRESSION_INFO_EX  struEventCompression;    //事件触发录像
}NET_DVR_COMPRESSIONCFG_NEW, *LPNET_DVR_COMPRESSIONCFG_NEW;






typedef struct tagNET_DVR_DEVICEINFO_V40
{
    NET_DVR_DEVICEINFO_V30 struDeviceV30;
    BYTE  bySupportLock;        //设备支持锁定功能，该字段由SDK根据设备返回值来赋值的。bySupportLock为1时，dwSurplusLockTime和byRetryLoginTime有效
    BYTE  byRetryLoginTime;        //剩余可尝试登陆的次数，用户名，密码错误时，此参数有效
    BYTE  byPasswordLevel;      //admin密码安全等级
    //0-无效，1-默认密码，2-有效密码，3-风险较高的密码。当用户的密码为出厂默认密码（12345）或者风险较高的密码时，上层客户端需要提示用户更改密码。
    //4-管理员创建一个普通用户为其设置密码，该普通用户正确登录设备后要提示“请修改初始登录密码”，未修改的情况下，用户每次登入都会进行提醒；
    //5-当普通用户的密码被管理员修改，该普通用户再次正确登录设备后，需要提示“请重新设置登录密码”，未修改的情况下，用户每次登入都会进行提醒;
    //6-管理员创建一个安装商/操作员用户为其设置密码，该用户正确登录设备后要提示“请修改初始登录密码”，未修改的情况下，无法进行除修改本身密码外的其他操作;
    BYTE  byProxyType;  //代理类型，0-不使用代理, 1-使用socks5代理, 2-使用EHome代理
    DWORD dwSurplusLockTime;    //剩余时间，单位秒，用户锁定时，此参数有效
    BYTE  byCharEncodeType;     //字符编码类型
    BYTE  bySupportDev5;//支持v50版本的设备参数获取，设备名称和设备类型名称长度扩展为64字节
    BYTE  bySupport;  //能力集扩展，位与结果：0- 不支持，1- 支持
    // bySupport & 0x1:  保留
    // bySupport & 0x2:  0-不支持变化上报 1-支持变化上报
    BYTE  byLoginMode; //登录模式 0-Private登录 1-ISAPI登录
    DWORD dwOEMCode;
    int iResidualValidity;   //该用户密码剩余有效天数，单位：天，返回负值，表示密码已经超期使用，例如“-3表示密码已经超期使用3天”
    BYTE  byResidualValidity; // iResidualValidity字段是否有效，0-无效，1-有效
    BYTE  bySingleStartDTalkChan;	//独立音轨接入的设备，起始接入通道号，0-为保留字节，无实际含义，音轨通道号不能从0开始
    BYTE  bySingleDTalkChanNums;	//独立音轨接入的设备的通道总数，0-表示不支持
    BYTE  byPassWordResetLevel; //0-无效，1-管理员创建一个非管理员用户为其设置密码，该非管理员用户正确登录设备后要提示“请修改初始登录密码”，未修改的情况下，用户每次登入都会进行提醒；2-当非管理员用户的密码被管理员修改，该非管理员用户再次正确登录设备后，需要提示“请重新设置登录密码”，未修改的情况下，用户每次登入都会进行提醒。
    BYTE  bySupportStreamEncrypt;  //能力集扩展，位与结果：0- 不支持，1- 支持 bySupportStreamEncrypt & 0x1:表示是否支持RTP/TLS取流 bySupportStreamEncrypt & 0x2:  表示是否支持SRTP/UDP取流 bySupportStreamEncrypt & 0x4:  表示是否支持SRTP/MULTICAST取流
    BYTE byMarketType;//0-无效（未知类型）,1-经销型，2-行业型
    BYTE  byRes2[238];
}NET_DVR_DEVICEINFO_V40, *LPNET_DVR_DEVICEINFO_V40;

typedef struct  
{
    char sDeviceAddress[NET_DVR_DEV_ADDRESS_MAX_LEN];
    BYTE byUseTransport;    //是否启用能力集透传，0--不启用透传，默认，1--启用透传
    WORD wPort;
    char sUserName[NET_DVR_LOGIN_USERNAME_MAX_LEN];
    char sPassword[NET_DVR_LOGIN_PASSWD_MAX_LEN];
    fLoginResultCallBack cbLoginResult;
    void *pUser;
    BOOL bUseAsynLogin;
    BYTE byProxyType; //0:不使用代理，1：使用标准代理，2：使用EHome代理
    BYTE byUseUTCTime;    //0-不进行转换，默认,1-接口上输入输出全部使用UTC时间,SDK完成UTC时间与设备时区的转换,2-接口上输入输出全部使用平台本地时间，SDK完成平台本地时间与设备时区的转换
    BYTE byLoginMode; //0-Private 1-ISAPI 2-自适应
    BYTE byHttps;    //0-不适用tls，1-使用tls 2-自适应
    LONG iProxyID;    //代理服务器序号，添加代理服务器信息时，相对应的服务器数组下表值
    BYTE byVerifyMode;  //认证方式，0-不认证，1-双向认证，2-单向认证；认证仅在使用TLS的时候生效;
    BYTE byRes3[119];
}NET_DVR_USER_LOGIN_INFO,*LPNET_DVR_USER_LOGIN_INFO;







typedef struct 
{
    DWORD dwTotalLoginNum;        //当前login用户数
    DWORD dwTotalRealPlayNum;    //当前realplay路数
    DWORD dwTotalPlayBackNum;    //当前回放或下载路数
    DWORD dwTotalAlarmChanNum;    //当前建立报警通道路数
    DWORD dwTotalFormatNum;        //当前硬盘格式化路数
    DWORD dwTotalFileSearchNum;    //当前日志或文件搜索路数
    DWORD dwTotalLogSearchNum;    //当前日志或文件搜索路数
    DWORD dwTotalSerialNum;        //当前透明通道路数
    DWORD dwTotalUpgradeNum;    //当前升级路数
    DWORD dwTotalVoiceComNum;    //当前语音转发路数
    DWORD dwTotalBroadCastNum;    //当前语音广播路数
    DWORD dwTotalListenNum;        //当前网络监听路数
    DWORD dwEmailTestNum;       //当前邮件计数路数
    DWORD dwBackupNum;          // 当前文件备份路数
    DWORD dwTotalInquestUploadNum; //当前审讯上传路数
    DWORD dwRes[6];
}NET_DVR_SDKSTATE, *LPNET_DVR_SDKSTATE;

typedef struct 
{
    DWORD dwMaxLoginNum;        //最大login用户数 MAX_LOGIN_USERS
    DWORD dwMaxRealPlayNum;        //最大realplay路数 WATCH_NUM
    DWORD dwMaxPlayBackNum;        //最大回放或下载路数 WATCH_NUM
    DWORD dwMaxAlarmChanNum;    //最大建立报警通道路数 ALARM_NUM
    DWORD dwMaxFormatNum;        //最大硬盘格式化路数 SERVER_NUM
    DWORD dwMaxFileSearchNum;    //最大文件搜索路数 SERVER_NUM
    DWORD dwMaxLogSearchNum;    //最大日志搜索路数 SERVER_NUM
    DWORD dwMaxSerialNum;        //最大透明通道路数 SERVER_NUM
    DWORD dwMaxUpgradeNum;        //最大升级路数 SERVER_NUM
    DWORD dwMaxVoiceComNum;        //最大语音转发路数 SERVER_NUM
    DWORD dwMaxBroadCastNum;    //最大语音广播路数 MAX_CASTNUM
    DWORD dwRes[10];
}NET_DVR_SDKABL, *LPNET_DVR_SDKABL;




typedef struct 
{
    char sFileName[100];//文件名
    NET_DVR_TIME struStartTime;//文件的开始时间
    NET_DVR_TIME struStopTime;//文件的结束时间
    DWORD dwFileSize;//文件的大小
}NET_DVR_FIND_DATA, *LPNET_DVR_FIND_DATA;

typedef struct 
{
    char sFileName[100];//文件名
    NET_DVR_TIME struStartTime;//文件的开始时间
    NET_DVR_TIME struStopTime;//文件的结束时间
    DWORD dwFileSize;//文件的大小
    char sCardNum[32];
    BYTE byLocked;//9000设备支持,1表示此文件已经被锁定,0表示正常的文件
    BYTE byFileType;  //文件类型:0－定时录像,1-移动侦测 ，2－报警触发，
    //3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警,14-智能交通事件
    BYTE byRes[2];
}NET_DVR_FINDDATA_V30, *LPNET_DVR_FINDDATA_V30;

typedef struct 
{
    char sFileName[100];//文件名
    NET_DVR_TIME struStartTime;//文件的开始时间
    NET_DVR_TIME struStopTime;//文件的结束时间
    DWORD dwFileSize;//文件的大小
    char sCardNum[32];
    BYTE byLocked;//9000设备支持,1表示此文件已经被锁定,0表示正常的文件
    BYTE byFileType;  //文件类型:0－定时录像,1-移动侦测 ，2－报警触发，
    //3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警,14-智能交通事件
    BYTE byQuickSearch; //0:普通查询结果，1：快速（日历）查询结果
    BYTE byRes;
    DWORD dwFileIndex; //文件索引号
    BYTE byStreamType;
    BYTE byRes1[127];    
}NET_DVR_FINDDATA_V40, *LPNET_DVR_FINDDATA_V40;

typedef struct tagNET_DVR_FINDDATA_V50
{
    char sFileName[100];
    NET_DVR_TIME_SEARCH   struStartTime;
    NET_DVR_TIME_SEARCH   struStopTime;
    NET_DVR_ADDRESS struAddr; //片段所在的地址信息，集群回放时用到
    DWORD   dwFileSize; //文件大小 //对于大文件搜索类型时（byBigFileType为1），该值无意义
    BYTE    byLocked; //文件是否被锁定，1－文件已锁定；0－文件未锁定
    BYTE   byFileType; //文件类型，与V40相同
    BYTE   byQuickSearch; //0- 普通查询结果，1- 快速（日历）查询结果
    BYTE  byStreamType; //码流类型：0- 主码流，1- 子码流，2- 码流三
    DWORD  dwFileIndex; //文件索引号
    char  sCardNum[32]; //卡号
    DWORD  dwTotalLenH; // 对于大文件搜索，时间段内数据总长度，高32字节
    DWORD  dwTotalLenL; // 对于大文件搜索，时间段内数据总长度，低32字节
    BYTE    byBigFileType;  // 0为普通片段搜索，1为大文件搜索          
    BYTE    byRes[247];
}NET_DVR_FINDDATA_V50, *LPNET_DVR_FINDDATA_V50;

typedef struct 
{
    char sFileName[100];//文件名
    NET_DVR_TIME struStartTime;//文件的开始时间
    NET_DVR_TIME struStopTime;//文件的结束时间
    DWORD dwFileSize;//文件的大小
    char sCardNum[32];
}NET_DVR_FINDDATA_CARD, *LPNET_DVR_FINDDATA_CARD;

typedef struct 
{
    LONG lChannel;//通道号
    DWORD dwFileType;//录象文件类型
       //不带卡号，0xff－全部，0－定时录像,1-移动侦测 ，2－报警触发，3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7-智能录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
    //带卡号，0xff－全部，0－定时录像，1-移动侦测，2－接近报警，3－出钞报警，4－进钞报警，5-命令触发，6－手动录像，7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
    DWORD dwIsLocked;//是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
    DWORD dwUseCardNo;//是否使用卡号
    BYTE sCardNumber[32];//卡号
    NET_DVR_TIME struStartTime;//开始时间
    NET_DVR_TIME struStopTime;//结束时间
}NET_DVR_FILECOND, *LPNET_DVR_FILECOND;

typedef struct 
{
    int xTop;     //方框起始点的x坐标
    int yTop;     //方框结束点的y坐标
    int xBottom;  //方框结束点的x坐标
    int yBottom;  //方框结束点的y坐标
    int bCounter; //保留
}NET_DVR_POINT_FRAME, *LPNET_DVR_POINT_FRAME;

typedef struct tagNET_DVR_COMPRESSION_AUDIO
{
    BYTE  byAudioEncType;   //音频编码类型 0-OggVorbis(G722.1);1-G711_U;2-G711_A;5-MP2L2;6-G726;7-AAC,8-PCM;9-G722.1.C;12-AAC_LC;13-AAC_LD;14-Opus;15-MP3;16-ADPCM
    BYTE  byAudioSamplingRate;//音频采样率 0-默认，1-16kHZ，2-32kHZ，3-48kHZ, 4- 44.1kHZ,5-8kHZ
    BYTE  byAudioBitRate;// 音频码率 参考 BITRATE_ENCODE_INDEX
    BYTE  byres[4];//这里保留音频的压缩参数  
    BYTE  bySupport;//bySupport Bit0表示 Mp2l2前4个字节的含义表示后面内容音频数据长度 
}NET_DVR_COMPRESSION_AUDIO, *LPNET_DVR_COMPRESSION_AUDIO;

typedef struct tagNET_DVR_AP_INFO
{
    char  sSsid[IW_ESSID_MAX_SIZE];
    DWORD  dwMode;                        /* 0 mange 模式;1 ad-hoc模式，参见NICMODE */
    DWORD  dwSecurity;           /*0 不加密；1 wep加密；2 wpa-psk;3 wpa-Enterprise;4-WPA2_PSK参见WIFISECURITY*/
    DWORD  dwChannel;            /*1-11表示11个通道*/
    DWORD  dwSignalStrength;    /*0-100信号由最弱变为最强*/
    DWORD  dwSpeed;               /*速率,单位是0.01mbps*/
}NET_DVR_AP_INFO,*LPNET_DVR_AP_INFO;

typedef struct tagNET_DVR_AP_INFO_LIST
{
    DWORD dwSize;
    DWORD dwCount;        /*无线AP数量，不超过20*/
    NET_DVR_AP_INFO struApInfo[WIFI_MAX_AP_COUNT];
}NET_DVR_AP_INFO_LIST,*LPNET_DVR_AP_INFO_LIST;

typedef struct tagNET_DVR_WIFIETHERNET
{    
    char sIpAddress[16];                /*IP地址*/
    char sIpMask[16];                    /*掩码*/    
    BYTE    byMACAddr[MACADDR_LEN];        /*物理地址，只用来显示*/
    BYTE    byCloseWifi;        //是否关闭wifi连接，0-不关闭，1-关闭
    BYTE    bRes;
    DWORD    dwEnableDhcp;                /*是否启动dhcp  0不启动 1启动*/
    DWORD    dwAutoDns;                    /*如果启动dhcp是否自动获取dns,0不自动获取 1自动获取；对于有线如果启动dhcp目前自动获取dns*/    
    char sFirstDns[16];                         /*第一个dns域名*/
    char sSecondDns[16];                     /*第二个dns域名*/
    char sGatewayIpAddr[16];                 /* 网关地址*/
    BYTE   bRes2[8];
}NET_DVR_WIFIETHERNET,*LPNET_DVR_WIFIETHERNET;

typedef struct tagNET_DVR_WIFI_CFG_EX
{
    NET_DVR_WIFIETHERNET struEtherNet;        /*wifi网口*/
    char sEssid[IW_ESSID_MAX_SIZE];     /*SSID*/
    DWORD dwMode;      /* 0 mange 模式;1 ad-hoc模式，参见*/
    DWORD dwSecurity; /*0-不加密;1-WEP加密;2-WPA-personal; 3-WPA-enterprise;4-WPA2-personal;5-WPA2-enterprise */
    union 
    {
        struct 
        {
            DWORD dwAuthentication;/*0 -开放式 1-共享式*/
            DWORD dwKeyLength;/* 0 -64位；1- 128位；2-152位*/
            DWORD dwKeyType;/*0 16进制;1 ASCI */
            DWORD dwActive;/*0 索引：0---3表示用哪一个密钥*/
            char sKeyInfo[WIFI_WEP_MAX_KEY_COUNT][WIFI_WEP_MAX_KEY_LENGTH];
        }wep;
        struct 
        {
            DWORD dwKeyLength;/*8-63个ASCII字符*/
            char sKeyInfo[WIFI_WPA_PSK_MAX_KEY_LENGTH];
            BYTE byEncryptType;  /*WPA/WPA2模式下加密类型,0-AES, 1-TKIP*/
            char sNewKeyInfo[WIFI_WPA_PSK_MAX_HEXKEY_LENGTH/*68*/];//新密钥（支持8-63个ASCII字符以及64个十六制字符密钥）
            //当byKeyType为0时，启用sKeyInfo，当byKeyType为1时，启用sNewKeyInfo
            //密钥类型；0 ~ 老密钥类型（只支持8-63个ASCII字符），1 ~新密钥类型（支持8-63个ASCII字符以及64个十六制字符密钥）
            BYTE byKeyType; 
            BYTE byRes[7];
        }wpa_psk;
        struct 
        {
            BYTE byEncryptType;  /*加密类型,0-AES, 1-TKIP*/
            BYTE byAuthType; //认证类型，0-EAP_TTLS,1-EAP_PEAP,2-EAP_TLS
            BYTE byRes[2];
            union
            {
                struct 
                {
                    BYTE byEapolVersion; //EAPOL版本，0-版本1，1-版本2
                    BYTE byAuthType; //内部认证方式，0-PAP，1-MSCHAPV2
                    BYTE byRes1[2];
                    BYTE byAnonyIdentity [NAME_LEN]; //匿名身份
                    BYTE byUserName[NAME_LEN]; //用户名
                    BYTE byPassword[NAME_LEN]; //密码
                    BYTE byRes[44];
                }EAP_TTLS; //WPA-enterprise/WPA2-enterpris模式适用
                struct 
                {
                    BYTE byEapolVersion; //EAPOL版本，0-版本1，1-版本2
                    BYTE byAuthType; //内部认证方式，0-GTC，1-MD5，2-MSCHAPV2
                    BYTE byPeapVersion; //PEAP版本，0-版本0，1-版本1
                    BYTE byPeapLabel; //PEAP标签，0-老标签，1-新标签
                    BYTE byAnonyIdentity[NAME_LEN]; //匿名身份
                    BYTE byUserName[NAME_LEN]; //用户名
                    BYTE byPassword[NAME_LEN]; //密码
                    BYTE byRes[44]; 
                }EAP_PEAP; //WPA-enterprise/WPA2-enterpris模式适用
                struct 
                {
                    BYTE byEapolVersion; //EAPOL版本，0-版本1，1-版本2
                    BYTE byRes1[3]; 
                    BYTE byIdentity[NAME_LEN]; //身份
                    BYTE byPrivateKeyPswd[NAME_LEN]; //私钥密码
                    BYTE byRes[76]; 
                }EAP_TLS; 
            }auth_param;
        }wpa_wpa2; //WPA-enterprise/WPA2-enterpris模式适用
    }key;    
}NET_DVR_WIFI_CFG_EX,*LPNET_DVR_WIFI_CFG_EX;

typedef struct tagNET_DVR_WIFI_CFG
{
    DWORD dwSize;
    NET_DVR_WIFI_CFG_EX struWifiCfg;
}NET_DVR_WIFI_CFG,*LPNET_DVR_WIFI_CFG;


typedef struct tagNET_DVR_WIFI_WORKMODE
{
    DWORD dwSize;
    DWORD dwNetworkInterfaceMode; /*0 自动切换模式　1 有线模式*/
}NET_DVR_WIFI_WORKMODE,*LPNET_DVR_WIFI_WORKMODE;



typedef struct tagNET_VCA_CTRLINFO
{
    BYTE   byVCAEnable;        //是否开启智能
    BYTE   byVCAType;        //智能能力类型，VCA_CHAN_ABILITY_TYPE 
    BYTE   byStreamWithVCA; //码流中是否带智能信息
    BYTE   byMode;            //模式，ATM能力时参照VCA_CHAN_MODE_TYPE ,TFS能力时参照TFS_CHAN_MODE_TYPE
    BYTE   byControlType;   //控制类型，按位表示，0-否，1-是
    // byControlType &1 是否启用抓拍功能
    BYTE   byPicWithVCA ;// 报警抓图叠加目标信息(目标框)：0-不叠加（默认），1-叠加；
    BYTE   byRes[2];         //保留，设置为0 
}NET_VCA_CTRLINFO, * LPNET_VCA_CTRLINFO;

typedef struct tagNET_VCA_CTRLCFG
{
    DWORD dwSize;
    NET_VCA_CTRLINFO  struCtrlInfo[MAX_VCA_CHAN];     //控制信息,数组0对应设备的起始通道
    BYTE byRes[16];
}NET_VCA_CTRLCFG, * LPNET_VCA_CTRLCFG;

typedef struct tagNET_VCA_DEV_ABILITY
{
    DWORD dwSize;              //结构长度
    BYTE byVCAChanNum;         //智能通道个数
    BYTE byPlateChanNum;       //车牌通道个数
    BYTE byBBaseChanNum;       //行为基本版个数
    BYTE byBAdvanceChanNum;    //行为高级版个数
    BYTE byBFullChanNum;       //行为完整版个数
    BYTE byATMChanNum;           //智能ATM个数
    BYTE byPDCChanNum;         //人数统计通道个数
    BYTE byITSChanNum;         //交通事件通道个数
    BYTE byBPrisonChanNum;     //行为监狱版(监舍)通道个数
    BYTE byFSnapChanNum;       //人脸抓拍通道个数
    BYTE byFSnapRecogChanNum;  //人脸抓拍和识别通道个数
    BYTE byFRetrievalChanNum;  //人脸后检索个数
    BYTE bySupport;            //能力，位与结果为0表示不支持，1表示支持
    //bySupport & 0x1，表示是否支持智能跟踪 2012-3-22
    //bySupport & 0x2，表示是否支持128路取流扩展2012-12-27
    BYTE byFRecogChanNum;      //人脸识别通道个数
    BYTE byBPPerimeterChanNum; //行为监狱版(周界)通道个数
    BYTE byTPSChanNum;         //交通诱导通道个数
    BYTE byTFSChanNum;         //道路违章取证通道个数
    BYTE byFSnapBFullChanNum;  //人脸抓拍和行为分析通道个数
    BYTE byHeatMapChanNum;     //热度图通道个数
    BYTE bySmartVehicleNum;    //SMART事件+车辆检测通道个数
    BYTE bySmartHVTNum;       //SMART事件+混行检测通道个数
    BYTE bySmartNum;          //SMART事件个数
    BYTE byVehicleNum;        //车辆检测通道个数
    BYTE bySmartRoadDetectionNum ; // SMART事件+道路监控通道个数
    BYTE bySmartFaceDetectionNum ; // SMART事件+人脸侦测通道个数
    BYTE bySmartHeatMapNum ; // SMART事件+热度图通道个数
    BYTE byHumanRecognitionNum; //人体识别通道个数
    BYTE byEdcationStudentNum; //教育录播（学生起来检测&&学生人数统计）支持的通道数
    BYTE byRoadDetectionNum;//道路监控通道个数
    BYTE byPersonDensityDetection; //人员密度检测通道个数
    BYTE bySafetyHelmetDetection; //安全帽检测通道个数
    BYTE byPerimeterCapture;//周界抓拍通道个数
    BYTE byHeelPDC;//倾斜客流通道个数
    BYTE by12MPLiveView;// 主码流 1200W@20fps预览（4000*3000）
    BYTE byTeacherBehaviorDetectNum; //教育录播（教师行为检测）支持的通道数
    BYTE byMixedTargetDetection;//混合目标检测通道个数
    BYTE byFaceContrast;//人脸比对检测通道个数
    BYTE byCityManagement;//智慧城管检测通道个数
    BYTE byMixedTargetDetectionSmart;//混合目标检测+Smart事件
    BYTE byRes;
}NET_VCA_DEV_ABILITY, *LPNET_VCA_DEV_ABILITY;








typedef struct tagNET_VCA_CHAN_IN_PARAM
{
    BYTE byVCAType;        //VCA_CHAN_ABILITY_TYPE枚举值
    BYTE byMode;        //模式，ATM 能力时参照VCA_CHAN_MODE_TYPE,TFS能力时参照TFS_CHAN_MODE_TYPE,当VCA_TYPE 为交通事件时参照TRAFFIC_SCENE_MODE
    BYTE byRes[2];         //保留，设置为0 
}NET_VCA_CHAN_IN_PARAM, *LPNET_VCA_CHAN_IN_PARAM;

typedef struct tagNET_VCA_BEHAVIOR_ABILITY
{
    DWORD dwSize;         //结构长度
    DWORD dwAbilityType; //支持的能力类型，按位表示，见VCA_ABILITY_TYPE定义
    BYTE  byMaxRuleNum;     //最大规则数
    BYTE  byMaxTargetNum; //最大目标数
    BYTE  bySupport;        // 支持的功能类型   按位表示  
    // bySupport & 0x01 支持标定功能
    BYTE  byRes[5];         //保留，设置为0 
    DWORD dwAbilityTypeEx;  //支持的能力类型，按位表示，见VCA_ABILITY_TYPE_EX定义
}NET_VCA_BEHAVIOR_ABILITY, *LPNET_VCA_BEHAVIOR_ABILITY;

typedef struct tagNET_DVR_SCENE_CHANGE_UPDATE_PARAM
{
    DWORD    dwSize;
    BYTE    byIDCount;    //实际流ID数
    BYTE    byRes1[3];
    BYTE    byStreamID[MAX_STREAM_ID_NUM][STREAM_ID_LEN];
    BYTE    byRes[256];
}NET_DVR_SCENE_CHANGE_UPDATE_PARAM, *LPNET_DVR_SCENE_CHANGE_UPDATE_PARAM;

typedef struct tagNET_DVR_ITS_ABILITY
{
    DWORD     dwSize;             // 结构体大小
    DWORD     dwAbilityType;      // 支持的能力列表  参照ITS_ABILITY_TYPE
    BYTE     byMaxRuleNum;         //最大规则数
    BYTE     byMaxTargetNum;     //最大目标数
       BYTE    byRes[10];            // 保留
}NET_DVR_ITS_ABILITY, *LPNET_DVR_ITS_ABILITY;




typedef struct tagNET_VCA_LINE
{
    NET_VCA_POINT struStart;    //起点 
    NET_VCA_POINT struEnd;      //终点
}NET_VCA_LINE, *LPNET_VCA_LINE;

typedef struct tagNET_VCA_POLYGON
{
    DWORD dwPointNum;                                  //有效点 大于等于3，若是3点在一条线上认为是无效区域，线交叉认为是无效区域 
    NET_VCA_POINT  struPos[VCA_MAX_POLYGON_POINT_NUM]; //多边形边界点,最多十个 
}NET_VCA_POLYGON, *LPNET_VCA_POLYGON;

typedef struct tagNET_VCA_TRAVERSE_PLANE
{    
    NET_VCA_LINE struPlaneBottom;          //警戒面底边
    VCA_CROSS_DIRECTION dwCrossDirection;  //穿越方向: 0-双向，1-从左到右，2-从右到左
    BYTE bySensitivity;                    //灵敏度参数，范围[1,5]
    BYTE byPlaneHeight;                    //警戒面高度
    /*
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    */
    BYTE byDetectionTarget;
    BYTE byPriority;//优先级,0~低,1~中,2~高
    BYTE byAlarmConfidence;       //报警置信度, 0-低,1-较低,2-较高,3-高
    BYTE byRecordConfidence;      //录像置信度, 0-低,1-较低,2-较高,3-高
    BYTE byRes2[34];              //保留
}NET_VCA_TRAVERSE_PLANE, *LPNET_VCA_TRAVERSE_PLANE;

typedef struct tagNET_VCA_SIT_QUIETLY
{
    NET_VCA_POLYGON struRegion;//区域范围
    //规则触发顺序，0-顺序或逆序触发，1-顺序触发
    DWORD   dwDuration;         //持续时间  单位s 范围1-3600
    BYTE    byRes[4];
} NET_VCA_SIT_QUIETLY, *LPNET_VCA_SIT_QUIETLY;

typedef struct tagNET_VCA_AREA
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1,5]
    /*
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    */
    BYTE byDetectionTarget;
    BYTE byPriority;//优先级,0~低,1~中,2~高
    BYTE byRes[5];
}NET_VCA_AREA, *LPNET_VCA_AREA;

typedef struct tagNET_VCA_INTRUSION
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration;            //行为事件触发时间阈值: 1-120秒，建议5秒，判断是有效报警的时间  在ATM系统中触发文件阈值为 1-1000秒
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byRate;               //占比：区域内所有未报警目标尺寸目标占区域面积的比重，归一化为－；
    /*
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    */
    BYTE byDetectionTarget;
    BYTE byPriority;//优先级,0~低,1~中,2~高
    BYTE byAlarmConfidence;    //报警置信度, 0-低,1-较低,2-较高,3-高
    BYTE byRecordConfidence;   //录像置信度, 0-低,1-较低,2-较高,3-高
}NET_VCA_INTRUSION, *LPNET_VCA_INTRUSION;

typedef struct tagNET_VCA_LOITER
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration; //触发时间阈值：1-120秒，建议10秒
    BYTE bySensitivity;            //灵敏度参数，范围[1,5]
    BYTE byRes[1];
    DWORD dwLoiterDistance; //行程总距离阈值：100-5000，默认1000cm
}NET_VCA_LOITER, *LPNET_VCA_LOITER;

typedef struct tagNET_VCA_TAKE_LEFT
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration; //触发时间阈值：1-120秒，建议10秒
    BYTE bySensitivity;            //灵敏度参数，范围[1,5]
    BYTE byRes[5];
}NET_VCA_TAKE_LEFT, *LPNET_VCA_TAKE_LEFT;

typedef struct tagNET_VCA_PARKING
{
    NET_VCA_POLYGON struRegion;    //区域范围
    WORD wDuration;                //触发时间阈值：1-100秒，建议10秒
    BYTE bySensitivity;            //灵敏度参数，范围[1,5]
    BYTE byRes[5];
}NET_VCA_PARKING, *LPNET_VCA_PARKING;

typedef struct tagNET_VCA_RUN
{
    NET_VCA_POLYGON struRegion;    //区域范围
    float  fRunDistance;        //人快速移动最大距离, 范围: [0.1, 1.00] 像素模式 实际模式(1,20)m/s
    BYTE bySensitivity;            //灵敏度参数，范围[1,5]
    BYTE byMode;     // 0 像素模式  1 实际模式
    /*
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    */
    BYTE byDetectionTarget;
    BYTE byRes;
}NET_VCA_RUN, *LPNET_VCA_RUN;

typedef struct tagNET_VCA_HIGH_DENSITY
{
    NET_VCA_POLYGON struRegion;        //区域范围
    float           fDensity;       //聚集比率, 范围: [0.1, 1.0]
    BYTE            bySensitivity;    //灵敏度参数，范围[1,5]
    BYTE            byRes;          // 保留字节
    WORD            wDuration;      // 触发人员聚集参数报警阈值 20-360s
}NET_VCA_HIGH_DENSITY, *LPNET_VCA_HIGH_DENSITY; 

typedef struct tagNET_VCA_VIOLENT_MOTION
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD  wDuration;           //触发剧烈运动报警阈值：1-50秒
    BYTE  bySensitivity;       //灵敏度参数，范围[1,5]
    BYTE  byMode;              //0-纯视频模式，1-音视频联合模式，2-纯音频模式
    BYTE  byRes[4];            //保留
}NET_VCA_VIOLENT_MOTION, *LPNET_VCA_VIOLENT_MOTION; 

typedef struct tagNET_VCA_REACH_HIGHT
{
    NET_VCA_LINE struVcaLine;   //攀高警戒面
    WORD wDuration; //触发攀高报警阈值：1-120秒
    BYTE    byRes[6];           // 保留字节
}NET_VCA_REACH_HIGHT, *LPNET_VCA_REACH_HIGHT;

typedef struct tagNET_VCA_GET_UP
{
    NET_VCA_POLYGON struRegion; //区域范围
    WORD    wDuration;            //触发起床报警阈值1-100 秒
    BYTE    byMode;             //起身检测模式,0-大床通铺模式,1-高低铺模式,2-大床通铺坐立起身模式
    BYTE    bySensitivity;      //灵敏度参数，范围[1,10]
    BYTE    byRes[4];            //保留字节
}NET_VCA_GET_UP, * LPNET_VCA_GET_UP;

typedef struct tagNET_VCA_LEFT
{
    NET_VCA_POLYGON struRegion; // 区域范围
    WORD       wDuration;       // 触发物品遗留报警阈值 10-100秒
    BYTE       bySensitivity;   // 灵敏度参数，范围[1,5] 
    BYTE       byRes[5];        // 保留字节
}NET_VCA_LEFT, *LPNET_VCA_LEFT;

typedef struct tagNET_VCA_TAKE
{
    NET_VCA_POLYGON struRegion;     // 区域范围
    WORD            wDuration;      // 触发物品拿取报警阈值10-100秒
    BYTE            bySensitivity;  // 灵敏度参数，范围[1,5] 
    BYTE            byRes[5];       // 保留字节
}NET_VCA_TAKE, *LPNET_VCA_TAKE;

typedef struct tagNET_VCA_OVER_TIME
{
    NET_VCA_POLYGON     struRegion;    // 区域范围
    WORD               wDuration;  // 操作报警时间阈值 4s-60000s
    BYTE   byRes[6];   // 保留字节
}NET_VCA_OVER_TIME, *LPNET_VCA_OVER_TIME;

typedef struct tagNET_VCA_HUMAN_ENTER
{
    DWORD                dwRes[23];            //保留字节
}NET_VCA_HUMAN_ENTER, *LPNET_VCA_HUMAN_ENTER;

typedef struct tagNET_VCA_STICK_UP
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration; //触发时间阈值：4-60秒，建议10秒
    BYTE  bySensitivity;       //灵敏度参数，范围[1,5]
    BYTE byRes[5];
}NET_VCA_STICK_UP, *LPNET_VCA_STICK_UP; 

typedef struct tagNET_VCA_SCANNER
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration; //读卡持续时间：4-60秒
    BYTE bySensitivity;       //灵敏度参数，范围[1,5]
    BYTE byRes[5];
}NET_VCA_SCANNER, *LPNET_VCA_SCANNER; 

typedef struct tagNET_VCA_LEAVE_POSITION
{
    NET_VCA_POLYGON   struRegion; //区域范围
    WORD   wLeaveDelay;  //无人报警时间，单位：s
    WORD   wStaticDelay; //睡觉报警时间，单位：s
    BYTE   byMode;       //模式，0-离岗事件，1-睡岗事件，2-离岗睡岗事件，3-在岗（当离岗人员回到岗位）
    BYTE   byPersonType; //值岗人数类型，0-单人值岗，1-双人值岗
    BYTE   byOnPosition; //在岗人数，1-10，默认1
    BYTE   bySensitivity;     //灵敏度参数，范围[1,5]
}NET_VCA_LEAVE_POSITION, *LPNET_VCA_LEAVE_POSITION;

typedef struct tagNET_VCA_TRAIL
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD  wRes;      /* 保留 */
    BYTE  bySensitivity;       /* 灵敏度参数，范围[1,5] */
    BYTE  byRes[5];
}NET_VCA_TRAIL, *LPNET_VCA_TRAIL;

typedef struct tagNET_VCA_FALL_DOWN
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD  wDuration;      /* 触发事件阈值 1-60s*/
    BYTE  bySensitivity;       /* 灵敏度参数，范围[1,5] */
    BYTE  byHeightThreshold; //高度阈值，范围[0,250]，默认90，单位：厘米
    BYTE  byRes[4];
}NET_VCA_FALL_DOWN, *LPNET_VCA_FALL_DOWN;

typedef struct tagNET_VCA_STANDUP
{
    NET_VCA_POLYGON  struRegion; //区域范围
    BYTE  bySensitivity;     //灵敏度参数，范围[1,100]
    BYTE  byHeightThreshold; //高度阈值，范围[0,250]，默认130，单位：厘米
    WORD  wDuration;         //触发事件阈值[1,3600]，默认2，单位：秒
    BYTE  byRes[4];          //保留
}NET_VCA_STANDUP, *LPNET_VCA_STANDUP;

typedef struct tagNET_VCA_PEOPLENUM_CHANGE
{
    NET_VCA_POLYGON  struRegion; //区域范围
    BYTE  bySensitivity;  //灵敏度参数，范围[1,100]
    BYTE  byPeopleNumThreshold; //人数阈值，范围[0,5]，默认1 
    BYTE  byDetectMode; //检测方式，与人数阈值相比较。1-大于，2-小于，3-等于，4-不等于
    BYTE  byNoneStateEffective; //无人状态是否有效，0-无效，1-有效
    WORD  wDuration;  //触发时间阈值[1,3600]，默认2，单位：秒
    BYTE  byPeopleNum; //触发报警人数，只读，仅报警上报，设备返回0表示不支持本功能上报，0xff表示报警人数为0
    BYTE  byRes;   //保留
}NET_VCA_PEOPLENUM_CHANGE, *LPNET_VCA_PEOPLENUM_CHANGE;

typedef struct tagNET_VCA_SPACING_CHANGE
{
    NET_VCA_POLYGON  struRegion; //区域范围
    float fSpacingThreshold; //间距阈值，范围[0,10.0]，默认1.0，单位：米
    BYTE  bySensitivity;  //灵敏度参数，范围[1,100]
    BYTE  byDetectMode; //检测方式，与间距阈值相比较。1-大于，2-小于
    WORD  wDuration;  //触发时间阈值[1,3600]，默认2，单位：秒
}NET_VCA_SPACING_CHANGE, *LPNET_VCA_SPACING_CHANGE;

typedef struct tagNET_VCA_AUDIO_ABNORMAL
{
    WORD wDecibel;       //声音强度
    BYTE bySensitivity;  //灵敏度参数，范围[1,100] 
    BYTE byAudioMode;    //声音检测模式，0-灵敏度检测，1-分贝阈值检测，2-灵敏度与分贝阈值检测 
    BYTE byEnable;       //使能，是否开启(声强突变，陡升)
    BYTE byThreshold;    //声音阈值[1,100]
    BYTE byRes[54];      //保留   
}NET_VCA_AUDIO_ABNORMAL, *LPNET_VCA_AUDIO_ABNORMAL;

typedef struct tagNET_DVR_AUDIO_STEEP_DROP
{
    BYTE  bySensitivity;   /* 灵敏度参数，范围[1,100] */
    BYTE  byEnable;        //使能，是否开启(声强突变，陡降)
    BYTE  byRes[6];    
}NET_DVR_AUDIO_STEEP_DROP, *LPNET_DVR_AUDIO_STEEP_DROP;

typedef struct tagNET_DVR_AUDIO_EXCEPTION
{
    DWORD                       dwSize;
    BYTE                        byEnableAudioInException;//使能，是否开启
    BYTE                        byRes1[3];
    NET_VCA_AUDIO_ABNORMAL      struAudioAbnormal;  
    NET_DVR_SCHEDTIME            struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30]; //布防时间
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;     //异常处理方式
    DWORD                       dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD                       dwRelRecordChanNum ;     //报警触发的录象通道 数 实际支持的数量
    DWORD                       byRelRecordChan[MAX_CHANNUM_V30];
    NET_DVR_AUDIO_STEEP_DROP    struAudioSteepDrop;      //声强陡降
    BYTE                        byRes2[24];
}NET_DVR_AUDIO_EXCEPTION, *LPNET_DVR_AUDIO_EXCEPTION;

typedef struct tagNET_VCA_TOILET_TARRY
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDelay;        //如厕超时时间[1,3600]，单位：秒
    BYTE byRes[6];    
}NET_VCA_TOILET_TARRY, *LPNET_VCA_TOILET_TARRY;

typedef struct tagNET_VCA_YARD_TARRY
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDelay;        //放风场滞留时间[1,120]，单位：秒
    BYTE byRes[6];    
}NET_VCA_YARD_TARRY, *LPNET_VCA_YARD_TARRY;

typedef struct tagNET_VCA_ADV_REACH_HEIGHT
{
    NET_VCA_POLYGON struRegion; //攀高折线
    DWORD   dwCrossDirection;   //跨越方向(详见VCA_CROSS_DIRECTION): 0-双向，1-从左到右2-从右到左
    BYTE    byRes[4];            // 保留字节
}NET_VCA_ADV_REACH_HEIGHT, * LPNET_VCA_ADV_REACH_HEIGHT;

typedef struct tagNET_VCA_ADV_TRAVERSE_PLANE
{
    NET_VCA_POLYGON struRegion; //警戒面折线
    DWORD   dwCrossDirection;   //跨越方向(详见VCA_CROSS_DIRECTION): 0-双向，1-从左到右2-从右到左
    BYTE    bySensitivity;      //灵敏度参数，范围[1,5] 
    BYTE    byRes[3];            //保留字节
} NET_VCA_ADV_TRAVERSE_PLANE,*LPNET_VCA_ADV_TRAVERSE_PLANE;

typedef struct tagNET_VCA_PLAY_CELLPHONE
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration;    //玩手机超时时间[1,600]秒, 默认20秒
    BYTE byRes[6];     //保留字节
}NET_VCA_PLAY_CELLPHONE, *LPNET_VCA_PLAY_CELLPHONE;

typedef struct tagNET_VCA_LECTURE
{
    NET_VCA_POLYGON struRegion;//区域范围
    WORD wDuration; //行为事件触发时间阈值: 1-10秒，建议1秒，判断是有效报警的时间
    BYTE bySensitivity; //灵敏度参数，范围[1-100]
    BYTE byAlarmState;//只读字段界面不显示；0-保留,1-报警开始,2-报警结束 
    BYTE byTrackingMode ;//跟踪模式，0-自动(默认) , 1-水平, 2-垂直
    BYTE byZoomMode;//变倍模式, 0-固定(默认), 1-自动
    BYTE byZoomOver;//0-保留,1-变倍到位(报警上传录播主机，作为切换画面判断依据)
    BYTE byTrackStatus;//跟踪状态 0-保留，1-开始授课（A，全景） 2-正在跟踪（2,特写），3 -跟踪丢失（2,全景）
}NET_VCA_LECTURE, *LPNET_VCA_LECTURE;

typedef struct tagNET_VCA_ANSWER
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;//灵敏度参数，范围[1-100]
    BYTE byAlarmState;//只读字段界面不显示；0-保留,1-报警开始,2-报警结束
    BYTE byZoomOver;//0-保留,1-变倍到位(报警上传录播主机，作为切换画面判断依据)
    BYTE byAnswerStudent;//0-保留，1-无学生起立，2-单个学生起立，3-多个学生起立,4-疑似学生起立, 5-单个学生走动
    BYTE byRes[4];             //保留
}NET_VCA_ANSWER, *LPNET_VCA_ANSWER;

typedef struct tagNET_VCA_RELATE_RULE_PARAM
{   
    BYTE  byRuleID;  //规则序号 0-表示无
    BYTE  byRes;  //保留
    WORD  wEventType;        //行为事件类型，参考VCA_RULE_EVENT_TYPE_EX留
}NET_VCA_RELATE_RULE_PARAM,*LPNET_VCA_RELATE_RULE_PARAM;

typedef struct tagNET_VCA_COMBINED_RULE_
{
    //规则触发顺序，0-顺序或逆序触发，1-顺序触发
    BYTE    byRuleSequence; 
    BYTE    byRes[7];
    DWORD  dwMinInterval;    //最小时间间隔，单位：秒
    DWORD  dwMaxInterval;  //最大时间间隔，单位：秒
    NET_VCA_RELATE_RULE_PARAM  struRule1Raram;//规则1
    NET_VCA_RELATE_RULE_PARAM  struRule2Raram;//规则2
    BYTE    byRes1[36];
} NET_VCA_COMBINED_RULE, *LPNET_VCA_COMBINED_RULE;

typedef struct  tagNET_VCA_BLACKBOARD_WRITE
{
    NET_VCA_POLYGON struRegion;//区域范围（配置区域，报警中不含有该区域）
    BYTE    byTeacherState;//教师状态；0~教师特写，1~教师全景，2~讲台无人状态
    BYTE    byWritingState;//板书状态；0~板书开始，1~板书结束
    BYTE    byWritingArea;//板书区域；0~整个板书，1~板书左边，2~板书右边
    BYTE    byRes[5];
}NET_VCA_BLACKBOARD_WRITE, *LPNET_VCA_BLACKBOARD_WRITE;

typedef struct tagNET_VCA_HIGH_DENSITY_STATUS
{
    NET_VCA_POLYGON struRegion;        //区域范围
    float           fDensity;       //聚集比率, 范围: [0.1, 1.0]
    BYTE            bySensitivity;    //灵敏度参数，范围[1,5]
    BYTE            byRes[3];          // 保留字节
}NET_VCA_HIGH_DENSITY_STATUS, *LPNET_VCA_HIGH_DENSITY_STATUS; 

typedef struct _NET_VCA_RUNNING_
{
    NET_VCA_POLYGON  struRegion;  //区域范围
    DWORD  dwSpeed;      //奔跑速度，范围[1,10]
    WORD   wDuration;      // 触发报警时间阈值
    BYTE   byRunMode;    //奔跑模式，0-保留,1：单人奔跑,2:多人奔跑
    BYTE   byRes;
}NET_VCA_RUNNING, *LPNET_VCA_RUNNING;

typedef struct tagNET_VCA_RETENTION
{
    NET_VCA_POLYGON struRegion; // 区域范围
    WORD       wDuration;       //触发滞留报警阈值时间（60-3600秒）默认1800秒
    BYTE       byRes[6];        // 保留字节
}NET_VCA_RETENTION, *LPNET_VCA_RETENTION;

typedef struct tagNET_VCA_SITUATION_ANALYSIS
{
    NET_VCA_POLYGON struRegion; // 区域范围
    WORD       wPeopleNum;       //区域人数
    BYTE       byRes[6];        // 保留字节
}NET_VCA_SITUATION_ANALYSIS, *LPNET_VCA_SITUATION_ANALYSIS;

typedef struct _NET_VCA_DURATION_
{
    WORD   wRelationEventType;  //参考VCA_RULE_EVENT_TYPE_EX
    BYTE   byRes[90];
}NET_VCA_DURATION, *LPNET_VCA_DURATION;

typedef struct tagNET_VCA_FAKECARD
{
    NET_VCA_POLYGON struRegion; // 区域范围
    BYTE         bySensitivity;  // 灵敏度参数：最小1,最大5,默认3
    BYTE         byRes[7];       // 保留字节
}NET_VCA_FAKECARD, *LPNET_VCA_FAKECARD;



typedef struct tagNET_VCA_SIZE_FILTER
{
    BYTE    byActive;            //是否激活尺寸过滤器 0-否 非0-是
    BYTE    byMode;         //过滤器模式SIZE_FILTER_MODE
    BYTE    byRes[2];        //保留，置0
    NET_VCA_RECT struMiniRect;    //最小目标框,全0表示不设置
    NET_VCA_RECT struMaxRect;      //最大目标框,全0表示不设置
}NET_VCA_SIZE_FILTER, *LPNET_VCA_SIZE_FILTER;

typedef struct tagNET_VCA_ONE_RULE
{
    BYTE   byActive;                    //是否激活规则,0-否,非0-是
    BYTE   byRes[7];                     //保留，设置为0字段
    BYTE   byRuleName[NAME_LEN];        //规则名称
    VCA_EVENT_TYPE dwEventType;            //行为分析事件类型
    NET_VCA_EVENT_UNION uEventParam;    //行为分析事件参数
    NET_VCA_SIZE_FILTER  struSizeFilter;  //尺寸过滤器
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //处理方式 
    BYTE byRelRecordChan[MAX_CHANNUM_V30];            //报警触发的录象通道,为1表示触发该通道
}NET_VCA_ONE_RULE, *LPNET_VCA_ONE_RULE;

typedef struct tagNET_VCA_RULECFG
{
    DWORD  dwSize;            //结构长度
    BYTE   byPicProType;    //报警时图片处理方式 0-不处理 非0-上传
    BYTE   byUpLastAlarm; //2011-04-06 是否先上传最近一次的报警
    BYTE   byPicRecordEnable;  /*2012-3-1是否启用图片存储, 0-不启用, 1-启用*/
    BYTE   byRes;
    NET_DVR_JPEGPARA  struPictureParam;         //图片规格结构
    NET_VCA_ONE_RULE  struRule[MAX_RULE_NUM];  //规则数组
}NET_VCA_RULECFG, *LPNET_VCA_RULECFG;

typedef struct tagNET_VCA_DEV_INFO
{
    NET_DVR_IPADDR  struDevIP; //前端设备地址， 
    WORD wPort;             //前端设备端口号， 
    BYTE byChannel;          //前端设备通道， 
    BYTE byIvmsChannel;        // Ivms 通道 
}NET_VCA_DEV_INFO, *LPNET_VCA_DEV_INFO;

typedef struct tagNET_DVR_TARGET_LEFT_REGION_ALARM
{
    DWORD     dwSize; //结构大小
    DWORD     dwRelativeTime; //相对时标
    DWORD        dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO  struDevInfo;   //前端设备信息
    BYTE     byTargetType;//检测目标类型 0-无效目标，1-教师 2-学生   
    BYTE     byLeftDirection;//检测目标离开方向类型0-保留,1-上,2-下,3-左,4-右
    BYTE     byTargetStatus;//0-保留(不做处理) 
    BYTE     byRes[125];
}NET_DVR_TARGET_LEFT_REGION_ALARM,*LPNET_DVR_TARGET_LEFT_REGION_ALARM;













typedef struct tagNET_VCA_FILTER_STRATEGY
{
    BYTE    byStrategy;      //尺寸过滤策略 0 - 不启用 1-高度和宽度过滤,2-面积过滤
    BYTE    byRes[11];       //保留
}NET_VCA_FILTER_STRATEGY,*LPNET_VCA_FILTER_STRATEGY;

typedef struct tagNET_VCA_RULE_TRIGGER_PARAM
{
    BYTE   byTriggerMode;   //规则的触发方式，0- 不启用，1- 轨迹点 2- 目标面积 
    BYTE   byTriggerPoint;  //触发点，触发方式为轨迹点时有效 0- 中,1-上,2-下
    BYTE   byRes1[2];       //保留
    float  fTriggerArea;    //触发目标面积百分比 [0,100]，触发方式为目标面积时有效
    BYTE   byRes2[4];       //保留
}NET_VCA_RULE_TRIGGER_PARAM,*LPNET_VCA_RULE_TRIGGER_PARAM;

typedef struct tagNET_VCA_ONE_RULE_V41
{
    BYTE   byActive; //是否激活规则,0-否,非0-是
    BYTE   byRes1[4];  //保留，设置为0字段
    BYTE   byEventTypeFlag;  //标志行为事件类型字段的有效性，0-dwEventType有效，1-wEventTypeEx有效
    //注：此字段byEventTypeFlag只在设置参数时有效，从设备获取参数时，可直接从wEventTypeEx获取事件类型，无需判断此字段的值
    WORD   wEventTypeEx; //行为事件类型扩展，用于代替字段dwEventType，参考VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN]; //规则名称
    VCA_EVENT_TYPE dwEventType;    //行为事件类型，保留是为了兼容，后续建议使用wEventTypeEx获取事件类型
    NET_VCA_EVENT_UNION uEventParam; //行为分析事件参数
    NET_VCA_SIZE_FILTER  struSizeFilter;  //尺寸过滤器
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;    //处理方式 
    BYTE   byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道
    WORD   wAlarmDelay; //智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE   byRes2[2]; //保留
    NET_VCA_FILTER_STRATEGY     struFilterStrategy; //尺寸过滤策略
    NET_VCA_RULE_TRIGGER_PARAM  struTriggerParam;   //规则触发参数
    BYTE   byRes[32];
}NET_VCA_ONE_RULE_V41, *LPNET_VCA_ONE_RULE_V41;

typedef struct tagNET_VCA_RULECFG_V41
{
    DWORD  dwSize;            //结构长度
    BYTE    byPicProType;    //报警时图片处理方式 0-不处理 非0-上传
    BYTE    byUpLastAlarm; //2011-04-06 是否先上传最近一次的报警
    BYTE    byPicRecordEnable;  /*2012-3-1是否启用图片存储, 0-不启用, 1-启用*/
    BYTE    byRes1;
    NET_DVR_JPEGPARA struPictureParam;         //图片规格结构
    NET_VCA_ONE_RULE_V41  struRule[MAX_RULE_NUM];  //规则数组
    WORD   wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
    BYTE   byRes[26];
}NET_VCA_RULECFG_V41, *LPNET_VCA_RULECFG_V41;

typedef struct NET_VCA_ONE_RULE_V42_  
{
    BYTE           byActive;       //是否激活规则, 0-否，非0-是
    BYTE        byEventPriority;//事件优先级 0-低，1-中，2-高
    BYTE        byBackgroundSuppression;//背景干扰抑制 0-关闭 1-开启 2-自适应
    BYTE           byRes1[3];           //保留，设置为0字段
    WORD          wEventType;        //行为事件类型，参考VCA_RULE_EVENT_TYPE_EX
    BYTE        byRuleName[NAME_LEN/*32*/];        //规则名称
    NET_VCA_EVENT_UNION  uEventParam;            //行为分析事件参数
    NET_VCA_SIZE_FILTER  struSizeFilter;          //尺寸过滤器
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; /*处理方式*/
    //异常处理方式中报警输出号与组号绑定，即组号为0时，表示关联的报警输出号范围为1-64，当组号为1时，表示关联的报警输出号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的报警出号无效
    DWORD       dwRelRecordChan[MAX_CHANNUM_V30];    /* 报警触发的录象通道（四字节的通道号，初始值是 0xffffffff）*/
    //关联的录像通道号与组号绑定，即组号为0时，表示关联的通道号范围为1-64，当组号为1时，表示关联的通道号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的关联通道号无效
    WORD          wAlarmDelay; //智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    BYTE           byRes2[2];           //保留
    NET_VCA_FILTER_STRATEGY     struFilterStrategy;  //尺寸过滤策略
    NET_VCA_RULE_TRIGGER_PARAM     struTriggerParam; //规则触发参数
    BYTE byRes[32];
}NET_VCA_ONE_RULE_V42, *LPNET_VCA_ONE_RULE_V42;

typedef struct    tagNET_DVR_PTZ_POSITION
{
    // 是否启用场景，在设置场景行为规则的时候该字段无效，在设置球机本地配置场景位置信息时作为使能位
    BYTE byEnable;
    BYTE byRes1[3];  //保留
    BYTE byPtzPositionName[NAME_LEN]; //场景位置名称
    NET_DVR_PTZPOS struPtzPos; //ptz 坐标
    BYTE byRes2[40];
}NET_DVR_PTZ_POSITION, *LPNET_DVR_PTZ_POSITION;

typedef struct tagNET_VCA_RULECFG_V42
{
    DWORD            dwSize;             //结构图大小
    BYTE                byPicProType;            //报警时图片处理方式 0-不处理 1-上传
    BYTE            byUpLastAlarm;         //是否先上传最近一次的报警，0-否，1-是
    BYTE             byPicRecordEnable;   //是否启用图片存储, 0-不启用, 1-启用
    BYTE            byRes1;
    NET_DVR_JPEGPARA     struPicParam;         //图片规格结构
    NET_VCA_ONE_RULE_V42  struRule[MAX_RULE_NUM_V42 /*16*/];       /* 规则数组*/
    WORD            wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
    BYTE            byTrackEnable; //是否启用跟踪
    BYTE            byRes2;
    NET_DVR_PTZ_POSITION  struPTZPosition;  //场景位置信息
    WORD            wTrackDuration; //跟踪持续时间，单位s
    WORD            wIntervalTime; //单次报警间隔时间（秒）[1-7200]（默认为600）
    WORD            wHeightLimit;//目标检测高度下限（厘米）[0-250]（默认为80cm），小于此高度的目标将不作为目标进行检测
    BYTE            byRes[58];//保留
}NET_VCA_RULECFG_V42, *LPNET_VCA_RULECFG_V42;

typedef struct tagNET_VCA_TARGET_INFO
{
    DWORD    dwID;                //目标ID ,人员聚集过高报警时为0
    NET_VCA_RECT struRect;      //目标边界框 
    BYTE      byRes[4];            //保留
}NET_VCA_TARGET_INFO, *LPNET_VCA_TARGET_INFO;

typedef struct tagNET_VCA_RULE_INFO
{
    BYTE   byRuleID;                //规则ID,0-7
    BYTE   bySceneID;                //场景ID,返回0无效
    WORD   wEventTypeEx;            //行为事件类型扩展，用于代替字段dwEventType，参考VCA_RULE_EVENT_TYPE_EX
    BYTE   byRuleName[NAME_LEN];    //规则名称
    VCA_EVENT_TYPE  dwEventType;    //行为事件类型，保留是为了兼容，后续建议使wEventTypeEx获取事件类型
    NET_VCA_EVENT_UNION uEventParam;//事件参数
}NET_VCA_RULE_INFO, *LPNET_VCA_RULE_INFO;

typedef struct  tagNET_VCA_RULE_ALARM
{
    DWORD    dwSize;                        //结构长度
    DWORD    dwRelativeTime;                //相对时标,历史原因，实际没用，本版本用起来当byRelativeTimeFlag为1时，表示为UTC的时间
    DWORD    dwAbsTime;                        //绝对时标,历史原因，这里实际为OSD时间
    NET_VCA_RULE_INFO     struRuleInfo;        //事件规则信息
    NET_VCA_TARGET_INFO  struTargetInfo;    //报警目标信息
    NET_VCA_DEV_INFO       struDevInfo;        //前端设备信息
    DWORD dwPicDataLen;                        //返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据*/
    BYTE       byPicType;        //  0-触发抓拍图片 1-对比图片
    BYTE       byRelAlarmPicNum; //关联通道报警图片数量
    BYTE       bySmart;//IDS设备返回0(默认值)，Smart Functiom Return 1
    BYTE       byPicTransType;        //图片数据传输方式: 0-二进制；1-url
    DWORD      dwAlarmID;     //报警ID，用以标识通道间关联产生的组合报警，0表示无效
    WORD       wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    BYTE       byRelativeTimeFlag;      //dwRelativeTime字段是否有效  0-无效， 1-有效，dwRelativeTime表示UTC时间 
    BYTE       byAppendInfoUploadEnabled; //附加信息上传使能 0-不上传 1-上传
    BYTE       *pAppendInfo;     //指向附加信息NET_VCA_APPEND_INFO的指针，byAppendInfoUploadEnabled为1时或者byTimeDiffFlag为1时有效
    BYTE       *pImage;       //指向图片的指针
}NET_VCA_RULE_ALARM, *LPNET_VCA_RULE_ALARM;

typedef struct tagNET_VCA_APPEND_INFO
{
    DWORD   dwSize;  //结构长度
    DWORD   dwAppendPicLen;//附加图片长度
    BYTE*   pAppendPicBuff;//附加图片指针
    BYTE    byAppendPicType;//附加图片类型：0-保留;1-可见光图片;2-热成像图片;
    BYTE    byUID[64];//设备报警UID
    BYTE    byRes1[3]; //保留
    DWORD   dwTargetSpeed;  //雷达检测到目标速度,单位:km/h
    DWORD   dwTargetDistance;  //雷达检测到目标距离,单位:m/米
    BYTE    byAlarmType;//报警类型 0-视频 1-雷达
    BYTE    byRadarChannel; //雷达通道，从1开始累加
    BYTE    byRes2; //保留
    BYTE    byAppendChannelType;//附加通道类型：0-保留;1-可见光通道;2-热成像通道;
    DWORD   dwAppendChannel; //附加通道通道号
    BYTE    byRes[44]; //保留
}NET_VCA_APPEND_INFO, *LPNET_VCA_APPEND_INFO;

typedef struct tagNET_VCA_DRAW_MODE
{ 
    DWORD  dwSize;
    BYTE    byDspAddTarget;            //编码是否叠加目标
    BYTE    byDspAddRule;            //编码是否叠加规则
    BYTE    byDspPicAddTarget;        //抓图是否叠加目标
    BYTE    byDspPicAddRule;        //抓图是否叠加规则
    BYTE    byRes[4];            
}NET_VCA_DRAW_MODE, *LPNET_VCA_DRAW_MODE;


typedef struct tagNET_DVR_OBJECT_COLOR_COND
{   
    DWORD  dwChannel;   //通道号
    DWORD  dwObjType;   //物体类型，参见OBJECT_TYPE_ENUM
    BYTE   byRes[64];   //保留
}NET_DVR_OBJECT_COLOR_COND,*LPNET_DVR_OBJECT_COLOR_COND;

typedef struct tagNET_DVR_PIC
{
    BYTE   byPicType;        //图片类型，1-jpg
    BYTE   byRes1[3];        //保留
    DWORD  dwPicWidth;       //图片宽度
    DWORD  dwPicHeight;      //图片高度
    DWORD  dwPicDataLen;     //图片数据实际大小
    DWORD  dwPicDataBuffLen; //图片数据缓冲区大小
    BYTE*  byPicDataBuff;    //图片数据缓冲区
    BYTE   byRes2[40];       //保留
}NET_DVR_PIC,*LPNET_DVR_PIC;


typedef struct tagNET_DVR_OBJECT_COLOR
{    
    DWORD  dwSize;       //结构体大小
    BYTE   byEnable;     //0-不启用，1-启用
    BYTE   byColorMode;  //取色方式，1-颜色值，2-图片
    BYTE   byRes1[2];    //保留
    NET_DVR_OBJECT_COLOR_UNION uObjColor; //物体颜色联合体，取值依赖于取色方式
    BYTE   byRes2[64];   //保留
}NET_DVR_OBJECT_COLOR, *LPNET_DVR_OBJECT_COLOR;


typedef struct tagNET_DVR_AUXAREA
{
    DWORD  dwAreaType;   //区域类型，参见AREA_TYPE_ENUM
    BYTE   byEnable;     //0-不启用，1-启用
    BYTE   byRes1[3];     //保留
    NET_VCA_POLYGON struPolygon; //区域
    BYTE   byRes2[16];   //保留
}NET_DVR_AUXAREA,*LPNET_DVR_AUXAREA;

typedef struct tagNET_DVR_AUXAREA_LIST
{
    DWORD     dwSize;    // 结构体大小
    NET_DVR_AUXAREA struArea[MAX_AUXAREA_NUM]; //辅助区域
    BYTE    byRes2[64];    // 保留
}NET_DVR_AUXAREA_LIST,*LPNET_DVR_AUXAREA_LIST;


typedef struct tagNET_DVR_CHANNEL_WORKMODE
{   
    DWORD dwSize;        //结构体大小
    BYTE  byWorkMode;    //工作模式，参见CHAN_WORKMODE_ENUM
    BYTE  byRes[63];     //保留
}NET_DVR_CHANNEL_WORKMODE,*LPNET_DVR_CHANNEL_WORKMODE;

typedef struct tagNET_DVR_CHANNEL
{
    BYTE   byAddress[MAX_DOMAIN_NAME];    //设备IP或域名
    WORD   wDVRPort;                     //端口号
    BYTE   byRes1[2];                   //保留
    BYTE   sUserName[NAME_LEN];            //主机用户名
    BYTE   sPassword[PASSWD_LEN];       //主机密码
    DWORD  dwChannel;                   //通道号
    BYTE   byRes2[32];                  //保留
}NET_DVR_CHANNEL,*LPNET_DVR_CHANNEL;


typedef struct tagNET_DVR_SLAVE_CHANNEL_PARAM
{
    BYTE   byChanType;   //从通道类型，1-本机通道，2-远程通道 
    BYTE   byRes1[3];    //保留
    NET_DVR_SLAVE_CHANNEL_UNION uSlaveChannel; //从通道联合体，取值依赖于byChanType
    BYTE   byRes2[64];   //保留
}NET_DVR_SLAVE_CHANNEL_PARAM,*LPNET_DVR_SLAVE_CHANNEL_PARAM;

typedef struct tagNET_DVR_SLAVE_CHANNEL_CFG
{   
    DWORD dwSize;   //结构体大小
    NET_DVR_SLAVE_CHANNEL_PARAM struChanParam[MAX_SLAVE_CHANNEL_NUM];//从通道参数
    BYTE  byRes[64];  //保留
}NET_DVR_SLAVE_CHANNEL_CFG,*LPNET_DVR_SLAVE_CHANNEL_CFG;


typedef struct tagNET_DVR_VQD_EVENT_COND
{
    DWORD dwChannel;   //通道号
    DWORD dwEventType; //检测事件类型，参见VQD_EVENT_ENUM
    BYTE  byRes[64];   //保留
}NET_DVR_VQD_EVENT_COND,*LPNET_DVR_VQD_EVENT_COND;

typedef struct tagNET_DVR_VQD_EVENT_PARAM
{ 
    BYTE   byThreshold;    //报警阈值，范围[0,100]
    BYTE   byTriggerMode;  //1-持续触发，2-单次触发
    BYTE   byUploadPic;    //0-不上传图片，1-上传图片，无论是否上传图片，事后都可以从设备获取该事件所对应最新的一张报警图片，参见接口NET_DVR_StartDownload
    BYTE   byRes1;         //保留
    DWORD  dwTimeInterval; //持续触发报警时间间隔，范围[0,3600] 单位：秒
    BYTE   byRes2[64];     //保留
}NET_DVR_VQD_EVENT_PARAM,*LPNET_DVR_VQD_EVENT_PARAM;

typedef struct tagNET_DVR_VQD_EVENT_RULE
{   
    DWORD  dwSize;       //结构体大小 
    BYTE   byEnable;     //0-不启用，1-启用
    BYTE   byRes1[3];    //保留
    NET_DVR_VQD_EVENT_PARAM struEventParam; //视频质量诊断事件参数
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//检测时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;  //处理方式
    BYTE   byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //报警触发的录象通道：1表示触发该通道；0表示不触发 
    BYTE   byRes2[128];    //保留
}NET_DVR_VQD_EVENT_RULE,*LPNET_DVR_VQD_EVENT_RULE;

typedef struct tagNET_DVR_BASELINE_SCENE
{   
    DWORD dwSize;     //结构体大小
    BYTE  byEnable;   //0-不启用，1-启用
    BYTE  byRes[63];  //保留
}NET_DVR_BASELINE_SCENE,*LPNET_DVR_BASELINE_SCENE;

typedef struct tagNET_DVR_CONTROL_BASELINE_SCENE_PARAM
{   
    DWORD dwSize;     //结构体大小
    DWORD dwChannel;  //通道号
    BYTE  byCommand;  //操作类型，1-此字段保留，暂不使用，2-更新基准场景
    BYTE  byRes[127];  //保留
}NET_DVR_CONTROL_BASELINE_SCENE_PARAM,*LPNET_DVR_CONTROL_BASELINE_SCENE_PARAM;

typedef struct tagNET_DVR_VQD_ALARM
{   
    DWORD  dwSize;                //结构体大小
    DWORD  dwRelativeTime;        //相对时标
    DWORD  dwAbsTime;              //绝对时标
    NET_VCA_DEV_INFO struDevInfo; //前端设备信息 
    DWORD  dwEventType;           //事件类型，参考VQD_EVENT_ENUM
    float  fThreshold;            //报警阈值[0.000,1.000]
    DWORD  dwPicDataLen;          //图片长度，为0表示没有图片
    BYTE   *pImage;               //指向图片的指针           
    BYTE   byRes[128];            //保留
}NET_DVR_VQD_ALARM,*LPNET_DVR_VQD_ALARM;

typedef struct tagNET_DVR_CB_POINT
{
    NET_VCA_POINT struPoint;     //标定点，主摄像机（枪机）
    NET_DVR_PTZPOS struPtzPos;  //球机输入的PTZ坐标
    BYTE    byRes[8];
}NET_DVR_CB_POINT, LPNET_DVR_CB_POINT;

typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM
{    
    BYTE byPointNum;            //有效标定点个数
    BYTE byRes[3];                
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT]; //标定点组
}NET_DVR_TRACK_CALIBRATION_PARAM, *LPNET_DVR_TRACK_CALIBRATION_PARAM;

typedef struct tagNET_DVR_TRACK_CFG 
{    
    DWORD dwSize;                //结构长度    
    BYTE byEnable;                //标定使能
    BYTE byFollowChan;          // 被控制的从通道
    BYTE byDomeCalibrate;            //设置智能跟踪球机标定，1设置 0不设置 
    BYTE byRes;                    // 保留字节
    NET_DVR_TRACK_CALIBRATION_PARAM  struCalParam; //标定点组
}NET_DVR_TRACK_CFG, *LPNET_DVR_TRACK_CFG ;


typedef struct tagNET_DVR_MANUAL_CTRL_INFO 
{
    NET_VCA_POINT struCtrlPoint;
    BYTE  byRes[8];
}NET_DVR_MANUAL_CTRL_INFO, *LPNET_DVR_MANUAL_CTRL_INFO ;

typedef struct tagNET_DVR_TRACK_MODE
{
    DWORD dwSize;        //结构长度
    BYTE byTrackMode;   //跟踪模式
    BYTE byRuleConfMode;   //规则配置跟踪模式0-本地配置跟踪，1-远程配置跟踪
    BYTE byRes[2];   //保留，置0
    union
    {
        DWORD dwULen[4];
        NET_DVR_MANUAL_CTRL_INFO  struManualCtrl;//手动跟踪结构
    }uModeParam;
}NET_DVR_TRACK_MODE,*LPNET_DVR_TRACK_MODE;

typedef struct tagNET_DVR_ALARM_JPEG
{
    BYTE    byPicProType;        /*报警时图片处理方式 0-不处理 1-上传*/
    BYTE    byRes[3];           //保留字节
    NET_DVR_JPEGPARA struPicParam;                 /*图片规格结构*/
}NET_DVR_ALARM_JPEG, *LPNET_DVR_ALARM_JPEG;

typedef struct tagNET_DVR_PHY_RATIO
{
    DWORD  dwSize;
    DWORD  dwPhysicsRatio;//物理倍率坐标
    BYTE   byRes[60];
}NET_DVR_PHY_RATIO, *LPNET_DVR_PHY_RATIO;

typedef struct tagNET_DVR_SLAVECAMERA_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byID;//主从跟踪 从摄像机ID编号[1,4]
    BYTE             byRes1[3];
    DWORD           dwSceneID;// scene Id 
    BYTE             byRes[56];
}NET_DVR_SLAVECAMERA_COND, *LPNET_DVR_SLAVECAMERA_COND;

typedef struct tagNET_DVR_SLAVECAMERA_CFG
{
    DWORD            dwSize;
    BYTE                 byAddressType;   //0-实际ipv4 ipv6地址 1-域名
    // 控制unionServer是使用实际地址还是域名
    WORD                wPort;            /*端口*/
    BYTE               byLoginStatus; /*从设备的登陆状态 0-logout,1-login*/
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME/*64*/];//服务器地址，域名 
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;/*IP地址*/        //IPv4 IPv6地址, 144字节
        } struAddrIP;
    }unionServer;  //使用联合体结构，通过byAddressType字段表示是IP地址还是域名 64    
    BYTE                szUserName[NAME_LEN/*32*/];        /*用户名*/
    BYTE                szPassWord[PASSWD_LEN/*16*/];        /*密码*/
    BYTE        byRes1[128];
}NET_DVR_SLAVECAMERA_CFG, *LPNET_DVR_SLAVECAMERA_CFG;

typedef struct tagNET_DVR_SLAVECAMERA_PARAM
{
    BYTE             byLinkStatus ;//连接状态 0- 未连接，1-连接
    BYTE             byRes[15];
}NET_DVR_SLAVECAMERA_PARAM, *LPNET_DVR_SLAVECAMERA_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_STATUS
{
    DWORD            dwSize;
    NET_DVR_SLAVECAMERA_PARAM  struSlaveCamera[MAX_SLAVECAMERA_NUM/*8*/];//数组下标0表示从摄像机ID 1,依次类推
    BYTE             byRes[64];
}NET_DVR_SLAVECAMERA_STATUS, *LPNET_DVR_SLAVECAMERA_STATUS;

typedef struct tagNET_PTZ_INFO
{    
    float fPan;
    float fTilt;
    float fZoom;
    DWORD dwFocus;// 聚焦参数，聚焦范围：归一化0-100000
    BYTE  byRes[4];
}NET_PTZ_INFO, *LPNET_PTZ_INFO;

typedef struct tagNET_DVR_BV_CALIB_POSITION
{
    DWORD  dwSize;  //结构长度
    NET_PTZ_INFO struInitialPos;  //初始坐标
    NET_PTZ_INFO struAdjustPos;  //调整坐标
    BYTE  byRes[300]; //保留
}NET_DVR_BV_CALIB_POSITION, *LPNET_DVR_BV_CALIB_POSITION;

typedef struct tagNET_DVR_HUMAN_CALIB_CFG
{
    DWORD  dwSize;  //结构长度
    NET_VCA_POINT struLeftPos;   //人体左坐标点
    NET_VCA_POINT struRightPos;  //人体右坐标点
    BYTE  byRes[300]; //保留
}NET_DVR_HUMAN_CALIB_CFG, *LPNET_DVR_HUMAN_CALIB_CFG;

typedef struct tagNET_DVR_CALIB_PARAM
{
    NET_PTZ_INFO   struPtzInfo;
    NET_VCA_POINT  struCalibCoordinates;//标定坐标
    int                iHorValue;//双目标定 水平值 cm（手动模式下生效 双目相机配置）
    int                iVerValue;//双目标定 垂直值 cm（手动模式下生效 双目相机配置）
    BYTE      byRes[8];
}NET_DVR_CALIB_PARAM, *LPNET_DVR_CALIB_PARAM;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_CFG
{
    DWORD            dwSize;
    BYTE              byCalibMode;//标定模式: 0-保留,1-自动标定, 2-手动标定
    BYTE             byRes[3]; 
    //数组下标0表示从摄像机ID 1，依次类推
    //手动标定模式下支持配置（设置&&获取），自动模式下支持获取操作
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM/*6*/];//只在手动标定模式下生效
    BYTE             byRes1[64];
}NET_DVR_SLAVECAMERA_CALIB_CFG, *LPNET_DVR_SLAVECAMERA_CALIB_CFG;

typedef struct tagNET_DVR_TRACKING
{
    DWORD dwSize;        //结构长度
    BYTE byEnable;      //使能 0-false,1-true
    BYTE byMode;        //模式 0-关闭，1-手动，2-自动
    WORD  wTrackingTime;//跟踪时间：[0,60]s
    NET_VCA_POLYGON struRegion;//手动跟踪目标区域范围
    BYTE byRes[64];
}NET_DVR_TRACKING,*LPNET_DVR_TRACKING;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_V50
{
    DWORD            dwSize;
    BYTE               byCalibMode;//标定模式: 0-保留,1-自动标定, 2-手动标定
    BYTE             byRes[3]; 
    //数组下标0表示从摄像机ID 1，依次类推
    //手动标定模式下支持配置（设置&&获取），自动模式下支持获取操作
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM_EX/*20*/]; 
    BYTE             byRes1[64];
}NET_DVR_SLAVECAMERA_CALIB_V50, *LPNET_DVR_SLAVECAMERA_CALIB_V50;

typedef struct tagNET_DVR_SLAVECAMERA_CALIB_V51
{
    DWORD            dwSize;
    BYTE               byCalibMode;//标定模式: 0-保留,1-自动标定, 2-手动标定
    BYTE             byRes[3];
    //数组下标0表示从摄像机ID 1，依次类推
    //手动标定模式下支持配置（设置&&获取），自动模式下支持获取操作
    NET_DVR_CALIB_PARAM  struCalibParam[MAX_CALIB_NUM_EX/*20*/];
    BYTE            byRes1[512];
}NET_DVR_SLAVECAMERA_CALIB_V51, *LPNET_DVR_SLAVECAMERA_CALIB_V51;


typedef struct tagNET_DVR_GOTOSCENE_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    DWORD            dwSceneID;//场景ID号
    BYTE              byRes[512];
}NET_DVR_GOTOSCENE_COND, *LPNET_DVR_GOTOSCENE_COND;

typedef struct tagNET_DVR_TRACK_INITPOSTION
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byID;//主从跟踪 从摄像机ID编号[1,4]
    BYTE             byRes[127];
}NET_DVR_TRACK_INITPOSTION, *LPNET_DVR_TRACK_INITPOSTION;

typedef struct tagNET_DVR_MANUAL_TRACKRATIO
{
    DWORD            dwSize;
    BYTE             byCoefficient;//倍率系数[1,60]
    BYTE             byRes[127];
}NET_DVR_MANUAL_TRACKRATIO, *LPNET_DVR_MANUAL_TRACKRATIO;

typedef struct tagNET_IVMS_ONE_RULE_
{
    BYTE    byActive;           /* 是否激活规则,0-否, 非0-是 */
    BYTE    byRes1[7];    //保留，设置为0字段
    BYTE   byRuleName[NAME_LEN]; //规则名称
    VCA_EVENT_TYPE dwEventType;   //行为分析事件类型
    NET_VCA_EVENT_UNION uEventParam;//行为分析事件参数
    NET_VCA_SIZE_FILTER  struSizeFilter;  //尺寸过滤器
    BYTE byRes2[68]; /*保留，设置为0*/
}NET_IVMS_ONE_RULE, *LPNET_IVMS_ONE_RULE;

typedef struct tagNET_IVMS_RULECFG
{
    NET_IVMS_ONE_RULE  struRule[MAX_RULE_NUM];   //规则数组
}NET_IVMS_RULECFG, *LPNET_IVMS_RULECFG;

typedef struct tagNET_IVMS_BEHAVIORCFG
{
    DWORD dwSize;
    BYTE    byPicProType;        //报警时图片处理方式 0-不处理 非0-上传
    BYTE    byRes[3];
    NET_DVR_JPEGPARA struPicParam;                 //图片规格结构
    NET_IVMS_RULECFG struRuleCfg[MAX_DAYS][MAX_TIMESEGMENT];//每个时间段对应规则
} NET_IVMS_BEHAVIORCFG, *LPNET_IVMS_BEHAVIORCFG;

typedef struct tagNET_IVMS_DEVSCHED
{
    NET_DVR_SCHEDTIME     struTime;       //时间参数
    NET_DVR_PU_STREAM_CFG struPUStream; //前端取流参数
}NET_IVMS_DEVSCHED, *LPNET_IVMS_DEVSCHED;

typedef struct tagNET_IVMS_STREAMCFG
{
    DWORD dwSize;
    NET_IVMS_DEVSCHED    struDevSched[MAX_DAYS][MAX_TIMESEGMENT];//按时间段配置前端取流以及规则信息
} NET_IVMS_STREAMCFG, *LPNET_IVMS_STREAMCFG;

typedef struct tagNET_VCA_MASK_REGION
{
    BYTE byEnable;            //是否激活, 0-否，非0-是
    BYTE byRes[3];         //保留，置0
    NET_VCA_POLYGON  struPolygon; //屏蔽多边形
}NET_VCA_MASK_REGION, * LPNET_VCA_MASK_REGION;

typedef struct tagNET_VCA_MASK_REGION_LIST
{
    DWORD dwSize;     //结构长度
    BYTE byRes[4];     //保留，置0
    NET_VCA_MASK_REGION  struMask[MAX_MASK_REGION_NUM]; //屏蔽区域数组
}NET_VCA_MASK_REGION_LIST, *LPNET_VCA_MASK_REGION_LIST;

typedef struct tagNET_VCA_ENTER_REGION//防止干扰ATM检测
{
    DWORD dwSize;
    BYTE byEnable;            //是否激活，0-否，非0-是
    BYTE byRes1[3];
    NET_VCA_POLYGON  struPolygon; //进入区域
    BYTE byRes2[16];
}NET_VCA_ENTER_REGION, * LPNET_VCA_ENTER_REGION;

typedef struct tagNET_IVMS_MASK_REGION_LIST
{
    DWORD dwSize;    //结构长度
    NET_VCA_MASK_REGION_LIST struList[MAX_DAYS][ MAX_TIMESEGMENT];
}NET_IVMS_MASK_REGION_LIST, *LPNET_IVMS_MASK_REGION_LIST;

typedef struct tagNET_IVMS_ENTER_REGION
{
    DWORD dwSize;
    NET_VCA_ENTER_REGION  struEnter[MAX_DAYS][ MAX_TIMESEGMENT]; //进入区域
}NET_IVMS_ENTER_REGION, *LPNET_IVMS_ENTER_REGION;

typedef struct tagNET_IVMS_ALARM_JPEG
{
    BYTE                byPicProType;               
    BYTE                byRes[3];
    NET_DVR_JPEGPARA      struPicParam;     
}NET_IVMS_ALARM_JPEG, *LPNET_IVMS_ALARM_JPEG;

typedef struct tagNET_IVMS_SEARCHCFG
{
    DWORD                        dwSize;
    NET_DVR_MATRIX_DEC_REMOTE_PLAY struRemotePlay;// 远程回放
    NET_IVMS_ALARM_JPEG         struAlarmJpeg; // 报警上传图片配置
    NET_IVMS_RULECFG           struRuleCfg;   //IVMS 行为规则配置
}NET_IVMS_SEARCHCFG, *LPNET_IVMS_SEARCHCFG;

typedef struct tagNET_DVR_TRACK_CALIBRATION_PARAM_V41
{    
    BYTE byPointNum;    //有效标定点个数
    BYTE byRes[3];        //保留
    NET_DVR_CB_POINT  struCBPoint[MAX_CALIB_PT]; //标定点组
    NET_DVR_PTZPOS struHorizonPtzPos;  //球机水平线PTZ坐标
    BYTE byRes2[256];    //保留
}NET_DVR_TRACK_CALIBRATION_PARAM_V41, *LPNET_DVR_TRACK_CALIBRATION_PARAM_V41;

typedef struct tagNET_DVR_TRACK_DEV_PARAM_
{    
    DWORD  dwSize;         //结构体大小
    BYTE   byEnable;       //启用此跟踪设备, 0-不启用, 1 -启用
    BYTE   byTransMode;    //通讯方式，0-网络SDK，1-485串口
    BYTE   byRes1[2];       //保留    
    NET_DVR_CHANNEL  struTrackDevChan; //联动跟踪设备参数    
    NET_DVR_TRACK_CALIBRATION_PARAM_V41 struCalParam; //跟踪设备标定参数    
    BYTE    byRes2[256];    //保留    
}NET_DVR_TRACK_DEV_PARAM, *LPNET_DVR_TRACK_DEV_PARAM;

typedef struct tagNET_DVR_IDENTIFICATION_PARAM
{
    BYTE    sUserName[NAME_LEN];        /* 用户名 32*/
    BYTE    sPassword[PASSWD_LEN];        /* 密码 16*/
    BYTE    byRes1[4];    //保留
}NET_DVR_IDENTIFICATION_PARAM, *LPNET_DVR_IDENTIFICATION_PARAM;


typedef struct tagNET_DVR_NAS_MOUNT_PARAM
{
    BYTE  byMountType; //0～保留,1~NFS, 2~ SMB/CIFS
    BYTE  byRes[3];
    NET_DVR_MOUNT_PARAM_UNION uMountParam;
}NET_DVR_NAS_MOUNT_PARAM, *LPNET_DVR_NAS_MOUNT_PARAM;


typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO
{
    BYTE byNetDiskType;                        //网络硬盘类型, 0-NFS(NAS),1-iSCSI
    BYTE byRes1[3];                            //保留
    NET_DVR_IPADDR struNetDiskAddr;            //网络硬盘地址
    BYTE sDirectory[PATHNAME_LEN];            // PATHNAME_LEN = 128
    WORD wPort;                                //iscsi有端口，现在为默认
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE  byRes3[8];                //保留
}NET_DVR_SINGLE_NET_DISK_INFO, *LPNET_DVR_SINGLE_NET_DISK_INFO;

typedef struct tagNET_DVR_NET_DISKCFG 
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG, *LPNET_DVR_NET_DISKCFG;

typedef struct tagNET_DVR_SINGLE_NET_DISK_INFO_V40
{
    BYTE byNetDiskType;                        //网络硬盘类型, 0-NFS(NAS),1-iSCSI
    BYTE byRes1[3];                            //保留
    BYTE sDirectory[PATHNAME_LEN];            // PATHNAME_LEN = 128
    BYTE byDevAddr[MAX_DOMAIN_NAME];    /*域名 64*/
    WORD wPort;                                //iscsi有端口，现在为默认
    BYTE  byRes2[2];
    NET_DVR_MOUNTMETHOD_PARAM_UNION  uMountMethodParam;
    BYTE    byRes4[80];
}NET_DVR_SINGLE_NET_DISK_INFO_V40, *LPNET_DVR_SINGLE_NET_DISK_INFO_V40;

typedef struct tagNET_DVR_NET_DISKCFG_V40 
{
    DWORD  dwSize;
    NET_DVR_SINGLE_NET_DISK_INFO_V40 struNetDiskParam[MAX_NET_DISK];
}NET_DVR_NET_DISKCFG_V40, *LPNET_DVR_NET_DISKCFG_V40;






typedef struct tagNET_DVR_SEARCH_EVENT_PARAM
{
    WORD wMajorType;            //0-移动侦测，1-报警输入, 2-智能事件
    WORD wMinorType;            //搜索次类型- 根据主类型变化，0xffff表示全部
    NET_DVR_TIME struStartTime;    //搜索的开始时间，停止时间: 同时为(0, 0) 表示从最早的时间开始，到最后，最前面的4000个事件
    NET_DVR_TIME struEndTime;    //
    BYTE            byLockType;        // 0xff-全部，0-未锁，1-锁定
    BYTE             byValue;            //0-按位表示，1-按值表示
    BYTE             byRes[130];        // 保留
    union    
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN];          
        struct//报警输入
        {
            BYTE byAlarmInNo[MAX_ALARMIN_V30];    //报警输入号，byAlarmInNo[0]若置1则表示查找由报警输入1触发的事件
            BYTE byRes[SEARCH_EVENT_INFO_LEN - MAX_ALARMIN_V30];
        }struAlarmParam;
        
        struct//报警输入--按值
        {
            WORD wAlarmInNo[128];     /*报警输入号，按值表示,采用紧凑型排列*/
            BYTE byRes[44]; //保留
        }struAlarmParamByValue;
        
        struct//移动侦测
        {
            BYTE byMotDetChanNo[MAX_CHANNUM_V30];//移动侦测通道，byMotDetChanNo[0]若置1则表示查找由通道1发生移动侦测触发的事件
            BYTE byRes[SEARCH_EVENT_INFO_LEN - MAX_CHANNUM_V30];
        }struMotionParam;
        
        struct//移动侦测--按值
        {
            WORD wMotDetChanNo[64];        /* 移动侦测通道，按值表示 ,采用紧凑型排列*/
            BYTE byRes[172];                /*保留*/
        }struMotionParamByValue;
        
        struct//行为分析
        {
            BYTE byChanNo[MAX_CHANNUM_V30];    //触发事件的通道
            BYTE byRuleID;                    //规则ID，0xff表示全部
            BYTE byRes1[43];                //保留
        }struVcaParam;
        
        struct //行为分析--按值方式查找 
        {
            WORD wChanNo[64];     //行为分析对应的通道，按值表示,采用紧凑型排列
            BYTE byRuleID;      //行为分析类型，规则0xff表示全部，从0开始
            BYTE byRes[171];     /*保留*/           
        }struVcaParamByValue;
        
        struct//审讯事件搜索条件
        {            
            BYTE byRoomIndex;    //审讯室编号,按值表示，从1开始
            BYTE byRes1[3];
            BYTE sInquestInfo[INQUEST_CASE_LEN];
            BYTE byRes2[232];     //保留
        } struInquestParam;
        struct  //智能侦测查找条件
        {
            BYTE byChan [256];//触发智能侦测的通道号，按数组下标表示，byChan[0]若置1则表示查找由通道1发生移动侦测触发的事件 
        }struVCADetectByBit;
        
        struct//智能侦测查找条件 ，通道号按值表示
        {
            DWORD dwChanNo[MAX_CHANNUM_V30-1];// 触发通道号,按值表示，0xffffffff无效，且后续数据也表示无效值
            BYTE byAll;//0-表示不是全部，1-表示全部。
            BYTE byres[3];
        }struVCADetectByValue;
        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // 流id信息，72字节长
            DWORD                dwCmdType;  // 外部触发类型，NVR接入云存储使用
            BYTE                byBackupVolumeNum; //存档卷号，CVR使用
            BYTE                byRes[223];
        }struStreamIDParam;
        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];  //案件编号
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN]; //案件名称；
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN]; //当事人1；
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN]; //当事人2；
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];//审判长
            BYTE    byCaseType; //案件类型；0-全部、1-刑事案件、2-民事案件
            BYTE    byRes[47];
        }struTrialParam;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM, *LPNET_DVR_SEARCH_EVENT_PARAM;

typedef struct tagNET_DVR_SEARCH_EVENT_PARAM_V40
{
    WORD wMajorType;            //0-移动侦测，1-报警输入, 2-智能事件 5-pos录像 7-门禁事件
    WORD wMinorType;            //搜索次类型- 根据主类型变化，0xffff表示全部
    NET_DVR_TIME struStartTime;    //搜索的开始时间，停止时间: 同时为(0, 0) 表示从最早的时间开始，到最后，最前面的4000个事件
    NET_DVR_TIME struEndTime;    //
    BYTE            byLockType;        // 0xff-全部，0-未锁，1-锁定
    BYTE            byQuickSearch;        // 是否启用快速查询，0-不启用，1-启用（快速查询不会返回文件大小，仅对设备数据库进行查询，避免频繁唤醒硬盘）
    BYTE             byRes[130];        // 保留
    union    
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN_V40/*800*/];          
        struct//报警输入
        {
            /*报警输入号，按值表示,采用紧凑型排列，0xffff表示后续无效*/
            WORD wAlarmInNo[128];     
            BYTE byRes[544]; //保留
        }struAlarmParam;
        
        struct//移动侦测
        {
            /* 移动侦测通道，按值表示 ,采用紧凑型排列，0xffff表示后续无效*/
            WORD wMotDetChanNo[MAX_CHANNUM_V30];        
            BYTE byRes[672];                /*保留*/
        }struMotionParam;
        
        struct //行为分析 
        {
            //行为分析对应的通道，按值表示,采用紧凑型排列，0xffff表示后续无效
            WORD wChanNo[MAX_CHANNUM_V30];
            BYTE byRuleID;      //行为分析类型，规则0xff表示全部，从0开始
            BYTE     byDriverBehaviortType;  //司机驾驶行为类型：0-保留、1-抽烟、2-接打电话、3-疲劳驾驶、4-分神提醒、5-驾驶员异常、6-未系安全带、7-红外阻断墨镜
            BYTE     byADASType;  //高级辅助驾驶类型：0-保留、1-前向碰撞、2-车道偏离、3-盲区检测、4-车距检测、5-行人防撞、6-急加速、7-急减速、8-急左转弯、9-急右转弯、10-车辆翻车、11-未礼让行人
            BYTE     byGSensorType;  // G-Sensor事件：0-保留、1-急加速、2-急减速、3-急左转弯、4-急右转弯、5-车辆翻车、6-车辆碰撞
            BYTE     bySensorInType;  // Sensor-In行为：0-保留、1-刹车、2-左转、3-右转、4-倒车
            BYTE byRes[667];     /*保留*/
        }struVcaParam;
        
        struct//审讯事件搜索条件
        {            
            BYTE byRoomIndex;    //审讯室编号,从1开始
            BYTE byRes[799];     //保留
        } struInquestParam;
        
        struct//智能侦测查找条件 ，通道号按值表示
        {
            BYTE byAll;                //查找全部通道，0-否，此时dwChanNo参数有效，
            //1-查找全部通道，此时dwChanNo参数无效。
            BYTE byRes1[3];
            WORD wChanNo[MAX_CHANNUM_V30];// 触发通道号,按值表示，0xffff无效，且后续数据也表示无效值
            BYTE byRes[668];
        }struVCADetect;
        
        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // 流id信息，72字节长
            DWORD                dwCmdType;  // 外部触发类型，NVR接入云存储使用
            BYTE                byBackupVolumeNum; //存档卷号，CVR使用
            BYTE                byRes1[3];
            BYTE                byArchiveLabel[64]; //存档标签，CVR使用
            BYTE                byRes[656];
        }struStreamIDParam;
        
        struct //pos录像
        {
            WORD   wChannel[MAX_CHANNUM_V30];        //通道，按值表示,紧凑型排列，遇到0xffff时表示数组后续值无效
            BYTE     byAllChan;        //是否查找全部通道，0-否，此时wChannel有效，1-全部通道，此时wChannel无效
            BYTE      byCaseSensitive;      //0-不区分大小写， 1-区分大小写
            BYTE      byCombinateMode;  //关键字组合方式，0-或，1-与
            BYTE      byRes1;              //保留
            char     sKeyWord[MAX_POS_KEYWORDS_NUM][MAX_POS_KEYWORD_LEN]; 
                                             //关键字查找时的条件
            BYTE    byRes[284];          //保留
        }struPosAlarm;
        
        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];       //案件编号
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN];   //案件名称
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN];   //当事人1
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN];   //当事人2
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];   //审判长
            BYTE    byCaseType;
            BYTE    byRes[47];
        }struTrialParam;

        struct //门禁事件搜索条件
        {
            DWORD dwMajor; //报警主类型（与事件上传主类型一致，0代表全部）
            DWORD dwMinor; //报警次类型（与事件上传主类型一致，0代表全部）
            BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
            BYTE byName[NAME_LEN/*32*/]; //姓名
            BYTE byMACAddr[MACADDR_LEN]; //物理MAC地址
            BYTE byRes[722];
        }struACSAlarm;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM_V40, *LPNET_DVR_SEARCH_EVENT_PARAM_V40;

typedef struct tagNET_DVR_SEARCH_EVENT_PARAM_V50
{
    WORD wMajorType;            //0-移动侦测，1-报警输入, 2-智能事件 5-pos录像 7-门禁事件, 8-非视频联动事件
    WORD wMinorType;            //搜索次类型- 根据主类型变化，0xffff表示全部
    NET_DVR_TIME_SEARCH_COND struStartTime;    //搜索的开始时间，停止时间: 同时为(0, 0) 表示从最早的时间开始，到最后，最前面的4000个事件
    NET_DVR_TIME_SEARCH_COND struEndTime;    //搜索的结束时间
    BYTE            byLockType;        // 0xff-全部，0-未锁，1-锁定
    BYTE            byQuickSearch;        // 是否启用快速查询，0-不启用，1-启用（快速查询不会返回文件大小，仅对设备数据库进行查询，避免频繁唤醒硬盘）
    BYTE             byRes[254];        // 保留
    union
    {
        BYTE byLen[SEARCH_EVENT_INFO_LEN_V40/*800*/];
        struct//报警输入
        {
            /*报警输入号，按值表示,采用紧凑型排列，0xffff表示后续无效*/
            WORD wAlarmInNo[128];
            BYTE byRes[544]; //保留
        }struAlarmParam;

        struct//移动侦测
        {
            /* 移动侦测通道，按值表示 ,采用紧凑型排列，0xffff表示后续无效*/
            WORD wMotDetChanNo[MAX_CHANNUM_V30];
            BYTE byRes[672];                /*保留*/
        }struMotionParam;

        struct //行为分析 
        {
            //行为分析对应的通道，按值表示,采用紧凑型排列，0xffff表示后续无效
            WORD wChanNo[MAX_CHANNUM_V30];
            BYTE byRuleID;      //行为分析类型，规则0xff表示全部，从0开始
            BYTE     byDriverBehaviortType;  //司机驾驶行为类型：0-保留、1-抽烟、2-接打电话、3-疲劳驾驶、4-分神提醒、5-驾驶员异常、6-未系安全带、7-红外阻断墨镜
            BYTE     byADASType;  //高级辅助驾驶类型：0-保留、1-前向碰撞、2-车道偏离、3-盲区检测、4-车距检测、5-行人防撞、6-急加速、7-急减速、8-急左转弯、9-急右转弯、10-车辆翻车、11-未礼让行人
            BYTE     byGSensorType;  // G-Sensor事件：0-保留、1-急加速、2-急减速、3-急左转弯、4-急右转弯、5-车辆翻车、6-车辆碰撞
            BYTE     bySensorInType;  // Sensor-In行为：0-保留、1-刹车、2-左转、3-右转、4-倒车
            BYTE byRes[667];     /*保留*/
        }struVcaParam;

        struct//审讯事件搜索条件
        {
            BYTE byRoomIndex;    //审讯室编号,从1开始
            BYTE byRes[799];     //保留
        } struInquestParam;

        struct//智能侦测查找条件 ，通道号按值表示
        {
            BYTE byAll;                //查找全部通道，0-否，此时dwChanNo参数有效，
            //1-查找全部通道，此时dwChanNo参数无效。
            BYTE byRes1[3];
            WORD wChanNo[MAX_CHANNUM_V30];// 触发通道号,按值表示，0xffff无效，且后续数据也表示无效值
            BYTE byRes[668];
        }struVCADetect;

        struct
        {
            NET_DVR_STREAM_INFO struIDInfo; // 流id信息，72字节长
            DWORD                dwCmdType;  // 外部触发类型，NVR接入云存储使用
            BYTE                byBackupVolumeNum; //存档卷号，CVR使用
            BYTE                byRes1[3];
            BYTE                byArchiveLabel[64]; //存档标签，CVR使用
            BYTE                byRes[656];
        }struStreamIDParam;

        struct //pos录像
        {
            WORD   wChannel[MAX_CHANNUM_V30];        //通道，按值表示,紧凑型排列，遇到0xffff时表示数组后续值无效
            BYTE     byAllChan;        //是否查找全部通道，0-否，此时wChannel有效，1-全部通道，此时wChannel无效
            BYTE      byCaseSensitive;      //0-不区分大小写， 1-区分大小写
            BYTE      byCombinateMode;  //关键字组合方式，0-或，1-与
            BYTE      byRes1;              //保留
            char     sKeyWord[MAX_POS_KEYWORDS_NUM][MAX_POS_KEYWORD_LEN];
            //关键字查找时的条件
            BYTE    byRes[284];          //保留
        }struPosAlarm;

        struct
        {
            BYTE    byCaseNo[SEARCH_CASE_NO_LEN];
            BYTE    byCaseName[SEARCH_CASE_NAME_LEN];
            BYTE    byLitigant1[SEARCH_LITIGANT_LEN];
            BYTE    byLitigant2[SEARCH_LITIGANT_LEN];
            BYTE    byChiefJudge[SEARCH_CHIEF_JUDGE_LEN];
            BYTE    byCaseType;
            BYTE    byRes[547];
        }struTrialParam;

        struct //门禁事件搜索条件
        {
            DWORD dwMajor; //报警主类型（与事件上传主类型一致，0代表全部）
            DWORD dwMinor; //报警次类型（与事件上传主类型一致，0代表全部）
            BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
            BYTE byName[NAME_LEN/*32*/]; //姓名
            BYTE byMACAddr[MACADDR_LEN]; //物理MAC地址
            BYTE byRes[722];
        }struACSAlarm;
        struct //非视频联动事件搜索条件
        {
            WORD      wDeviceType;            //设备类型,0-门禁主机，1-可视对讲设备, 2-报警主机（预留） 3-GJD报警主机 4-Luminite报警主机, 5-OPTEX报警主机,6-cameraDetector模拟相机传感器设备
            WORD      wEventType;            //搜索次类型- 根据主类型变化，0xffff表示全部
            WORD      wChannel[MAX_CHANNUM_V30/*64*/];        //通道号，按值表示,紧凑型排列，遇到0xffff时表示数组后续值无效
            BYTE      byAllChan;        //是否查找全部通道，0-否，此时wChannel有效，1-全部通道，此时wChannel无效
            BYTE      byCaseSensitive;      //0-不区分大小写， 1-区分大小写
            BYTE      byCombinateMode;  //关键字组合方式，0-或，1-与
            BYTE      bySearchType;      //搜索方式：0-按视频源搜索（此时通道号为视频通道号）
            char      sKeyWord[MAX_POS_KEYWORDS_NUM/*3*/][MAX_POS_KEYWORD_LEN/*128*/];//关键字查找时的条件
            WORD      wZoneNo;      //防区号，仅当设备类型为报警主机，次类型为防区（wEventType为1）时有效
            BYTE      byRes[278];   //保留
        }struIOTAlarm;
    }uSeniorParam;
}NET_DVR_SEARCH_EVENT_PARAM_V50, *LPNET_DVR_SEARCH_EVENT_PARAM_V50;

typedef struct tagNET_DVR_SEARCH_EVENT_RET
{
    WORD wMajorType;            //主类型
    WORD wMinorType;            //次类型
    NET_DVR_TIME struStartTime;    //事件开始的时间
    NET_DVR_TIME struEndTime;   //事件停止的时间，脉冲事件时和开始时间一样
    BYTE byChan[MAX_CHANNUM_V30];    
    BYTE byChanEx[32];   //关联通道，按位表示，使用该字段后byChan可以不使用
    BYTE byRes[4];
    union        
    {
        struct//报警输入结果
        {
            DWORD dwAlarmInNo;     //报警输入号
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struAlarmRet;
        struct//移动侦测结果
        {
            DWORD dwMotDetNo;    //移动侦测通道
            BYTE byRes[SEARCH_EVENT_INFO_LEN];
        }struMotionRet;
        struct//行为分析结果  
        {
            DWORD dwChanNo;                    //触发事件的通道号
            BYTE byRuleID;                    //规则ID
            BYTE byRes1[3];                    //保留
            BYTE byRuleName[NAME_LEN];        //规则名称
            NET_VCA_EVENT_UNION uEvent;     //行为事件参数
        }struVcaRet;
        struct//审讯事件
        {
            BYTE  byRoomIndex;     //审讯室编号,从1开始
            BYTE  byDriveIndex;    //刻录机编号,从1开始
            BYTE  byRes1[6];       //保留
            DWORD dwSegmentNo;     //本片断在本次审讯中的序号,从1开始 
            WORD  wSegmetSize;     //本片断的大小, 单位M 
            WORD  wSegmentState;   //本片断状态 0 刻录正常，1 刻录异常，2 不刻录审讯
            BYTE  byRes2[288];     //保留
        }struInquestRet;
        struct //流id录像查询结果
        {
            DWORD dwRecordType;    /*录像类型 0-定时录像,1-移动侦测,2-报警触发,3-报警|移动侦测, 4-报警&移动侦测,5-命令触发,6-手动录像,7-震动报警,8-环境触发报警, 
                                   9-智能报警,10-PIR报警,11-无线报警,12-呼救报警,13- PIR|无线报警|呼救报, 14-智能交通事件,15-越界侦测,16-区域入侵,17-声音异常,
                                   18-场景变更侦测, 19-全部简单智能（越界侦测|区域入侵|进入区域|离开区域|人脸识别）, 20-信号量,21-回传、22-回迁录像,23-遮挡 24-录像拼接存档*/
            DWORD dwRecordLength;    //录像大小
            BYTE  byLockFlag;    // 锁定标志 0：没锁定 1：锁定
            BYTE  byDrawFrameType;    // 0：非抽帧录像 1：抽帧录像
            BYTE  byRes1[2];
            BYTE  byFileName[NAME_LEN];     //文件名
            DWORD dwFileIndex;            // 存档卷上的文件索引
            BYTE  byRes[256];
        }struStreamIDRet;
        struct
        {
            BYTE    byRoomIndex;     //审讯室编号,从1开始
            BYTE    byDriveIndex;    //刻录机编号,从1开始
            WORD    wSegmetSize;     //本片断的大小, 单位M
            DWORD    dwSegmentNo;    //本片断在本次审讯中的序号,从1开始
            BYTE    bySegmentState;   //本片断状态，0-刻录正常，1-刻录异常，2-不刻录审讯
            BYTE    byCaseType; //案件类型；0-全部、1-刑事案件、2-民事案件
            BYTE    byRes[2];
            BYTE    byCaseNo[CASE_NO_RET_LEN];  //案件编号
            BYTE    byCaseName[CASE_NAME_RET_LEN]; //案件名称；
            BYTE    byLitigant1[LITIGANT_RET_LEN]; //当事人1；
            BYTE    byLitigant2[LITIGANT_RET_LEN]; //当事人2；
            BYTE    byChiefJudge[CHIEF_JUDGE_RET_LEN];//审判长
            BYTE    byRes1[104];
        }struTrialRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET, *LPNET_DVR_SEARCH_EVENT_RET;

typedef struct tagNET_DVR_SEARCH_EVENT_RET_V40
{
    WORD wMajorType;            //主类型
    WORD wMinorType;            //次类型
    NET_DVR_TIME struStartTime;    //事件开始的时间
    NET_DVR_TIME struEndTime;   //事件停止的时间，脉冲事件时和开始时间一样
    WORD  wChan[MAX_CHANNUM_V40/*512*/];    //触发的通道号，0xffff表示后续无效
    BYTE byRes[36];
    union        
    {
        BYTE  byLen[800];               //联合体长度
        struct//报警输入结果
        {
            DWORD dwAlarmInNo;     //报警输入号
            BYTE byRes[796];
        }struAlarmRet;
        struct//移动侦测结果
        {
            DWORD dwMotDetNo;    //移动侦测通道
            BYTE byRes[796];
        }struMotionRet;
        struct//行为分析结果  
        {
            DWORD dwChanNo;                    //触发事件的通道号
            BYTE byRuleID;                    //规则ID
            BYTE byRes1[3];                    //保留
            BYTE byRuleName[NAME_LEN];        //规则名称
            NET_VCA_EVENT_UNION uEvent;     //行为事件参数
            BYTE byRes[668];                    //保留
        }struVcaRet;
        
        struct//审讯事件
        {
            BYTE  byRoomIndex;     //审讯室编号,从1开始
            BYTE  byDriveIndex;    //刻录机编号,从1开始
            BYTE  byRes1[6];       //保留
            DWORD dwSegmentNo;     //本片断在本次审讯中的序号,从1开始 
            WORD  wSegmetSize;     //本片断的大小, 单位M 
            WORD  wSegmentState;   //本片断状态 0 刻录正常，1 刻录异常，2 不刻录审讯
            BYTE  byRes2[784];     //保留
        }struInquestRet;
        
        struct //流id录像查询结果
        {
            DWORD dwRecordType;    //录像类型 0-定时录像 1-移动侦测 2-报警录像 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像 7-震动报警 8-环境触发 9-智能报警 10-回传录像
            DWORD dwRecordLength;    //录像大小
            BYTE  byLockFlag;    // 锁定标志 0：没锁定 1：锁定
            BYTE  byDrawFrameType;    // 0：非抽帧录像 1：抽帧录像
            BYTE  byPosition;// 文件所在存储位置：0-阵列上，1-带库机位上，可以直接下载，2-磁带库内，需要把磁盘切换到机位上，3-不在磁带库中，需要把磁盘插到磁带库中
            BYTE  byRes1;
            BYTE  byFileName[NAME_LEN];     //文件名
            DWORD dwFileIndex;            // 存档卷上的文件索引
            BYTE  byTapeIndex[NET_SDK_MAX_TAPE_INDEX_LEN];  //文件所在磁带编号
            BYTE  byFileNameEx[NET_SDK_MAX_FILE_LEN/*256*/]; //文件名扩展
            BYTE  byRes[464];
        }struStreamIDRet;
        
        struct//POS录像查询结果
        {
            DWORD dwChanNo;        //触发产生pos事件的通道
            BYTE  byRes[796];
        }struPosRet;
        
        struct
        {
            BYTE    byRoomIndex;     //审讯室编号,从1开始
            BYTE    byDriveIndex;    //刻录机编号,从1开始
            WORD    wSegmetSize;     //本片断的大小, 单位M
            DWORD    dwSegmentNo;    //本片断在本次审讯中的序号,从1开始
            BYTE    bySegmentState;   //本片断状态，0-刻录正常，1-刻录异常，2-不刻录审讯
            BYTE    byCaseType; //案件类型；0-全部、1-刑事案件、2-民事案件
            BYTE    byRes[2];
            BYTE    byCaseNo[CASE_NO_RET_LEN];  //案件编号
            BYTE    byCaseName[CASE_NAME_RET_LEN]; //案件名称；
            BYTE    byLitigant1[LITIGANT_RET_LEN]; //当事人1；
            BYTE    byLitigant2[LITIGANT_RET_LEN]; //当事人2；
            BYTE    byChiefJudge[CHIEF_JUDGE_RET_LEN];//审判长
            BYTE    byRes1[600];
        }struTrialRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET_V40, *LPNET_DVR_SEARCH_EVENT_RET_V40;

typedef struct tagNET_DVR_SEARCH_EVENT_RET_V50
{
    WORD wMajorType;            //主类型
    WORD wMinorType;            //次类型
    NET_DVR_TIME_SEARCH struStartTime;    //事件开始的时间
    NET_DVR_TIME_SEARCH struEndTime;   //事件停止的时间，脉冲事件时和开始时间一样
    NET_DVR_ADDRESS struAddr;  //片段所在的地址信息，集群回放时用到
    WORD  wChan[MAX_CHANNUM_V40/*512*/];    //触发的通道号，0xffff表示后续无效
    BYTE byRes[256];
    union
    {
        BYTE  byLen[800];               //联合体长度
        struct//报警输入结果
        {
            DWORD dwAlarmInNo;     //报警输入号
            BYTE byRes[796];
        }struAlarmRet;
        struct//移动侦测结果
        {
            DWORD dwMotDetNo;    //移动侦测通道
            BYTE byRes[796];
        }struMotionRet;
        struct//行为分析结果  
        {
            DWORD dwChanNo;                    //触发事件的通道号
            BYTE byRuleID;                    //规则ID
            BYTE byRes1[3];                    //保留
            BYTE byRuleName[NAME_LEN];        //规则名称
            NET_VCA_EVENT_UNION uEvent;     //行为事件参数
            BYTE byRes[668];                    //保留
        }struVcaRet;

        struct//审讯事件
        {
            BYTE  byRoomIndex;     //审讯室编号,从1开始
            BYTE  byDriveIndex;    //刻录机编号,从1开始
            BYTE  byRes1[6];       //保留
            DWORD dwSegmentNo;     //本片断在本次审讯中的序号,从1开始 
            WORD  wSegmetSize;     //本片断的大小, 单位M 
            WORD  wSegmentState;   //本片断状态 0 刻录正常，1 刻录异常，2 不刻录审讯
            BYTE  byRes2[784];     //保留
        }struInquestRet;

        struct //流id录像查询结果
        {
            DWORD dwRecordType;    //录像类型 0-定时录像 1-移动侦测 2-报警录像 3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像 7-震动报警 8-环境触发 9-智能报警 10-回传录像
            DWORD dwRecordLength;    //录像大小
            BYTE  byLockFlag;    // 锁定标志 0：没锁定 1：锁定
            BYTE  byDrawFrameType;    // 0：非抽帧录像 1：抽帧录像
            BYTE  byPosition;// 文件所在存储位置：0-阵列上，1-带库机位上，可以直接下载，2-磁带库内，需要把磁盘切换到机位上，3-不在磁带库中，需要把磁盘插到磁带库中
            BYTE  byRes1;
            BYTE  byFileName[NAME_LEN];     //文件名
            DWORD dwFileIndex;            // 存档卷上的文件索引
            BYTE  byTapeIndex[NET_SDK_MAX_TAPE_INDEX_LEN];  //文件所在磁带编号
            BYTE  byFileNameEx[NET_SDK_MAX_FILE_LEN/*256*/]; //文件名扩展
            BYTE  byRes[464];
        }struStreamIDRet;

        struct//POS录像查询结果
        {
            DWORD dwChanNo;        //触发产生pos事件的通道
            BYTE byRes[796];
        }struPosRet;

        struct
        {
            BYTE    byRoomIndex;     //审讯室编号,从1开始
            BYTE    byDriveIndex;    //刻录机编号,从1开始
            WORD    wSegmetSize;     //本片断的大小, 单位M
            DWORD    dwSegmentNo;    //本片断在本次审讯中的序号,从1开始
            BYTE    bySegmentState;   //本片断状态，0-刻录正常，1-刻录异常，2-不刻录审讯
            BYTE    byCaseType; //案件类型；0-全部、1-刑事案件、2-民事案件
            BYTE    byRes[2];
            BYTE    byCaseNo[CASE_NO_RET_LEN];  //案件编号
            BYTE    byCaseName[CASE_NAME_RET_LEN]; //案件名称；
            BYTE    byLitigant1[LITIGANT_RET_LEN]; //当事人1；
            BYTE    byLitigant2[LITIGANT_RET_LEN]; //当事人2；
            BYTE    byChiefJudge[CHIEF_JUDGE_RET_LEN];//审判长
            BYTE    byRes1[600];
        }struTrialRet;
        struct//非视频通道查询结果
        {
            DWORD dwChanNo;        //触发产生事件的通道号（事件源通道）
            BYTE byRes[796];
        }struIOTRet;
    }uSeniorRet;
}NET_DVR_SEARCH_EVENT_RET_V50, *LPNET_DVR_SEARCH_EVENT_RET_V50;


typedef struct tagNET_DVR_RECT_LIST
{    
    BYTE    byRectNum;    // 矩形框的个数
    BYTE    byRes1[11];  //保留字节 
    NET_VCA_RECT struVcaRect[MAX_RECT_NUM]; // 最大为6个Rect 
}NET_DVR_RECT_LIST, *LPNET_DVR_RECT_LIST;

typedef struct tagNET_DVR_PDC_CALIBRATION
{
    NET_DVR_RECT_LIST struRectList;       // 标定矩形框列表
    BYTE           byRes[120];       // 保留字节 
}NET_DVR_PDC_CALIBRATION, *LPNET_DVR_PDC_CALIBRATION;


typedef struct tagNET_DVR_CAMERA_PARAM
{
    BYTE    byEnableHeight;     // 是否使能设置摄像机高度线
    BYTE    byEnableAngle;      // 是否使能设置摄像机俯仰角度
    BYTE    byEnableHorizon;    // 是否使能设置摄像机地平线
    BYTE    byRes[5];   // 保留字节 
    float   fCameraHeight;    // 摄像机高度
    float   fCameraAngle;     // 摄像机俯仰角度
    float   fHorizon;         // 场景中的地平线
}NET_DVR_CAMERA_PARAM, *LPNET_DVR_CAMERA_PARAM;

typedef struct tagNET_DVR_LINE_SEGMENT
{
    BYTE            byLineMode;     // 参照 LINE_MODE
    BYTE            byRes[3];       // 保留字节 
    NET_VCA_POINT   struStartPoint;  
    NET_VCA_POINT   struEndPoint;
    float           fValue;
}NET_DVR_LINE_SEGMENT, *LPNET_DVR_LINE_SEGMENT;

typedef struct tagNET_DVR_BEHAVIOR_OUT_CALIBRATION
{
    DWORD                   dwLineSegNum;          // 样本线个数
    NET_DVR_LINE_SEGMENT    struLineSegment[MAX_LINE_SEG_NUM];    // 样本线最大个数
    NET_DVR_CAMERA_PARAM    struCameraParam;    // 摄像机参数
    BYTE byRes[20];
}NET_DVR_BEHAVIOR_OUT_CALIBRATION, *LPNET_DVR_BEHAVIOR_OUT_CALIBRATION;

typedef struct tagNET_DVR_IN_CAL_SAMPLE
{
    NET_VCA_RECT struVcaRect;   // 目标框
    NET_DVR_LINE_SEGMENT struLineSegment;    // 高度标定线
}NET_DVR_IN_CAL_SAMPLE, *LPNET_DVR_IN_CAL_SAMPLE;

typedef struct tagNET_DVR_BEHAVIOR_IN_CALIBRATION 
{
    DWORD    dwCalSampleNum;      //  标定样本个数
    NET_DVR_IN_CAL_SAMPLE  struCalSample[MAX_SAMPLE_NUM]; // 标定样本最大个数
    NET_DVR_CAMERA_PARAM    struCameraParam;    // 摄像机参数
    BYTE byRes[16];
}NET_DVR_BEHAVIOR_IN_CALIBRATION, *LPNET_DVR_BEHAVIOR_IN_CALIBRATION;

typedef struct tagNET_DVR_ITS_CALIBRATION
{
    DWORD dwPointNum; //标定点数
    NET_VCA_POINT struPoint[CALIB_PT_NUM]; //图像坐标
    float       fWidth;
    float       fHeight;
    BYTE        byRes1[100];        // 保留字节
}NET_DVR_ITS_CALIBRATION, *LPNET_DVR_ITS_CALIBRATION;

typedef struct tagNET_DVR_BV_DIRECT_CALIBRATION
{   
    DWORD  dwCameraHeight;  //摄像机高度，单位cm
    float  fPitchAngle;     //摄像机俯视角度[0°, 60°],
    float  fInclineAngle;   //摄像机倾斜角度[-20°,20°]
    BYTE   byRes1[228];     //保留
}NET_DVR_BV_DIRECT_CALIBRATION,*LPNET_DVR_BV_DIRECT_CALIBRATION;

typedef struct  tagNET_DVR_PDC_LINE_CALIBRATION
{
    NET_VCA_LINE  struCalibrationLine;
    BYTE       byRes[224];// 保留字节 
} NET_DVR_PDC_LINE_CALIBRATION, *LPNET_DVR_PDC_LINE_CALIBRATION;


typedef struct tagNET_DVR_CALIBRATION_CFG
{
    DWORD   dwSize;               //标定结构大小
    BYTE    byEnable;           // 是否启用标定
    BYTE    byCalibrationType;    // 标定类型 根据不同类型在联合体类选择不同的标定 参考CALIBRATE_TYPE
    BYTE    byRes1[2];
    NET_DVR_CALIBRATION_PRARM_UNION uCalibrateParam;  // 标定参数联合体
    BYTE    byRes2[12];
}NET_DVR_CALIBRATION_CFG, *LPNET_DVR_CALIBRATION_CFG; 

typedef struct  tagNET_DVR_PDC_ENTER_DIRECTION
{
    NET_VCA_POINT struStartPoint; //流量统计方向起始点
    NET_VCA_POINT struEndPoint;    // 流量统计方向结束点 
}NET_DVR_PDC_ENTER_DIRECTION, *LPNET_DVR_PDC_ENTER_DIRECTION;

typedef struct tagNET_DVR_PDC_RULE_CFG
{
    DWORD           dwSize;              //结构大小
    BYTE            byEnable;             // 是否激活规则;
    BYTE            byRes1[23];       // 保留字节 
    NET_VCA_POLYGON          struPolygon;            // 多边形
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;    // 流量进入方向
} NET_DVR_PDC_RULE_CFG, *LPNET_DVR_PDC_RULE_CFG;

typedef struct tagNET_DVR_PDC_RULE_CFG_V41
{
    DWORD           dwSize;              //结构大小
    BYTE            byEnable;             // 是否激活规则;
    BYTE            byRes1[23];       // 保留字节 
    NET_VCA_POLYGON struPolygon;            // 多边形
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection;    // 流量进入方向
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_TIME_EX struDayStartTime; //白天开始时间，时分秒有效
    NET_DVR_TIME_EX struNightStartTime; //夜晚开始时间，时分秒有效
    BYTE            byRes[100];       // 保留字节
}NET_DVR_PDC_RULE_CFG_V41, *LPNET_DVR_PDC_RULE_CFG_V41;

typedef struct tagNET_DVR_PDC_RULE_COND
{
    DWORD  dwSize; //结构大小
    DWORD  dwChannel; //通道号
    DWORD dwID; //场景ID，兼容球机多场景概念，兼容老版本SDK配置新设备时，保留字节为0的情况，所以这个字节为0时，也默认为场景1 
    BYTE  byRes[60]; 
}NET_DVR_PDC_RULE_COND, *LPNET_DVR_PDC_RULE_COND;

typedef struct tagNET_VCA_POLYLINE
{
    NET_VCA_POINT struPoint[4];    //折线点 
}NET_VCA_POLYLINE, *LPNET_VCA_POLYLINE;

typedef struct tagNET_DVR_PDC_RULE_CFG_V42
{
    DWORD  dwSize; //结构大小
    BYTE   byEnable; //是否激活规则;
    BYTE   byOSDEnable;//客流统计OSD显示是否启用,  0-否（0-无），1-是（0-进入和离开）， 2-进入， 3-离开   对于老设备的不启用OSD叠加对应（无），启用对应（进入/离开），4-经过人数，5-进入和经过。
    BYTE   byCurDetectType;//当前检测区域类型，0-多边形，1-检测线, 2-折线检测
    BYTE   byInterferenceSuppression; //干扰抑制，按位表示,0-未勾选,1-勾选，bit0-阴影，bit1-徘徊，bit2-推车
    NET_VCA_POINT   struOSDPoint;//客流统计显示OSD显示左上角坐标
    //客流量检测数据上传周期（0-15、1-1、2-5、3-10、4-20、5-30、6-60）单位：分钟
    BYTE   byDataUploadCycle; 
    //每秒上传机制使能（0-关闭，1-开启）
    BYTE   bySECUploadEnable;
    BYTE   byEmailDayReport;//客流日报表使能 0-关闭，1-开启
    BYTE   byEmailWeekReport;//客流周报表使能 0-关闭，1-开启
    BYTE   byEmailMonthReport;//客流月报表使能0-关闭，1-开启
    BYTE   byEmailYearReport;//客流年报表使能0-关闭，1-开启
    BYTE   byRes2[6];// 保留字节  
    NET_VCA_POLYGON          struPolygon; // 多边形
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection; // 流量进入方向
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_TIME_EX struDayStartTime; //白天开始时间，时分秒有效
    NET_DVR_TIME_EX struNightStartTime; //夜晚开始时间，时分秒有效
    NET_DVR_HANDLEEXCEPTION_V40 struAlarmHandleType; /*处理方式 仅支持上传中心*/
    BYTE   byDetecteSensitivity;//目标检测灵敏度：范围1-100，默认50
    BYTE   byGenerateSpeedSpace;//目标生成速度（空域）：范围1-100，默认50
    BYTE   byGenerateSpeedTime;// 目标生成速度（时域）：范围1-100，默认50
    BYTE   byCountSpeed;// 计数速度：范围1-100，默认50
    BYTE   byDetecteType;// 目标检测类型：0-自动，1-人头，2-头肩，默认0-自动，自动模式下DSP调整算法的参数配置给算法库
    BYTE   byTargetSizeCorrect;//目标尺寸修正：范围1-100，默认50
    BYTE   byStreamOverlayRuleInfos;//码流智能信息叠加 0-否，1-是
    BYTE   byRes3;// 保留字节
    NET_VCA_LINE  struLine;//检测线
    BYTE byHeightFilterEnable;//高度过滤是否开启，0-保留，1-关闭，2-开启
    BYTE  byDetectThreshold;//检测阈值,范围[0,100],默认 90(内部使用，暂不开放)用于设定算法库中被检测目标的置信度阈值，置信度低于该阈值的目标，不用于跟踪计数；
    BYTE  byAidedTrackEnabled;//辅助跟踪开关，0~开启、1~关闭，默认开启(内部使用) 用于开启和关闭算法跟踪模块中的光流辅助跟踪，跟踪客流人员，增加精准度。
    BYTE byRes4;
    float fHeightFilter;//过滤高度，单位：厘米，默认值：120厘米，范围：40-200厘米。byHeightFilterEnable为2是才有效
    BYTE byCalibrateType;//标定类型，0-未进行标定，1-自动标定，2-手动标定
    BYTE byCountingType;//计数触发方式 0-无,1-报警输入触发,2-视频分析触发
    BYTE bySignalType;//信号类型 0-电平，1-脉冲
    BYTE byRS485TransmissionEnabled;//启用485传输 0-关闭，1-开启
    float fTiltAngle;//俯仰角,单位：度；俯仰角默认值：0；俯仰角范围：0-180度,只读
    float fHeelAngle;//倾斜角,单位：度；倾斜角默认值：0；倾斜角范围：-90-90度,只读
    float fHeight;//高度，高度单位：厘米；高度默认值300厘米：高度范围：200-500厘米,当byCalibrateType为2时设置有效，其余时只读
    NET_VCA_POLYGON struCountPolygon;//计数区域：该参数默认为只读属性，若智能通道分析能力中返回了<CountingPolygon>能力节点，则代表该参数支持配置。
    NET_VCA_POLYGON struAutoCalibPolygon;//标定区域，当byCalibrateType为1时有效
    NET_DVR_TIME_EX struDailyResetTime; //定时清零
    NET_VCA_POLYLINE struPolyLine;//折线检测区域（配置折线后，struLine不做显示）
    BYTE   byRes[4]; //保留字节
}NET_DVR_PDC_RULE_CFG_V42, *LPNET_DVR_PDC_RULE_CFG_V42;

typedef struct tagNET_DVR_TRIAL_VERSION_CFG
{
    DWORD dwSize;
    WORD wReserveTime; //试用期剩余时间，0xffff表示无效，单位：天
    BYTE byRes[62];
}NET_DVR_TRIAL_VERSION_CFG, *LPNET_DVR_TRIAL_VERSION_CFG;

typedef struct tagNET_DVR_SYN_CHANNEL_NAME_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  byRes[64]; 
}NET_DVR_SYN_CHANNEL_NAME_PARAM, *LPNET_DVR_SYN_CHANNEL_NAME_PARAM;

typedef struct tagNET_DVR_RESET_COUNTER_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //是否启用，0-不启用，1-启用
    BYTE  byMode; //生效模式，0-定时，1-手动
    BYTE  byRes1[2];
    NET_DVR_TIME_EX struTime[MAX_DAYS];//数据清零时间，时分秒有效
    BYTE  byRes[64]; 
}NET_DVR_RESET_COUNTER_CFG, *LPNET_DVR_RESET_COUNTER_CFG;

typedef struct tagNET_DVR_VCA_CTRLINFO_COND
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO  struStreamInfo;
    BYTE byRes[64];
}NET_DVR_VCA_CTRLINFO_COND, *LPNET_DVR_VCA_CTRLINFO_COND;

typedef struct tagNET_DVR_VCA_CTRLINFO_CFG
{
    DWORD  dwSize;
    BYTE   byVCAEnable;     //是否开启智能
    BYTE   byVCAType;       //智能能力类型，VCA_CHAN_ABILITY_TYPE 
    BYTE   byStreamWithVCA; //码流中是否带智能信息
    BYTE   byMode;            //模式，ATM 能力时参照VCA_CHAN_MODE_TYPE ,TFS 能力时参照 TFS_CHAN_MODE_TYPE，行为分析完整版时参照BEHAVIOR_SCENE_MODE_TYPE
    BYTE   byControlType;   //控制类型，按位表示，0-否，1-是
    //byControlType &1 是否启用抓拍功能
    //byControlType &2 是否启用联动前端设备
    BYTE   byRes1[3];
    WORD   wRelatedChannel[NET_SDK_MAX_RELATED_CHAN_NUM/*4*/];/*关联通道号，0-不关联（当前仅ATM设备使用，当设置通道模式为ATM面板时，可以关联一路ATM人脸通道）*/
    BYTE   byRes[72];       //保留，设置为0
}NET_DVR_VCA_CTRLINFO_CFG, *LPNET_DVR_VCA_CTRLINFO_CFG;


typedef struct tagNET_DVR_PDC_TARGET_INFO
{
    DWORD       dwTargetID;                 // 目标id 
    NET_VCA_RECT struTargetRect;               // 目标框
    BYTE      byRes1[8];        // 保留字节
}NET_DVR_PDC_TARGET_INFO, *LPNET_DVR_PDC_TARGET_INFO;

typedef struct tagNET_DVR_PDC_TARGET_IN_FRAME
{
    BYTE           byTargetNum;                   //目标个数
    BYTE            byRes1[3];
    NET_DVR_PDC_TARGET_INFO  struTargetInfo[MAX_TARGET_NUM];   //目标信息数组
    BYTE    byRes2[8];                  // 保留字节
}NET_DVR_PDC_TARGET_IN_FRAME, *LPNET_DVR_PDC_TARGET_IN_FRAME;

typedef struct tagNET_DVR_PDC_ALRAM_INFO
{
    DWORD                       dwSize;          // PDC人流量报警上传结构体大小
    BYTE                        byMode;          // 0 单帧统计结果 1最小时间段统计结果 2 信号量触发（结果存在“统计起始时间”&&“统计结束时间”） 
    BYTE                        byChannel;       // 报警上传通道号
    /********* IPC5.1.7 新增参数 Begin 2014-03-21***********/
    BYTE                        bySmart;         //专业智能返回0，Smart 返回 1
    BYTE                        byRes1;          // 保留字节    
    /********* IPC5.1.7 新增参数 End 2014-03-21***********/
    NET_VCA_DEV_INFO       struDevInfo;             //前端设备信息
    union        
    {
        struct   // 单帧统计结果时使用
        {
            DWORD   dwRelativeTime;     // 相对时标
            DWORD   dwAbsTime;          // 绝对时标
            BYTE    byTimeDiffFlag;      /*时差字段是否有效  0-时差无效， 1-时差有效 */
            char    cTimeDifferenceH;         /*与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效*/
            char    cTimeDifferenceM;      	/*与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效*/
            BYTE    byRes[89];            
        }struStatFrame;
        struct
        {
            NET_DVR_TIME                      tmStart; // 统计起始时间 
            NET_DVR_TIME                      tmEnd;  //  统计结束时间 
            BYTE	        byTimeDifferenceFlag;   /*0-默认行为，cStartTimeDifferenceH,等时差信息无效，1-时差信息有效*/
            char            cStartTimeDifferenceH;      /*开始时间与UTC的时差（小时），-12 ... +14，+表示东区*/
            char            cStartTimeDifferenceM;      /*开始时间与UTC的时差（分钟），-30, 30, 45，+表示东区*/
            char            cStopTimeDifferenceH;        /*结束时间与UTC的时差（小时），-12 ... +14，+表示东区*/
            char            cStopTimeDifferenceM;       /*结束时间与UTC的时差（分钟），-30, 30, 45，+表示东区*/
            BYTE            byRes[87];
        }struStatTime;
    }uStatModeParam;  // 作为一个联合体 单帧的时候才有帧内目标信息 最小时间段统计结果需要统计时间 参数
    DWORD                       dwLeaveNum;        // 离开人数
    DWORD                       dwEnterNum;        // 进入人数
    BYTE                        byBrokenNetHttp;     //断网续传标志位，0-不是重传数据，1-重传数据
    BYTE                        byRes3;
    WORD                        wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx
    DWORD                       dwPassingNum;        // 经过人数（进入区域后徘徊没有触发进入、离开的人数）
    DWORD                       dwChildLeaveNum;        // 小孩离开人数
    DWORD                       dwChildEnterNum;        // 小孩进入人数
    DWORD                       dwDuplicatePeople;        // 重复人数
    DWORD                       dwXmlLen;//XML透传数据长度, 即EventNotificationAlert XML Block的数据长度
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    char*  pXmlBuf; // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
#else
    char*   pXmlBuf; // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
    BYTE  byRes4[4];
#endif 
    BYTE                        byRes2[8];           // 保留字节
}NET_DVR_PDC_ALRAM_INFO, *LPNET_DVR_PDC_ALRAM_INFO;

typedef struct tagNET_DVR_PDC_QUERY
{
    NET_DVR_TIME tmStart;
    NET_DVR_TIME tmEnd;
    DWORD       dwLeaveNum;
    DWORD       dwEnterNum; 
    BYTE        byRes1[256];
}NET_DVR_PDC_QUERY, *LPNET_DVR_PDC_QUERY;

typedef struct tagNET_DVR_POSITION_RULE_CFG
{
    DWORD                   dwSize;             // 结构大小 
    NET_DVR_PTZ_POSITION    struPtzPosition;    // 场景位置信息
    NET_VCA_RULECFG         struVcaRuleCfg;     //行为规则配置
    BYTE                    byRes2[80];         // 保留字节
}NET_DVR_POSITION_RULE_CFG, *LPNET_DVR_POSITION_RULE_CFG;

typedef struct tagNET_DVR_POSITION_RULE_CFG_V41
{
    DWORD                   dwSize;             // 结构大小 
    NET_DVR_PTZ_POSITION    struPtzPosition;    // 场景位置信息
    NET_VCA_RULECFG_V41         struVcaRuleCfg;     //行为规则配置
    BYTE  byTrackEnable; //是否启用跟踪
    BYTE  byRes1;
    WORD wTrackDuration; //跟踪持续时间，单位s
    BYTE                    byRes2[76];         // 保留字节
}NET_DVR_POSITION_RULE_CFG_V41, *LPNET_DVR_POSITION_RULE_CFG_V41;

typedef struct tagNET_DVR_LIMIT_ANGLE
{
    BYTE                byEnable;    // 是否启用场景限位功能
    BYTE                byRes1[3];
    NET_DVR_PTZPOS      struUp;     // 上限位
    NET_DVR_PTZPOS      struDown;   // 下限位
    NET_DVR_PTZPOS      struLeft;   // 左限位
    NET_DVR_PTZPOS      struRight;  // 右限位
    BYTE                byRes2[20];
}NET_DVR_LIMIT_ANGLE, *LPNET_DVR_LIMIT_ANGLE;

typedef struct tagNET_DVR_POSITION_INDEX
{
    BYTE    byIndex;    // 场景索引
    BYTE    byRes1;
    WORD    wDwell;    // 停留时间 
    BYTE    byRes2[4];   // 保留字节
}NET_DVR_POSITION_INDEX, *LPNET_DVR_POSITION_INDEX;

typedef struct tagNET_DVR_POSITION_TRACK_CFG
{
    DWORD dwSize;
    BYTE    byNum; // 场景个数
    BYTE    byRes1[3];
    NET_DVR_POSITION_INDEX   struPositionIndex[MAX_POSITION_NUM];
    BYTE    byRes2[8];
}NET_DVR_POSITION_TRACK_CFG, *LPNET_DVR_POSITION_TRACK_CFG;

typedef struct tagNET_DVR_PATROL_SCENE_INFO
{
    WORD   wDwell;         // 停留时间 30-300
    BYTE   byPositionID;   // 场景号1-10，默认0表示该巡航点不添加场景
    BYTE   byRes[5];
}NET_DVR_PATROL_SCENE_INFO, *LPNET_DVR_PATROL_SCENE_INFO;

typedef struct tagNET_DVR_PATROL_TRACKCFG
{
    DWORD  dwSize;                                 // 结构大小
    NET_DVR_PATROL_SCENE_INFO struPatrolSceneInfo[10];    // 巡航路径
    BYTE   byRes[16];                              // 保留字节
}NET_DVR_PATROL_TRACKCFG, *LPNET_DVR_PATROL_TRACKCFG;

typedef struct tagNET_DVR_TRACK_PARAMCFG
{
    DWORD   dwSize;             // 结构大小
    WORD    wAlarmDelayTime;    // 报警延时时间，目前球机只支持全局入侵 范围1-120秒
    WORD    wTrackHoldTime;     // 报警跟踪持续时间  范围0-300秒
    BYTE    byTrackMode;        //  参照 IPDOME_TRACK_MODE
    BYTE     byPreDirection;    // 跟踪方向预判 0-不启用 1-启用
    BYTE      byTrackSmooth;        // 跟踪连续  0-不启用 1-启用
    BYTE     byZoomAdjust;    // 倍率系数调整 参见下表
    BYTE    byMaxTrackZoom;    //最大跟踪倍率系数,0-表示默认倍率系数,等级6-标定值*1.0(默认),1-5为缩小标定值，值越小，缩小的比例越大,7-15为放大，值越大，放大的比例越大
    BYTE   byStopTrackWhenFindFace;  //人脸检测到后是否停止跟踪 0-否 1-是
    BYTE   byStopTrackThreshold;   //跟踪终止评分阈值
    BYTE   byRes[9];          //  保留字节                
}NET_DVR_TRACK_PARAMCFG, *LPNET_DVR_TRACK_PARAMCFG;

typedef struct tagNET_DVR_DOME_MOVEMENT_PARAM
{
    WORD wMaxZoom;   // 球机最大倍率系数
    BYTE    byRes[42];  // 保留字节
}NET_DVR_DOME_MOVEMENT_PARAM, *LPNET_DVR_DOME_MOVEMENT_PARAM;





typedef struct tagNET_DVR_REGION_LIST 
{
    DWORD    dwSize;    // 结构体大小
    BYTE    byNum;      // 区域个数
    BYTE    byRes1[3];    // 保留字节
    NET_VCA_POLYGON struPolygon[MAX_REGION_NUM]; // 区域
    BYTE    byRes2[20];    // 保留字节
}NET_DVR_REGION_LIST,*LPNET_DVR_REGION_LIST;

typedef struct tagNET_DVR_DIRECTION
{
    NET_VCA_POINT struStartPoint;   // 方向起始点
    NET_VCA_POINT struEndPoint;     // 方向结束点 
}NET_DVR_DIRECTION, *LPNET_DVR_DIRECTION;

typedef struct tagNET_DVR_ONE_LANE
{
    BYTE    byEnable;                   // 车道是否启用
    BYTE    byRes1[11];                    // 保留字节
    BYTE    byLaneName[NAME_LEN];       // 车道规则名称
    NET_DVR_DIRECTION struFlowDirection;// 车道内车流方向
    NET_VCA_POLYGON struPolygon;        // 车道区域
}NET_DVR_ONE_LANE, *LPNET_DVR_ONE_LANE;

typedef struct tagNET_DVR_LANE_CFG
{
    DWORD    dwSize;    // 结构体大小
    NET_DVR_ONE_LANE struLane[MAX_LANE_NUM];    // 车道参数 数组下标作为车道ID，
    BYTE    byRes1[40];     // 保留字节
}NET_DVR_LANE_CFG, *LPNET_DVR_LANE_CFG;

typedef struct tagNET_DVR_AID_PARAM
{
    WORD    wParkingDuration;       // 违停检测灵敏度  10-120s
    WORD    wPedestrianDuration;    // 行人持续时间    1-120s
    WORD    wDebrisDuration;        // 抛洒物持续时间  10-120s
    WORD    wCongestionLength;      // 拥堵长度阈值    5-200（米）
    WORD    wCongestionDuration;    // 拥堵持续参数    10-120s
    WORD    wInverseDuration;       // 逆行持续时间    1-10s
    WORD    wInverseDistance;       // 逆行距离阈值 单位m 范围[2-100] 默认 10米
    WORD    wInverseAngleTolerance; // 允许角度偏差 90-180度,车流与逆行允许的夹角
    WORD    wIllegalParkingTime;    // 违停时间[4,60]，单位：分钟 ,TFS(交通违章取证) 城市模式下
    WORD    wIllegalParkingPicNum;  // 违停图片数量[1,6], TFS(交通违章取证) 城市模式下
    BYTE    byMergePic;             // 图片拼接,TFS 城市模式下 0- 不拼接 1- 拼接
    BYTE    byRes1[23];             // 保留字节
}NET_DVR_AID_PARAM, *LPNET_DVR_AID_PARAM;

typedef struct tagNET_DVR_ONE_AID_RULE
{   
    BYTE    byEnable;                   // 是否启用事件规则
    BYTE    byRes1[3];                  // 保留字节
    BYTE    byRuleName[NAME_LEN];       // 规则名称 
    DWORD   dwEventType;                // 交通事件检测类型 TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter; // 尺寸过滤器
    NET_VCA_POLYGON     struPolygon;    // 规则区域
    NET_DVR_AID_PARAM   struAIDParam;   //  事件参数
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //处理方式 
    BYTE byRelRecordChan[MAX_CHANNUM_V30];        //报警触发的录象通道,为1表示触发该通道
    BYTE byRes2[20];
}NET_DVR_ONE_AID_RULE, *LPNET_DVR_ONE_AID_RULE;

typedef struct tagNET_DVR_AID_RULECFG
{
    DWORD   dwSize;                    // 结构体大小 
    BYTE    byPicProType;              //报警时图片处理方式 0-不处理 非0-上传
    BYTE    byRes1[3];                 // 保留字节
    NET_DVR_JPEGPARA struPictureParam; //图片规格结构
    NET_DVR_ONE_AID_RULE  struOneAIDRule[MAX_AID_RULE];
    BYTE    byRes2[32];
}NET_DVR_AID_RULECFG, *LPNET_DVR_AID_RULECFG;

typedef struct tagNET_DVR_ONE_AID_RULE_V41
{   
    BYTE                        byEnable;                 // 是否启用事件规则
    BYTE                        byLaneNo;                 // 关联车道号
    BYTE                        byRes1[2];                // 保留字节
    BYTE                        byRuleName[NAME_LEN];     // 规则名称 
    DWORD                       dwEventType;              // 交通事件检测类型 TRAFFIC_AID_TYPE
    NET_VCA_SIZE_FILTER         struSizeFilter;           // 尺寸过滤器
    NET_VCA_POLYGON             struPolygon;              // 规则区域
    NET_DVR_AID_PARAM           struAIDParam;             // 事件参数
    NET_DVR_SCHEDTIME           struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];// 布防时间段
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;              //处理方式 
    BYTE                        byRelRecordChan[MAX_IVMS_IP_CHANNEL]; //报警触发的录象通道：1表示触发该通道；0表示不触发 
    BYTE                        byRes2[60];               //保留
}NET_DVR_ONE_AID_RULE_V41, *LPNET_DVR_ONE_AID_RULE_V41;

typedef struct tagNET_DVR_AID_RULECFG_V41
{
    DWORD   dwSize;                     // 结构体大小 
    BYTE    byPicProType;               // 报警时图片处理方式 0-不处理 非0-上传
    BYTE    byRes1[3];                  // 保留字节
    NET_DVR_JPEGPARA struPictureParam;     // 图片规格结构
    NET_DVR_ONE_AID_RULE_V41  struAIDRule[MAX_AID_RULE];  //规则数组
    BYTE    byRes2[128];                //保留
} NET_DVR_AID_RULECFG_V41, *LPNET_DVR_AID_RULECFG_V41;

typedef struct tagNET_DVR_ONE_TPS_RULE
{
    BYTE    byEnable;                   //是否使能车道交通规则参数
    BYTE    byLaneID;                    //车道ID
    BYTE    byRes1[2];
    DWORD   dwCalcType;                 //统计参数类型ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER struSizeFilter; //尺寸过滤器 
    NET_VCA_POLYGON struVitrualLoop;    //虚拟线圈
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;    //处理方式,一般为处理是否上传中心，其他功能不需要
    BYTE    byRes2[20];                         //保留字节
}NET_DVR_ONE_TPS_RULE, *LPNET_DVR_ONE_TPS_RULE;

typedef struct tagNET_DVR_TPS_RULECFG
{
    DWORD   dwSize;              // 结构大小
    NET_DVR_ONE_TPS_RULE struOneTpsRule[MAX_TPS_RULE]; // 下标对应交通参数ID
    BYTE    byRes2[40];         // 保留字节
}NET_DVR_TPS_RULECFG, *LPNET_DVR_TPS_RULECFG;

typedef struct tagNET_DVR_ONE_TPS_RULE_V41
{
    BYTE    byEnable;                     //是否使能车道交通规则参数
    BYTE    byLaneID;                      //车道ID
    BYTE    byRes1[2];                    //保留
    DWORD   dwCalcType;                   // 统计参数类型ITS_TPS_TYPE
    NET_VCA_SIZE_FILTER  struSizeFilter;  //尺寸过滤器 
    NET_VCA_POLYGON      struVitrualLoop; //虚拟线圈
    NET_DVR_SCHEDTIME    struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;       //处理方式 
    BYTE    byRes2[60];                   // 保留字节
}NET_DVR_ONE_TPS_RULE_V41, *LPNET_DVR_ONE_TPS_RULE_V41;

typedef struct tagNET_DVR_TPS_RULECFG_V41
{
    DWORD   dwSize;         // 结构大小
    NET_DVR_ONE_TPS_RULE_V41 struOneTpsRule[MAX_TPS_RULE]; // 下标对应交通参数ID
    BYTE    byRes[128];     // 保留
}NET_DVR_TPS_RULECFG_V41, *LPNET_DVR_TPS_RULECFG_V41;


typedef struct tagNET_DVR_AID_INFO
{
    BYTE            byRuleID;   // 规则序号，为规则配置结构下标，0-16
    BYTE            byVisibilityLevel; // 能见度等级：0-保留；1-无雾~薄雾；2-薄雾~中雾；3-大雾~浓雾；4-浓雾及以上
    BYTE            byRes1[2];
    BYTE            byRuleName[NAME_LEN]; //  规则名称
    DWORD           dwAIDType;  // 报警事件类型
    NET_DVR_DIRECTION   struDirect; // 报警指向区域  
    BYTE    bySpeedLimit; //限速值，单位km/h[0,255]
    BYTE    byCurrentSpeed; //当前速度值，单位km/h[0,255]
    BYTE    byVehicleEnterState;//车辆出入状态 0-无效 1-驶入 2-驶出
    BYTE            byState; //0-变化上传，1-轮巡上传，2-当前设备定时抓拍的数据上传，实际作用于平台形成图片序列，用于反查算法没有检测到的停车车辆（索引值2在“dwAIDType;//报警事件类型”为 “停车事件”的时候生效）
    BYTE            byParkingID[16]; //停车位编号
    DWORD           dwAIDTypeEx;  // 报警事件类型扩展,参考TRAFFIC_AID_TYPE_EX
    BYTE            byRes2[16];  // 保留字节 
}NET_DVR_AID_INFO, *LPNET_DVR_AID_INFO;

typedef struct tagNET_DVR_AID_ALARM
{
    DWORD               dwSize;         // 结构长度
    DWORD               dwRelativeTime;    // 相对时标
    DWORD               dwAbsTime;        // 绝对时标
    NET_VCA_DEV_INFO      struDevInfo;    // 前端设备信息
    NET_DVR_AID_INFO    struAIDInfo;    // 交通事件信息
    DWORD               dwPicDataLen;   // 返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据
    BYTE                *pImage;        // 指向图片的指针 
    BYTE                byRes[40];      // 保留字节  
}NET_DVR_AID_ALARM, *LPNET_DVR_AID_ALARM;

typedef struct tagNET_DVR_LANE_QUEUE
{
    NET_VCA_POINT   struHead;       //队列头
    NET_VCA_POINT   struTail;       //队列尾
    DWORD           dwLength;      //实际队列长度 单位为米 [0-500]
}NET_DVR_LANE_QUEUE, *LPNET_DVR_LANE_QUEUE; 


typedef struct tagNET_DVR_LANE_PARAM
{
    BYTE    byRuleName[NAME_LEN];  //车道规则名称 
    BYTE    byRuleID;              //规则序号，为规则配置结构下标，0-7 
    BYTE    byVaryType;            //车道交通参数变化类型 参照 TRAFFIC_DATA_VARY_TYPE
    BYTE    byLaneType;               //车道上行或下行
    BYTE    byRes1;
    DWORD    dwLaneVolume;         //车道流量 ，统计有多少车子通过
    DWORD   dwLaneVelocity;        //车道速度，公里计算
    DWORD   dwTimeHeadway;         //车头时距，以秒计算
    DWORD   dwSpaceHeadway;        //车头间距，以米来计算
    float   fSpaceOccupyRation;    //车道占有率，百分比计算（空间上)
    NET_DVR_LANE_QUEUE  struLaneQueue;    //车道队列长度
    NET_VCA_POINT       struRuleLocation; //线圈规则的中心点位置
    BYTE    byRes2[32];
}NET_DVR_LANE_PARAM, *LPNET_DVR_LANE_PARAM;

typedef struct tagNET_DVR_TPS_INFO
{
    DWORD   dwLanNum;   // 交通参数的车道数目
    NET_DVR_LANE_PARAM  struLaneParam[MAX_TPS_RULE];
}NET_DVR_TPS_INFO, *LPNET_DVR_TPS_INFO;

typedef struct tagNET_DVR_TPS_ALARM
{
    DWORD             dwSize;          //结构体大小
    DWORD             dwRelativeTime;  //相对时标
    DWORD             dwAbsTime;       //绝对时标
    NET_VCA_DEV_INFO  struDevInfo;     //前端设备信息
    NET_DVR_TPS_INFO  struTPSInfo;     //交通事件信息
    BYTE              byRes1[32];      //保留字节
}NET_DVR_TPS_ALARM, *LPNET_DVR_TPS_ALARM;


typedef struct tagNET_DVR_LANE_PARAM_V41
{
    BYTE               byRuleName[NAME_LEN]; // 车道规则名称
    BYTE               byRuleID;             // 规则序号，为规则配置结构下标，0-7 
    BYTE               byLaneType;             // 车道上行或下行
    BYTE               byTrafficState;       // 车道的交通状态，0-无效，1-畅通，2-拥挤，3-堵塞
    BYTE               byLaneNo;            //车道号
    DWORD              dwVaryType;           // 车道交通参数变化类型参照  TRAFFIC_DATA_VARY_TYPE_EX_ENUM，按位区分
    DWORD              dwTpsType;            // 数据变化类型标志，表示当前上传的统计参数中，哪些数据有效，参照ITS_TPS_TYPE,按位区分
    DWORD              dwLaneVolume;         // 车道流量，统计有多少车子通过
    DWORD              dwLaneVelocity;       // 车道速度，公里计算
    DWORD              dwTimeHeadway ;       // 车头时距，以秒计算
    DWORD              dwSpaceHeadway;       // 车头间距，以米来计算
    float              fSpaceOccupyRation;   // 车道占有率，百分比计算（空间上)
    float              fTimeOccupyRation;    // 时间占有率，百分比计算
    DWORD              dwLightVehicle;       // 小型车数量
    DWORD              dwMidVehicle;         // 中型车数量
    DWORD              dwHeavyVehicle;       // 重型车数量
    NET_DVR_LANE_QUEUE struLaneQueue;        // 车道队列长度
    NET_VCA_POINT      struRuleLocation;     // 规则位置虚拟线圈的中心
    DWORD               dwOversizeVehicle;    // 大型车数量
    BYTE               byRes2[60];           // 保留
}NET_DVR_LANE_PARAM_V41, *LPNET_DVR_LANE_PARAM_V41;

typedef struct tagNET_DVR_TPS_INFO_V41
{
    DWORD                   dwLanNum;          // 交通参数的车道数目
    NET_DVR_LANE_PARAM_V41  struLaneParam[MAX_TPS_RULE];
    DWORD                   dwSceneID;//场景ID
    BYTE                    byRes[28];         //保留
}NET_DVR_TPS_INFO_V41, *LPNET_DVR_TPS_INFO_V41;

typedef struct tagNET_DVR_FACEDETECT_RULECFG
{
    DWORD          dwSize;              // 结构体大小
    BYTE           byEnable;            // 是否启用
    BYTE           byEventType;            //警戒事件类型， 0-异常人脸; 1-正常人脸;2-异常人脸&正常人脸;4-多张人脸&异常人脸;5-多张人脸&正常人脸; 6-多张人脸&异常人脸&正常人脸; 7-多张人脸 
    BYTE           byUpLastAlarm;       //2011-04-06 是否先上传最近一次的报警
    BYTE           byUpFacePic; //是否上传人脸子图，0-否，1-是    
    BYTE           byRuleName[NAME_LEN];
    NET_VCA_POLYGON     struVcaPolygon;    // 人脸检测规则区域
    BYTE           byPicProType;    //报警时图片处理方式 0-不处理 非0-上传
    BYTE           bySensitivity;   // 规则灵敏度
    WORD            wDuration;      // 触发人脸报警时间阈值
    NET_DVR_JPEGPARA    struPictureParam;         //图片规格结构
    NET_VCA_SIZE_FILTER struSizeFilter;         //尺寸过滤器
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_2];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //处理方式 
    BYTE           byRelRecordChan[MAX_CHANNUM_V30];            //报警触发的录象通道,为1表示触发该通道
    BYTE           byPicRecordEnable;  /*2012-3-1是否启用图片存储, 0-不启用, 1-启用*/
    BYTE           byRes1[3];         //保留字节
    /*
    警戒事件类型：（目前事件类型按位表示，可任意选择其中1种或者几种进行组合）
    0x00: 无效
    0x01: 异常人脸
    0x02: 正常人脸
    0x04: 多张人脸
    0x08: 戴墨镜人脸
    0x10: 打电话人脸
    */
    DWORD          dwEventTypeEx; //dwEventTypeEx字段若为0时，byEventType字段生效。若dwEventTypeEx、byEventType字段都有值时，以dwEventTypeEx字段为准。上层配置dwEventTypeEx字段后，会将值同步到byEventType中。
    BYTE            byRes2[32];         //保留字节
}NET_DVR_FACEDETECT_RULECFG, *LPNET_DVR_FACEDETECT_RULECFG;

typedef struct tagNET_DVR_FACE_PIPCFG
{    
    BYTE byEnable; //是否开启画中画
    BYTE byBackChannel; //背景通道号（面板通道）
    BYTE byPosition; //叠加位置，0-左上,1-左下,2-右上,3-右下
    BYTE byPIPDiv; //分屏系数(人脸画面:面板画面)，0-1:4,1-1:9,2-1:16
    BYTE byRes[4];
}NET_DVR_FACE_PIPCFG, *LPNET_DVR_FACE_PIPCFG;

typedef struct tagNET_DVR_FACEDETECT_RULECFG_V41
{
    DWORD dwSize;              // 结构体大小
    BYTE  byEnable;            // 是否启用
    BYTE  byEventType;            //警戒事件类型， 0-异常人脸; 1-正常人脸;2-异常人脸&正常人脸;4-多张人脸&异常人脸;5-多张人脸&正常人脸; 6-多张人脸&异常人脸&正常人脸; 7-多张人脸 
    BYTE  byUpLastAlarm;       //2011-04-06 是否先上传最近一次的报警
    BYTE  byUpFacePic; //是否上传人脸子图，0-否，1-是    
    BYTE  byRuleName[NAME_LEN];
    NET_VCA_POLYGON struVcaPolygon;    // 人脸检测规则区域
    BYTE  byPicProType;    //报警时图片处理方式 0-不处理 非0-上传
    BYTE  bySensitivity;   // 规则灵敏度
    WORD  wDuration;      // 触发人脸报警时间阈值
    NET_DVR_JPEGPARA    struPictureParam;         //图片规格结构
    NET_VCA_SIZE_FILTER struSizeFilter;         //尺寸过滤器
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//布防时间
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;      //处理方式 
    BYTE  byRelRecordChan[MAX_CHANNUM_V30];            //报警触发的录象通道,为1表示触发该通道
    BYTE  byPicRecordEnable;  /*2012-10-22是否启用图片存储, 0-不启用, 1-启用*/
    BYTE  byRes1;
    WORD  wAlarmDelay; //2012-10-22智能报警延时，0-5s,1-10,2-30s,3-60s,4-120s,5-300s,6-600s
    NET_DVR_FACE_PIPCFG struFacePIP; //2012-11-7画中画参数
    WORD  wRelSnapChan[MAX_REL_SNAPCHAN_NUM]; //关联抓图通道，当主通道报警时，同时会上传关联通道的抓拍图片，0表示不关联，其他值为关联通道号
    BYTE  byRes2[2];         //保留字节
    /*
    警戒事件类型：（目前事件类型按位表示，可任意选择其中1种或者几种进行组合）
    0x00: 无效
    0x01: 异常人脸
    0x02: 正常人脸
    0x04: 多张人脸
    0x08: 戴墨镜人脸
    0x10: 打电话人脸
    */
    DWORD dwEventTypeEx; //dwEventTypeEx字段若为0时，byEventType字段生效。若dwEventTypeEx、byEventType字段都有值时，以dwEventTypeEx字段为准。上层配置dwEventTypeEx字段后，会将值同步到byEventType中。
    BYTE  byRes[16];         //保留字节
}NET_DVR_FACEDETECT_RULECFG_V41, *LPNET_DVR_FACEDETECT_RULECFG_V41;

typedef struct tagNET_DVR_FACEDETECT_ALARM
{
    DWORD   dwSize;         //结构大小
    DWORD     dwRelativeTime; //相对时标
    DWORD    dwAbsTime;        //绝对时标
    BYTE    byRuleName[NAME_LEN];   //规则名称
    NET_VCA_TARGET_INFO  struTargetInfo;//报警目标信息
    NET_VCA_DEV_INFO       struDevInfo;//前端设备信息
    DWORD   dwPicDataLen;    //返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据*/
    BYTE    byAlarmPicType;    // 0-异常人脸报警图片 1- 人脸图片,2-多张人脸, 3-戴墨镜人脸, 4-打电话人脸 
    BYTE    byPanelChan;    /*2012-3-1人脸通道关联的面板通道*/
    BYTE    byRelAlarmPicNum; //关联通道报警图片数量
    BYTE    byRes1;
    DWORD   dwFacePicDataLen;//人脸图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据*/
    DWORD   dwAlarmID;    //报警ID，用以标识通道间关联产生的组合报警，0表示无效
    WORD    wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    BYTE    byRes2[42];   // 保留字节
    BYTE    *pFaceImage; //指向人脸图指针
    BYTE    *pImage;                           //指向图片的指针
}NET_DVR_FACEDETECT_ALARM, *LPNET_DVR_FACEDETECT_ALARM;

typedef struct tagNET_DVR_EVENT_PARAM_UNION
{
    DWORD   uLen[3];            // 联合体大小为12字节
    DWORD  dwHumanIn;      //有无人接近 0 - 无人 1- 有人  
    float       fCrowdDensity;  // 人员聚集值
}NET_DVR_EVENT_PARAM_UNION, *LPNET_DVR_EVENT_PARAM_UNION;

typedef struct tagNET_DVR_EVENT_INFO
{
    BYTE   byRuleID;                // Rule ID
    BYTE   byRes[3];                // 保留字节
    BYTE   byRuleName[NAME_LEN];    // 规则名称
    DWORD       dwEventType;            // 参照VCA_EVENT_TYPE
    NET_DVR_EVENT_PARAM_UNION uEventParam;  // 
}NET_DVR_EVENT_INFO, *LPNET_DVR_EVENT_INFO;

typedef struct tagNET_DVR_EVENT_INFO_LIST
{
    BYTE            byNum;        // 事件实时信息个数
    BYTE            byRes1[3];            // 保留字节
    NET_DVR_EVENT_INFO struEventInfo[MAX_RULE_NUM];    // 事际实时信息
}NET_DVR_EVENT_INFO_LIST,*LPNET_DVR_EVENT_INFO_LIST;

typedef struct tagNET_DVR_RULE_INFO_ALARM
{
    DWORD             dwSize;                // 结构体大小
    DWORD         dwRelativeTime;     // 相对时标
    DWORD        dwAbsTime;            // 绝对时标
    NET_VCA_DEV_INFO      struDevInfo;        // 前端设备信息
    NET_DVR_EVENT_INFO_LIST struEventInfoList;    //事件信息列表
    BYTE            byRes2[40];            // 保留字节
}NET_DVR_RULE_INFO_ALARM, *LPNET_DVR_RULE_INFO_ALARM;

typedef struct tagNET_DVR_ONE_SCENE_TIME
{
    BYTE     byActive;                     //0 -无效,1–有效
    BYTE     byRes1[3];                    //保留
    DWORD    dwSceneID;                    //场景ID
    NET_DVR_SCHEDTIME struEffectiveTime;   //场景起效时间
    BYTE     byRes2[16];                   //保留
}NET_DVR_ONE_SCENE_TIME, *LPNET_DVR_ONE_SCENE_TIME ;

typedef struct tagNET_DVR_SCENE_TIME_CFG
{   
    DWORD  dwSize;                                               //结构大小
    NET_DVR_ONE_SCENE_TIME struSceneTime[MAX_SCENE_TIMESEG_NUM]; //场景时间段数组
    BYTE   byRes[64];                                            //保留
}NET_DVR_SCENE_TIME_CFG, *LPNET_DVR_SCENE_TIME_CFG;

typedef struct  tagNET_DVR_ONE_SCENE_CFG_
{    
    BYTE   byEnable;                 //是否启用该场景,0-不启用 1- 启用
    BYTE   byDirection;              //监测方向 1-上行，2-下行，3-双向，4-由东向西，5-由南向北，6-由西向东，7-由北向南，8-其它
    BYTE   byRes1[2];                //保留
    DWORD  dwSceneID;                //场景ID(只读), 0 - 表示该场景无效
    BYTE   bySceneName[NAME_LEN];    //场景名称
    NET_DVR_PTZPOS struPtzPos;       //ptz 坐标
    DWORD  dwTrackTime;              //球机跟踪时间[5,300] 秒，TFS(交通取证)模式下有效
    BYTE   byRes2[24];               //保留
}NET_DVR_ONE_SCENE_CFG, *LPNET_DVR_ONE_SCENE_CFG;

typedef struct tagNET_DVR_SCENE_CFG
{
    DWORD dwSize;                                          //结构大小
    NET_DVR_ONE_SCENE_CFG struSceneCfg[MAX_ITS_SCENE_NUM]; //场景配置信息
    BYTE   byRes[40];                                      //保留
}NET_DVR_SCENE_CFG,*LPNET_DVR_SCENE_CFG;

typedef struct tagNET_DVR_SCENE_COND
{
    DWORD   dwSize;       //结构大小
    LONG    lChannel;     //通道号
    DWORD   dwSceneID;    //场景ID, 0-表示该场景无效
    BYTE    byRes[48];    //保留
}NET_DVR_SCENE_COND, *LPNET_DVR_SCENE_COND;

typedef struct tagNET_DVR_FORENSICS_MODE
{
    DWORD  dwSize;      //结构大小
    BYTE   byMode;      // 0-手动取证 ,1-自动取证，2-半自动跟踪和静态取证
    BYTE   byRes[23];   //保留
}NET_DVR_FORENSICS_MODE,*LPNET_DVR_FORENSICS_MODE;

typedef struct tagNET_DVR_SCENE_INFO_
{  
    DWORD           dwSceneID;              //场景ID, 0 - 表示该场景无效
    BYTE            bySceneName[NAME_LEN];  //场景名称
    BYTE            byDirection;            //监测方向 1-上行，2-下行，3-双向，4-由东向西，5-由南向北，6-由西向东，7-由北向南，8-其它
    BYTE            byRes1[3];              //保留
    NET_DVR_PTZPOS  struPtzPos;             //Ptz 坐标
    BYTE            byRes2[64] ;            //保留
}NET_DVR_SCENE_INFO,*LPNET_DVR_SCENE_INFO;

typedef struct tagNET_DVR_AID_ALARM_V41
{
    DWORD              dwSize;              //结构长度
    DWORD              dwRelativeTime;        //相对时标
    DWORD              dwAbsTime;            //绝对时标
    NET_VCA_DEV_INFO   struDevInfo;            //前端设备信息
    NET_DVR_AID_INFO   struAIDInfo;         //交通事件信息
    NET_DVR_SCENE_INFO struSceneInfo;       //场景信息
    DWORD              dwPicDataLen;        //图片长度
    BYTE               *pImage;             //指向图片的指针
    // 0-数据直接上传; 1-云存储服务器URL(3.7Ver)原先的图片数据变成URL数据，图片长度变成URL长度
    BYTE               byDataType;
    BYTE               byLaneNo;  //关联车道号 
    WORD               wMilliSecond;        //时标毫秒
    //监测点编号（路口编号、内部编号）
    BYTE               byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE               byDeviceID[DEVICE_ID_LEN/*48*/];//设备编号
    DWORD              dwXmlLen;//XML报警信息长度
    char*              pXmlBuf;// XML报警信息指针,其XML对应到EventNotificationAlert XML Block
    BYTE               byTargetType;// 检测的目标类型，0~未知，1~行人、2~二轮车、3~三轮车(行人检测中返回)
    BYTE               byRuleID;//规则ID,1-4,当congestion事件配置了规则区域时返回
	WORD               wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    BYTE               byBrokenNetHttp; // 断网续传标志位，0-不重传数据，1-重传数据
    BYTE               byRes[3]; // 保留字节   	
    DWORD              dwPlateSmallPicDataLen;      //车牌小图图片长度
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    char*                   pPlateSmallImage;  // //指向车牌小图的指针
#else
    char*                   pPlateSmallImage;   //指向车牌小图的指针
    BYTE                   byRes1[4];
#endif  
}NET_DVR_AID_ALARM_V41, *LPNET_DVR_AID_ALARM_V41;

typedef struct tagNET_DVR_TPS_ALARM_V41
{
    DWORD                 dwSize;          // 结构体大小
    DWORD                 dwRelativeTime;  // 相对时标
    DWORD                 dwAbsTime;       // 绝对时标
    NET_VCA_DEV_INFO      struDevInfo;     // 前端设备信息
    NET_DVR_TPS_INFO_V41  struTPSInfo;     // 交通参数统计信息 
    //监测点编号（路口编号、内部编号）
    BYTE           byMonitoringSiteID[MONITORSITE_ID_LEN/*48*/];
    BYTE           byDeviceID[DEVICE_ID_LEN/*48*/];//设备编号 
    DWORD                dwStartTime;  // 开始统计时间
    DWORD                dwStopTime;    // 结束统计时间
    BYTE                   byRes[24];      // 保留
} NET_DVR_TPS_ALARM_V41,*LPNET_DVR_TPS_ALARM_V41;

typedef struct tagNET_DVR_VCA_VERSION
{
    WORD    wMajorVersion;        // 主版本号
    WORD    wMinorVersion;        // 次版本号
    WORD    wRevisionNumber;    // 修正号
    WORD    wBuildNumber;        // 编译号
    WORD    wVersionYear;        //    版本日期-年
    BYTE    byVersionMonth;        //    版本日期-月
    BYTE    byVersionDay;        //    版本日期-日
    BYTE    byType;/*算法库类型名称，0-保留，1-人脸属性,2-行为分析,3-人体属性,4-人脸抓拍,5人脸识别 6-人脸对比,7-学生站立检测, 
                   8-区域人数统计,9-人脸评分库,10-安全帽检测,11-电梯检测算法库,12-客流量统计,13-(私有目标结构化算法)HMS, 
                   14-教师行为检测, 15-人员密度，16-人数异常，17-离岗检测，18-人员滞留，19-人脸建模抓拍，20-HMS建模,21-态势分析,
                   22-城管算法,23-排队检测*/
    BYTE    byRes[7];            // 保留字节
}NET_DVR_VCA_VERSION, *LPNET_DVR_VCA_VERSION;

typedef struct tagNET_DVR_PLATE_PARAM
{    
    BYTE    byPlateRecoMode;    //车牌识别的模式,默认为1(视频触发模式)
    BYTE    byBelive;            //整牌置信度阈值, 只用于视频识别方式, 根据背景复杂程度设置, 误触发率高就设高, 漏车率高就设低, 建议在80-90范围内
    BYTE    byRes[22];          //保留字节
}NET_DVR_PALTE_PARAM, *LPNET_DVR_PALTE_PARAM;

typedef struct tagNET_DVR_PLATECFG
{    
    DWORD        dwSize;
    DWORD    dwEnable;                           /* 是否启用视频车牌识别 0－否 1－是 */
    BYTE    byPicProType;    //报警时图片处理方式 0-不处理 非0-上传
    BYTE    byRes1[3];  // 保留字节
    NET_DVR_JPEGPARA struPictureParam;         //图片规格结构
    NET_DVR_PALTE_PARAM struPlateParam;   // 车牌识别参数配置
    NET_DVR_HANDLEEXCEPTION struHandleType;       /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];//布防时间
    BYTE    byRelRecordChan[MAX_CHANNUM];        //报警触发的录象通道,为1表示触发该通道
    BYTE   byRes[20];   // 保留字节
}NET_DVR_PLATECFG, *LPNET_DVR_PLATECFG;

typedef struct tagNET_DVR_PLATE_INFO
{
    BYTE  byPlateType;                    //车牌类型
    BYTE  byColor;                        //车牌颜色
    BYTE  byBright;                        //车牌亮度
    BYTE  byLicenseLen;                    //车牌字符个数
    BYTE  byEntireBelieve;                //整个车牌的置信度，-100
    BYTE  byRegion;                       // 区域索引值 0-保留，1-欧洲(EU)，2-俄语区域(ER)，3-欧洲&俄罗斯(EU&CIS) ,4-中东(ME),5-亚太(APAC),6-非美(非洲和美洲,AfandAM),0xff-所有
    BYTE  byCountry;                      // 国家索引值，参照枚举COUNTRY_INDEX（不支持"COUNTRY_ALL = 0xff, //ALL  全部"）
    BYTE  byArea;                         //区域（省份），各国家内部区域枚举，阿联酋参照 EMI_AREA
    BYTE  byPlateSize;                    //车牌尺寸，0~未知，1~long, 2~short(中东车牌使用)
    /*附加信息标识（即是否有NET_DVR_VEHICLE_ADDINFO结构体）,0-无附加信息, 1-有附加信息。*/
    BYTE  byAddInfoFlag;
    //该字段是在byCountry索引基础上，扩展了区域索引，之后使用该字段代替byCountry，优先使用wCRIndex字段
    //为了兼容老用户，如果该字段值大于256（即新增区域），则byCountry赋值为0xfd（国家字段无效）。
    WORD  wCRIndex ;//国家/地区索引，索引值参考_CR_ INDEX_
    BYTE  byRes[4];	             //保留
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    BYTE*  pAddInfoBuffer;
#else
    /*附加信息指针,指向NET_DVR_VEHICLE_ADDINFO结构体*/
    BYTE*   pAddInfoBuffer;
    BYTE  byRes2[4];
#endif 
    char  sPlateCategory[MAX_CATEGORY_LEN/*8*/];//车牌附加信息, 即中东车牌中车牌号码旁边的小字信息，(目前只有中东地区支持)
    DWORD dwXmlLen;                        //XML报警信息长度
    char* pXmlBuf;                      // XML报警信息指针,报警类型为 COMM_ITS_PLATE_RESUL时有效，其XML对应到EventNotificationAlert XML Block
    NET_VCA_RECT    struPlateRect;        //车牌位置
    char sLicense[MAX_LICENSE_LEN];        //车牌号码,注：中东车牌需求把小字也纳入车牌号码，小字和车牌号中间用空格分隔
    BYTE byBelieve[MAX_LICENSE_LEN];    //各个识别字符的置信度，如检测到车牌"浙A12345", 置信度为,20,30,40,50,60,70，则表示"浙"字正确的可能性只有%，"A"字的正确的可能性是%
}NET_DVR_PLATE_INFO, *LPNET_DVR_PLATE_INFO;

typedef struct tagNET_DVR_PLATERECO_RESULE
{
    DWORD dwSize;
    DWORD    dwRelativeTime;                //相对时标
    DWORD    dwAbsTime;                        //绝对时标
    NET_VCA_DEV_INFO struDevInfo;           // 前段设备信息
    NET_DVR_PLATE_INFO struPlateInfo;
    DWORD dwPicDataLen;                        //返回图片的长度 为0表示没有图片，大于0表示该结构后面紧跟图片数据*/
    DWORD dwRes[4];                            //保留，设置为0
    BYTE  *pImage;                           //指向图片的指针
}NET_DVR_PLATERECO_RESULE, *LPNET_DVR_PLATERECO_RESULE;

typedef struct 
{
    NET_DVR_TIME strLogTime;
    DWORD    dwMajorType;    //Main type 1-alarm; 2-abnormal; 3-operation; 0xff-all 
    DWORD    dwMinorType;    //Hypo-Type 0-all;
    BYTE    sPanelUser[MAX_NAMELEN]; //user ID for local panel operation
    BYTE    sNetUser[MAX_NAMELEN];//user ID for network operation
    NET_DVR_IPADDR    struRemoteHostAddr;//remote host IP
    DWORD    dwParaType;//parameter type
    DWORD    dwChannel;//channel number
    DWORD    dwDiskNumber;//HD number
    DWORD    dwAlarmInPort;//alarm input port
    DWORD    dwAlarmOutPort;//alarm output port
    DWORD   dwInfoLen;
    BYTE    byDevSequence;//槽位号
    BYTE    byMacAddr[MACADDR_LEN];//MAC地址,6
    BYTE    sSerialNumber[SERIALNO_LEN];//序列号，48
    char    sInfo[LOG_INFO_LEN - SERIALNO_LEN - MACADDR_LEN - 1 ];
}NET_DVR_LOG_MATRIX, *LPNET_DVR_LOG_MATRIX;

typedef struct tagVEDIOPLATLOG
{
    BYTE bySearchCondition;//搜索条件，0-按槽位号搜索，1-按序列号搜索，2-按MAC地址进行搜索
    //槽位号，0-79：对应子系统的槽位号；
    //0xff：表示搜索所有的日志，包括78K和所有6467；
    //0xfe：表示搜索78K上的日志；0xfd：子域日志；0xfc：域日志。。
    BYTE byDevSequence;
    BYTE  sSerialNumber[SERIALNO_LEN];//序列号，48
    BYTE  byMacAddr[MACADDR_LEN];//MAC地址,6
} NET_DVR_VEDIOPLATLOG, *LPNET_DVR_VEDIOPLATLOG;

typedef struct tagNET_DVR_CODESYSTEMABILITY
{
    DWORD dwSize;
    DWORD dwAbilityVersion;//能力集版本号，高16位表示主版本，低16位表示次版本 
    DWORD dwSupportMaxVideoFrameRate;//单位(K)
                                     /*按位:
                                     0:定时录像；
                                     1:定时|事件触发录像 
                                     2:移动侦测录像；
                                     3:网络开关量报警录像；
                                     4:移动侦测|网络开关量报警录像；
                                     5:移动侦测&网络开关量报警录像；
                                     6:周界防范触发录像；
                                     7:人脸检测触发录像；
                                     8:车牌识别触发录像；
    9:手动录像*/
    DWORD dwSupportRecordType;
    BYTE  bySupportLinkMode;//按位:第0位:表示主码流，第1位:表示子码流
    BYTE  bySupportStringRow;//支持字符叠加行数
    BYTE  bySupportHideNum;//支持视频遮挡数量
    BYTE  byRes1;
    /*0-DCIF，1-CIF，2-QCIF，3-4CIF，4-2CIF，6-QVGA(320*240), 16-VGA，17-UXGA，18-SVGA，19-HD720p，20-XVGA，21-HD900p，22-SXGAp，27-HD1080i，28-2560*1920，29-1600*304，30-2048*1536，31-2448*2048，32-2448*1200，33-2448*800 ，34-XGA（1024x768），35-SXGA（1280x1024）*/
    BYTE  byMainStreamSupportResolution[8];//主码流支持的分辨率，按位
    BYTE  bySubStreamSupportResolution[8];//子码流支持的分辨率，按位
    BYTE  byEventStreamSupportResolution[8];//事件触发码流支持的分辨率，按位
    BYTE  byNotSupportPreview;//是否支持预览,1-不支持，0-支持
    BYTE  byNotSupportStorage;//是否支持存储,1-不支持，0-支持
    BYTE  byRes2[98];//保留        
}NET_DVR_CODESYSTEMABILITY, *LPNET_DVR_CODESYSTEMABILITY;

typedef struct tagNET_DVR_IO_INCFG
{
    DWORD   dwSize;
    BYTE    byIoInStatus;//输入的IO口状态，0-下降沿，1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    BYTE    byRes[3];//保留字节
}NET_DVR_IO_INCFG, *LPNET_DVR_IO_INCFG;

typedef struct tagNET_DVR_IO_OUTCFG
{
    DWORD   dwSize;
    BYTE    byDefaultStatus;//IO默认状态：0-低电平，1-高电平 
    BYTE    byIoOutStatus;//IO起效时状态：0-低电平，1-高电平，2-脉冲
    WORD    wAheadTime;//输出IO提前时间，单位us
    DWORD   dwTimePluse;//脉冲间隔时间，单位us
    DWORD   dwTimeDelay;//IO有效持续时间，单位us
    BYTE    byFreqMulti;        //倍频，数值范围[1,15]
    BYTE    byDutyRate;        //占空比，[0,40%]
    BYTE    byRes[2];
}NET_DVR_IO_OUTCFG, *LPNET_DVR_IO_OUTCFG;

typedef struct tagNET_DVR_FLASH_OUTCFG
{
    DWORD  dwSize;
    BYTE   byMode;//闪光灯闪烁模式，0-不闪，1-闪，2-关联闪，3-轮闪
    BYTE   byRelatedIoIn;//闪光灯关联的输入IO号（关联闪时此参数有效）
    BYTE   byRecognizedLane;  /*关联的IO号，按位表示，bit0表示IO1是否关联，0-不关联，1-关联*/
    BYTE   byDetectBrightness;/*自动检测亮度使能闪光灯0-不检测；1-检测*/
    BYTE   byBrightnessThreld;/*使能闪光灯亮度阈值，范围[0,100],高于阈值闪*/
    BYTE   byStartHour;        //开始时间-小时,取值范围0-23
    BYTE   byStartMinute;        //开始时间-分,取值范围0-59
    BYTE   byEndHour;             //结束时间-小时,取值范围0-23
    BYTE   byEndMinute;        //结束时间-分,取值范围0-59
    BYTE   byFlashLightEnable;    //设置闪光灯时间使能:0-关;1-开
    BYTE   byRes[2];
}NET_DVR_FLASH_OUTCFG, *LPNET_DVR_FLASH_OUTCFG;

typedef struct tagNET_DVR_LIGHTSNAPCFG
{
    DWORD   dwSize;
    BYTE    byLightIoIn;//红绿灯的IO 号
    BYTE    byTrigIoIn;//触发的IO号
    BYTE    byRelatedDriveWay;//触发IO关联的车道号
    BYTE    byTrafficLight; //0-高电平红灯，低电平绿灯；1-高电平绿灯，低电平红灯
    BYTE     bySnapTimes1; //红灯抓拍次数1，0-不抓拍，非0-连拍次数，最大5次 
    BYTE     bySnapTimes2; //绿灯抓拍次数2，0-不抓拍，非0-连拍次数，最大5次 
    BYTE    byRes1[2];
    WORD    wIntervalTime1[MAX_INTERVAL_NUM];//红灯连拍间隔时间，ms
    WORD    wIntervalTime2[MAX_INTERVAL_NUM];//绿灯连拍间隔时间，ms
    BYTE    byRecord;//闯红灯周期录像标志，0-不录像，1-录像
    BYTE    bySessionTimeout;//闯红灯周期录像超时时间（秒）
    BYTE    byPreRecordTime;//闯红灯录像片段预录时间(秒)
    BYTE    byVideoDelay;//闯红灯录像片段延时时间（秒）
    BYTE    byRes2[32];//保留字节
}NET_DVR_LIGHTSNAPCFG, *LPNET_DVR_LIGHTSNAPCFG;

typedef struct tagNET_DVR_MEASURESPEEDCFG
{
    DWORD   dwSize;
    BYTE    byTrigIo1;   //测速第1线圈
    BYTE    byTrigIo2;   //测速第2线圈
    BYTE    byRelatedDriveWay;//触发IO关联的车道号
    BYTE    byTestSpeedTimeOut;//测速模式超时时间，单位s
    DWORD   dwDistance;//线圈距离,cm
    BYTE    byCapSpeed;//测速模式起拍速度，单位km/h
    BYTE    bySpeedLimit;//限速值，单位km/h
    BYTE     bySnapTimes1; //线圈1抓拍次数，0-不抓拍，非0-连拍次数，最大5次 
    BYTE     bySnapTimes2; //线圈2抓拍次数，0-不抓拍，非0-连拍次数，最大5次 
    WORD    wIntervalTime1[MAX_INTERVAL_NUM];//线圈1连拍间隔时间，ms
    WORD    wIntervalTime2[MAX_INTERVAL_NUM];//线圈2连拍间隔时间，ms
    BYTE    byRes[32];//保留字节
}NET_DVR_MEASURESPEEDCFG, *LPNET_DVR_MEASURESPEEDCFG;

typedef struct tagNET_DVR_CLOUDSTORAGE_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE    byRes1[64];
}NET_DVR_CLOUDSTORAGE_COND,*LPNET_DVR_CLOUDSTORAGE_COND;

typedef struct tagNET_DVR_POOLPARAM
{
    DWORD  dwPoolID;// 云存储分配节点号
    BYTE    byRes[4];
}NET_DVR_POOLPARAM,*LPNET_DVR_POOLPARAM;

typedef struct tagNET_DVR_CLOUDSTORAGE_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;//0-不开启，1-开启
    BYTE    byRes[3];
    NET_DVR_IPADDR  struIP;
    WORD    wPort;//数据端口
    BYTE    byRes1[2];
    char    szUser[CLOUD_NAME_LEN/*48*/]; //用户名
    char    szPassword[CLOUD_PASSWD_LEN/*48*/];     // 密码
    NET_DVR_POOLPARAM  struPoolInfo[16];//数组0表示卡口录像池，数组1表示违章录像池，数组2表示车辆侦测数据池（IPC/D）
    BYTE    byRes2[128];
}NET_DVR_CLOUDSTORAGE_CFG,*LPNET_DVR_CLOUDSTORAGE_CFG;



typedef struct tagNET_DVR_VIDEOEFFECT
{
    BYTE byBrightnessLevel; /*0-100*/
    BYTE byContrastLevel; /*0-100*/
    BYTE bySharpnessLevel; /*0-100*/
    BYTE bySaturationLevel; /*0-100*/
    BYTE byHueLevel; /*0-100,（保留）*/
    BYTE byEnableFunc; //使能，按位表示，bit0-SMART IR(防过曝)，bit1-低照度,bit2-强光抑制使能，0-否，1-是
    BYTE byLightInhibitLevel; //强光抑制等级，[1-3]表示等级
    BYTE byGrayLevel; //灰度值域，0-[0-255]，1-[16-235]
}NET_DVR_VIDEOEFFECT, *LPNET_DVR_VIDEOEFFECT;

typedef struct tagNET_DVR_GAIN
{
    BYTE byGainLevel; /*增益：0-100*/
    BYTE byGainUserSet; /*用户自定义增益；0-100，对于抓拍机，是CCD模式下的抓拍增益*/
    BYTE byRes[2];
    DWORD dwMaxGainValue;/*最大增益值，单位dB*/
}NET_DVR_GAIN, *LPNET_DVR_GAIN;

typedef struct tagNET_DVR_WHITEBALANCE
{
BYTE byWhiteBalanceMode; /*0-手动白平衡（MWB）,1-自动白平衡1（AWB1）,2-自动白平衡2 (AWB2),3-自动控制改名为锁定白平衡(Locked WB)，
                         4-室外(Indoor)，5-室内(Outdoor)6-日光灯(Fluorescent Lamp)，7-钠灯(Sodium Lamp)，
                         8-自动跟踪(Auto-Track)9-一次白平衡(One Push)，10-室外自动(Auto-Outdoor)，
                         11-钠灯自动 (Auto-Sodiumlight)，12-水银灯(Mercury Lamp)，13-自动白平衡(Auto)，
14-白炽灯 (IncandescentLamp)，15-暖光灯(Warm Light Lamp)，16-自然光(Natural Light) */
BYTE byWhiteBalanceModeRGain; /*手动白平衡时有效，手动白平衡 R增益*/
BYTE byWhiteBalanceModeBGain; /*手动白平衡时有效，手动白平衡 B增益*/
BYTE byRes[5];
}NET_DVR_WHITEBALANCE, *LPNET_DVR_WHITEBALANCE;

typedef struct tagNET_DVR_EXPOSURE
{
    BYTE  byExposureMode; /*0 手动曝光 1自动曝光*/
    BYTE  byAutoApertureLevel; /* 自动光圈灵敏度, 0-10 */ 
    BYTE  byRes[2];
    DWORD dwVideoExposureSet; /* 自定义视频曝光时间（单位us）*//*注:自动曝光时该值为曝光最慢值 新增20-1s(1000000us)*/        
    DWORD dwExposureUserSet; /* 自定义曝光时间,在抓拍机上应用时，CCD模式时是抓拍快门速度*/   
    DWORD dwRes;    
} NET_DVR_EXPOSURE, *LPNET_DVR_EXPOSURE;

typedef struct tagNET_DVR_WDR
{
    BYTE byWDREnabled; /*宽动态：0 dsibale  1 enable 2 auto*/
    BYTE byWDRLevel1; /*0-F*/
    BYTE byWDRLevel2; /*0-F*/
    BYTE byWDRContrastLevel; /*0-100*/
    BYTE byRes[16];
} NET_DVR_WDR, *LPNET_DVR_WDR;

typedef struct tagNET_DVR_WDR_CFG
{
    DWORD  dwSize;   //结构体大小
    NET_DVR_WDR  struWDR; //配置信息
}NET_DVR_WDR_CFG, *LPNET_DVR_WDR_CFG;

typedef struct tagNET_DVR_DAYNIGHT
{
    BYTE byDayNightFilterType; /*日夜切换：0-白天，1-夜晚，2-自动，3-定时，4-报警输入触发, 5-自动模式2（无光敏）,6-黑光，7-黑光自动，8-黑光定时*/
    BYTE bySwitchScheduleEnabled; /*0 dsibale  1 enable,(保留)*/
    //定时模式参数
    BYTE byBeginTime; /*开始时间（小时），0-23*/
    BYTE byEndTime; /*结束时间（小时），0-23*/
    //模式2
    BYTE byDayToNightFilterLevel; //0-7
    BYTE byNightToDayFilterLevel; //0-7
    BYTE byDayNightFilterTime;//(60秒)
    //定时模式参数
    BYTE byBeginTimeMin; //开始时间（分），0-59
    BYTE byBeginTimeSec; //开始时间（秒），0-59
    BYTE byEndTimeMin; //结束时间（分），0-59
    BYTE byEndTimeSec; //结束时间（秒），0-59
    //报警输入触发模式参数
    BYTE byAlarmTrigState; //报警输入触发状态，0-白天，1-夜晚
} NET_DVR_DAYNIGHT, *LPNET_DVR_DAYNIGHT;

typedef struct tagNET_DVR_GAMMACORRECT
{
    BYTE byGammaCorrectionEnabled; /*0 dsibale  1 enable*/
    BYTE byGammaCorrectionLevel; /*0-100*/
    BYTE byRes[6];
} NET_DVR_GAMMACORRECT, *LPNET_DVR_GAMMACORRECT;

typedef struct tagNET_DVR_BACKLIGHT
{
    BYTE byBacklightMode; /*背光补偿:0 off 1 UP、2 DOWN、3 LEFT、4 RIGHT、5MIDDLE、6自定义，10-开，11-自动，12-多区域背光补偿*/
    BYTE byBacklightLevel; /*0x0-0xF*/
    BYTE byRes1[2];
    DWORD dwPositionX1; //（X坐标1）
    DWORD dwPositionY1; //（Y坐标1）
    DWORD dwPositionX2; //（X坐标2）
    DWORD dwPositionY2; //（Y坐标2）
    BYTE byRes2[4];
} NET_DVR_BACKLIGHT, *LPNET_DVR_BACKLIGHT;

typedef struct tagNET_DVR_NOISEREMOVE
{
    BYTE byDigitalNoiseRemoveEnable; /*0-不启用，1-普通模式数字降噪，2-专家模式数字降噪*/
    BYTE byDigitalNoiseRemoveLevel; /*普通模式数字降噪级别：0x0-0xF*/
    BYTE bySpectralLevel;       /*专家模式下空域强度：0-100*/
    BYTE byTemporalLevel;   /*专家模式下时域强度：0-100*/
    BYTE byDigitalNoiseRemove2DEnable;         /* 抓拍帧2D降噪，0-不启用，1-启用 */    
    BYTE byDigitalNoiseRemove2DLevel;            /* 抓拍帧2D降噪级别，0-100 */
    BYTE byRes[2];
} NET_DVR_NOISEREMOVE, *LPNET_DVR_NOISEREMOVE;

typedef struct tagNET_DVR_CMOSMODCFG
{
    BYTE byCaptureMod;   //抓拍模式：0-抓拍模式1；1-抓拍模式2
    BYTE byBrightnessGate;//亮度阈值
    BYTE byCaptureGain1;   //抓拍增益1,0-100
    BYTE byCaptureGain2;   //抓拍增益2,0-100
    DWORD dwCaptureShutterSpeed1;//抓拍快门速度1
    DWORD dwCaptureShutterSpeed2;//抓拍快门速度2
    BYTE  byRes[4];
}NET_DVR_CMOSMODECFG, *LPNET_DVR_CMOSMODECFG;

typedef struct tagNET_DVR_CAMERAPARAMCFG
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect;/*亮度、对比度、饱和度、锐度、色调配置*/    
    NET_DVR_GAIN struGain;/*自动增益*/
    NET_DVR_WHITEBALANCE struWhiteBalance;/*白平衡*/
    NET_DVR_EXPOSURE struExposure; /*曝光控制*/
    NET_DVR_GAMMACORRECT struGammaCorrect;/*Gamma校正*/
    NET_DVR_WDR struWdr;/*宽动态*/
    NET_DVR_DAYNIGHT struDayNight;/*日夜转换*/
    NET_DVR_BACKLIGHT struBackLight;/*背光补偿*/
    NET_DVR_NOISEREMOVE struNoiseRemove;/*数字降噪*/
    BYTE byPowerLineFrequencyMode; /*0-50HZ; 1-60HZ*/
    /*
        0-自动光圈, 
        1-手动光圈, 
        2-P-Iris1,
        3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
        4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
        5-private 3.8-16mm F1.5（HV3816P-8MPIR)
        6-private 11-40mm F1.7 (HV1140P-8MPIR)
        7-private 2.7-12mm F1.2（TV2712P-MPIR）
        8- MZ5721D-12MPIR
        9- MZ1555D-12MPIR
        10- MZ5721D-12MPIR(RS485)
        11- MZ1555D-12MPIR(RS485)
    */
    BYTE byIrisMode;  
    BYTE byMirror ;  /* 镜像：0 off，1- leftright，2- updown，3-center */
    BYTE byDigitalZoom;  /*数字缩放:0 dsibale  1 enable*/
    BYTE byDeadPixelDetect;   /*坏点检测,0 dsibale  1 enable*/
    BYTE byBlackPwl;/*黑电平补偿 ,  0-255*/ 
    BYTE byEptzGate;// EPTZ开关变量:0-不启用电子云台，1-启用电子云台
    BYTE byLocalOutputGate;//本地输出开关变量0-本地输出关闭1-本地BNC输出打开 2-HDMI输出关闭  11-缩放输出，12-裁剪输出，13-裁剪缩放输出
    //20-HDMI_720P50输出开
    //21-HDMI_720P60输出开
    //22-HDMI_1080I60输出开
    //23-HDMI_1080I50输出开
    //24-HDMI_1080P24输出开
    //25-HDMI_1080P25输出开
    //26-HDMI_1080P30输出开
    //27-HDMI_1080P50输出开
    //28-HDMI_1080P60输出开
    //40-SDI_720P50,
    //41-SDI_720P60,
    //42-SDI_1080I50,
    //43-SDI_1080I60,
    //44-SDI_1080P24,
    //45-SDI_1080P25,
    //46-SDI_1080P30,
    //47-SDI_1080P50,
    //48-SDI_1080P60,
    //49-SDI_720P25
    //50-SDI_720P30 
    //51-SDI_1080I25
    //52-SDI_1080I30
    //60- YPBPR_720P50
    //61-YPBPR_720P60
    //62-YPBPR_1080I50
    //63-YPBPR_1080I60
    //64-YPBPR_1080P24
    //65-YPBPR_1080P25
    //66-YPBPR_1080P30
    //67-YPBPR_1080P50
    //68-YPBPR_1080P60
    //69-YPBPR_720P25 
    //70-YPBPR_720P30
    //71- HDMI_1080P输出开（没有具体帧率，帧率由设备加入和captureMode保持一致）
    //72- HDMI_720P输出开（没有具体帧率，帧率由设备加入和captureMode保持一致）
    //73- HDMI_2160P输出开（没有具体帧率，帧率由设备加入和captureMode保持一致）
    BYTE byCoderOutputMode;//编码器fpga输出模式0直通3像素搬家
    BYTE byLineCoding; //是否开启行编码：0-否，1-是
    BYTE byDimmerMode; //调光模式：0-半自动，1-自动
    BYTE byPaletteMode; //调色板：0-白热，1-黑热，2-调色板2，…，8-调色板8
    BYTE byEnhancedMode; //增强方式（探测物体周边）：0-不增强，1-1，2-2，3-3，4-4
    BYTE byDynamicContrastEN;    //动态对比度增强 0-1
    BYTE byDynamicContrast;    //动态对比度 0-100
    BYTE byJPEGQuality;    //JPEG图像质量 0-100
    NET_DVR_CMOSMODECFG struCmosModeCfg;//CMOS模式下前端参数配置，镜头模式从能力集获取
    BYTE byFilterSwitch; //滤波开关：0-不启用，1-启用
    BYTE byFocusSpeed; //镜头调焦速度：0-10
    BYTE byAutoCompensationInterval; //定时自动快门补偿：1-120，单位：分钟
    BYTE bySceneMode;  //场景模式：0-室外，1-室内，2-默认，3-弱光
}NET_DVR_CAMERAPARAMCFG, *LPNET_DVR_CAMERAPARAMCFG;

typedef struct tagNET_DVR_DEFOGCFG
{
    BYTE byMode; //模式，0-不启用，1-自动模式，2-常开模式
    BYTE byLevel; //等级，0-100
    BYTE byRes[6]; 
}NET_DVR_DEFOGCFG, *LPNET_DVR_DEFOGCFG;

typedef struct tagNET_DVR_ELECTRONICSTABILIZATION
{
    BYTE byEnable;//使能 0- 不启用，1- 启用
    BYTE byLevel; //等级，0-100
    BYTE byRes[6]; 
}NET_DVR_ELECTRONICSTABILIZATION, *LPNET_DVR_ELECTRONICSTABILIZATION;

typedef struct tagNET_DVR_CORRIDOR_MODE_CCD
{
    BYTE       byEnableCorridorMode; //是否启用走廊模式 0～不启用， 1～启用
    BYTE       byRes[11];
}NET_DVR_CORRIDOR_MODE_CCD, *LPNET_DVR_CORRIDOR_MODE_CCD;

typedef struct tagNET_DVR_SMARTIR_PARAM
{
    BYTE  byMode;//0～手动，1～自动
    BYTE  byIRDistance;//红外距离等级(等级，距离正比例)level:1~100 默认:50（手动模式下增加）
    BYTE  byShortIRDistance;// 近光灯距离等级(1~100)
    BYTE  byLongIRDistance;// 远光灯距离等级(1~100)
}NET_DVR_SMARTIR_PARAM,*LPNET_DVR_SMARTIR_PARAM;

typedef struct tagNET_DVR_PIRIS_PARAM
{
    BYTE  byMode;//0-自动，1-手动
    BYTE  byPIrisAperture;//红外光圈大小等级(等级,光圈大小正比例)level:1~100 默认:50（手动模式下增加）
    BYTE  byRes[6];
}NET_DVR_PIRIS_PARAM,*LPNET_DVR_PIRIS_PARAM;

typedef struct tagNET_DVR_LASER_PARAM_CFG
{
    //Length = 16
    BYTE    byControlMode;        //控制模式            0-无效，1-自动，2-手动 默认自动
    BYTE    bySensitivity;        //激光灯灵敏度        0-100 默认50
    BYTE    byTriggerMode;        //激光灯触发模式    0-无效，1-机芯触发，2-光敏触发 默认机芯触发
    BYTE    byBrightness;        //控制模式为手动模式下有效；激光灯亮度        0-255 默认100
    BYTE    byAngle;            //激光灯角度        0-无效，范围1-36  默认12，激光灯照射范围为一个圆圈，调节激光角度是调节这个圆的半径的大小
    BYTE    byLimitBrightness;  //控制模式为自动模式下有效；激光灯亮度限制 0~100 （新增）2014-01-26
    BYTE    byEnabled ;         //手动控制激光灯使能 0-关闭，1-启动
    BYTE    byIllumination;     //激光灯强度配置0~100
    BYTE    byLightAngle;       //补光角度 0~100
    BYTE    byRes[7];           //保留
} NET_DVR_LASER_PARAM_CFG, *LPNET_DVR_LASER_PARAM_CFG;

typedef struct tagNET_DVR_FFC_PARAM
{
    //1-Schedule Mode,2-Temperature Mode, 3-Off 
    BYTE   byMode;
    //（时间:按能力显示，单位分钟，选项有10,20,30,40,50,60,120,180,240）
    BYTE   byRes1;
    WORD   wCompensateTime; //定时模式下生效
    BYTE   byRes2[4];
}NET_DVR_FFC_PARAM,*LPNET_DVR_FFC_PARAM;

typedef struct tagNET_DVR_DDE_PARAM   //在sensor中完成
{
    BYTE  byMode;//1-Off,2-Normal Mode,3-Expert Mode
    BYTE  byNormalLevel;//普通模式等级范围[1,100]，普通模式下生效
    BYTE  byExpertLevel;//专家模式等级范围[1,100]，专家模式下生效
    BYTE  byRes[5];
}NET_DVR_DDE_PARAM,*LPNET_DVR_DDE_PARAM;

typedef struct tagNET_DVR_AGC_PARAM
{
    BYTE  bySceneType;//1-Normal Sence,2-Highlight Sence,3-Manual Sence
    BYTE  byLightLevel;//亮度等级[1,100]；手动模式下生效
    BYTE  byGainLevel; //增益等级[1,100]；手动模式下生效
    BYTE  byRes[5];
}NET_DVR_AGC_PARAM,*LPNET_DVR_AGC_PARAM;

typedef struct tagNET_DVR_SNAP_CAMERAPARAMCFG 
{
    BYTE byWDRMode;   // 宽动态模式;0~关闭，1~数字宽动态 2~宽动态
    BYTE byWDRType;    // 宽动态切换模式; 0~强制启用，1~按时间启用，2~按亮度启用
    BYTE byWDRLevel;   // 宽动态等级，0~6索引对应1-7，默认索引2（即3级）；
    BYTE byRes1;
    NET_DVR_TIME_EX struStartTime; //开始宽动态时间
    NET_DVR_TIME_EX struEndTime; //结束宽动态时间
    BYTE byDayNightBrightness; //日夜转换亮度阈值，0-100，默认50；
    //记忆色增强
    BYTE byMCEEnabled;//记忆色增强使能，true：开启，false：关闭
    BYTE byMCELevel;//记忆色增强强度，0~100，默认值50
    //自动对比度
    BYTE byAutoContrastEnabled;//自动对比度使能，true：开启，false：关闭
    BYTE byAutoContrastLevel;//自动对比等级（0-100）,默认50
    //细节增强
    BYTE byLSEDetailEnabled;//细节增强使能，true：开启，false：关闭
    BYTE byLSEDetailLevel;//细节增强等级（0-100）,默认50
    // License Plate Definition Enhancement车牌增强
    BYTE byLPDEEnabled;//车牌增强使能，true：开启，false：关闭
    BYTE byLPDELevel;//车牌增强等级（0-100）,默认50
    //对比度增强
    BYTE byLseEnabled; //对比度增强使能，true：开启，false：关闭
    BYTE byLseLevel; //对比度增强等级（0-100）,默认0
    BYTE byLSEHaloLevel;//光晕抑制等级。范围 0-100,默认0
    BYTE byLseType; //对比度增强切换模式; 0~强制启用，1~按时间启用，2~按亮度启用（该字段可同时控制byLseLevel、byLSEHaloLevel两个参数）
    BYTE byRes2[3];
    NET_DVR_TIME_EX struLSEStartTime; //开始对比度增强时间（当byLseType为1时生效）
    NET_DVR_TIME_EX struLSEEndTime; //结束对比度增强时间（当byLseType为1时生效）
    BYTE byLightLevel;//为亮度等级参数（0-100）,默认0，（当byLseType为2时生效）
    //车牌对比度
    BYTE byPlateContrastLevel;//车牌对比度等级，0~100，默认0
    //车牌饱和度
    BYTE byPlateSaturationLevel;//车牌饱和度等级，0~100，默认0
    BYTE byRes[9];
} NET_DVR_SNAP_CAMERAPARAMCFG,*LPNET_DVR_SNAP_CAMERAPARAMCFG;

typedef struct tagNET_DVR_OPTICAL_DEHAZE
{
    BYTE byEnable; //0~不启用光学透雾，1~启用光学透雾
    BYTE byRes[7]; 
} NET_DVR_OPTICAL_DEHAZE, *LPNET_DVR_OPTICAL_DEHAZE;

typedef struct tagNET_DVR_THERMOMETRY_AGC
{
    BYTE  byMode;//AGC模式，0~无效，1~自动，2~手动
    BYTE  byRes1[3];
    int     iHighTemperature;//最高温度，范围为：-273~9999摄氏度（1~手动模式下生效）
    int     iLowTemperature;//最低温度，范围为：-273~9999摄氏度（1~手动模式下生效）
    BYTE  byRes[8];
}NET_DVR_THERMOMETRY_AGC, *LPNET_DVR_THERMOMETRY_AGC;

typedef struct tagNET_DVR_CAMERAPARAMCFG_EX
{
    DWORD dwSize;
    NET_DVR_VIDEOEFFECT struVideoEffect;/*亮度、对比度、饱和度、锐度、色调配置*/    
    NET_DVR_GAIN struGain;/*自动增益*/
    NET_DVR_WHITEBALANCE struWhiteBalance;/*白平衡*/
    NET_DVR_EXPOSURE struExposure; /*曝光控制*/
    NET_DVR_GAMMACORRECT struGammaCorrect;/*Gamma校正*/
    NET_DVR_WDR struWdr;/*宽动态*/
    NET_DVR_DAYNIGHT struDayNight;/*日夜转换*/
    NET_DVR_BACKLIGHT struBackLight;/*背光补偿*/
    NET_DVR_NOISEREMOVE struNoiseRemove;/*数字降噪*/
    BYTE byPowerLineFrequencyMode; /*0-50HZ; 1-60HZ*/
    /*
    0-自动光圈,
    1-手动光圈,
    2-P-Iris1,
    3-Union 3-9mm F1.6-2.7 (T5280-PQ1) [IPC5.1.7]
    4-Union 2.8-12mm F1.6-2.7 (T5289-PQ1) [IPC5.1.7]
    5-HIK 3.8-16mm F1.5（HV3816P-8MPIR)
    6-HIK 11-40mm F1.7 (HV1140P-8MPIR)
    7-HIK 2.7-12mm F1.2（TV2712P-MPIR）
    8- MZ5721D-12MPIR
    9- MZ1555D-12MPIR
    10- MZ5721D-12MPIR(RS485)
    11- MZ1555D-12MPIR(RS485)
    */
    BYTE byIrisMode;
    BYTE byMirror ;  /* 镜像：0 off，1- leftright，2- updown，3-center 4-Auto*/
    BYTE byDigitalZoom;  /*数字缩放:0 dsibale  1 enable*/
    BYTE byDeadPixelDetect;   /*坏点检测,0 dsibale  1 enable*/
    BYTE byBlackPwl;/*黑电平补偿 ,  0-255*/ 
    BYTE byEptzGate;// EPTZ开关变量:0-不启用电子云台，1-启用电子云台
    BYTE byLocalOutputGate;//本地输出开关变量0-本地输出关闭1-本地BNC输出打开 2-HDMI输出关闭  
    //20-HDMI_720P50输出开
    //21-HDMI_720P60输出开
    //22-HDMI_1080I60输出开
    //23-HDMI_1080I50输出开
    //24-HDMI_1080P24输出开
    //25-HDMI_1080P25输出开
    //26-HDMI_1080P30输出开
    //27-HDMI_1080P50输出开
    //28-HDMI_1080P60输出开
    BYTE byCoderOutputMode;//编码器fpga输出模式0直通3像素搬家
    BYTE byLineCoding; //是否开启行编码：0-否，1-是
    BYTE byDimmerMode; //调光模式：0-半自动，1-自动
    BYTE byPaletteMode; //调色板：0-白热，1-黑热，2-调色板2，…，8-调色板8, 9-融合1,10-彩虹,11-融合2,12-铁红1,13-铁红2,14-深褐色,15-色彩1,16-色彩2,17-冰火,18-雨,19-红热,20-绿热,21-深蓝，22-色彩3
    BYTE byEnhancedMode; //增强方式（探测物体周边）：0-不增强，1-1，2-2，3-3，4-4
    BYTE byDynamicContrastEN;    //动态对比度增强 0-1
    BYTE byDynamicContrast;    //动态对比度 0-100
    BYTE byJPEGQuality;    //JPEG图像质量 0-100
    NET_DVR_CMOSMODECFG struCmosModeCfg;//CMOS模式下前端参数配置，镜头模式从能力集获取
    BYTE byFilterSwitch; //滤波开关：0-不启用，1-启用
    BYTE byFocusSpeed; //镜头调焦速度：0-10
    BYTE byAutoCompensationInterval; //定时自动快门补偿：1-120，单位：分钟
    BYTE bySceneMode;  //场景模式：0-室外，1-室内，2-默认，3-弱光
    NET_DVR_DEFOGCFG struDefogCfg;//透雾参数
    NET_DVR_ELECTRONICSTABILIZATION struElectronicStabilization;//电子防抖
    NET_DVR_CORRIDOR_MODE_CCD struCorridorMode;//走廊模式
    BYTE   byExposureSegmentEnable; //0~不启用,1~启用  曝光时间和增益呈阶梯状调整，比如曝光往上调整时，先提高曝光时间到中间值，然后提高增益到中间值，再提高曝光到最大值，最后提高增益到最大值
    BYTE   byBrightCompensate;//亮度增强 [0~100]
    /*
    0-关闭、1-640*480@25fps、2-640*480@30ps、3-704*576@25fps、4-704*480@30fps、5-1280*720@25fps、6-1280*720@30fps、
    7-1280*720@50fps、8-1280*720@60fps、9-1280*960@15fps、10-1280*960@25fps、11-1280*960@30fps、
    12-1280*1024@25fps、13--1280*1024@30fps、14-1600*900@15fps、15-1600*1200@15fps、16-1920*1080@15fps、
    17-1920*1080@25fps、18-1920*1080@30fps、19-1920*1080@50fps、20-1920*1080@60fps、21-2048*1536@15fps、22-2048*1536@20fps、
    23-2048*1536@24fps、24-2048*1536@25fps、25-2048*1536@30fps、26-2560*2048@25fps、27-2560*2048@30fps、
    28-2560*1920@7.5fps、29-3072*2048@25fps、30-3072*2048@30fps、31-2048*1536@12.5、32-2560*1920@6.25、
    33-1600*1200@25、34-1600*1200@30、35-1600*1200@12.5、36-1600*900@12.5、37-1280*960@12.5fps、38-800*600@25fps、39-800*600@30fps40、
    4000*3000@12.5fps、41-4000*3000@15fps、42-4096*2160@20fps、43-3840*2160@20fps 、44-960*576@25fps、45-960*480@30fps、46-752*582@25fps、
    47-768*494@30fps、48-2560*1440@25fps、49-2560*1440@30fps 、50-720P@100fps、51-720P@120fps、52-2048*1536@50fps、53-2048*1536@60fps、
    54-3840*2160@25fps、55-3840*2160@30fps、56-4096*2160@25fps、57-4096*2160@30fps 、58-1280*1024@50fps、59-1280*1024@60fps、
    60-3072*2048@50fps、61-3072*2048@60fps、62-3072*1728@25fps、63-3072*1728@30fps、64-3072*1728@50fps、65-3072*1728@60fps、66-336*256@50fps、67-336*256@60fps、
    68-384*288@50fps、69-384*288@60fps 、70- 640 * 512@50fps 、71- 640 * 512@60fps、72-2592*1944@25fps、73-2592*1944@30fps、74-2688*1536@25fps、75-2688*1536@30fps 
    76-2592*1944@20fps、77-2592*1944@15fps、78-2688*1520@20fps、79-2688*1520@15fps、80-2688*1520@25fps、81-2688*1520@30fps、82- 2720*2048@25fps、 83- 2720*2048@30fps、
    84-336*256@25fps、85- 384*288@25fps、86-640*512@25fps、87-1280*960@50fps、88-1280*960@60fps、89-1280*960@100fps、90-1280*960@120fps、91-4000*3000@20fps、
    92-1920*1200@25fps、93-1920*1200@30fps、94-2560*1920@25fps、95-2560*1920@20fps、96-2560*1920@30fps、97-1280*1920@25fps、98-1280*1920@30fps
    99-4000*3000@24fps、100-4000*3000@25fps、101-4000*3000@10fps、102- 384*288@30fps、103-2560*1920@15fps、104-2400*3840@25fps、105-1200*1920@25fps
    106-4096*1800@30fps、107-3840*1680@30fps、108-2560*1120@30fps、109-704*320@30fps、110-1280*560@30fps、111-4096*1800@25fps、112-3840*1680@25fps
    113-2560*1120@25fps、114-704*320@25fps、115-1280*560@25fps、116-2400*3840@24fps、117-3840*2400@24fps、118-3840*2400@25fps、119-2560*1920@12.5fps
    120-2560*2048@12fps、121-2560*2048@15fps、122-2560*1536@25fps、123-2560*1536@30fps、124-2256*2048@25fps、125-2256*2048@30fps、126-2592*2592@12.5fps、127-2592*2592@15fps、
    128 - 640*512@30fps、129-2048*1520@30fps、130-2048*1520@25fps、131-3840*2160@24fps、132-2592*1520@25fps、133-2592*1520@30fps、134-2592*1536@25fps、135-2592*1536@30fps
    136-640*960@25fps、137-640*960@24fps、139-3840*1080@25fps、140-3840*1080@30fps、142-2992*2192@25fps、143-2992*2192@30fps、144-3008*2160@25fps、145-3008*2160@30fps、
    146-3072*1728@20fps、147-2560*1440@20fps、148-2160*3840@25fps、149-2160*3840@30fps、150-7008*1080@25fps、151-7008*1080@30fps、152-3072*2048@20fps、153-1536*864@25fps、
    154-2560*1920@24fps、155-2400*3840@30fps、156-3840*2400@30fps、157-3840*2160@15fps、
    158-384*288@8.3fps、159-640*512@8.3fps、160-160*120@8.3fps、161-1024*768@8.3fps、162-640*480@8.3fps、163-3840*2160@12.5fps、164-2304*1296@30fps、165-2304*1296@25fps、
    166-2560*1440@24fps、167-2688*1512@25fps、168-2688*1512@30fps、169-2688*1512@50fps、170-2688*1512@60fps、171-1536*864@30fps、172-2560*1440@50fps、173-2560*1440@60fps、
    174-2048*2048@25fps、175-2048*2048@30fps、176-4000*3060@20fps、177-3060*3060@25fps、178-3060*3060@30fps、179-3000*3000@25fps、180-3000*3000@30fps、181-8160*3616@30fps、
    182-8160*3616@25fps、183-3000*3000@20fps、184-3000*3000@15fps、185-3000*3000@12.5fps、186-5472*3648@25fps、187-5472*3648@30fps、188-7680*4320@25fps、189-7680*4320@30fps、
    190-8160*2400@25fps、191-8160*2400@30fps、192-5520*2400@25fps、193-5520*2400@30fps、194-2560*1440@15fps、195-1944*1212@24fps、196-1944*1212@25fps、197-3456*1920@30fps、
    198-4800*2688@25fps、199-4800*2688@30fps、200-6480*1080@25fps、201-6480*1080@30fps、202-8640*1440@25fps、203-8640*1440@30fps、204-3456*1920@25fps、205-2688*1520@50fps、
    206-2688*1520@60fps、207-4976*1452@25fps、208-4976*1452@30fps、 209-3200*1800@25fps、210-3200*1800@30fps、211-5472*3648@24fps、212-1920*1080@12.5fps、213-2944*1656@20fps、
    214-1920*1080@24fps、215-4800*1600@25fps、216-4800*1600@30fps、217-2560*1440@12.5fps、218-6560*3690@1fps、219-5120*1400@20fps、220-7680*4320@1fps、221-1920*1080@20fps
    222-5120*1440@20fps、223-4080*1808@25fps、224-4080*1808@30fps、225-4080*1152@25fps、226-4080*1152@30fps、227-2688*1944@20fps、228-2592*1944@24fps、229-3200*1800@15fps、
    230-4416*1696@20fps、231-3456*1080@25fps、232-3200*1800@12.5fps、233-2688*1532@25fps、234-2688*1532@30fps、235-4416*1696@12.5fps、236-3840*2048P12.5fps、237-3840*4096P12.5fps、
    238-5120*1440@12.5fps、239-3840*1080@24fps、240-320*256@30fps、241-3264*2448@25fps、242-3264*2448@30fps、243-5430*3054@1fps、244-2688*1520@24@24fps、245-4000*3000@30fps*/
    BYTE   byCaptureModeN; //视频输入模式（N制）
    BYTE   byCaptureModeP; //视频输入模式（P制）
    NET_DVR_SMARTIR_PARAM struSmartIRParam; //红外放过爆配置信息
    NET_DVR_PIRIS_PARAM struPIrisParam;//PIris配置信息对应byIrisMode字段从2-PIris1开始生效
    //2014-02-25 新增参数
    NET_DVR_LASER_PARAM_CFG struLaserParam;    //激光参数
    NET_DVR_FFC_PARAM  struFFCParam;
    NET_DVR_DDE_PARAM  struDDEParam;
    NET_DVR_AGC_PARAM  struAGCParam;
    BYTE   byLensDistortionCorrection;//镜头畸变校正 0-关闭,1-开启
    BYTE byDistortionCorrectionLevel;//畸变校正等级：0-保留；1-等级一；2-等级二；3-等级三;255-自定义
    BYTE byCalibrationAccurateLevel;// 畸变校正强度[0-100]
    BYTE byZoomedInDistantViewLevel;//远端放大等级[0-100]
    NET_DVR_SNAP_CAMERAPARAMCFG struSnapCCD ; //抓拍机CCD参数，只用于抓拍机
    NET_DVR_OPTICAL_DEHAZE struOpticalDehaze;//光学透雾参数
    NET_DVR_THERMOMETRY_AGC struThermAGC;//测温AGC配置
    BYTE   byFusionMode;//双光谱视频融合模式，0~热成像模式，1~融合模式，2~画中画模式,3~可见光模式, 4~融合黑白模式, 5~融合彩色模式-草地，6~融合彩色模式-荒地，7~融合彩色模式-雪地，8~融合彩色模式-海洋，9~融合彩色模式-城市
    BYTE   byHorizontalFOV;//水平视场角[0-100]
    BYTE   byVerticalFOV;//垂直视场角[0-100]
    BYTE   byBrightnessSuddenChangeSuppression;//亮度突变抑制0-关闭,1-开启
    BYTE   byGPSEnabled;//GPS开关使能，0-关，1-开
    BYTE   byRes2[155];
}NET_DVR_CAMERAPARAMCFG_EX, *LPNET_DVR_CAMERAPARAMCFG_EX;

typedef struct tagNET_DVR_FOCUSING_POSITION_STATE
{
    DWORD   dwSize;
    BYTE    byState;//聚焦到位状态参数 0-不到位，1-到位
    BYTE    byRes[31];    
}NET_DVR_FOCUSING_POSITION_STATE, *LPNET_DVR_FOCUSING_POSITION_STATE;



















































































































typedef struct tagNET_DVR_VEHICLE_INFO_
{
    DWORD dwIndex;          //车辆序号
    BYTE  byVehicleType;    //车辆类型 0 表示其它车型，1 表示小型车，2 表示大型车 ,3表示行人触发 ,4表示二轮车触发 5表示三轮车触发(3.5Ver)  6表示机动车触发
    BYTE  byColorDepth;        //车身颜色深浅
    BYTE  byColor;          //车身颜色,参考VCR_CLR_CLASS
    /*雷达异常状态：
    0~雷达正常，
    1~雷达故障
    2~雷达一直发送某一个相同速度值
    3~雷达送出数据为0
    4~雷达送出数据过大或者过小
    */
    BYTE  byRadarState;
    WORD  wSpeed;           //单位km/h
    WORD  wLength;          //前一辆车的车身长度  
                            /*违规类型，0-正常，1-低速，2-超速，3-逆行，4-闯红灯,5-压车道线,6-不按导向，7-路口滞留，
                            8-机占非，9-违法变道，10-不按车道 11-违反禁令，12-路口停车，13-绿灯停车, 14-未礼让行人(违法代码1357), 
    15-违章停车，16-违章掉头,17-占用应急车道,18-禁右,19-禁左,20-压黄线,21-未系安全带,22-行人闯红灯,23-加塞,24-违法使用远光灯，
    25-驾驶时拨打接听手持电话，26-左转不让直行，27-右转不让左转，28-掉头不让直行，29-大弯小转, 30-闯绿灯，31-未带头盔，
    32-非机动车载人，33-非机动车占用机动车道，34-非机动车打伞棚, 35-黑烟车, 36-鸣笛,37-压线停车,38-跨位停车,39-压线且跨位停车,
    40-不让右方道路来车先行,41-进入环形路口未让已在路口内的机动车先行,42-机动车从匝道进入主路未让行,43-大车占道,44-炸街,45-吸烟
    */
    BYTE  byIllegalType;
    BYTE  byVehicleLogoRecog; //参考枚举类型 VLR_VEHICLE_CLASS
    BYTE  byVehicleSubLogoRecog; //车辆品牌子类型识别；参考VSB_VOLKSWAGEN_CLASS等子类型枚举。
    BYTE  byVehicleModel; //车辆子品牌年款，0-未知，参考"车辆子品牌年款.xlsx"
    BYTE  byCustomInfo[16];  //自定义信息
    WORD  wVehicleLogoRecog;  //车辆主品牌，参考"车辆主品牌.xlsx" (该字段兼容byVehicleLogoRecog);
    BYTE  byIsParking;//是否停车 0-无效，1-停车，2-未停车
    BYTE  byRes;//保留字节
    DWORD dwParkingTime; //停车时间，单位：s
    BYTE  byBelieve; //byIllegalType置信度，1-100
    BYTE  byCurrentWorkerNumber;//当前作业人数
    BYTE  byCurrentGoodsLoadingRate;//当前货物装载率 0-空 1-少 2-中 3-多 4-满
    BYTE  byDoorsStatus;//车门状态 0-车门关闭 1-车门开启
    BYTE  byRes3[4];
}NET_DVR_VEHICLE_INFO, *LPNET_DVR_VEHICLE_INFO;

typedef struct tagNET_DVR_PLATE_RESULT
{
    DWORD   dwSize;            //结构长度
    BYTE    byResultType;    //0-视频识别结果，1图像识别结果 2 大于10M时走下载路线
    BYTE    byChanIndex;    //通道号
    WORD    wAlarmRecordID;    //报警录像ID(用于查询录像，仅当byResultType为2时有效)
    DWORD   dwRelativeTime;    //相对时间点  
    BYTE    byAbsTime[32];    //绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999（毫秒）
    DWORD   dwPicLen;        //图片长度(近景图)
    DWORD    dwPicPlateLen;  //车牌小图片长度
    DWORD   dwVideoLen;        //录像内容长度
    BYTE    byTrafficLight;    //0-非红绿灯抓拍，1-绿灯时抓拍；2-红灯时抓拍
    BYTE    byPicNum;       //连拍的图片序号
    BYTE    byDriveChan;    //触发车道号
    BYTE     byVehicleType; //车辆类型，参考VTR_RESULT
    DWORD   dwBinPicLen;    //车牌二值图长度
    DWORD   dwCarPicLen;    //车辆原图长度
    DWORD   dwFarCarPicLen; //远景图长度
    BYTE    *pBuffer3;      //车牌二值图
    BYTE    *pBuffer4;      //车辆原图
    BYTE    *pBuffer5;      //远景图
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）,2表示未知
    BYTE    byRes3[6];   
    NET_DVR_PLATE_INFO  struPlateInfo;    //车牌信息结构
    NET_DVR_VEHICLE_INFO struVehicleInfo; //车辆信息
    BYTE    *pBuffer1;                   // 当上传的是图片(近景图)，指针指向图片信息，当上传的是视频，指针指向视频信息，如果不想获得图片或视频信息，传NULL(DVS车辆近景图)
    BYTE    *pBuffer2;                  // 当上传的是图片(车牌图)时，指向车牌图片的指针（DVS车牌彩图）
}NET_DVR_PLATE_RESULT, *LPNET_DVR_PLATE_RESULT;

typedef struct tagNET_VPD_SHUTTER
{
    DWORD dwCommmand;    //命令:0,不控制 1,调亮 2,调暗 3,保持 4,直接输入快门值
    DWORD dwCode;       //快门值, 当参数dwCommmand为4, 该参数不能为空
    BYTE  byRes[60];            //保留
}NET_VPD_SHUTTER, *LPNET_VPD_SHUTTER;

typedef struct tagNET_DVR_IMAGEOVERLAYCFG
{
    DWORD        dwSize;
    BYTE        byOverlayInfo;//叠加使能开关，0-不叠加，1-叠加
    BYTE        byOverlayMonitorInfo;//是否叠加监测点信息，0-不叠加，1-叠加
    BYTE        byOverlayTime;//是否叠加时间，0-不叠加，1-叠加
    BYTE        byOverlaySpeed;//是否叠加速度，0-不叠加，1-叠加
    BYTE        byOverlaySpeeding;//是否叠加超速比例，0-不叠加，1-叠加
    BYTE        byOverlayLimitFlag;//是否叠加限速标志，0-不叠加，1-叠加
    BYTE        byOverlayPlate;//是否叠加车牌号，0-不叠加，1-叠加
    BYTE        byOverlayColor;//是否叠加车身颜色，0-不叠加，1-叠加
    BYTE        byOverlayLength;//是否叠加车长，0-不叠加，1-叠加
    BYTE        byOverlayType;//是否叠加车型，0-不叠加，1-叠加
    BYTE        byOverlayColorDepth;//是否叠加车身颜色深浅，0-不叠加，1-叠加
    BYTE        byOverlayDriveChan;//是否叠加车道，0-不叠加，1-叠加
    BYTE        byOverlayMilliSec; //叠加毫秒信息 0-不叠加，1-叠加
    BYTE        byOverlayIllegalInfo; //叠加违章信息 0-不叠加，1-叠加
    BYTE        byOverlayRedOnTime;  //叠加红灯已亮时间 0-不叠加，1-叠加
    BYTE        byFarAddPlateJpeg;      //远景图是否叠加车牌截图,0-不叠加,1-叠加
    BYTE        byNearAddPlateJpeg;      //近景图是否叠加车牌截图,0-不叠加,1-叠加
    BYTE        byRes1[3];    //保留
    BYTE        byMonitorInfo1[32];    //监测点信息1
    BYTE        byMonitorInfo2[44]; //检测点信息2
    BYTE        byRes2[52];    //保留
}NET_DVR_IMAGEOVERLAYCFG, *LPNET_DVR_IMAGEOVERLAYCFG;

typedef struct tagNET_DVR_SNAPCFG
{
    DWORD   dwSize;
    BYTE    byRelatedDriveWay;//触发IO关联的车道号
    BYTE     bySnapTimes; //线圈抓拍次数，0-不抓拍，非0-连拍次数，目前最大5次  
    WORD    wSnapWaitTime;  //抓拍等待时间，单位ms，取值范围[0,60000]
    WORD    wIntervalTime[MAX_INTERVAL_NUM];//连拍间隔时间，ms
    DWORD   dwSnapVehicleNum; //抓拍车辆序号。
    NET_DVR_JPEGPARA  struJpegPara;//抓拍图片参数
    BYTE    byRes2[16];//保留字节
}NET_DVR_SNAPCFG, *LPNET_DVR_SNAPCFG;



typedef struct tagNET_DVR_SNAP_ABILITY
{
    DWORD dwSize;
    BYTE  byIoInNum;//IO输入口数
    BYTE  byIoOutNum;//IO输出口数
    BYTE  bySingleSnapNum;//单IO触发组数
    BYTE  byLightModeArrayNum;//红绿灯模式组数
    BYTE  byMeasureModeArrayNum;//测速模式组数
    BYTE  byPlateEnable; //车牌识别能力
    BYTE  byLensMode;//镜头模式0-CCD,1-CMOS
    BYTE  byPreTriggerSupport; //是否支持原触发模式，0-支持，1-不支持
    DWORD dwAbilityType; //支持的触发模式能力，按位表示，定义见ITC_MAINMODE_ABILITY
    BYTE  byIoSpeedGroup; //支持的IO测速组数
    BYTE  byIoLightGroup; //支持的IO红绿灯组数
    BYTE  byRecogRegionType; //牌识区域支持的类型，详见定义ITC_RECOG_REGION_TYPE
    BYTE  bySupport; //设备能力，按位表示，0-不支持，1-支持
    // bySupport&0x1，表示是否支持扩展的字符叠加配置
    // bySupport&0x2，表示是否支持扩展的校时配置结构
    // bySupport&0x4, 表示是否支持多网卡(多网隔离)
    // bySupport&0x8, 表示是否支持网卡的bonding功能(网络容错)
    // bySupport&0x10, 表示是否支持语音对讲
    //2013-07-09 能力集返回
    WORD wSupportMultiRadar;// 设备能力，按位表示，0-不支持，1-支持
    // wSupportMultiRadar&0x1，表示 卡口RS485雷达 支持车道关联雷达处理
    // wSupportMultiRadar&0x2，表示 卡口虚拟线圈 支持车道关联雷达处理
    // wSupportMultiRadar&0x4，表示 混行卡口 支持车道关联雷达处理
    // wSupportMultiRadar&0x8，表示 视频检测 支持车道关联雷达处理
    BYTE  byICRPresetNum;
    // 表示支持的ICR预置点（滤光片偏移点）数
    BYTE  byICRTimeSlot;//表示支持的ICR的时间段数（1～8）
    BYTE  bySupportRS485Num;//表示支持的RS485口的数量
    BYTE  byExpandRs485SupportSensor;// 设备能力，按位表示，0-不支持，1-支持
    // byExpandRs485SupportSensor &0x1，表示电警车检器支持车检器
    // byExpandRs485SupportSensor &0x2，表示卡式电警车检器支持车检器
    BYTE  byExpandRs485SupportSignalLampDet;// 设备能力，按位表示，0-不支持，1-支持
    // byExpandRs485SupportSignalLampDet &0x1，表示电警车检器支持外接信号灯检测器
    // byExpandRs485SupportSignalLampDet &0x2，表示卡式电警车检器支持外接信号灯检测器
    BYTE  byRelayNum;// 表示支持继电器的个数 2013-11-04
    BYTE  bySupport1; //设备能力，按位表示，0-不支持，1-支持
    // bySupport1&0x1，表示是否支持自定义校时信息配置
    // bySupport1&0x2,  表示是否支持视频触发优化方案
    // bySupport1&0x4,  表示是否支持DDNS配置方案
    // bySupport1&0x8,  表示是否支持获取设备当前触发模式接口命令
    // bySupport1&0x10, 表示是否支持出入口配置 2014-03-03
    // bySupport1&0x20,  表示是否支持GPS模块参数配置
    // bySupport1&0x40,  表示是否支持NTP校时间隔支持分钟设置
    // bySupport1&0x80,  表示是否支持tps报警数据上传
    BYTE  bySupport2; //设备能力，按位表示，0-不支持，1-支持
    // bySupport2&0x01,  表示是否支持码流附加信息配置
    // bySupport2&0x02,  表示通道图像参数（INTER_PICCFG_V30）中是否支持视频叠加时间毫秒启用参数（byOSDMilliSecondEnable）
    // bySupport2&0x04,   表示道闸控制（NET_DVR_BARRIERGATE_CFG）中byBarrierGateCtrl字段支持索引4~解锁道闸，且支持byUnlock解锁使能。反之则标识不支持
    BYTE  bySupportWhiteBalance; //白平衡能力，默认都是支持手动白平衡、自动白平衡、自动白平衡2这3种模式。
    // bySupportWhiteBalance &0x01,  表示是否支持日光灯模式
    // bySupportWhiteBalance &0x02,  表示是否支持自然光模式
    // bySupportWhiteBalance &0x04,  表示是否支持暖光灯模式
    // bySupportWhiteBalance &0x08,  表示是否支持白炽灯模式
    BYTE  byRes[9];
} NET_DVR_SNAP_ABILITY, *LPNET_DVR_SNAP_ABILITY;

typedef struct tagNET_DVR_TRANSFER_CAP
{
    BYTE  byAbility;
    BYTE  byRes[63];
}NET_DVR_TRANSFER_CAP, *LPNET_DVR_TRANSFER_CAP;

typedef struct tagNET_ITC_ICRTIMECFG
{
    NET_DVR_SCHEDTIME  struTime;
    BYTE   byAssociateRresetNo;//预置点号1～8 , 0代表无
    BYTE   bySubSwitchMode;//1~白天，2~晚上 (当预置点等于0 的时候生效)
    BYTE   byRes[10];
}NET_ITC_ICRTIMECFG, *LPNET_ITC_ICRTIMECFG;

typedef struct tagNET_ITC_ICR_TIMESWITCH_PARAM  //156
{
    NET_ITC_ICRTIMECFG  struAutoCtrlTime[MAX_TIMESEGMENT_V30];//自动切换时间段 (自动切换下 时空下生效 现在支持4组，预留4组)
    BYTE  byICRPreset[MAX_ICR_NUM]; //实际生效根据能力集动态显示 [0~100] 数组下标表示预置点号1～8 （0～7 相对应）
    BYTE  byRes[20];
}NET_ITC_ICR_TIMESWITCH_PARAM, *LPNET_ITC_ICR_TIMESWITCH_PARAM;

typedef struct tagNET_ITC_ICR_MANUALSWITCH_PARAM
{    
    BYTE  byICRPreset[MAX_ICR_NUM]; //实际生效根据能力集动态显示 [0~100]
    BYTE  bySubSwitchMode;//1~白天，2~晚上
    BYTE  byRes[147];
}NET_ITC_ICR_MANUALSWITCH_PARAM, *LPNET_ITC_ICR_MANUALSWITCH_PARAM;

typedef struct tagNET_ITC_ICR_AOTOSWITCH_PARAM
{
    BYTE  byICRPreset[MAX_ICR_NUM]; //实际生效根据能力集动态显示 [0~100] 数组下标表示预置点号1～8 （0～7 相对应）
    BYTE  byICRAutoSwitch; // ICR自动切换加阈值选项, 取值范围[0 100]
    BYTE  byRes[147];
}NET_ITC_ICR_AOTOSWITCH_PARAM, *LPNET_ITC_ICR_AOTOSWITCH_PARAM;

typedef struct tagNET_ITC_ICR_ALGAOTOSWITCH_PARAM
{
    BYTE  byDetectThreshold;//检测阈值,范围[0,100],默认 58
    BYTE  byAbBrightnessThreshold; //异常亮度阈值，范围[0,100]，默认12
    BYTE  byRes[154];
}NET_ITC_ICR_ALGAOTOSWITCH_PARAM, *LPNET_ITC_ICR_ALGAOTOSWITCH_PARAM;


typedef struct tagNET_ITC_ICRCFG
{
    DWORD dwSize;
    BYTE  bySwitchType;//1~自动切换，2~手动切换 ,3~定时切换,4~算法自动 
    BYTE  byRes[3];
    NET_ITC_ICR_PARAM_UNION uICRParam;
}NET_ITC_ICRCFG, *LPNET_ITC_ICRCFG;



typedef struct tagNET_DVR_TRIGCOORDINATE
{
    WORD wTopLeftX; /*线圈左上角横坐标（2个字节）*/
    WORD wTopLeftY; /*线圈左上角纵坐标（2个字节）*/
    WORD wWdith; /*线圈宽度（2个字节）*/
    WORD wHeight; /*线圈高度（2个字节）*/
} NET_DVR_TRIGCOORDINATE, *LPNET_DVR_TRIGCOORDINATE;


typedef struct tagNET_DVR_GEOGLOCATION
{
    int iRes[2]; /*保留*/
    DWORD dwCity; /*城市，详见PROVINCE_CITY_IDX */
}NET_DVR_GEOGLOCATION, *LPNET_DVR_GEOGLOCATION;







typedef struct tagNET_DVR_VTPARAM
{
    DWORD   dwSize;
    BYTE    byEnable;  /* 是否使能虚拟线圈，0-不使用，1-使用*/
    BYTE    byIsDisplay; /* 是否显示虚拟线圈，0-不显示，1-显示*/
    BYTE    byLoopPos; //晚间触发线圈的偏向：0-向上，1-向下
    BYTE    bySnapGain; /*抓拍增益*/
    DWORD   dwSnapShutter; /*抓拍快门速度*/
    NET_DVR_TRIGCOORDINATE struTrigCoordinate; //保留
    NET_DVR_TRIGCOORDINATE struRes[MAX_VL_NUM];
    BYTE    byTotalLaneNum;/*视频触发的车道数1*/
    BYTE    byPolarLenType; /*偏振镜类型，0：不加偏振镜；1：加施耐德偏振镜。*/
    BYTE    byDayAuxLightMode; /*白天辅助照明模式，0：无辅助照明；1：LED灯照明；2：闪光灯照明*/
    BYTE    byLoopToCalRoadBright; /*用以计算路面亮度的车道(虚拟线圈)*/
    BYTE    byRoadGrayLowTh; /*路面亮度低阈值初始化值1*/
    BYTE    byRoadGrayHighTh; /*路面亮度高阈值初始化值140*/
    WORD    wLoopPosBias; /*晚间触发线圈位移30*/
    DWORD   dwHfrShtterInitValue; /*连续图像曝光时间的初始值2000*/
    DWORD   dwSnapShtterInitValue; /*抓拍图像曝光时间的初始值500*/
    DWORD   dwHfrShtterMaxValue; /*连续图像曝光时间的最大值20000*/
    DWORD   dwSnapShtterMaxValue; /*抓拍图像曝光时间的最大值1500*/
    DWORD   dwHfrShtterNightValue; /*晚间连续图像曝光时间的设置值3000*/
    DWORD   dwSnapShtterNightMinValue; /*晚间抓拍图像曝光时间的最小值3000*/
    DWORD   dwSnapShtterNightMaxValue; /*晚间抓拍图像曝光时间的最大值5000*/
    DWORD   dwInitAfe; /*增益的初始值200*/
    DWORD   dwMaxAfe; /*增益的最大值400*/
    WORD    wResolutionX;/* 设备当前分辨率宽*/
    WORD    wResolutionY;/* 设备当前分辨率高*/
    DWORD   dwGainNightValue; /*晚间增益，默认值70*/
    DWORD   dwSceneMode; /*场景模式， 详见SCENE_MODE */
    DWORD   dwRecordMode; /*录像标志：0-不录像，1-录像*/
    NET_DVR_GEOGLOCATION struGeogLocation; /*地址位置*/
    BYTE    byTrigFlag[MAX_VL_NUM]; /*触发标志，0-车头触发；1-车尾触发；2-车头/车尾都触发*/
    BYTE    byTrigSensitive[MAX_VL_NUM];  /*触发灵敏度，1-100*/
    BYTE    byRes2[62];
}NET_DVR_VTPARAM, *LPNET_DVR_VTPARAM;

typedef struct tagNET_DVR_SNAPENABLECFG
{
    DWORD dwSize;
    BYTE  byPlateEnable;//是否支持车牌识别，0-不支持，1-支持
    BYTE  byRes1[2];   //保留
    BYTE  byFrameFlip;   //图像是否翻转 0-不翻转，1-翻转
    WORD  wFlipAngle;    //图像翻转角度 0,90,180,270
    WORD  wLightPhase;   //相位，取值范围[0, 360]
    BYTE  byLightSyncPower;  //是否信号灯电源同步，0-不同步；1-同步
    BYTE  byFrequency;        //信号频率
    BYTE  byUploadSDEnable;  //是否自动上传SD图片，0-否；1-是
    BYTE  byPlateMode; //识别模式参数:0-视频触发,1-外部触发
    BYTE  byUploadInfoFTP; //是否上传抓拍附加信息到FTP，0-否，1-是
    BYTE  byAutoFormatSD; //是否自动格式化SD卡，0-否，1-是
    WORD  wJpegPicSize; //Jpeg图片大小[64-8196]
    BYTE  bySnapPicResolution;  //抓拍图片分辨率(与NET_DVR_COMPRESSION_INFO_V30中分辨率保持一致)
    BYTE  byRes[55]; //保留
}NET_DVR_SNAPENABLECFG, *LPNET_DVR_SNAPENABLECFG;

typedef struct 
{
    DWORD    dwSize;
    DWORD    dwEnableFTP;            /*是否启动ftp上传功能*/
    char    sFTPIP[16];                /*ftp 服务器*/
    DWORD    dwFTPPort;                /*ftp端口*/
    BYTE    sUserName[NAME_LEN];    /*用户名*/
    BYTE    sPassword[PASSWD_LEN];    /*密码*/
    DWORD    dwDirLevel;    /*0 = 不使用目录结构，直接保存在根目录,1 = 使用1级目录,2=使用2级目录*/
    WORD     wTopDirMode;    /* 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址，0x4=使用监测点,0x5=使用时间(年月),0x=6自定义,0x7=违规类型,0x8=方向,0x9=地点*/
    WORD     wSubDirMode;    /* 二级目录，0x1 = 使用通道名,0x2 = 使用通道号，,0x3=使用时间(年月日),0x4=使用车道号,0x=5自定义,0x6=违规类型,0x7=方向,0x8=地点*/
    BYTE    byEnableAnony; //启用匿名，0-否，1-是
    BYTE    byPicArchivingInterval;//图片归档间隔[1~30],0表示关闭
    BYTE    byRes[22];
}NET_DVR_FTPCFG, *LPNET_DVR_FTPCFG;

typedef struct 
{
    BYTE     byItemOrder[PICNAME_MAXITEM];    /*    桉数组定义文件命名的规则 */
    BYTE     byDelimiter;        /*分隔符，一般为'_'*/
}NET_DVR_PICTURE_NAME, *LPNET_DVR_PICTURE_NAME;

typedef struct 
{
    BYTE     byItemOrder[PICNAME_MAXITEM];    /*    桉数组定义文件命名的规则 */
    BYTE     byDelimiter;                    /*分隔符，一般为'_'*/
    BYTE    byPicNamePrefix[PICNAME_PREFIX/*32*/];  //图片名自定义前缀
}NET_DVR_PICTURE_NAME_EX, *LPNET_DVR_PICTURE_NAME_EX;

typedef struct 
{
    BYTE    byStrFlag;    /*串口数据开始符*/
    BYTE     byEndFlag;    /*结束符*/
    WORD    wCardIdx;    /*卡号相对起始位*/
    DWORD     dwCardLen;    /*卡号长度*/
    DWORD   dwTriggerPicChans;    /*所触发的通道号，按位，从第1位开始计，即0x2表示第一通道*/
}NET_DVR_SERIAL_CATCHPIC_PARA, *LPNET_DVR_SERIAL_CATCHPIC_PARA;

typedef struct 
{
    DWORD    dwSize;
    NET_DVR_JPEGPARA struJpegPara[MAX_CHANNUM_V30];    /*每个通道的图像参数*/
    WORD    wBurstMode;                            /*抓图方式,按位设置.0x1=报警输入触发，0x2=移动侦测触发 0x4=232触发，0x8=485触发，0x10=网络触发*/
    WORD    wUploadInterval;                    /*图片上传间隔(秒)[0,65535]*/
    NET_DVR_PICTURE_NAME     struPicNameRule;    /* 图片命名规则 */
    BYTE    bySaveToHD;        /*是否保存到硬盘*/
    BYTE    byRes1;
    WORD    wCatchInterval;        /*抓图间隔(毫秒)[0,65535]*/
    BYTE    byRes2[12];
    NET_DVR_SERIAL_CATCHPIC_PARA struRs232Cfg;
    NET_DVR_SERIAL_CATCHPIC_PARA struRs485Cfg;
    DWORD dwTriggerPicTimes[MAX_CHANNUM_V30];    /* 每个通道一次触发拍照次数 */
    DWORD dwAlarmInPicChanTriggered[MAX_ALARMIN_V30]; /*报警触发抓拍通道,按位设置，从第1位开始*/
}NET_DVR_JPEGCFG_V30, *LPNET_DVR_JPEGCFG_V30;

typedef struct tagNET_DVR_MANUALSNAP
{
    BYTE   byOSDEnable;//0-不关闭(默认)，1-关闭
    BYTE   byLaneNo;//车道号, 范围为1-6，默认为1(抓拍机内部测试使用)
    BYTE   byChannel;//通道号
    BYTE   byRes[21]; //保留
}NET_DVR_MANUALSNAP, *LPNET_DVR_MANUALSNAP;

typedef struct tagNET_DVR_SPRCFG    
{
    DWORD dwSize; 
    BYTE byDefaultCHN[MAX_CHJC_NUM]; /*设备运行省份的汉字简写*/
    BYTE byPlateOSD;    /*0:不发送车牌彩色图,1:发送车牌彩色图*/
    BYTE bySendJPEG1;   /*0-不传送近景JPEG图,1-传送近景JPEG图*/
    BYTE bySendJPEG2;   /*0-不传送远景JPEG图,1-传送远景JPEG图*/
    WORD wDesignedPlateWidth;   /*车牌设计宽度*/
    BYTE byTotalLaneNum;  /*识别的车道数*/
    BYTE byRes1;      /*保留*/
    WORD wRecognizedLane;  /*识别的车道号，按位表示，bit0表示车道1是否识别，0-不识别，1-识别*/
    NET_VCA_RECT struLaneRect[MAX_LANERECT_NUM];  /*车道识别区域*/
                                                  DWORD dwRecogMode;  /*识别的类型，
                                                                      bit0-背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ； 
                                                                      bit1-大车牌识别或小车牌识别：0-小车牌识别，1-大车牌识别 ；
                                                                      bit2-车身颜色识别：0-不采用车身颜色识别，在背向识别或小车牌识别时禁止启用，1-车身颜色识别；
                                                                      bit3-农用车识别：0-不采用农用车识别，1-农用车识别； 
                                                                      bit4-模糊识别：0-不采用模糊识别，1-模糊识别；
                                                                      bit5-帧定位或场定位：0-帧定位，1-场定位；
                                                                      bit6-帧识别或场识别：0-帧识别，1-场识别； 
                                                  bit7-晚上或白天：0-白天，1-晚上 */
                                                  BYTE  bySendPRRaw;           //是否发送原图：0-不发送，1-发送 
                                                  BYTE  bySendBinImage;      //是否发送车牌二值图：0-不发送，1-发送 
                                                  BYTE  byDelayCapture;  //延时抓拍控制,单位：帧
                                                  BYTE  byUseLED;    //使用LED控制，0-否，1-是
                                                  BYTE  byRes2[68];    //保留
}NET_DVR_SPRCFG, *LPNET_DVR_SPRCFG;

typedef struct tagNET_DVR_PLCCFG
{
    DWORD dwSize;
    BYTE byPlcEnable;    //是否启用车牌亮度补偿（默认启用）：0-关闭，1-启用 
    BYTE byPlateExpectedBright;    //车牌的预期亮度（默认值50）, 范围[0, 100]
    BYTE byRes1[2];    //保留 
    BYTE byTradeoffFlash;     //是否考虑闪光灯的影响: 0 - 否;  1 - 是(默认); 
    //使用闪光灯补光时, 如果考虑减弱闪光灯的亮度增强效应, 则需要设为1;否则为0
    BYTE byCorrectFactor;     //纠正系数, 范围[0, 100], 默认值50 (在tradeoff_flash切换时,恢复默认值）
    WORD wLoopStatsEn;  //是否该线圈的亮度，按位表示，0-不统计，1-统计
    BYTE byPlcBrightOffset;// 车牌亮度补偿灵敏度(虚拟线圈模式起效)，取值范围1~100
    BYTE byRes[19];
}NET_DVR_PLCCFG, *LPNET_DVR_PLCCFG;

typedef struct tagNET_DVR_DEVICESTATECFG
{
    DWORD dwSize;
    WORD wPreviewNum; //预览连接个数
    WORD wFortifyLinkNum; //布防连接个数
    NET_DVR_IPADDR struPreviewIP[MAX_LINK];  //预览的用户IP地址
    NET_DVR_IPADDR struFortifyIP[MAX_FORTIFY_NUM]; //布防连接的用户IP地址
    DWORD dwVideoFrameRate;    //帧率：0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20; 14-15; 15-18; 16-22;
    BYTE byResolution;      //分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE bySnapResolution;      //抓拍分辨率0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 31-2448*2048
    BYTE byStreamType; //传输类型：0-主码流；1-子码流
    BYTE byTriggerType; //触发模式：0-视频触发；1-普通触发
    DWORD dwSDVolume;  //SD卡容量
    DWORD dwSDFreeSpace; //SD卡剩余空间
    BYTE byDetectorState[MAX_DRIVECHAN_NUM][MAX_COIL_NUM];  //车检器状态：0-未使用；1-正常；2-异常
    BYTE byDetectorLinkState; //车检器连接状态：0-未连接；1-连接
    BYTE bySDStatus;    //SD卡状态 0－活动；1－休眠；2－异常，3-无sd卡
    BYTE byFortifyLevel[MAX_FORTIFY_NUM]; //布防等级，0-无，1-一等级（高），2-二等级（中），3-三等级（低）
    BYTE byRes2[116]; //保留
}NET_DVR_DEVICESTATECFG, *LPNET_DVR_DEVICESTATECFG;

typedef struct tagNET_DVR_POSTEPOLICECFG
{
    DWORD dwSize;
    DWORD dwDistance;//线圈距离,单位cm，取值范围[0,20000]
    DWORD dwLightChan[MAX_SIGNALLIGHT_NUM];    //信号灯通道号
    BYTE  byCapSpeed;//标志限速，单位km/h，取值范围[0,255]
    BYTE  bySpeedLimit;//限速值，单位km/h，取值范围[0,255]
    BYTE  byTrafficDirection;//车流方向，0-由东向西，1-由西向东，2-由南向北，3-由北向南
    BYTE  byRes1; //保留
    WORD  wLoopPreDist;        /*触发延迟距离 ，单位：分米*/
    WORD  wTrigDelay;             /*触发硬延时时间 ，单位：毫秒*/
    BYTE  byRes[124];//保留字节
}NET_DVR_POSTEPOLICECFG, *LPNET_DVR_POSTEPOLICECFG;

typedef struct  tagNET_DVR_SIGNALLAMP_DETCFG
{
    DWORD   dwSize;        //结构长度
    //绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999  最后三位为毫秒数
    BYTE    byAbsTime[32];    
    NET_DVR_IPADDR    struAlarmCamIP;//报警摄像机IP
    DWORD   dwPic1Len;     //异常图片1长度
    DWORD   dwPic2Len;     //异常图片2长度
    char    *pPic1Buffer;    //数据指针  叠加车道线图片
    char    *pPic2Buffer;    //数据指针  叠加信号灯状态图片
    BYTE    byRes[128];
}NET_DVR_SIGNALLAMP_DETCFG, *LPNET_DVR_SIGNALLAMP_DETCFG;

typedef struct tagNET_DVR_EXDEVDET_COND
{
    DWORD         dwSize; // 结构体大小
    DWORD         dwChannel;                //通道号    
    BYTE          byExternalDevType;// 0-无效值（保留）1-信号灯,2-闪光灯
    BYTE          byRes[63];             // 保留字节
}NET_DVR_EXDEVDET_COND,*LPNET_DVR_EXDEVDET_COND;

typedef struct tagNET_DVR_EXDEVDET_CFG
{
    DWORD         dwSize; // 结构体大小
    BYTE          byExternalDevStatus;// 0-正常1-异常
    BYTE          byRes[63];// 保留字节
} NET_DVR_EXDEVDET_CFG,*LPNET_DVR_EXDEVDET_CFG;

typedef struct tagNET_DVR_PROTO_TYPE
{ 
    DWORD dwType;               /*ipc协议值*/    
    BYTE  byDescribe[DESC_LEN]; /*协议描述字段*/    
}NET_DVR_PROTO_TYPE, *LPNET_DVR_PROTO_TYPE;

typedef struct tagNET_DVR_IPC_PROTO_LIST
{    
    DWORD   dwSize; 
    DWORD   dwProtoNum;           /*有效的ipc协议数目*/   
    NET_DVR_PROTO_TYPE struProto[IPC_PROTOCOL_NUM];   /*有效的ipc协议*/    
    BYTE    byRes[8];
}NET_DVR_IPC_PROTO_LIST, *LPNET_DVR_IPC_PROTO_LIST;

typedef struct tagNET_DVR_IPC_PROTO_LIST_V41
{
    DWORD   dwSize;  
    DWORD   dwProtoNum;  //有效的ipc协议数目
    BYTE    *pBuffer;    //协议列表缓冲区, dwProtoNum 个NET_DVR_PROTO_TYPE结构  
    DWORD   dwBufferLen; //缓冲区长度
    BYTE    byRes[32];   
}NET_DVR_IPC_PROTO_LIST_V41, *LPNET_DVR_IPC_PROTO_LIST_V41;

typedef struct tagNET_DVR_PTZPOS_INFO
{
    DWORD    dwPanPos;    // P参数（水平参数）
    DWORD    dwTiltPos;    // T参数（垂直参数）
    DWORD    dwZoomPos;  // Z参数（变倍参数）
}NET_DVR_PTZPOS_INFO, *LPNET_DVR_PTZPOS_INFO;

typedef struct tagNET_VCA_HUMAN_FEATURE
{
    BYTE byAgeGroup;    //年龄段,参见 HUMAN_AGE_GROUP_ENUM
    BYTE bySex;         //性别, 0-表示“未知”（算法不支持）,1 – 男 , 2 – 女, 0xff-算法支持，但是没有识别出来
    BYTE byEyeGlass;    //是否戴眼镜 0-表示“未知”（算法不支持）,1 –不戴, 2 –戴眼镜, 3 –戴墨镜,0xff-算法支持，但是没有识别出来
    //抓拍图片人脸年龄的使用方式，如byAge为15,byAgeDeviation为1,表示，实际人脸图片年龄的为14-16之间
    BYTE byAge;//年龄 0-表示“未知”（算法不支持）,0xff-算法支持，但是没有识别出来
    BYTE byAgeDeviation;//年龄误差值
    BYTE byRes0; 
    BYTE byMask;       //是否戴口罩 0-表示“未知”（算法不支持）,1 – 不戴, 2 – 戴, 0xff-算法支持，但是没有识别出来
    BYTE bySmile;      //是否微笑 0-表示“未知”（算法不支持）,1 – 不微笑, 2 – 微笑, 0xff-算法支持，但是没有识别出来
    BYTE byFaceExpression;    /* 表情,参见FACE_EXPRESSION_GROUP_ENUM*/
    BYTE byRes1; 
    BYTE byRes2;
    BYTE byHat; // 帽子, 0-不支持,1-不戴帽子,2-戴帽子, 3-头盔 0xff-unknow表示未知,算法支持未检出
    BYTE byRes[4];    //保留
}NET_VCA_HUMAN_FEATURE ,*LPNET_VCA_HUMAN_FEATURE;

typedef struct tagNET_DVR_OBJECT_FEATURE
{
    BYTE  byColorRatel;            //颜色在移动物体中的占比阈值
    BYTE  byRed;                        // RGB颜色三分量中的红色
    BYTE  byGreen;                    // RGB颜色三分量中的绿色
    BYTE  byBlue;                   // RGB颜色三分量中的兰色
    BYTE  byRes[32];
}NET_DVR_OBJECT_FEATURE ,*LPNET_DVR_OBJECT_FEATURE;


typedef struct tagNET_DVR_TRAVERSE_PLANE_SEARCHCOND
{    
    NET_VCA_TRAVERSE_PLANE struVcaTraversePlane[MAX_ALERTLINE_NUM/*8*/];  //穿越境界面参数
    DWORD dwPreTime;   /*智能报警提前时间 单位:秒*/
    DWORD dwDelayTime; /*智能报警延迟时间 单位:秒*/ 
    NET_DVR_PTZPOS_INFO struPTZPosInfo;  //PTZ坐标信息
    BYTE  byAdvanceType;   //组合方式，0-不使用组号，1-和人脸属性组合，2-与物体颜色占比组合
    BYTE  byRes1[3];  //保留
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;  //组合属性
    BYTE  byRes[5604]; //保留
}NET_DVR_TRAVERSE_PLANE_SEARCHCOND, *LPNET_DVR_TRAVERSE_PLANE_SEARCHCOND; //越界侦测查询条件

typedef struct tagNET_DVR_INTRUSION_SEARCHCOND  
{
    NET_VCA_INTRUSION struVcaIntrusion[MAX_INTRUSIONREGION_NUM/*8*/]; //入侵区域
    DWORD dwPreTime;   /*智能报警提前时间 单位:秒*/
    DWORD dwDelayTime; /*智能报警延迟时间 单位:秒*/ 
    NET_DVR_PTZPOS_INFO struPTZPosInfo;  //PTZ坐标信息
    BYTE  byAdvanceType;//组合方式，0-不使用组号，1-和人脸属性组合，2-与物体颜色占比组合
    BYTE  byRes1[3];  //保留
    NET_DVR_ADVANCE_COND_UNION uAdvanceCond;  //组合属性
    BYTE byRes[5348]; //保留
} NET_DVR_INTRUSION_SEARCHCOND, *LPNET_DVR_INTRUSION_SEARCHCOND; //区域入侵

typedef struct tagNET_DVR_FACEDETECTION_SEARCHCOND
{
    NET_VCA_POLYGON  struFacePolygon; //识别区域
    DWORD           dwPreTime;   /*智能录像提前时间 单位:秒*/
    DWORD           dwDelayTime; /*智能录像延迟时间 单位:秒*/
    BYTE byRes[5972]; //保留
}NET_DVR_FACEDETECTION_SEARCHCOND, *LPNET_DVR_FACEDETECTION_SEARCHCOND; //人脸检测


typedef struct tagNET_DVR_SMART_SEARCH_PARAM
{
    BYTE      byChan;                    //通道号
    BYTE      bySearchCondType; //智能查找联合体NET_DVR_AREA_SMARTSEARCH_COND_UNION的索引     
    /*0-移动侦测区域 ，1-越界侦测， 2-区域入侵, 3-人脸侦测 */
    WORD      wChan;                //通道号， 该字段是对byChan的扩展，使用该字段后byChan可以不再使用
    NET_DVR_TIME struStartTime;        //录像开始的时间
    NET_DVR_TIME struEndTime;        //录像停止的时间
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;  //智能查找条件
    BYTE  bySensitivity;               //移动侦测搜索灵敏度,1    >80%  2 40%~80%  3 1%~40%    
    BYTE byRes2[11];
}NET_DVR_SMART_SEARCH_PARAM, *LPNET_DVR_SMART_SEARCH_PARAM;

typedef struct tagNET_DVR_SMART_SEARCH_PARAM_V40
{  
    DWORD                   dwSize;                 //结构体大小
    NET_DVR_STREAM_INFO   struIDInfo;           //通道信息
    BYTE                   bySearchCondType;     //智能查找联合体索引 0-侦测区域, 1-越界侦测, 2-区域入侵,3-人脸侦测, 4-车牌检测
    BYTE                  bySensitivity; //侦测区域动态分析灵敏度,1-100
    BYTE                  byRes1[2];
    NET_DVR_TIME_EX       struStartTime;  
    NET_DVR_TIME_EX       struEndTime;
    NET_DVR_AREA_SMARTSEARCH_COND_UNION uSmartSearchCond;  //智能查找条件
    BYTE   	           byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char        cStartTimeDifferenceH;   //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区，byISO8601为1时有效
    char        cStartTimeDifferenceM;   //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区，byISO8601为1时有效
    char        cStopTimeDifferenceH;    //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区，byISO8601为1时有效
    char        cStopTimeDifferenceM;    //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区，byISO8601为1时有效
    BYTE               byRes2[251];
}NET_DVR_SMART_SEARCH_PARAM_V40,*LPNET_DVR_SMART_SEARCH_PARAM_V40;

typedef struct tagNET_DVR_SMART_SEARCH_RET
{
    NET_DVR_TIME struStartTime;    //移动侦测报警开始的时间
    NET_DVR_TIME struEndTime;   //事件停止的时间
    BYTE   	     byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char  cStartTimeDifferenceH;   //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    char  cStartTimeDifferenceM;   //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    char  cStopTimeDifferenceH;    //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    char  cStopTimeDifferenceM;    //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    BYTE         byRes[59];
}NET_DVR_SMART_SEARCH_RET, *LPNET_DVR_SMART_SEARCH_RET;

typedef struct tagNET_DVR_IPSAN_SERACH_PARAM
{
    NET_DVR_IPADDR  struIP;     // IPSAN IP地址
    WORD            wPort;      // IPSAN  端口
    BYTE            byRes[10];  // 保留字节
}NET_DVR_IPSAN_SERACH_PARAM, *LPNET_DVR_IPSAN_SERACH_PARAM;

typedef struct tagNET_DVR_IPSAN_SERACH_RET
{
    BYTE byDirectory[128];  // 返回的文件目录
    BYTE byRes[20];
}NET_DVR_IPSAN_SERACH_RET, *LPNET_DVR_IPSAN_SERACH_RET;



typedef struct tagNET_DVR_ZEROCHANCFG
{
    DWORD dwSize;            //结构长度
    BYTE  byEnable;            //0-停止零通道编码，1-表示启用零通道编码
    BYTE  byRes1[3];            //保留
    DWORD dwVideoBitrate;     //视频码率 0-保留 1-16K(保留) 2-32K 3-48k 4-64K 5-80K 6-96K 7-128K 8-160k 9-192K 10-224K 11-256K 12-320K
    // 13-384K 14-448K 15-512K 16-640K 17-768K 18-896K 19-1024K 20-1280K 21-1536K 22-1792K 23-2048K
    //最高位(31位)置成1表示是自定义码流, 0-30位表示码流值(MIN-32K MAX-8192K)。
    DWORD dwVideoFrameRate;    //帧率 0-全部; 1-1/16; 2-1/8; 3-1/4; 4-1/2; 5-1; 6-2; 7-4; 8-6; 9-8; 10-10; 11-12; 12-16; 13-20, //V2.0增加14-15, 15-18, 16-22;
    BYTE  byRes2[32];        //保留
}NET_DVR_ZEROCHANCFG, *LPNET_DVR_ZEROCHANCFG;

typedef struct tagNET_DVR_ZERO_ZOOMCFG
{
    DWORD dwSize;                //结构长度
    NET_VCA_POINT  struPoint;    //画面中的坐标点
    BYTE byState;                //现在的状态，0-缩小，1-放大  
    BYTE byPreviewNumber;       //预览数目,0-1画面,1-4画面,2-9画面,3-16画面 该参数只读
    BYTE byPreviewSeq[MAX_WINDOW_V30];//画面通道信息 该参数只读
    BYTE byRes[30];                //保留 
}NET_DVR_ZERO_ZOOMCFG, *LPNET_DVR_ZERO_ZOOMCFG;

typedef struct tagNET_DVR_SNMPCFG
{
    DWORD   dwSize;            //结构长度
    BYTE    byEnable;            //0-禁用SNMP，1-表示启用SNMP
    BYTE    byRes1[3];            //保留
    WORD    wVersion;        //snmp 版本  v1 = 1, v2 =2, v3 =3，设备目前不支持 v3
    WORD    wServerPort; //snmp消息接收端口，默认 161
    BYTE    byReadCommunity[NAME_LEN]; //读共同体，最多31,默认"public"
    BYTE    byWriteCommunity[NAME_LEN];//写共同体,最多31 字节,默认 "private"
    BYTE     byTrapHostIP [DESC_LEN_64];    //自陷主机ip地址描述，支持IPV4 IPV6和域名描述    
    WORD    wTrapHostPort;   // trap主机端口
    BYTE    byTrapName[NAME_LEN];    
    BYTE    byRes2[70];    //保留
}NET_DVR_SNMPCFG, *LPNET_DVR_SNMPCFG;

typedef struct tagNET_DVR_SNMPv3_USER
{
    BYTE    byUserName[NAME_LEN];            // 用户名                
    BYTE    bySecLevel;                        // 安全级别 0-保留 1-无校验 2-无授权校验 3-授权校验
    BYTE    byAuthtype;                        // 认证类型 0-MD5认证 1-SHA认证 2: none
    BYTE    byPrivtype;                        // 0: DES; 1: AES; 2: none;
    BYTE    byRes[5];
    BYTE    byAuthpass[PASSWD_LEN];            // 认证密码
    BYTE    byPrivpass[PASSWD_LEN];            // 加密密码
}NET_DVR_SNMPv3_USER, *LPNET_DVR_SNMPv3_USER;

typedef struct tagNET_DVR_SNMPCFG_V30
{
    DWORD                dwSize;            //结构长度
    BYTE                byEnableV1;        //0-禁用SNMP V1，1-表示启用SNMP V1
    BYTE                byEnableV2;        //0-禁用SNMP V2，1-表示启用SNMP V2
    BYTE                byEnableV3;        //0-禁用SNMP V3，1-表示启用SNMP V3
    BYTE                byRes1[3];
    WORD                wServerPort;                    //snmp消息接收端口，默认 161
    BYTE                byReadCommunity[NAME_LEN];        //读共同体，最多31,默认"public"
    BYTE                byWriteCommunity[NAME_LEN];        //写共同体,最多31 字节,默认 "private"
    BYTE                 byTrapHostIP [DESC_LEN_64];        //自陷主机ip地址描述，支持IPV4 IPV6和域名描述    
    WORD                wTrapHostPort;                    // trap主机端口
    BYTE                byRes2[2];       
    NET_DVR_SNMPv3_USER    struRWUser;    // 读写用户
    NET_DVR_SNMPv3_USER    struROUser;    // 只读用户
    BYTE                byTrapName[NAME_LEN];
}NET_DVR_SNMPCFG_V30, *LPNET_DVR_SNMPCFG_V30;

typedef struct tagNET_DVR_SADPINFO
{
    NET_DVR_IPADDR  struIP;     // 设备IP地址
    WORD            wPort;      // 设备端口号
    WORD            wFactoryType;   // 设备厂家类型
    char            chSoftwareVersion[SOFTWARE_VERSION_LEN];
    char            chSerialNo[16]; // 序列号
    WORD            wEncCnt;       // 编码通道个数
    BYTE            byMACAddr[MACADDR_LEN];        // MAC 地址
    NET_DVR_IPADDR  struSubDVRIPMask;   // DVR IP地址掩码
    NET_DVR_IPADDR  struGatewayIpAddr;  // 网关
    NET_DVR_IPADDR    struDnsServer1IpAddr;            /* 域名服务器1的IP地址 */
    NET_DVR_IPADDR    struDnsServer2IpAddr;            /* 域名服务器2的IP地址 */
    BYTE            byDns;
    BYTE            byDhcp;
    BYTE            szGB28181DevID[DEV_ID_LEN];  //GB28181协议接入时的设备ID，用于IPC以GB28181协议接入
    BYTE            byActivated;//0-无效，1-已激活，2-未激活
    BYTE            byDeviceModel[NET_SDK_DEVICE_MODEL_LEN/*24*/];//设备型号
    BYTE            byRes[101];     // 保留字节
}NET_DVR_SADPINFO, *LPNET_DVR_SADPINFO;

typedef struct tagNET_DVR_SADPINFO_LIST
{
    DWORD            dwSize;   //  结构大小
    WORD             wSadpNum;   // 搜索到设备数目
    BYTE             byRes[6];   // 保留字节
    NET_DVR_SADPINFO struSadpInfo[MAX_SADP_NUM]; // 搜索
}NET_DVR_SADPINFO_LIST, *LPNET_DVR_SADPINFO_LIST;

typedef struct tagNET_DVR_SADP_VERIFY
{
    char chPassword[PASSWD_LEN];
    NET_DVR_IPADDR struOldIP;
    WORD        wOldPort;
    BYTE        byRes[62];
}NET_DVR_SADP_VERIFY, *LPNET_DVR_SADP_VERIFY;

typedef struct tagNET_DVR_DESC_NODE
{ 
    int   iValue;           
    BYTE  byDescribe[DESC_LEN_32]; //描述字段 
    DWORD dwFreeSpace;           //获取磁盘列表专用,单位为M
    BYTE  byRes[12];              //保留  
}NET_DVR_DESC_NODE, *LPNET_DVR_DESC_NODE;

typedef struct tagNET_DVR_DISKABILITY_LIST
{ 
    DWORD     dwSize;            //结构长度
    DWORD     dwNodeNum;         //能力结点个数
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];  //描述参数  
}NET_DVR_DISKABILITY_LIST, *LPNET_DVR_DISKABILITY_LIST;

typedef struct tagNET_DVR_BACKUP_NAME_PARAM
{
    DWORD dwFileNum;   //文件个数
    NET_DVR_FINDDATA_V30 struFileList[MAX_RECORD_FILE_NUM]; //文件列表
    BYTE byDiskDes[DESC_LEN_32];   //备份磁盘描述
    BYTE byWithPlayer;      //是否备份播放器
    BYTE byContinue;    /*是否继续备份 0不继续 1继续*/
    BYTE byRes[34];         //保留
}NET_DVR_BACKUP_NAME_PARAM, *LPNET_DVR_BACKUP_NAME_PARAM;

typedef struct tagNET_DVR_BACKUP_TIME_PARAM
{
    LONG            lChannel;        //按时间备份的通道
    NET_DVR_TIME    struStartTime;   //备份的起始时间
    NET_DVR_TIME    struStopTime;    //备份的终止时间
    BYTE            byDiskDes[DESC_LEN_32];     //备份磁盘描述
    BYTE            byWithPlayer;               //是否备份播放器
    BYTE            byContinue;                 //是否继续备份 0不继续 1继续
    BYTE            byDrawFrame;                 //0 不抽帧  1 抽帧
    BYTE            byUseBackCfgParam;          //使用备份配置中的参数，0-无效，1-启用(启用后，通道号无效)，2-不启用
    DWORD           dwStreamType;                //备份码流类型，按位表示
    //&0x1-表示主码流 
    //&0x2-表示子码流
    //&0x4-表示码流三
    BYTE            byRes[28];                     // 保留字节 
}NET_DVR_BACKUP_TIME_PARAM, *LPNET_DVR_BACKUP_TIME_PARAM;


typedef struct tagNET_DVR_ABILITY_LIST
{ 
    DWORD     dwAbilityType;    //能力类型 COMPRESSION_ABILITY_TYPE
    BYTE      byRes[32];        //保留字节
    DWORD     dwNodeNum;        //能力结点个数
    NET_DVR_DESC_NODE  struDescNode[MAX_NODE_NUM];  //描述参数  
}NET_DVR_ABILITY_LIST, *LPNET_DVR_ABILITY_LIST;

typedef struct tagNET_DVR_COMPRESSIONCFG_ABILITY
{ 
    DWORD     dwSize;            //结构长度
    DWORD     dwAbilityNum;        //能力类型个数
    NET_DVR_ABILITY_LIST struAbilityNode[MAX_ABILITYTYPE_NUM]; //描述参数  
}NET_DVR_COMPRESSIONCFG_ABILITY, *LPNET_DVR_COMPRESSIONCFG_ABILITY;




typedef struct tagNET_DVR_PHY_DISK_INFO
{
    WORD    wPhySlot;         // 硬盘槽位 
    BYTE    byType;         // 硬盘信息；0 普通，1全局热备，2-阵列热备 3-阵列盘
    BYTE    byStatus;       // 硬盘状态；  0-正常 1-降级 2-已删除 3-磁盘丢失 4-下线 5-次正常 6-外来 7-异常 8-SMART状态异常 9-休眠 10-有坏块,11-SMR硬盘不支持阵列功能,0xff-不存在
    BYTE    byMode[40];   // 硬盘类型 字符串
    DWORD   dwHCapacity;    //  磁盘总量高32位 单位kb
    DWORD   dwLCapacity;    //  磁盘总量低32位
    BYTE    byArrrayName[MAX_NAMELEN];
    WORD    wArrayID;          // 所属阵列ID
    BYTE    byArrayInformation;   // 是否含有阵列信息：0 否，1是
    BYTE    byRes[101];         // 保留字节  
}NET_DVR_PHY_DISK_INFO, *LPNET_DVR_PHY_DISK_INFO;

typedef struct tagNET_DVR_PHY_DISK_LIST
{
    DWORD   dwSize;
    DWORD   dwCount;
    NET_DVR_PHY_DISK_INFO struPhyDiskInfo[SUPPORT_PD_NUM];
}NET_DVR_PHY_DISK_LIST, *LPNET_DVR_PHY_DISK_LIST;



typedef struct tagNET_DVR_BGA_INFO
{
    BYTE    byBga;  // 后台任务及类型 
    BYTE    byBgaState;           /*函数返回值--后台任务状态*/
    WORD    wBgaPercentage;     /*函数返回值--后台任务执行百分比*/
    BYTE    byRes[4];  // 保留字节
}NET_DVR_BGA_INFO, *LPNET_DVR_BGA_INFO;

typedef struct tagNET_DVR_ARRAY_INFO
{
    WORD    wArrayID; // 阵列ID
    BYTE    byRaidMode; // raid模式  参照RAID_MODE
    BYTE    byStatus;  // 0-在线 1-磁盘丢失 2-下线 3-降级 4-异常 5-次正常 6-外来盘  7-已删除 8-SMART状态异常 0xff-不存在
    DWORD   dwHCapacity; // 阵列容量高32位
    DWORD   dwLCapacity; // 阵列容量低32位
    DWORD   dwHFreeSpace;   // 阵列剩余空间高32位
    DWORD   dwLFreeSpace;   // 阵列剩余空间高32位
    BYTE    byArrayName[MAX_NAMELEN]; // 阵列名称
    BYTE    byPDCount;  // 物理磁盘数目
    BYTE    bySpareCount;   // 热备数目
    BYTE    byRes1[2];
    WORD    wPDSlots[SUPPORT_PD_NUM];    // 物理磁盘索引
    WORD    wSparePDSlots[SUPPORT_PD_NUM];    // 热备磁盘索引
    NET_DVR_BGA_INFO    struBgaInfo;    // 后台任务运行状态
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];  //物理磁盘索引扩展，0表示无效
    WORD    wSparePDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];    // 热备磁盘索引扩展，0表示无效
    BYTE    byRes2[48]; // 保留字节
}NET_DVR_ARRAY_INFO, *LPNET_DVR_ARRAY_INFO;

typedef struct tagNET_DVR_ARRAY_LIST
{
    DWORD   dwSize;     // 结构体大小
    DWORD   dwCount;    // 阵列个数
    NET_DVR_ARRAY_INFO struArrayInfo[SUPPORT_ARRAY_NUM];
}NET_DVR_ARRAY_LIST, *LPNET_DVR_ARRAY_LIST;

typedef struct tagNET_DVR_VD_INFO
{
    WORD    wSlot;    //虚拟磁盘槽位  
    BYTE    byStatus; // 状态0-正常 1-降级 2-已删除 3-磁盘丢失 4-下线 5-次正常 6-外来 7-异常 8-SMART状态异常 0xff-不存在 
    BYTE    byRaidMode; // Raid 模式 参照 RAID_MODE
    WORD    wArrayID;      // 所属阵列ID
    BYTE    byRepair;   // 是否需要修复 0 不需要 1需要
    BYTE    byUsage;          //LUN卷的使用方式  0-IPSAN 1-FCSAN 2-DVR网盘 3-NAS 4-录像卷
    BYTE    byArrayName[MAX_NAMELEN];
    BYTE    byName[MAX_NAMELEN];    // 虚拟磁盘名名称
    DWORD   dwHCapacity;    // 虚拟磁盘容量高32位
    DWORD   dwLCapacity;    // 虚拟磁盘容量低32位
    DWORD   dwHFreeSpace;   // 虚拟磁盘剩余空间高32位
    DWORD   dwLFreeSpace;   // 虚拟磁盘剩余空间低32位
    NET_DVR_BGA_INFO    struBgaInfo;    // 后台运行状态
    DWORD                dwBlockSize;    //最小存储单元块大小
    NET_DVR_IPADDR        struWarrantIP;    // 授权的DVR网盘IP
    char                szArrayGroup[NAME_LEN];     //使用的阵列名称组，以逗号隔开，为空则使用默认阵列
    BYTE                byRes[20];
}NET_DVR_VD_INFO, *LPNET_DVR_VD_INFO;

typedef struct tagNET_DVR_VD_LIST
{
    DWORD   dwSize;     // 结构体大小
    DWORD   dwCount;    // 虚拟磁盘个数
    NET_DVR_VD_INFO struVDInfo[SUPPORT_VD_NUM];  //虚拟磁盘数组
}NET_DVR_VD_LIST, *LPNET_DVR_VD_LIST;

typedef struct tagNET_DVR_ADAPTER_VERSION
{
    WORD    wMajorVersion;
    WORD    wMinorVersion;
    WORD    wRevisionNumber;
    WORD    wBuildNumber;
}NET_DVR_ADAPTER_VERSION, *LPNET_DVR_ADAPTER_VERSION;

typedef struct tagNET_DVR_VD_SLOT
{
    WORD  wVDSlot;
    BYTE  byAlloc;  // 是否已经分配
    BYTE  byRes[5];
    DWORD dwHVDSlotSize;    // 虚拟磁盘空间大小高32位
    DWORD dwLVDSlotSize;    // 虚拟磁盘空间大小低32位
}NET_DVR_VD_SLOT, *LPNET_DVR_VD_SLOT;

typedef struct tagNET_DVR_ARRAY_SPACE_ALLOC_INFO
{
    BYTE    byVDSlotCount;                        /*current number of slots in DG*/ 
    BYTE    byRes1[3];              // 保留字节
    NET_DVR_VD_SLOT struVDSlots[SUPPORT_VD_NUM];
}NET_DVR_ARRAY_SPACE_ALLOC_INFO, *LPNET_DVR_ARRAY_SPACE_ALLOC_INFO;

typedef struct tagNET_DVR_RAID_ADAPTER_INFO
{
    DWORD dwSize;    // 结构体大小
    NET_DVR_ADAPTER_VERSION struVersion;    // 适配器版本号
    BYTE    bySlotCount;    //适配器槽位数
    BYTE    bySupportMigrate;  // 迁移(1-支持  0-不支持)
    BYTE    bySupportExpand;   // 扩容  (1-支持  0-不支持)
    BYTE    bySupportRebuild;  // 是否支持重建阵列 (1、支持 0-不支持)
    WORD    wSlotSupportType; //  按位表示 HD_SUPPORT_TYPE
    WORD    wSupportRaidType;      // 支持Raid 类型 按位表示  
    BYTE    byAutoRebuild;      // 0 不自动重建 1自动重建 可设
    BYTE    byRes[27];      // 保留字节
}NET_DVR_RAID_ADAPTER_INFO, *LPNET_DVR_RAID_ADAPTER_INFO;

typedef struct tagNET_DVR_OPERATE_ARRAY_PARAM
{
    //是否一键创建  如果为一键创建，则创建时时候的之需要array名称，而不需要其他参数
    // 其他参数有设备自行创建
    BYTE    byRaidMode;     // 创建/迁移时Raid的类型
    BYTE    byPDCount;  // 物理磁盘数目
    WORD    wArrayID;   // 迁移或者重建时需要指出阵列ID      
    WORD    wPDSlots[SUPPORT_PD_NUM];// 物理磁盘 
    BYTE    byName[MAX_NAMELEN];  // array 名称
    BYTE    byInitMode;              //初始化方式
    BYTE    byRes1;
    WORD    wPDSlotsPartTwo[SUPPORT_PD_NUM_PARTTWO];       //物理磁盘信息
    BYTE    byRes2[2];
}NET_DVR_OPERATE_ARRAY_PARAM, *LPNET_DVR_OPERATE_ARRAY_PARAM;

typedef struct tagNET_DVR_OPERATE_VD_PARAM
{
    WORD    wArrayID;        // 阵列ID
    BYTE    bySlot;            // 创建虚拟磁盘指定槽位
    BYTE    byInitType;     // 创建虚拟磁盘时初始化类型 0 - 快速初始化 1 - 前台完全初始化 2 - 后台完全初始化
    DWORD    dwHCapacity;    // 虚拟磁盘大小高32位
    DWORD    dwLCapacity;    // 虚拟磁盘大小低32位
    BYTE    byName[MAX_NAMELEN]; // 虚拟磁盘名称
    BYTE    byRes2[16];          // 保留字节 
}NET_DVR_OPERATE_VD_PARAM, *LPNET_DVR_OPERATE_VD_PARAM;

typedef struct tagNET_DVR_SPARE_DISK_PARAM
{
    WORD    wPDSlot;        // 物理磁盘槽位
    WORD    wArrayID;       // 所属的阵列
    BYTE    bySpareType;    // 热备类型 1-全局热备  2 指定阵列  当为指定阵列的时候需要指出所属阵列的ID
    BYTE    byRes[7];       // 保留字节
}NET_DVR_SPARE_DISK_PARAM, *LPNET_DVR_SPARE_DISK_PARAM;

typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS
{
    BYTE    byJoinStatus;//关联状态，0-没有关联，1-已经关联
    BYTE    byJoinSubSystem;//所关联子系统槽位号
    BYTE    byJoinDispNum;//所关联显示通道号
    BYTE    byJoinSubWindowNum;//所关联子窗口号
    BYTE    byRes[4];
}NET_DVR_DECSUBSYSTEMJIONSTATUS,LPNET_DVR_DECSUBSYSTEMJIONSTATUS;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO
{
    BYTE    bySubSystemType;//子系统类型，0-无，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统,5-码分子系统，6-报警子系统
    BYTE    byConnectStatus;//级联系统关联状态，1-连接正常，2-连接断开
    BYTE    byMatrixNum;//级联视频综合平台号，子系统类型是3或4时可用
    BYTE    bySubSystemNum;//级联子系统槽位号，0~79，子系统类型是3或4时可用    
    NET_DVR_DECSUBSYSTEMJIONSTATUS struDecSub [MATRIX_MAXDECSUBSYSTEMCHAN];
    BYTE    byBindStatus;//绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
    BYTE    byRes[7];
}NET_DVR_SINGLESUBSYSTEMJOININFO,LPNET_DVR_SINGLESUBSYSTEMJOININFO;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM];//80
    BYTE  byRes[8];
}NET_DVR_ALLDECSUBSYSTEMJOININFO, *LPNET_DVR_ALLDECSUBSYSTEMJOININFO;

typedef struct tagNET_DVR_NATASSOCIATECFG
{
    DWORD                  dwSize;
    NET_DVR_NETCFG_V30  struNatIpAddress[2];//NAT IP地址 
    BYTE                byNATEnable;//是否启用NAT功能，0-不启用，非0-启用
    BYTE   byNATCfgMode; //NAT配置模式，0-手动分配，1-自动分配
    BYTE   byRes[62];
}NET_DVR_NATASSOCIATECFG, *LPNET_DVR_NATASSOCIATECFG;

typedef struct tagNET_DVR_TEMPERATUREALARMCFG
{
    BYTE     byEnableTemperatureAlarm;//使能温度超限报警，0-报警，1-不报警
    BYTE     byRes1[3];
    int      iTemperatureUpLimited;    //精确到小数点后两位，如1234表示温度12.34度
    int      iTemperatureDownLimited;    
    NET_DVR_HANDLEEXCEPTION_V30 struTempHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    BYTE     byRes2[32];
}NET_DVR_TEMPERATUREALARMCFG, *LPNET_DVR_TEMPERATUREALARMCFG;

typedef struct tagNET_DVR_BOARDALARMCFG
{
    BYTE   byEnablePullAlarm;//热插拔报警使能，1-报警，0-不报警
    BYTE   byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struBoardHandleType;    /* 处理方式 */
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    BYTE   byRes2[32];
}NET_DVR_BOARDALARMCFG, *LPNET_DVR_BOARDALARMCFG;

typedef struct tagNET_DVR_VIDEOPLATFORMALARMCFG
{
    DWORD                          dwSize;
    NET_DVR_TEMPERATUREALARMCFG  struTempAlarmCfg;    
    NET_DVR_BOARDALARMCFG          struBoardAlarmCfg;    
    NET_DVR_HANDLEEXCEPTION_V30  struHandleException[MAX_EXCEPTIONNUM];//0-风扇异常，1-子系统异常，2-IP地址冲突，3-网线断，4-非法访问，5-光纤异常，6-前面板异常
    BYTE                         byRes[32];
}NET_DVR_VIDEOPLATFORMALARMCFG,*LPNET_DVR_VIDEOPLATFORMALARMCFG;

typedef struct  tagNET_DVR_CODESPLITTERASSOCIATE
{
    DWORD        dwSize;
    NET_DVR_IPADDR   struIP;  /*编码器IP地址*/
    WORD        wPort;        //编码器端口号
    BYTE        byRes1[6];
    BYTE        sUserName[NAME_LEN];    /* 用户名（32） */
    BYTE        sPassword[PASSWD_LEN];    /*密码 （16）*/
    BYTE        byChan;//编码器通道号
    BYTE        byRes2[15];
} NET_DVR_CODESPLITTERASSOCIATE, *LPNET_DVR_CODESPLITTERASSOCIATE;

typedef struct tagNET_DVR_MATRIXSUBSYSTEMINFO
{
    BYTE   byMatrixNum;//视频综合平台号
    BYTE    bySubSystemNum;//子系统槽位号
    BYTE   byRes [14];
} NET_DVR_MATRIXSUBSYSTEMINFO, *LPNET_DVR_MATRIXSUBSYSTEMINFO;

typedef struct tagNET_DVR_VIDEOPLATFORM_ALRAMINFO
{
    DWORD  dwSize;      //结构体大小
    BYTE   byAlarmType;    // 0-拔出子板，1-插入子板,2-温度超上限报警，3-温度超下限报警，4-风扇状态异常，5-子系统异常,6-非法访问，7-光纤异常报警,8-前面板异常报警
    BYTE   byBoardNum;     //子板号，从1起，B10不支持该字段，无效，置为0xff
    BYTE   byRes1[2];
    BYTE   bySubSystemChan[8]; //子板槽位号,一个子板中有8个子系统，其分别对应的槽位号，子系统异常时，bySubSystemChan[0]表示对应子系统序号        
    int    iTemperature;  //温度超限报警时有用，温度值
    BYTE   byMainboardSeq;//温度超限报警时有用，0-非主板，1-主板
    BYTE   byRes2[3];
    BYTE   byFanSequence[32];//异常风扇，byFanSequence[i] = 1表示风扇i+1异常，byFanSequence[i] = 0表示风扇i+1正常    
    NET_DVR_MATRIXSUBSYSTEMINFO struInputNote;// 光纤异常报警时使用，输入结点
    NET_DVR_MATRIXSUBSYSTEMINFO struOutputNote;//光纤异常报警时使用，输出结点
    BYTE   byRes3[68];    
}NET_DVR_VIDEOPLATFORM_ALRAMINFO,*LPNET_DVR_VIDEOPLATFORM_ALRAMINFO;

typedef struct 
{
    DWORD      dwSize;
    DWORD      dwNum;                       //刻录机的数量
    DWORD      dwRwSelectPara[MAX_CHANNUM_V30];// 是否选中该光驱
    DWORD      dwModeSelect;                //0表示循环刻录模式  1表示并行刻录模式(默认模式)
    BYTE       byRes[24];                   //保留
    DWORD       dwStartCDRW;                 //DVR 本地已经开始刻录
    DWORD      dwHdExcp;                    //硬盘有异 常
    DWORD       dwInterval;                  //时间间隔，10分钟(0)、20分钟(1)、30分钟(2)
    char        sLable[64];                  //光盘名称
}NET_DVR_INQUEST_CDRW_CFG, *LPNET_DVR_INQUEST_CDRW_CFG;


typedef struct 
{
    DWORD     dwFileNum;                     // 需要刻录或者删除的文件数，最多一次20个
    NET_DVR_INQUEST_FILEINFO struFileInfo[MAX_RECORD_FILE_NUM];
    //下面两个参数在表示刻录的文件时使用
    DWORD     dwCDIndex;                    //刻录机的索引：1:选择1号刻录机；2:选择2号刻录机； 3:3号刻录机,4:4号刻录机,5:所有刻录机
    DWORD      bFinalizeDisc;                 // 0=刻录完之后不封盘；1=刻录完之后封盘
}NET_DVR_INQUEST_FILES, *LPNET_DVR_INQUEST_FILES;

typedef struct 
{    
    DWORD     dwEnable;            //刻录机状态是否有效,0-无效,1-有效    
                                DWORD     dwStatus;            /* 当dwType=0时，
                                                            0-光盘正常，1-无光盘或光盘异常,
                                                            当dwType=1或2时，
                                                            0-刻录正常，1-无光盘或光盘异常，
                                                            2-光盘已封盘(81不支持)，3-光盘空间不足，
                                                            4-异常导致审讯终止(81不支持)
                                                            当dwType=3时，
                                                            0-刻录正常，1-无光盘或光盘异常，
                                                            2-光盘已封盘(81不支持)，3-光盘空间不足
                                                            当dwType=4时，
                                                            0-刻录正常，1-无光盘或光盘异常，
                                                            2-光盘已封盘(81不支持)，3-光盘空间不足
                                                            当dwType=5时,
                                                            0-光盘正常， 1-无光盘或光盘异常,
                                                            2-光盘已封盘(81不支持)
                                                            当dwType=6或7时,
                                                            0-刻录正常, 1-无光盘或光盘异常,
                                2-光盘已封盘(81不支持), 3-光盘空间不足*/        
                                DWORD    dwVolumn;      //光盘容量,单位M
                                DWORD    dwFreeSpace;   //光盘剩余容量,单位M    
                                DWORD    dwTimeLeft;     // 光盘剩余时间，单位秒
                                BYTE          byCDType;         // 光盘类型
                                BYTE       byRes[3];      //保留字节
}NET_DVR_INQUEST_CDRW, *LPNET_DVR_INQUEST_CDRW;

typedef struct 
{    
/*运行状态：0-审讯开始，
1-审讯过程中刻录，2-审讯停止，
3-刻录审讯文件, 
4-备份(事后备份和本地备份)
5-空闲
6-初始化硬盘
    7-恢复审讯*/
    DWORD    dwType;            
    NET_DVR_INQUEST_CDRW   strCDRWNum[MAX_INQUEST_CDRW_NUM];   //数组0表示刻录机1    
    NET_DVR_TIME_EX            struInquestStartTime;        //审讯开始的时间点
    BYTE                    byRes[16];             //保留
}NET_DVR_INQUEST_CDRW_STATUS, *LPNET_DVR_INQUEST_CDRW_STATUS;


typedef struct 
{
    BYTE     byBaseChan;          //显示画中画所在的通道
    BYTE     byBackChan;          //显示画中画背景通道
                                  BYTE     byPIPMode;           /*是否开启, 
                                                                0 当前窗口无小画面
                                                                1 当前窗口有1个小画面
                                                                2 当前窗口有2个小画面
                                                                3 当前窗口有3个小画面
                                  */
                                  BYTE     byRes;               //保留字节
                                  NET_DVR_INQUEST_PIP_PARAM  strPipPara[MAX_INQUEST_PIP_NUM];  //画面位置的参数    
}NET_DVR_INQUEST_PIP_STATUS, *LPNET_DVR_INQUEST_PIP_STATUS;

typedef struct tagNET_DVR_INQUEST_PIP_PARAM_V40
{
    BYTE     byPipChan;      /*画中画显示的通道 0xFF关闭*/ 
    BYTE     byRes1[3];
    WORD     wTopLeftX;         /*画中画的x坐标*/
    WORD     wTopLeftY;         /*画中画的Y坐标*/
    WORD     wHeight;            /*画中画的高 */
    WORD     wWidth;            /*画中画的宽 */
    BYTE     byRes2[32];
}NET_DVR_INQUEST_PIP_PARAM_V40, *LPNET_DVR_INQUEST_PIP_PARAM_V40;

typedef struct tagNET_DVR_INQUEST_PIP_STATUS_V40
{
    NET_DVR_STRUCTHEAD    struStructHead;
    BYTE             byBaseChan;     /*显示画中画所在的通道*/
    BYTE             byBackChan;     /*显示画中画背景通道*/
                                    BYTE             byPIPMode;      /*是否开启, 0 当前窗口无小画面
                                                                    1 当前窗口有1个小画面
                                                                    2 当前窗口有2个小画面
                                                                    3 当前窗口有3个小画面
                                                                    4 当前窗口有4个小画面
                                                                    5 当前窗口有5个小画面
                                                                    6 当前画面有6个小画面
                                                                    7 当前窗口有7个小画面
                                                                    8 当前窗口有8个小画面
                                                                    9 当前窗口有9个小画面
                                    255  当前窗口关闭预览画面*/
                                    BYTE                         byPipCount;          /*小画面的个数*/
                                    BYTE                        byPicShowMode; /*画面显示模式，0-画中画，1-画面均分2-画面拼接*/
                                    BYTE                        byRes[31];        /*保留*/
                                    NET_DVR_INQUEST_PIP_PARAM_V40     strPipPara[MAX_INQUEST_PIP_NUM_EX];  /*画面位置的参数*/
}NET_DVR_INQUEST_PIP_STATUS_V40, *LPNET_DVR_INQUEST_PIP_STATUS_V40;

typedef struct 
{
    BYTE    sSecretKey[16];        /*码流加密密钥*/
    BYTE    byRes[64];             /*保留字节*/
}NET_DVR_INQUEST_SECRET_INFO, *LPNET_DVR_INQUEST_SECRET_INFO;

typedef struct tagNET_DVR_SINGLESCREENCFG
{
    BYTE    byScreenSeq;//屏幕序号，0xff表示不用此屏,64-T解码器第一个表示主屏
    BYTE    bySubSystemNum;//解码子系统槽位号,解码器此值没有用
    BYTE    byDispNum;//解码子系统上对应显示通道号，64-T解码器中该值表示解码器的显示通道号
    BYTE    byRes[9];
}NET_DVR_SINGLESCREENCFG, *LPNET_DVR_SINGLESCREENCFG;

typedef struct tagNET_DVR_BIGSCREENCFG
{
    DWORD   dwSize;
    BYTE    byEnable;//大屏拼接使能，0-不使能，1-使能
    BYTE    byModeX;/*大屏拼接模式*/
    BYTE    byModeY;
    BYTE    byMainDecodeSystem;//综合平台的解码板中该值表示主屏槽位号，64-T解码器中该值表示解码通道号
    BYTE    byMainDecoderDispChan;//主屏所用显示通道号，1.1netra版本新增，netra解码器有两个显示通道，都能够作为主屏。64-T中该值无效
    BYTE    byVideoStandard;      //大屏每个子屏制式相同 1:NTSC,2:PAL
    BYTE    byRes1[2];
    DWORD  dwResolution;         //大屏每个子屏分辨率相同
    //大屏拼接从屏幕信息
    NET_DVR_SINGLESCREENCFG struFollowSingleScreen[MAX_BIGSCREENNUM]; 
    //起始坐标必须为基准坐标的整数倍
    WORD    wBigScreenX; //大屏在电视墙中起始X坐标
    WORD    wBigScreenY; //大屏在电视墙中起始Y坐标
    BYTE    byRes2[12];
}NET_DVR_BIGSCREENCFG, *LPNET_DVR_BIGSCREENCFG;

typedef struct tagNET_DVR_SUBSERVERINFO
{
    BYTE        bySequence;//序号，对于子域，是子域号，对于视频综合平台，是平台号，0表示无此平台\子域
    BYTE        byBelongSubDomain;//对于平台有效，表示属于哪个子域
    BYTE        byRes1[6];
    DWORD       dwMaxIpcNums;//连接的最多IPC数量
    NET_DVR_IPADDR struSubMatrixIP;        /*IP地址*/
    WORD        wSubMatrixPort;        /*子系统端口号*/
    BYTE        byRes2[6];
}NET_DVR_SUBSERVERINFO, *LPNET_DVR_SUBSERVERINFO;

typedef struct tagNET_DVR_UNITEDMATRIXINFO
{
    DWORD dwSize;
    NET_DVR_SUBSERVERINFO struDomainInfo;
    NET_DVR_SUBSERVERINFO struSubDomainInfo[MAX_SUBDOMAIN_NUM];//子域信息
    NET_DVR_SUBSERVERINFO struMatrixInfo[MAX_UNITEDMATRIX_NUM];//视频综合平台信息
    BYTE  byRes[32];
}NET_DVR_UNITEDMATRIXINFO, *LPNET_DVR_UNITEDMATRIXINFO;        

typedef struct tagNET_DVR_REGCALLBACKPARAM
{
    char sDeviceID[NAME_LEN];//设备ID串
    char sPassword[PASSWD_LEN];
    BYTE sSerialNumber[SERIALNO_LEN]; /* 设备序列号 */
    DWORD dwDeviceType;//设备类型
    BYTE nStatus;// 上下线状态（0下线，1上线）
    /* net type, 0: unknow; 1: 2G wireless networks; 2: 3G wireless networks; 3: line networks */
    BYTE byNetType;    
    BYTE byRes[14];
}NET_DVR_REGCALLBACKPARAM, *LPNET_DVR_REGCALLBACKPARAM;

typedef struct tagNET_DVR_LOGONREPONSEPARAM
{
    //心跳时间间隔，单位：秒, 5的倍数，180秒以内。默认是15秒。
    WORD wHeartbeatTime;
    BYTE byOvertimes;// 设备心跳超时次数，默认是3次
    BYTE byRes[13];    
}NET_DVR_LOGONREPONSEPARAM, *LPNET_DVR_LOGONREPONSEPARAM;

typedef struct tagNET_DVR_PREVIEWPARAM
{
    BYTE byTransProtol;        //传输协议，0-TCP, 1-UDP
    BYTE byTransMode;        ///* 传输码流模式 0－主码流 1－子码流*/ 
    NET_DVR_IPADDR struCuIp; //CU端IP地址
    WORD wPort;/*CU端口*/
    WORD wUdpPort;
    BYTE bySupportQos;//是否启用QOS,1-启用，0-不启用
    //是否是NAT预览请求，0-否，1-是(只需byTransMode字段)
    BYTE  byNatRequest;
    BYTE  byPreviewType;// 0-普通预览 1-延时预览
    BYTE  byRes[7];
}NET_DVR_PREVIEWPARAM, *LPNET_DVR_PREVIEWPARAM;

typedef struct tagNET_DVR_DEVICENATINFO
{
    NET_DVR_IPADDR struPuIp; //PU端外网IP地址
    WORD    wOuterPort;/*PU外网端口*/
    WORD    wInterPort;//PU发送视频的本地端口
    DWORD   nSessionID;//CMS分配的sessionID
    BYTE    byRes[4];
}NET_DVR_DEVICENATINFO, *LPNET_DVR_DEVICENATINFO;

typedef struct tagNET_DVR_PREVIEWCALLBACKPARAM
{
    LONG lChannel;
    BYTE nLinkProtocol;
    BYTE nTransMode;
    BYTE byPreviewType; //0-普通预览 1-延时预览
    BYTE byRes[5];
    DWORD nSessionID;//CMS分配的sessionID
}NET_DVR_PREVIEWCALLBACKPARAM, *LPNET_DVR_PREVIEWCALLBACKPARAM;

typedef struct tagNET_DVR_PLAYBACKREQUESTPARAM
{
    BYTE byPlayBackMode;        /* 回放下载模式 1－按名字 2－按时间 */
    BYTE byRes1[3];
    union
    {
        char sFileName [100];        /* 回放的文件名 */
        struct 
        {
            LONG    lChannel;                /*回放的通道号*/
            NET_DVR_TIME struStartTime;            /* 按时间回放的开始时间 */
            NET_DVR_TIME struStopTime;            /* 按时间回放的结束时间 */
            BYTE    byRes[48];
        }struPlayBackbyTime;
    }playbackmode;
    NET_DVR_IPADDR struCuIp; //CU端IP地址
    WORD    wPort;/*CU端口*/
    BYTE    byRes2[2];
    DWORD   dwSessionID;//CMS分配的sessionID,输出参数
    BYTE    byRes3[16];
}NET_DVR_PLAYBACKREQUESTPARAM, *LPNET_DVR_PLAYBACKREQUESTPARAM;    

typedef struct tagNET_DVR_PLAYBACKCALLBACKPARAM
{
    BYTE byPlayBackMode;        /* 回放下载模式 1－按名字 2－按时间 */
    BYTE byRes1[3];
    union
    {
        char sFileName [100];        /* 回放的文件名 */
        struct 
        {
            LONG        lChannel;                /*回放的通道号*/
            NET_DVR_TIME struStartTime;            /* 按时间回放的开始时间 */
            NET_DVR_TIME struStopTime;            /* 按时间回放的结束时间 */
            BYTE       byRes[48];
        }struPlayBackbyTime;
    }playbackmode;
    DWORD nSessionID;//CMS分配的sessionID
    BYTE byRes2[44];
}NET_DVR_PLAYBACKCALLBACKPARAM, *LPNET_DVR_PLAYBACKCALLBACKPARAM;  

typedef struct tagNET_DVR_VOICEREQUESETPARAM
{
    BYTE    nVoiceChannel;        //对讲通道号
    BYTE    byRes1[3];
    NET_DVR_IPADDR struCuIp; //CU端IP地址
    WORD     wPort;/*CU端口*/
    BYTE    byRes2[10];
}NET_DVR_VOICEREQUESTPARAM, *LPNET_DVR_VOICEREQUESTPARAM;             

typedef struct tagNET_DVR_ALARMSETUPREQUESETPARAM
{
    NET_DVR_IPADDR struCuIp; //CU端IP地址
    WORD     wPort;/*CU端口*/
    BYTE    byRes[2];
}NET_DVR_ALARMSETUPREQUESTPARAM, *LPNET_DVR_ALARMSETUPREQUESTPARAM;        

typedef struct tagNET_DVR_GPSALARMINFO
{
    BYTE byDeviceID[NAME_LEN];/*设备的ID串*/
    NET_DVR_TIME_EX struGpsTime;    /*GPS上传的时间*/
    DWORD    dwLongitude;    /* 经度*/
    DWORD    dwLatitude;  /* 纬度*/
    int     iTimeZone; /*时区，用分钟数表示，+60代表东1区，+480代表东8区，-60代表西区，-480代表西8区，该字段和GPSTime构成一个完整的时间描述*/ 
    DWORD dwDirection; /*车辆方向=实际方向（以度为单位，正北方向为，顺时针方向计算）*100*/
    WORD  wSatellites; /*卫星数量*/
    WORD  wPrecision; /*精度*/
    DWORD dwHeight; /*高度:厘米，预留*/
    DWORD dwGPSSeq; /*GPS序号，GPS补传时要用到*/
    WORD  wSpeed;//速度，单位，km/h
    /* direction[0]:'E'or'W'(东经/西经), direction[1]:'N'or'S'(北纬/南纬)*/
    char sDirection[2]; 
    BYTE byLocateMode;/*定位模式(初值0)，1,自主定位,2,差分3,估算,4,数据无效，65,有效定位，78，无效定位*/  
    BYTE byRes[3];
}NET_DVR_GPSALARMINFO, *LPNET_DVR_GPSALARMINFO;

typedef struct tagNET_DVR_PICINFO
{
    DWORD   dwSize;                //结构长度
    BYTE    byChanIndex;            //通道号
    BYTE    byRes1[3];                //保留
    BYTE     byDeviceID[NAME_LEN];/*设备的ID串*/
    BYTE    byAbsTime[32];        //绝对时间点, yyyymmddhhmmssxxx,
    DWORD   dwPicLen;                    //图片长度
    BYTE    byRes2[32];
    BYTE    *pPicBuffer;
}NET_DVR_PICTUREINFO, *LPNET_DVR_PICTUREINFO;

typedef struct tagNET_DVR_CMSPARAM
{
    DWORD   dwSize;
    NET_DVR_IPADDR struCmsAddr;
    WORD   wCmsPort;
    BYTE   byRes1[2];
    BYTE   sDeviceID[NAME_LEN];
    BYTE   byPassword[PASSWD_LEN];
    NET_DVR_IPADDR struPicServerAddr;
    WORD   wPicServerPort;
    WORD   wCmsUdpPort;//CMS用于UDP外网查询的端口
    BYTE   byRes2[12];
}NET_DVR_CMSPARAM, *LPNET_DVR_CMSPARAM;

typedef struct tagNET_DVR_QOSPARAM
{
    WORD wMaxBitUL;    /* the maximum number of kbits/s in up-link traffic */
    WORD wMaxBitDL;    /* the maximum number of kbits/s in down-link traffic */
    BYTE byTrafficClass;    /* 0: conversationnal; 1: streaming; 2: interactive;3: background; 4: subscribed value(default) */
    BYTE byRes[7];
}NET_DVR_QOSPARAM, *LPNET_DVR_QOSPARAM;

typedef struct tagNET_DVR_PPPDPARAM
{
    BYTE byDialNum[NAME_LEN];        /* dial number, eg. "#777" */
    BYTE byUserName[NAME_LEN];    /* user name, eg. "card" */
    BYTE byPassword[DIALPASSWD_LEN];    /* password, eg. "card" */
    BYTE byApn[NAME_LEN];        /* access point name, eg. "cmnet" */
    NET_DVR_IPADDR struLocalIp;/* local IP address */
    NET_DVR_IPADDR struRemoteIp;/* remote IP address */
    WORD wMtuSize;        /* max transfer unit of ppp interface */
    BYTE byVerifyProtocal;    /* IPCP verify protocal: 0: auto; 1: CHAP; 2: PAP */
    BYTE byRes[25];    
}NET_DVR_PPPDPARAM, *LPNET_DVR_PPPDPARAM;

typedef struct tagNET_DVR_DIALPARAM
{
    DWORD dwSize;
    BYTE bEnable3G;        /* 0: disable; 1: enable 3g */
    BYTE byDialMethod;        /* dial methold: 0: auto dial; 1: manual dial; */
    BYTE bySwitchMethod;    /* switch methold: 0: auto switch;1：3G优先，2: manual switch to 2G; 3: manual switch to 3G; */
    BYTE byEnaAlarmInDial;   /* 使能报警输入触发拨号; 0: disable; 1: enable */
    BYTE byRes1[10];
    WORD wOffLineTime;        /* auto off line when no connection exist,单位：分钟，范围：5~65535分钟 */    
    NET_DVR_PPPDPARAM struPppdParam;
    NET_DVR_QOSPARAM struQosParam;
    BYTE byUimNumber[MAX_PHONE_NUM];
    BYTE byRes2[24];
}NET_DVR_DIALPARAM, *LPNET_DVR_DIALPARAM;

typedef struct tagNET_DVR_DIALREQUEST
{
    BYTE byConnNum;        /*网卡序号*/
    BYTE byNetType;        /* 指定获得某个网络的默认拨号参数，设置时此参数没用。0：自动；1：CDMA；2：EVDO；3：WCDMA；4：TD-SCDMA */
    BYTE byRes[6];
} NET_DVR_DIALREQUEST, *LPNET_DVR_DIALREQUEST;



typedef struct tagNET_DVR_DIALSTATUS
{
    BYTE byRealMode;        /* REAL_MODE ,real 3g mode networks */
    BYTE byUimCard;        /* UIM_INFO ,UIM card information */
    BYTE byRes1[6];
    DWORD dwSignal;            /* signal RSSI */
    DWORD dwDialStatus;        /* dial status */
    NET_DVR_IPADDR struLocalIp;    /* wireless networks IP address */
    NET_DVR_IPADDR struRemoteIp;    /* wireless networks gateway */
    NET_DVR_IPADDR struNetMask;    /* wireless networks netmask */
    NET_DVR_IPADDR struDns;        /* wireless networks DNS */     
    BYTE  byRes2[16];
}NET_DVR_DIALSTATUS, *LPNET_DVR_DIALSTATUS;

typedef struct tagNET_DVR_PHONECFG
{
    BYTE byAllowList[MAX_PHONE_NUM];
    BYTE byPhonePerssion[32]; /*按字节表示是否使能该号码的某功能，具体位代表的含义
    见PHONECFG_RECEIVE_SMS等定义 */
    BYTE byAlarmHandler[32];   /*按字节表示是否使能对某个报警类型的短信发送*/
    BYTE byRes[128];
} NET_DVR_PHONECFG, *LPNET_DVR_PHONECFG;

typedef struct tagNET_DVR_SMSRELATIVEPARAM
{
    DWORD dwSize;
    BYTE bEnableSmsAlarm;    /* 0: disable; 1: enable 3g */
    BYTE byRes1[7];
    NET_DVR_PHONECFG struAllowList[MAX_ALLOWLIST_NUM];
    BYTE byRes2[32];
}NET_DVR_SMSRELATIVEPARAM, *LPNET_DVR_SMSRELATIVEPARAM;

typedef struct tagNET_DVR_PHONECFG_V50
{
    BYTE byAllowList[MAX_PHONE_NUM];
    BYTE byPhonePerssion[32]; /*按字节表示是否使能该号码的某功能，具体位代表的含义
                              见PHONECFG_RECEIVE_SMS等定义 */
    BYTE byAlarmHandler[32];   /*按字节表示是否使能对某个报警类型的短信发送(门禁主机暂时用不到)*/
    BYTE byAcsPassword[16];       /*开门命令*/
    BYTE byName[NAME_LEN/*32*/];     /*姓名*/
    BYTE byRes[80];
} NET_DVR_PHONECFG_V50, *LPNET_DVR_PHONECFG_V50;

typedef struct tagNET_DVR_SMSRELATIVEPARAM_V50
{
    DWORD dwSize;
    BYTE bEnableSmsAlarm;    /* 0: disable; 1: enable 3g */
    BYTE byRes1[7];
    NET_DVR_PHONECFG_V50 struAllowList[NET_SDK_MAX_ALLOWLIST_NUM_32];
    BYTE byRes2[32];
}NET_DVR_SMSRELATIVEPARAM_V50, *LPNET_DVR_SMSRELATIVEPARAM_V50;

typedef struct tagNET_DVR_ACS_EVENT_COND
{
    DWORD dwSize;
    DWORD dwMajor; //报警主类型，参考事件上传宏定义，0-全部
    DWORD dwMinor; //报警次类型，参考事件上传宏定义，0-全部
    NET_DVR_TIME    struStartTime; //开始时间
    NET_DVR_TIME    struEndTime; //结束时间
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
    BYTE byName[NAME_LEN]; //持卡人姓名
    BYTE byPicEnable; //是否带图片，0-不带图片，1-带图片
    BYTE byTimeType; //时间类型：0-设备本地时间（默认），1-UTC时间（struStartTime和struEndTime的时间）
    BYTE byRes2[2]; //保留
    DWORD dwBeginSerialNo; //起始流水号（为0时默认全部）
    DWORD dwEndSerialNo; //结束流水号（为0时默认全部）
    DWORD dwIOTChannelNo; //IOT通道号，0-无效
    WORD  wInductiveEventType; //归纳事件类型，0-无效，其他值参见2.2章节，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
    BYTE   bySearchType;      //搜索方式：0-保留，1-按事件源搜索（此时通道号为非视频通道号），2-按监控点ID搜索
    BYTE   byEventAttribute; //事件属性：0-未定义，1-合法事件，2-其它
    char     szMonitorID[NET_SDK_MONITOR_ID_LEN/*64*/];          //监控点ID（由设备序列号、通道类型、编号组成，例如门禁点：设备序列号+“DOOR”+门编号）
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //工号（人员ID）
    BYTE byRes[140]; //保留
}NET_DVR_ACS_EVENT_COND, *LPNET_DVR_ACS_EVENT_COND;

typedef struct tagNET_DVR_ACS_EVENT_DETAIL
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号（mac地址），为0无效
    BYTE byCardType; //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
    BYTE byAllowListNo; //允许名单单号,1-8，为0无效
    BYTE byReportChannel; //报告上传通道，1-布防上传，2-中心组1上传，3-中心组2上传，为0无效
    BYTE byCardReaderKind; //读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
    DWORD dwCardReaderNo; //读卡器编号，为0无效
    DWORD dwDoorNo; //门编号（楼层编号），为0无效
    DWORD dwVerifyNo; //多重卡认证序号，为0无效
    DWORD dwAlarmInNo;  //报警输入号，为0无效
    DWORD dwAlarmOutNo; //报警输出号，为0无效
    DWORD dwCaseSensorNo; //事件触发器编号
    DWORD dwRs485No;    //RS485通道号，为0无效
    DWORD dwMultiCardGroupNo; //群组编号
    WORD wAccessChannel;    //人员通道号
    BYTE  byDeviceNo; //设备编号，为0无效（有效范围1-255）
    BYTE  byDistractControlNo;//分控器编号，为0无效
    DWORD dwEmployeeNo; //工号，为0无效
    WORD wLocalControllerID; //就地控制器编号，0-门禁主机，1-64代表就地控制器
    BYTE  byInternetAccess; //网口ID：（1-上行网口1,2-上行网口2,3-下行网口1）
    BYTE  byType;     //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区 0xff-无
    BYTE  byMACAddr[MACADDR_LEN]; //物理地址，为0无效
    BYTE  bySwipeCardType;//刷卡类型，0-无效，1-二维码
    BYTE  byEventAttribute; //事件属性：0-未定义，1-合法认证，2-其它
    DWORD dwSerialNo; //事件流水号，为0无效
    BYTE  byChannelControllerID; //通道控制器ID，为0无效，1-主通道控制器，2-从通道控制器
    BYTE  byChannelControllerLampID; //通道控制器灯板ID，为0无效（有效范围1-255）
    BYTE  byChannelControllerIRAdaptorID; //通道控制器红外转接板ID，为0无效（有效范围1-255）
    BYTE  byChannelControllerIREmitterID; //通道控制器红外对射ID，为0无效（有效范围1-255）
    DWORD dwRecordChannelNum; //录像通道数目
    char    *pRecordChannelData;//录像通道，大小为sizeof(DWORD)* dwRecordChannelNum
    BYTE  byUserType; //人员类型：0-无效，1-普通人（主人），2-来宾（访客），3-禁止名单人，4-管理员
    BYTE  byCurrentVerifyMode; //读卡器当前验证方式：0-无效，1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码，5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码，10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，
            //13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡，23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码，28-人脸或密码，29-工号+人脸+密码，30-刷卡或人脸或人脸+刷卡，31-人脸或指纹或密码，32-虹膜，33-人脸或指纹或刷卡或密码或虹膜，34-人脸或刷卡或密码或虹膜
    BYTE  byAttendanceStatus;  //考勤状态：0-未定义,1-上班，2-下班，3-开始休息，4-结束休息，5-开始加班，6-结束加班
    BYTE  byStatusValue;  //考勤状态值
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //工号（人员ID）（对于设备来说，如果使用了工号（人员ID）字段，byEmployeeNo一定要传递，如果byEmployeeNo可转换为dwEmployeeNo，那么该字段也要传递；对于上层平台或客户端来说，优先解析byEmployeeNo字段，如该字段为空，再考虑解析dwEmployeeNo字段）
    BYTE  byRes1; //保留
    BYTE  byMask; //是否带口罩：0-保留，1-未知，2-不戴口罩，3-戴口罩
    BYTE  byThermometryUnit; //测温单位（0-摄氏度（默认），1-华氏度，2-开尔文）
    BYTE  byIsAbnomalTemperature; //人脸抓拍测温是否温度异常：1-是，0-否
    float fCurrTemperature; //人脸温度（精确到小数点后一位）
    NET_VCA_POINT struRegionCoordinates; //人脸温度坐标
    BYTE  byRes[48];
}NET_DVR_ACS_EVENT_DETAIL, *LPNET_DVR_ACS_EVENT_DETAIL;

typedef struct tagNET_DVR_ACS_EVENT_CFG
{
    DWORD dwSize;
    DWORD dwMajor; //报警主类型，参考宏定义
    DWORD dwMinor; //报警次类型，参考宏定义
    NET_DVR_TIME struTime; //时间
    BYTE    sNetUser[MAX_NAMELEN];//网络操作的用户名
    NET_DVR_IPADDR    struRemoteHostAddr;//远程主机地址
    NET_DVR_ACS_EVENT_DETAIL struAcsEventInfo; //详细参数
    DWORD dwPicDataLen;   //图片数据大小，不为0是表示后面带数据
    char    *pPicData;
    WORD  wInductiveEventType; //归纳事件类型，0-无效，其他值参见2.2章节，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
    BYTE byTimeType; //时间类型：0-设备本地时间（默认），1-UTC时间（struTime的时间）
    BYTE byRes1;
    DWORD dwQRCodeInfoLen; //二维码信息长度，不为0是表示后面带数据
    DWORD dwVisibleLightDataLen; //热成像相机可见光图片长度，不为0是表示后面带数据
    DWORD dwThermalDataLen; //热成像图片长度，不为0是表示后面带数据
    char *pQRCodeInfo; //二维码信息指针
    char *pVisibleLightData; //热成像相机可见光图片指针
    char *pThermalData; //热成像图片指针
    BYTE byRes[36];
}NET_DVR_ACS_EVENT_CFG, *LPNET_DVR_ACS_EVENT_CFG;

typedef struct tagNET_DVR_SMSLISTINFO
{
    DWORD  dwSize;
    DWORD dwTotalSmsNum;//短信条数
    BYTE  byRes[8];
    BYTE  *pSmsParam;
    DWORD dwBufLen;//所分配指针长度，输入参数
}NET_DVR_SMSLISTINFO, *LPNET_DVR_SMSLISTINFO;

typedef struct tagNET_DVR_SMSPARAM
{
    DWORD dwIndex;            /* the index of sms */
    BYTE byStatus;            /* read yet or not */
    BYTE byRes[7];
    NET_DVR_TIME_EX struRecvTime;        /* sms receive time */
}NET_DVR_SMSPARAM, *LPNET_DVR_SMSPARAM;

typedef struct tagNET_DVR_SMSCONTENT
{
    BYTE byPhoneNum[MAX_PHONE_NUM];
    BYTE byMsg[MAX_SMSCONTENT_LEN];
}NET_DVR_SMSCONTENT, *LPNET_DVR_SMSCONTENT;     


typedef struct tagNET_DVR_PINSTATUS
{
    DWORD dwSize;
    BYTE byStatus;        /* PIN status, defination see enum: PIN_READY */
    BYTE byPinTimes;    /* remain input PIN times */
    BYTE byPukTimes;    /* remain input PUK times */    
    BYTE bEnableLock;    /* now the PIN locking function is enabled or not: 0, not enabled lock; 1, lock enabled */
    BYTE byRes[4];
}NET_DVR_PINSTATUS, *LPNET_DVR_PINSTATUS;


typedef struct tagNET_DVR_PINCODEPARAM
{
    DWORD dwSize;
    BYTE byPinCmd;        /* PIN command, defination see enum: PIN_CMD */
    BYTE byRes1[3];
    BYTE byPinCode[MAX_PIN_LEN];        /* pin/puk code */
    BYTE byNewPinCode[MAX_PIN_LEN];    /* new pin code */
    BYTE byRes2[16];
}NET_DVR_PINCODEPARAM, *LPNET_DVR_PINCODEPARAM;

typedef struct 
{
    /* 0=CIF, 1=QCIF, 2=D1 3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6=VGA*/
    WORD    wPicSize;
    WORD    wPicQuality; /* 图片质量系数 0-最好 1-较好 2-一般 */
    //抓图图片处理方式，1-上传中心，2-设备本地保存，3-上传中心同时设备本地保存
    BYTE    byPicTackleMode; 
    BYTE   byRes[11];
}NET_DVR_PUSHJPEGPARA, *LPNET_DVR_PUSHJPEGPARA;

typedef struct tagNET_DVR_PUSHALARMINFO
{
    DWORD dwAlarmType;/*0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问*/
    DWORD dwAlarmInputNumber;/*报警输入端口*/
    DWORD dwAlarmOutputNumber[MAX_ALARMOUT];/*触发的输出端口，哪一位为1表示对应哪一个输出*/
    DWORD dwAlarmRelateChannel[MAX_CHANNUM];/*触发的录像通道，哪一位为1表示对应哪一路录像, dwAlarmRelateChannel[0]对应第1个通道*/
    DWORD dwChannel[MAX_CHANNUM];/*dwAlarmType为2或3,6时，表示哪个通道，dwChannel[0]对应第1个通道*/
    DWORD dwDiskNumber[MAX_DISKNUM];/*dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]位对应第1个硬盘*/
    BYTE byDeviceID[NAME_LEN];/*设备的ID串*/
    BYTE byRes[4];
}NET_DVR_PUSHALARMINFO, *LPNET_DVR_PUSHALARMINFO;

typedef struct 
{
    DWORD dwAlarmType;/*0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常，10-录像异常 11- 智能场景变化  12-阵列异常 */
    DWORD dwAlarmInputNumber;/*报警输入端口*/
    BYTE byAlarmOutputNumber[MAX_ALARMOUT_V30];/*触发的输出端口，为1表示对应输出*/
    BYTE byAlarmRelateChannel[MAX_CHANNUM_V30];/*触发的录像通道，为1表示对应录像, dwAlarmRelateChannel[0]对应第1个通道*/
    BYTE byChannel[MAX_CHANNUM_V30];/*dwAlarmType为2或3,6，9，10时，表示哪个通道，dwChannel[0]对应第1个通道*/
    BYTE byDiskNumber[MAX_DISKNUM_V30];/*dwAlarmType为1,4,5时,表示哪个硬盘, dwDiskNumber[0]对应第1个硬盘*/
    BYTE byDeviceID[NAME_LEN];/*设备的ID串*/
    BYTE byRes[7];
}NET_DVR_PUSHALARMINFO_V30, *LPNET_DVR_PUSHALARMINFO_V30;

typedef struct tagNET_DVR_MB_AUTOWORKPARA
{
    /*当前启动控制方式 0:  预留,  1:  延时关机,  2:  自动开关机*/
    BYTE    byCurPowerCtrlType;   
    BYTE    byRes[3];
    NET_DVR_SCHEDTIME    struWorkTime[MAX_DAYS][2];    
}NET_DVR_MB_AUTOWORKPARA, *LPNET_DVR_MB_AUTOWORKPARA;

typedef struct tagNET_DVR_MB_POWERCTRLPARA
{
    DWORD    dwSize;
    DWORD     dwHaltDelay; /* 关机延迟时间,单位min */
    NET_DVR_MB_AUTOWORKPARA  struAutoWorkPara;/*启动控制相关参数设置*/
    BYTE       byEnableUnderVoltProtect;   /*是否开启欠压保护*/
    BYTE       byUnderVoltPercent;   /*欠压保护百分比，有85、90、95三个有效值*/
    BYTE       byRes[34];
}NET_DVR_MB_POWERCTRLPARA, *LPNET_DVR_MB_POWERCTRLPARA;

typedef struct tagNET_DVR_MB_AUTOBACKUPPARA
{
    DWORD dwSize;
    BYTE  byEnableAutoBackup; /* 是否开启自动备份 0 关闭 ，1 开启 */
    BYTE  byRes1[3];
    BYTE  byBackupChannel[MAX_CHANNUM_V30];     /*需要备份的通道*/
    BYTE  byBackupDays[MAX_CHANNUM_V30];/*备份天数*/
                                        /* 备份文件类型 
                                        {0,ALL_RECORD_TYPE,全部},
                                        {1,TIMING_REC,定时},
                                        {2,MOTION_DETECT_REC,移动侦测 },
                                        {3,ALARM_REC,报警 },
    {4,MANUAL_REC,手动录像}*/
    BYTE  byBackupFileType[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struBackupTime[MAX_CHANNUM_V30][2];    /* 自动备份时间段*/                
    BYTE  byRes2[36];                        /* 保留字节*/
}NET_DVR_MB_AUTOBACKUPPARA, *LPNET_DVR_MB_AUTOBACKUPPARA;

typedef struct tagNET_DVR_MB_GPSPARA
{
    DWORD dwSize;
    BYTE  byEnableGPS;    /*是否启用GPS */
    BYTE  byGpsInterface;/*gps接收接口0-rs232, 1-rs485, 2-frontpanel, 3-lcd */
    BYTE  bySpeedUnit;  /*速度单位，0：公里/小时，1 ：英里/小时*/
    BYTE  byEnableRetrieve; /* 盲区补发(1启用，0不启用) */
    int      iAdjustTime;/*时区*/
    BYTE  byEnableAdjustTime;/*是否启用GPS校时， 1-启用, 0-不启动*/
    BYTE  byRes1[5];
    WORD  wGpsUploadInterval;    /* GPS上传间隔, 秒*/
    BYTE  byGpsOsdChannel[MAX_CHANNUM_V30];/*OSD 显示，每字节代表一路 */
    DWORD dwSpeedLimit;    /* 限速报警*/
    NET_DVR_HANDLEEXCEPTION_V30  struGpsAlarm; 
    BYTE  byRes2[36];
}NET_DVR_MB_GPSPARA, *LPNET_DVR_MB_GPSPARA;

typedef struct tagNET_DVR_MB_SENSORINPARA
{
    DWORD dwSize;
    BYTE  byTriggerType[SENSOR_IN_NUMBER];/*行车状态相关触发的联动，只用后4个，分别代表刹车、左转、右转、倒车，0-高电平，1-低电平*/
    BYTE  byTriggerChannel [SENSOR_IN_NUMBER];
    BYTE  byOsdDisplay [MAX_CHANNUM_V30];/*OSD显示,每位代表一路*/
    BYTE  byRes[32];
}NET_DVR_MB_SENSORINPARA, *LPNET_DVR_MB_SENSORINPARA;

typedef struct tagNET_DVR_ACCELERATIONCFG
{
    DWORD    dwMaxXAcc;    /* X轴加速度报警值 ，该取值为实际数值乘以10,最小为0*/
    DWORD    dwMaxYAcc;    /* Y轴加速度报警值 ，该取值为实际数值乘以10.最小为0*/
    DWORD    dwMaxZAcc;    /* Z轴加速度报警值， 该取值为实际数值乘以10,最小为0*/
    BYTE    byRes[4];
}NET_DVR_ACCELERATIONCFG,*LPNET_DVR_ACCERATIONCFG;

typedef struct tagNET_DVR_GSENSORPARA
{
    DWORD dwSize;
    NET_DVR_ACCELERATIONCFG struAccelerationCfg;
    BYTE  byModuleSelect;/*模块选择：0内置/1外置*/
    BYTE  byRes1[3];
    NET_DVR_HANDLEEXCEPTION_V30 struHandleException;
    BYTE  byRes2[24];    /*保留扩展字节*/
}NET_DVR_GSENSORPARA, *LPNET_DVR_GSENSORPARA;

typedef struct tagNET_DVR_MB_DOWNLOADSVRPARA
{
    DWORD dwSize;
    NET_DVR_IPADDR    struDownloadSvrIp;        /* 自动下载服务器地址 */
    BYTE  byRes[64];
}NET_DVR_MB_DOWNLOADSVRPARA,*LPNET_DVR_MB_DOWNLOADSVRPARA;

typedef struct tagNET_DVR_PLATERECOG_PARA
{
    DWORD dwSize;
    BYTE byPrMode; /* 车牌识别的模式, 静态图像0/动态视频1 */
    BYTE byPrScene; /* 车牌识别的场景, 低速场景0/高速场景1 */
    BYTE byPrDetRect; /* 0:全屏幕;1:中心区域 */
    BYTE byPrPicQuality; /* 车牌识别返回的图片质量, 0:最低/3:最高 */    
    BYTE byPrPicMode;/*车牌识别返回的图片分辨率: JPEG_MODE_D1, JPEG_MODE_CIF, JPEG_MODE_QCIF */
    BYTE byPlateOsdDisplay; /* 车牌OSD是否显示 0:不显示/1:显示 */
    BYTE byPrProvCharIndex;    /* 车牌识别省份首汉字对应的索引 */
    BYTE byPrProvCharIndex1;    /* 车牌识别常见首汉字1对应的索引 */
    BYTE byPrProvCharIndex2;    /* 车牌识别常见首汉字2对应的索引 */
    BYTE byRes[7];
}NET_DVR_PLATERECOG_PARA, *LPNET_DVR_PLATERECOG_PARA;

typedef struct tagNET_DVR_SPEEDLMT_PARA
{
    BYTE    bStartMaxSpeedLimit;        /* 开启高速限制 */
    BYTE    bStartMinSpeedLimit;        /* 开启低速限制 */
    BYTE    byRes[6];
    DWORD    dwMaxSpeedLimit;                /* 最高限速 */
    DWORD    dwMinSpeedLimit;                /* 最低限速 */
}NET_DVR_SPEEDLMT_PARA, *LPNET_DVR_SPEEDLMT_PARA;

typedef struct tagNET_DVR_PLATECHECK_PARA
{
    BYTE    bAlarmWhenChecked;            /* 稽查成功是否报警 */
    BYTE    bInformWhenChecked;            /* 稽查成功是否对话框提示 */
    BYTE    byRes[6];
    NET_DVR_IPADDR struBlockFtpServer;            /* 禁止名单FTP服务器地址 */
}NET_DVR_PLATECHECK_PARA, *LPNET_DVR_PLATECHECK_PARA;

typedef struct tagNET_DVR_ENFORCESYS_PARA
{
    DWORD dwSize;
    NET_DVR_SPEEDLMT_PARA    struSpeedLmtPara;    /*限速设置*/
    NET_DVR_PLATECHECK_PARA struPlateCheckPara;    /*车牌比对*/
    BYTE    bySelPeccType;    /*是否选择违章类型*/
    BYTE    byEnfOptHabit; /*取证操作习惯, 0:长按取证;1:短按两次取证*/
                           /*预览帧率调节模式分三种：
                           A 关闭 adjPrevFpsMode=0
                           以固定高帧率(25FPS)预览
                           B 标准 adjPrevFpsMode=1
                           以固定低帧率(6FPS)预览
                           C 自适应 adjPrevFpsMode=2
                           根据GPS速度信息动态调整预览帧率，
    3秒无有效GPS的情况下，以固定高帧率预览*/
    BYTE    byAdjPrevFpsMode;        
    BYTE    byRes1;
    NET_DVR_IPADDR  struUploadServerIp; //上传服务器地址
    WORD    wUploadServerPort;
    BYTE    byRes2[18];
}NET_DVR_ENFORCESYS_PARA, *LPNET_DVR_ENFORCESYS_PARA;

typedef struct tagNET_DVR_PUSHMODEPARAM
{
    //直连模式下UDP预览模式，1-同端口多路流，2-一端口一路流
    BYTE byUdpPreviewMode; 
    //语音对讲工作模式，0-语音对讲，1-语音转发（SDK不进行语音的采集和播放）
    BYTE byVoiceWorkMode; 
    BYTE byRes[18];    
}NET_DVR_PUSHMODEPARAM, *LPNET_DVR_PUSHMODEPARAM;


typedef struct tagNET_DVR_SENSOR_INFO
{
    DWORD  dwSize;                 // 结构体大小
    BYTE    byName[NAME_LEN];    // 传感器名称
    BYTE    byEnable;               // 是否启用 
    BYTE    byValid;                // 是否有效 传感器正常不正常(该参数只能获取不能个配置)
    BYTE    byType;                 // 模拟量类型 参照SENSOR_TYPE
    BYTE    byAlarmMode;//报警模式，五种，15-HHHH、14-HHHL、12-HHLL、8HLLL、0-LLLL，即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下)
    float   fMeasureHigh;           // 量程上限
    float   fMeasureLow;            // 量程下限
    float    fAlarm1;           //报警限1,报警限1-4 依次增大
    float    fAlarm2;           //报警限2
    float    fAlarm3;           //报警限3
    float    fAlarm4;           //报警限4
    DWORD   dwOsdCfg;          //模拟量字符叠加，按位表示0-15对应视频通道1-16
    float    fSensitive;            // 灵敏度表示当实时值的变化超过灵敏度的范围时，则表示实时值发生了变化，否则认为没有发生变化。如：灵敏度为0.1，则表示前后检测的两个值之差大于0.1时，则认为数据发生变化大于0.1，需要上传。如果为1，则表示变化超过1时上报。
    BYTE    bySensorStandard;    //传感器规格，0- 0~20mA，1- 0~5V，2- 0~2.5Mpa，3- 0~1.6Mpa，4- 0~5m
    BYTE    byChan;            //模拟量通道号
    BYTE    byRes3[114];            // 保留字节
}NET_DVR_SENSOR_INFO, *LPNET_DVR_SENSOR_INFO;

typedef struct tagNET_DVR_SIREN_PARAM
{
    DWORD   dwSize;                    // 结构大小
    BYTE    byName[NAME_LEN];        // 名称
    WORD    wDelay;                    // 输出延迟 单位为秒, 范围 0~5599s 0表示一直有输出
    BYTE    byRes1[2];
    DWORD   dwOverallEventJointSirenOn;        //全局事件联动警号输出开启，事件类型按位表示，bit0-主机防拆, bit1-全局键盘紧急报警,bit2-交流电断电，bit3-电池电压低,bit4-电话线掉线,bit5-有线网络异常,bit6-无线网络异常,  bit7-键盘485断线，bit8- WIFI通信故障，bit9-RF信号干扰故障
    DWORD    dwSubsystemEventJointSirenOn[MAX_ALARMHOST_SUBSYSTEM/*32*/];//子系统事件联动警号输出开启。数组下标表示子系统号，每一个元素按位表示事件类型，bit0-紧急报警
    BYTE    byRes2[448];  // 保留字节　　
}NET_DVR_SIREN_PARAM, *LPNET_DVR_SIREN_PARAM;

typedef struct tagNET_DVR_AIR_CONDITION_PARAM
{
    DWORD    dwSize;        // 结构体大小
    BYTE    byEnable;    // 0--关机 1--开机
    BYTE    byMode;        // 空调模式
    BYTE    byTemperature;    // 温度，具体值表示 通常为16-30度
    BYTE	byAirConditionNo;	// 空调编号
    BYTE    byRes[8];        // 保留字节
}NET_DVR_AIR_CONDITION_PARAM, *LPNET_DVR_AIR_CONDITION_PARAM;


typedef struct tagNET_DVR_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType; // DETECTOR_TYPE
    BYTE    byType;     //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区 ，12-超时防区，13-紧急防区，0xff-无
    BYTE    byUploadAlarmRecoveryReport;    //是否上传防区报警恢复报告，0-不上传，1-上传        
    DWORD    dwParam;    // 防区参数  延时防区延时多长时间, 动环报警主机和自助行报警主机的延时时间通过这个参数来设置 , 具体用哪种设置方式通过能力集中的bySupportAlarmInDelay字段来区别
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];/*布防时间时间段*/
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  // 报警输入关联报警输出
    BYTE    byAssociateSirenOut[8];        //  警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出
    BYTE    bySensitivityParam;//防区灵敏度参数, 0-10ms、1-250ms、2-500ms、3-750ms
    BYTE    byArrayBypass;//是否加入旁路组,0-不支持组旁路,1-支持组旁路
    BYTE    byJointSubSystem; //防区所属的子系统号，该参数只能获取  
    BYTE    byModuleStatus;    //模块状态 1-在线 2-离线
    WORD    wModuleAddress;    //模块地址，扩展模块从0~255，0xFFFF表示无效
    BYTE    byModuleChan;    //模块通道号，从1开始，最大值根据模块类型来决定，0xFF表示无效
    BYTE    byModuleType;    //模块类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区, 6-单防区触发器, 7-1门就地控制器、8-2门就地控制器、9-4门就地控制器、10-8防区无线、11-键盘、12-8防区有线、13-扩展防区
    WORD    wZoneIndex;        //防区号，该参数只能获取      
    WORD    wInDelay;    //进入延时，0-255秒
    WORD    wOutDelay;    //退出延时，0-255秒
    BYTE    byAlarmType;     //报警器类型 0-无效，1-常开，2-常闭
    BYTE    byZoneResistor;    //防区电阻，单位千欧  0-无效 1--2.2 ，2--3.3，3--4.7，4--5.6 ， 5--8.2 ，0xff-自定义
    float    fZoneResistorManual;/*防区手动电阻，1.0-10.0，精确到小数点后一位，单位千欧，byZoneResistor为0xff时有效*/
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN]; //探测器序列号，只读
    BYTE    byZoneSignalType;    //防区信号传输类型(只读)，0-有线防区，1-无线防区
    BYTE    byDisableDetectorTypeCfg;    //探测是类型是否不可配，0-可配，1-不可配
    BYTE    byTimeOutRange;      // 超时时间范围，0:1~599s,1:1~65535s
    BYTE    byAssociateLampOut[8];//  警灯输出 数组0 表示警灯1 值为1表示输出 0 表示不输出
    WORD   wTimeOut;  //超时时间，秒
    BYTE    byDetectorSignalIntensity;      // 探测器信号强度（只读），0~100
    BYTE    byTimeOutMethod;    //超时防区计时方式：0-触发计时，1-恢复计时
    BYTE    byRes3[8];      // 保留字节
}NET_DVR_ALARMIN_PARAM, *LPNET_DVR_ALARMIN_PARAM;

typedef struct tagNET_DVR_ALARMIN_PARAM_V50
{
    DWORD   dwSize;
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType; // DETECTOR_TYPE
    BYTE    byType;     //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区 ，12-超时防区，13-紧急防区，14-燃气防区，0xff-无
    BYTE    byUploadAlarmRecoveryReport;    //是否上传防区报警恢复报告，0-不上传，1-上传        
    DWORD    dwParam;    // 防区参数  延时防区延时多长时间, 动环报警主机和自助行报警主机的延时时间通过这个参数来设置 , 具体用哪种设置方式通过能力集中的bySupportAlarmInDelay字段来区别
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT];/*布防时间时间段*/
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  // 报警输入关联报警输出
    BYTE    byAssociateSirenOut[8];        //  警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出
    BYTE    bySensitivityParam;//防区灵敏度参数, 0-10ms、1-250ms、2-500ms、3-750ms
    BYTE    byArrayBypass;//是否加入旁路组,0-不支持组旁路,1-支持组旁路
    BYTE    byJointSubSystem; //防区所属的子系统号，该参数只能获取  
    BYTE    byModuleStatus;    //模块状态 1-在线 2-离线
    WORD    wModuleAddress;    //模块地址，扩展模块从0~255，0xFFFF表示无效
    BYTE    byModuleChan;    //模块通道号，从1开始，最大值根据模块类型来决定，0xFF表示无效
    BYTE    byModuleType;    //模块类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区, 6-单防区触发器, 7-1门就地控制器、8-2门就地控制器、9-4门就地控制器、10-8防区无线、11-键盘、12-8防区有线、13-扩展防区
    WORD    wZoneIndex;        //防区号，该参数只能获取      
    WORD    wInDelay;    //进入延时，0-255秒
    WORD    wOutDelay;    //退出延时，0-255秒
    BYTE    byAlarmType;     //报警器类型 0-无效，1-常开，2-常闭
    BYTE    byZoneResistor;    //防区电阻，单位千欧  0-无效 1--2.2 ，2--3.3，3--4.7，4--5.6 ， 5--8.2 ，0xff-自定义
    float    fZoneResistorManual;/*防区手动电阻，1.0-10.0，精确到小数点后一位，单位千欧，byZoneResistor为0xff时有效*/
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN_V50]; //探测器序列号，只读
    BYTE    byZoneSignalType;    //防区信号传输类型(只读)，0-有线防区，1-无线防区
    BYTE    byDisableDetectorTypeCfg;    //探测是类型是否不可配，0-可配，1-不可配
    WORD   wTimeOut;  //超时时间，秒    
    BYTE    byAssociateLampOut[8];//  警灯输出 数组0 表示警灯1 值为1表示输出 0 表示不输出
    BYTE    byVoiceFileName[32];   //语音文件名
    BYTE    byTimeOutRange;      // 超时时间范围，0:1~599s,1:1~65535s
    BYTE    byDetectorSignalIntensity;      // 探测器信号强度（只读），0~100
    BYTE    byTimeOutMethod;    //超时防区计时方式：0-触发计时，1-恢复计时
    BYTE    byAssociateFlashLamp;//  闪光灯输出 0-无效，1-不输出，2-输出
    BYTE    byStayAwayEnabled;//  及时防区在家旁路使能 0-无效，1-不使能，2-使能
    BYTE    bySilentModeEnabled;//  静音模式使能 0-无效，1-不使能，2-使能
    BYTE    byRelativeChannel[RELATIVE_CHANNEL_LEN];// 关联的通道号，0表示无效，一个byte字节表示一个通道号
    BYTE    byDetectorVersion[VERSION_INFO_LEN];   //探测器版本，只读
    BYTE    byDetectorMAC[MACADDR_LEN];    //探测器MAC地址，只读
    BYTE    byLinkageAlarmType;    //关联报警类型：1-火警，2-监管，3-联动，4-屏蔽，5-故障
    BYTE    byRes3[465];  // 保留字节
}NET_DVR_ALARMIN_PARAM_V50, *LPNET_DVR_ALARMIN_PARAM_V50;


typedef struct tagNET_DVR_SINGLE_ALARMIN_PARAM
{
    DWORD   dwSize;
    WORD    wZoneNo;        //防区号，该参数只能获取
    BYTE    byJointSubSystem; //防区所属的子系统号，该参数只能获取 
    BYTE    byType;            //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,12-超时防区,13-紧急防区14-燃气防区，0xff-无
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType;    // DETECTOR_TYPE
    WORD    wInDelay;        //进入延时，0-255秒
    WORD    wOutDelay;        //退出延时，0-255秒
    BYTE    byAlarmType;    //报警器类型  0-无效 1-常开 1-常闭
    BYTE    byZoneSignalType;    //防区信号传输类型，0-有线防区，1-无线防区
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN]; //探测器序列号，只读
    BYTE    byDisableDetectorTypeCfg;    //探测是类型是否不可配，0-可配，1-不可配
    BYTE    byTimeOutRange;      // 超时时间范围，0:1~599s,1:1~65535s
    BYTE    byDetectorSignalIntensity;      // 探测器信号强度（只读），0~100
    WORD   wTimeOut;  //超时时间，秒
    BYTE    byTimeOutMethod;    //超时防区计时方式：0-触发计时，1-恢复计时
    BYTE    byAssociateFlashLamp;//  闪光灯输出 0-无效，1-不输出，2-输出
    BYTE    byStayAwayEnabled;//  及时防区在家旁路使能 0-无效，1-不使能，2-使能
    BYTE    bySilentModeEnabled;//  静音模式使能 0-无效，1-不使能，2-使能
    BYTE    byRes2[110];    // 保留字节
}NET_DVR_SINGLE_ALARMIN_PARAM, *LPNET_DVR_SINGLE_ALARMIN_PARAM;

typedef struct tagNET_DVR_SINGLE_ALARMIN_PARAM_V50
{
    DWORD   dwSize;
    WORD    wZoneNo;        //防区号，该参数只能获取
    BYTE    byJointSubSystem; //防区所属的子系统号，该参数只能获取 
    BYTE    byType;            //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,12-超时防区,13-紧急防区14-燃气防区，0xff-无
    BYTE    byName[NAME_LEN];
    WORD    wDetectorType;    // DETECTOR_TYPE
    WORD    wInDelay;        //进入延时，0-255秒
    WORD    wOutDelay;        //退出延时，0-255秒
    BYTE    byAlarmType;    //报警器类型  0-无效 1-常开 1-常闭
    BYTE    byZoneSignalType;    //防区信号传输类型，0-有线防区，1-无线防区
    BYTE    byDetectorSerialNo[ALARMHOST_DETECTOR_SERIAL_LEN]; //探测器序列号，只读
    BYTE    byDisableDetectorTypeCfg;    //探测是类型是否不可配，0-可配，1-不可配
    BYTE    byTimeOutRange;      // 超时时间范围，0:1~599s,1:1~65535s
    BYTE    byDetectorSignalIntensity;      // 探测器信号强度（只读），0~100
    WORD   wTimeOut;  //超时时间，秒
    BYTE    byTimeOutMethod;    //超时防区计时方式：0-触发计时，1-恢复计时
    BYTE    byAssociateFlashLamp;//  闪光灯输出 0-无效，1-不输出，2-输出
    BYTE    byStayAwayEnabled;//  及时防区在家旁路使能 0-无效，1-不使能，2-使能
    BYTE    bySilentModeEnabled;//  静音模式使能 0-无效，1-不使能，2-使能
    BYTE    byRes3[2];
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  // 报警输入关联报警输出
    BYTE    byRes2[128];    // 保留字节
}NET_DVR_SINGLE_ALARMIN_PARAM_V50, *LPNET_DVR_SINGLE_ALARMIN_PARAM_V50;

typedef struct tagNET_DVR_ALARMIN_PARAM_LIST
{
    DWORD    dwSize;
    NET_DVR_SINGLE_ALARMIN_PARAM    struSingleAlarmInParam[MAX_MAX_ALARMIN_NUM];
    BYTE    byRes[128];
}NET_DVR_ALARMIN_PARAM_LIST, *LPNET_DVR_ALARMIN_PARAM_LIST;

typedef struct tagNET_DVR_ALARMIN_PARAM_LIST_V50
{
    DWORD	dwSize;
    NET_DVR_SINGLE_ALARMIN_PARAM_V50	struSingleAlarmInParam[MAX_MAX_ALARMIN_NUM];
    BYTE	byRes[128];
}NET_DVR_ALARMIN_PARAM_LIST_V50, *LPNET_DVR_ALARMIN_PARAM_LIST_V50;

typedef struct tagNET_DVR_ALARMOUT_PARAM
{
    DWORD   dwSize;             // 结构体大小
    BYTE    byName[NAME_LEN];   // 名称
    WORD    wDelay;             // 输出延迟 单位s, 范围：0~3599s 0 表示一直有输出
    WORD    wTriggerIndex;        //触发器号，该参数只能获取
    BYTE    byAssociateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];   //表示警号跟随的报警输入通道 （多个报警输入同时触发一个警号输出）数组下标0表示报警输入1，依次类推 0-不跟随 1-跟随
    BYTE    byModuleType;   //外接触发器类型，1-本地触发器， 2-4路触发器，3-8路触发器 4-单防区触发器，5-32路触发器，6-1门就地控制器、7-2门就地控制器、8-4门就地控制器,9-2路触发器，10-键盘，11-扩展触发器
    BYTE    byModuleStatus;    //外接触发器状态 1-在线 2-离线
    WORD    wModuleAddress;    //外接触发器地址，扩展模块从0~255，0xFFFF表示无效
    BYTE    byModuleChan;    //外接触发器通道号，从1开始，最大值根据模块类型来决定，0xFF表示无效
    BYTE    byWorkMode;        //工作模式，1-联动，2-随动
    BYTE    byAlarmOutMode;    //输出模式，1-非脉冲模式，2-脉冲模式
    BYTE    byTimeOn;        //开时间 1~60s
    BYTE    byTimeOff;        //关时间 1~60s
    BYTE    byDurationConstOutputEnable; //继电器常开使能
    BYTE       byRes2[50];             //保留字节
}NET_DVR_ALARMOUT_PARAM, *LPNET_DVR_ALARMOUT_PARAM;

typedef struct tagNET_DVR_ALARMIN_SETUP
{
    BYTE byAssiciateAlarmIn[MAX_ALARMHOST_ALARMIN_NUM];//报警输入通道 数组下标0对应报警输入口1，依次类推
    BYTE byRes[100];//保留字节
}NET_DVR_ALARMIN_SETUP, *LPNET_DVR_ALARMIN_SETUP;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS
{
    DWORD  dwSize; 
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//报警输入口布防状态，(最大支持512个报警输入口查询)，0-对应报警输入口处于撤防状态，1-对应报警输入口处于布防状态
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM];//报警输入口报警状态，(最大支持512个报警输入口查询)，0-对应报警输入口当前无报警，1-对应报警输入口当前有报警
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM];//报警输出口状态，(最大支持512个报警输出口查询)，0-对应报警输出口无报警，1-对应报警输出口有报警
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM];  // 旁路状态 数组下标表示0对应报警输入口1 0-表示报警输入口没有旁路 1-表示报警输入口旁路
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM]; //子系统布防状态,0-对应子系统处于撤防状态，1-对应子系统处于布防状态
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM];//报警输入口故障状态，0-对应报警输入口处于正常状态，1-对应报警输入口处于故障状态
    BYTE   byRes[56];      //  保留字节
}NET_DVR_ALARMHOST_MAIN_STATUS, *LPNET_DVR_ALARMHOST_MAIN_STATUS;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS_V40
{
    DWORD  dwSize;
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区布防状态，(最大支持512个防区查询)，0-对应防区处于撤防状态，1-对应防区处于布防状态
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区报警状态，(最大支持512个防区查询)，0-对应防区当前无报警，1-对应防区当前有报警
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //触发器状态，(最大支持512个触发器查询)，0-对应触发器无报警，1-对应触发器有报警
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM]; //旁路状态 数组下标表示0对应防区1 0-表示防区没有旁路 1-表示防区旁路
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //子系统布防状态,0-对应子系统处于撤防状态，1-对应子系统处于布防状态
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区故障状态，0-对应防区处于正常状态，1-对应防区处于故障状态
    BYTE   byAlarmInMemoryStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区报警记忆状态， 0-对应防区当前无报警，1-对应防区当前有报警
    BYTE   byAlarmInTamperStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区防拆状态，0-对应防区无报警，1-对应防区有报警
    BYTE   byEnableSubSystem[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //子系统启用状态，0-无效，1-对应子系统未启用，2-对应子系统启用
    BYTE   bySubSystemGuardType[MAX_ALARMHOST_SUBSYSTEM]; //子系统布放状态，0-无效，1-外出布防，2-即时布防，3-在家布防
    BYTE   byRes[448]; //保留字节
}NET_DVR_ALARMHOST_MAIN_STATUS_V40, *LPNET_DVR_ALARMHOST_MAIN_STATUS_V40;

typedef struct tagNET_DVR_ALARMHOST_MAIN_STATUS_V51
{
    DWORD  dwSize;
    BYTE   bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区布防状态，(最大支持512个防区查询)，0xff-无效，0-对应防区处于撤防状态，1-对应防区处于布防状态，2-对应防区处于布防中
    BYTE   byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区报警状态（触发状态），(最大支持512个防区查询)，0xff-无效，0-对应防区当前无报警，1-对应防区当前有报警
    BYTE   byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //触发器状态，(最大支持512个触发器查询)，0xff-无效，0-对应触发器无报警，1-对应触发器有报警，2-未关联，3-离线，4-心跳异常
    BYTE   byBypassStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区旁路状态，数组下标表示0对应防区1，0xff-无效，0-表示防区没有旁路 1-表示防区旁路
    BYTE   bySubSystemGuardStatus[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //子系统布防状态，0xff-无效，0-对应子系统处于撤防状态，1-对应子系统处于布防状态，2-对应子系统处于布防中
    BYTE   byAlarmInFaultStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区故障状态，0xff-无效，0-对应防区处于正常状态，1-对应防区处于故障状态
    BYTE   byAlarmInMemoryStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区报警记忆状态（报警状态）， 0xff-无效，0-对应防区当前无报警，1-对应防区当前有报警
    BYTE   byAlarmInTamperStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区防拆状态，0xff-无效，0-对应防区无报警，1-对应防区有报警
    BYTE   byEnableSubSystem[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //子系统启用状态，0-无效，1-对应子系统未启用，2-对应子系统启用
    BYTE   bySubSystemGuardType[MAX_ALARMHOST_SUBSYSTEM]; //子系统布防类型，0-无效，1-外出布防，2-即时布防，3-在家布防
    BYTE   bySubSystemAlarm[MAX_ALARMHOST_SUBSYSTEM]; //子系统报警状态，0-无效，1-正常，2-报警
    BYTE   byAlarmOutCharge[MAX_ALARMHOST_ALARMOUT_NUM]; //触发器电量状态，(最大支持512个触发器查询)，0-无效，1-正常，2-电量低
    BYTE   byAlarmOutTamperStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //触发器防拆状态，(最大支持512个触发器查询)，0-无效，1-防拆，2-无防拆
    BYTE   byAlarmInShieldedStatus[MAX_ALARMHOST_ALARMIN_NUM]; //防区屏蔽状态，0-无效，1-屏蔽，2-非屏蔽
    BYTE   byAlarmOutLinkage[MAX_ALARMHOST_ALARMOUT_NUM]; //触发器联动事件类型，(最大支持512个触发器查询)，0-无效，1-报警，2-布防，3-撤防，4-手动控制
    BYTE   byRes[512]; //保留字节
}NET_DVR_ALARMHOST_MAIN_STATUS_V51, *LPNET_DVR_ALARMHOST_MAIN_STATUS_V51;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS
{
    DWORD  dwSize;
    BYTE   bySirenStatus[ALARMHOST_MAX_SIREN_NUM];    // 警号输出状态 0-警号处于无报警状态，1-警号处于有报警状态
    BYTE   byRes[92];             // 保留字节
}NET_DVR_ALARMHOST_OTHER_STATUS, *LPNET_DVR_ALARMHOST_OTHER_STATUS;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS_V50
{
    DWORD  dwSize;
    //对于DS-PEA系列一键式紧急报警产品，数组下标0对应警灯状态，数组下标1对应电锁状态,数组下标2开始对应警号输出状态
    BYTE   bySirenStatus[ALARMHOST_MAX_SIREN_NUM]; //警号输出状态，0xff-无效，0-警号处于无报警状态，1-警号处于有报警状态，2-未关联，3-离线，4-心跳异常
    BYTE   byDetetorPower[MAX_DETECTOR_NUM]; //探测器电量状态，0xff-无效，电量值为0-100，默认电量小于20为欠压状态
    BYTE   byDetetorConnection[MAX_DETECTOR_NUM]; //探测器连接状态，0xff-无效，0-表示未注册，1-表示不在线， 2-表示在线，3-心跳异常
    BYTE   bySirenPower[ALARMHOST_MAX_SIREN_NUM]; //警号电量状态，0-无效，1-正常，2-欠压
    BYTE   bySirenTamperStatus[ALARMHOST_MAX_SIREN_NUM]; //警号防拆状态，0-无效，1-防拆，2-无防拆
    BYTE   byPowerStausEnabled[MAX_DETECTOR_NUM / 8]; //探测器电量状态是否有效，按位表示，0-无效，1-有效
    BYTE   byDetetorPowerStatus[MAX_DETECTOR_NUM / 8]; //探测器电量状态，按位表示，0-正常，1-电量低
    BYTE   byDetetorPowerType; //探测器电量的表示类型，0-按照电量值表示，使用byDetetorPower 字段，1-按照电量状态表示，使用byPowerStausEnabled和byDetetorPowerStatus字段
    BYTE   byRes[975]; //保留字节
}NET_DVR_ALARMHOST_OTHER_STATUS_V50, *LPNET_DVR_ALARMHOST_OTHER_STATUS_V50;

typedef struct tagNET_DVR_ALARMHOST_OTHER_STATUS_V51
{
    DWORD   dwSize;
    //对于DS-PEA系列一键式紧急报警产品，数组下标0对应警灯状态，数组下标1对应电锁状态,数组下标2开始对应警号输出状态
    BYTE    bySirenStatus[ALARMHOST_MAX_SIREN_NUM]; //警号输出状态，0xff-无效，0-警号处于无报警状态，1-警号处于有报警状态，2-未关联，3-离线
    BYTE    byDetetorPower[MAX_DETECTOR_NUM_V51]; //探测器电量，0xff-无效，电量值为0-100，默认电量小于20为欠压状态，byDetetorPowerType为0时有效
    BYTE    byDetetorConnection[MAX_DETECTOR_NUM_V51]; //探测器连接状态，0xff-无效，0-表示未注册，1-表示不在线， 2-表示在线
    BYTE    bySirenPower[ALARMHOST_MAX_SIREN_NUM]; //警号电量状态，0-无效，1-正常，2-欠压
    BYTE    bySirenTamperStatus[ALARMHOST_MAX_SIREN_NUM]; //警号防拆状态，0-无效，1-防拆，2-无防拆
    BYTE    byPowerStausEnabled[MAX_DETECTOR_NUM_V51 / 8]; //探测器电量状态是否有效，按位表示，0-无效，1-有效
    BYTE    byDetetorPowerStatus[MAX_DETECTOR_NUM_V51 / 8]; //探测器电量状态，按位表示，0-正常，1-电量低
    BYTE    byDetetorPowerType; //探测器电量的表示类型，0-按照电量值表示，使用byDetetorPower 字段，1-按照电量状态表示，使用byPowerStausEnabled和byDetetorPowerStatus字段
    BYTE    byRes2[3];
    BYTE    byRepeaterStatus[MAX_REPEATER_NUM];    //中继器状态，0-无效，1-离线，2-在线，3-未关联
    BYTE    byRepeaterTamperStatus[MAX_REPEATER_NUM / 8];    //中继器防拆状态，按位表示，0-对应中继器无报警，1-对应中继器有报警
    BYTE    byAlarmOutTamperStatus[MAX_ALARMHOST_ALARMOUT_NUM / 8];    //报警输出（继电器）防拆状态，按位表示，0-对应报警输出无报警，1-对应报警输出有报警
    BYTE    byOutputModuleTamperStatus[MAX_OUTPUT_MODULE_NUM / 8];    //输出模块防拆状态，按位表示，0-对应输出模块无报警，1-对应输出模块有报警
    BYTE    byElectricLockStatus[MAX_ELECTRIC_LOCK_NUM]; //电锁状态 0-关闭，1 –打开，为确保兼容性，第一个电锁的状态在bySirenStatus第0位也需要填写
    BYTE    byRes[274]; //保留字节
}NET_DVR_ALARMHOST_OTHER_STATUS_V51, *LPNET_DVR_ALARMHOST_OTHER_STATUS_V51;

typedef struct tagNET_DVR_ALARMHOST_ENABLECFG
{
    DWORD dwSize;
    BYTE  byAudioOutEnable[ALARMHOST_MAX_AUDIOOUT_NUM];//语音输出使能，0-禁能，1-使能
    BYTE  byElectroLockEnable[ALARMHOST_MAX_ELECTROLOCK_NUM];//电锁使能，0-禁能，1-使能
    BYTE  byMobileGateEnable[ALARMHOST_MAX_MOBILEGATE_NUM];//移动门使能，0-禁能，1-使能
    BYTE  bySirenEnable[ALARMHOST_MAX_SIREN_NUM];//警号使能， 0-禁能，1-使能
    BYTE  bySerialPurpose;//串口用途，0-用于级联报警主机，1-用于PTZ控制
    BYTE  byRes[63];    
}NET_DVR_ALARMHOST_ENABLECFG, *LPNET_DVR_ALARMHOST_ENABLECFG;

typedef struct tagNET_DVR_ALARMHOST_ABILITY
{
    DWORD   dwSize;                      // 结构体大小
    WORD    wTotalAlarmInNum;         // 报警输入口总数(防区),包括级联
    WORD    wLocalAlarmInNum;         // 本地报警输入口
    WORD    wExpandAlarmInNum;        // 可扩展的报警输入口
    WORD    wTotalAlarmOutNum;        // 报警输出口总数 （设备支持的总数）
    WORD    wLocalAlarmOutNum;        // 本地报警输出口个数
    WORD    wExpandAlarmOutNum;       // 可扩展的报警输出口
    WORD    wTotalRs485Num;           // 报警输出口总数 （设备支持的总数）
    WORD    wLocalRs485Num;           // 本地485口数
    WORD    wExpandRs485Num;          // 可扩展的485口数
    WORD    wFullDuplexRs485Num;    // 全双工的485口数
    WORD    wTotalSensorNum;          // 模拟量最大个数 (设备支持的总数)
    WORD    wLocalSensorNum;        // 本地模拟量个数
    WORD    wExpandSensorNum;         // 可扩展的模拟量个数
    WORD    wAudioOutNum;                //语音输出个数
    WORD    wGatewayNum;            //门禁个数
    WORD    wElectroLockNum;            //电锁个数
    WORD    wSirenNum;                 // 主机警号数目
    WORD    wSubSystemNum;            // 可划分子系统数目
    WORD    wNetUserNum;            // 网络用户数
    WORD    wKeyboardNum;           // 键盘数
    WORD    wOperatorUserNum;           // 操作用户数
    BYTE    bySupportDetector;//是否支持常开、常闭探测器，1-支持，0-不支持
    BYTE    bySupportSensitivity;//是否支持防区灵敏度，1-支持，0-不支持
    BYTE    bySupportArrayBypass;//是否支持组旁路，1-支持，0-不支持
    BYTE    bySupportAlarmInDelay;//是否支持防区延迟,1-支持，0-不支持
    //如果bySupportAlarmInDelay为1时，表示客户端应该使用NET_DVR_ALARMIN_PARAM 中的dwParam来设置延时时间，动环报警主机和自助行报警主机使用这种配置延时方式;
    //如果bySupportAlarmInDelay为0时，表示通过NET_DVR_ALARMSUBSYSTEMPARAM 中的wEnterDelay 、wExitDelay 来设置
    BYTE    bySupportAlarmInType[16];//支持的防区类型,数组0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区 8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区15-无
    BYTE    byTelNum;        //支持电话个数
    BYTE    byCenterGroupNum;    //中心组个数
    BYTE    byGPRSNum;        //GPRS中心数，最多4个
    BYTE    byNetNum;        //网络中心数，最多4个
    BYTE    byAudioNum;        //音频个数
    BYTE    by3GNum;        //3G模块个数
    BYTE    byAnalogVideoChanNum;        //模拟视频通道个数
    BYTE    byDigitalVideoChanNum;        //数字视频通道个数
    BYTE    bySubSystemArmType;        //子系统布防类型，0-表示不支持，1-表示支持。bit0-普通布防（注：网络小主机只支持普通布防，在能力集中加这个字段的时候网络小主机已经发布，所以网络小主机中该字段为0，所以用0表示支持，1表示不支持。对外接口中SDK内部会做兼容），bit1-即时布防，bit2-留守布防。    
    BYTE    byPublicSubSystemNum;    //公共子系统个数
    DWORD    dwSupport1;    //按位表示，结果非0表示支持，0表示不支持
    // bit0:     是否支持子系统内配置警号输出时间，如果支持则警号输出时间在每个子系统内配置，如果不支持，警号时间在警号参数配置里面设置
    // bit1:    是否支持事件触发报警输出开启
    // bit2:    是否支持事件触发报警输出关闭
    // bit3:    是否支持子系统使能
    // bit4;    是否支持防区布防
    // bit5;    是否支持子系统自动布撤防
    // bit6:    是否支持具体故障关联声音输出
    // bit7:    是否支持故障状态查询
    // bit8:    是否支持子系统扩展配置
    // bit9:    是否支持钥匙防区操作子系统
    // bit10:   是否支持"键盘提示成功发送报告"配置
    // bit11:   是否支持导入导出参数配置
    // bit12:   是否支持LED屏幕参数配置
    // bit13: 是否支持故障关联本地故障灯输出
    DWORD    dwSubSystemEvent;        //子系统事件，按位表示，0表示不支持，非0表示支持,bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆
    DWORD    dwOverallEvent;            //全局事件，按位表示，0表示不支持，非0表示支持，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常，bit5-硬盘故障,bit6-3G/4G信号异常, bit7-（模块链接）第三方主机掉线,bit8-WIFI通信故障，bit9-RF信号干扰故障
    DWORD    dwFaultType;            //设备支持的故障类型，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-主键盘掉线，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常    
    BYTE    byPublicSubsystemAssociateSubsystemNum;    //公共子系统可关联的子系统个数
    BYTE    byOverallKeyboard;    //全局键盘个数
    WORD    wSafetyCabinSupport; //防护舱控制器能力，按位表示，结果非0表示支持，0表示不支持    
    //bit0: 是否支持防护舱控制器工作模式配置
    //bit1: 是否支持人信号传感器类型配置
    //bit2: 是否支持幕帘传感器参数配置（探测延迟时间、人状态变化响应时间）
    //bit3: 是否支持红外对射传感器参数配置（滤波）
    //bit4: 是否支持防护舱使用超时时间配置
    BYTE    by485SlotNum;        //485虚拟槽位号
    BYTE    bySubSystemAttributeAbility;  // 值恒为1，禁止1号子系统关闭使能
    WORD    wKeyboardAddrNum;      // 键盘地址数
    BYTE     byAlarmLampNum;         //警灯数目
    BYTE    byRes[117];            //  保留字节
}NET_DVR_ALARMHOST_ABILITY, *LPNET_DVR_ALARMHOST_ABILITY;

typedef struct tagNET_DVR_485_SLOT_LIST_INFO
{
    DWORD        dwSize;
    BYTE        byAll;    //0-不是全部获取，1-全部获取
    BYTE        byres[3];
    BYTE        byIndex[MAX_485SLOT];            //485槽位号
    BYTE           byRes[64];      //保留
}NET_DVR_485_SLOT_LIST_INFO,* LPNET_DVR_485_SLOT_LIST_INFO;

typedef struct tagNET_DVR_485LIST_INFO
{
    DWORD        dwSize;
    BYTE        byAll;    //0-不是全部获取，1-全部获取
    BYTE        byres[3];
    BYTE        byIndex[MAX_485CHAN];            //485通道号 下标表示通道号，值0-表示不使用，1表示使用
    BYTE       byRes[64];      //保留
}NET_DVR_485LIST_INFO,*LPNET_DVR_485LIST_INFO;

typedef struct tagNET_DVR_ALARM_RS485CFG
{
    DWORD   dwSize;                 // 结构体大小
    BYTE    sDeviceName[NAME_LEN];  // 前端设备名称 
    WORD    wDeviceType;            // 前端设备类型,通过NET_DVR_GetDeviceTypeList获取
    WORD    wDeviceProtocol;        // 前端设备协议 通过获取协议列表获取    
    DWORD   dwBaudRate;             //波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k 
    BYTE    byDataBit;              // 数据有几位：0-5位，1-6位，2-7位，3-8位 
    BYTE    byStopBit;              // 停止位：0-1位，1-2位 
    BYTE    byParity;               //是否校验：0-无校验，1-奇校验，2-偶校验 
    BYTE    byFlowcontrol;           // 是否流控：0-无，1-软流控,2-硬流控 
    BYTE    byDuplex;                // 0 - 半双工1- 全双工  只有通道1可以是全双工其他都只能是半双工
    BYTE    byWorkMode;                // 工作模式 0-控制台 1-透明通道,2-梯控，3-读卡器,4-门禁安全模块,0xfe-自定义，0xff-禁用
    BYTE    byChannel;                //485通道号
    BYTE    bySerialType;            //串口类型: 0--485, 1--232
    BYTE    byMode;                 //模式 0-连接读卡器 1-连接客户端 2-连接扩展模块 3-连接门禁主机 4-连接梯控主机  0xff-禁用
    BYTE    byOutputDataType;  //0-无效，1-输出卡号，2-输出工号
    BYTE    byAddress;               //串口地址
    BYTE    byStairsOutputDataType;   //0-无效，1-输出楼层号，2-输出卡号，当byMode为梯控主机时有效
    BYTE    byRes[32];              // 保留字节
}NET_DVR_ALARM_RS485CFG, *LPNET_DVR_ALARM_RS485CFG;

typedef struct tagNET_DVR_DEVICE_PROTO_LIST
{
    DWORD   dwSize;             // 结构体大小
    DWORD   dwProtoNum;         // 协议个数
    NET_DVR_PROTO_TYPE struProtoType[MAX_DEVICE_PROTO_NUM];  // 协议类型
    BYTE    byRes[12];          // 保留字节
}NET_DVR_DEVICE_PROTO_LIST, *LPNET_DVR_DEVICE_PROTO_LIST;

typedef struct tagNET_DVR_DEVICE_TYPE
{
    DWORD    dwType;
    BYTE    byDescribe[DESC_LEN];
}NET_DVR_DEVICE_TYPE, *LPNET_DVR_DEVICE_TYPE;

typedef struct tagNET_DVR_DEVICE_TYPE_LIST
{
    DWORD    dwSize;                // 结构体大小
    DWORD    dwTypeNum;            // 类型个数
    NET_DVR_DEVICE_TYPE struDeviceType[MAX_DEVICE_TYPE_NUM];
    BYTE    byRes[12];
}NET_DVR_DEVICE_TYPE_LIST, *LPNET_DVR_DEVICE_TYPE_LIST;

typedef struct tagNET_DVR_ALARM_DEVICE_USER
{
    DWORD  dwSize;                 // 结构体大小
    BYTE   sUserName[NAME_LEN];    // 用户名
    BYTE   sPassword[PASSWD_LEN];    // 密码
    NET_DVR_IPADDR    struUserIP;                    /* 用户IP地址(为0时表示允许任何地址) */
    BYTE   byMACAddr[MACADDR_LEN];            /* 物理地址 */
    BYTE   byUserType; // 0-普通用户（操作员） 1-管理员用户 2-安装员用户 3-制造商用户
    BYTE   byAlarmOnRight;         // 布防权限
    BYTE   byAlarmOffRight;        // 撤防权限
    BYTE   byBypassRight;          // 旁路权限
    BYTE   byOtherRight[MAX_RIGHT];  // 其他权限
    // 0 -- 日志权限
    // 1 -- 重启关机
    // 2 -- 参数设置权限
    // 3 -- 参数获取权限
    // 4 -- 恢复默认参数权限
    // 5 -- 警号输出权限
    // 6 -- PTZ 控制权限
    // 7 -- 远程升级权限
    // 8 -- 远程预览
    // 9 -- 远程手动录像
    // 10 -- 远程回放
    // 11 -- 消警
    // 12 -- 强制布防
    // 13 -- 永久旁路
    // 14 -- 添加更改个人授权代码
    // 15 -- 调试模式
    BYTE    byNetPreviewRight[MAX_ALARMHOST_VIDEO_CHAN/8];    // 远程可以预览的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    BYTE    byNetRecordRight[MAX_ALARMHOST_VIDEO_CHAN/8];    // 远程可以录像的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    BYTE    byNetPlaybackRight[MAX_ALARMHOST_VIDEO_CHAN/8]; // 远程可以回放的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    BYTE    byNetPTZRight[MAX_ALARMHOST_VIDEO_CHAN/8];        // 远程可以PTZ的通道，按位表示各通道（bit0-channel 1），1-有权限，0-无权限
    //BYTE    byPriority;                                        // 优先级，0xff-无，0--低，1--中，2--高
    //无（表示不支持优先级的设置）
    //低（默认权限：包括远程回放，远程查看日志和状态，远程关机/重启）
    //中（包括远程控制云台，远程手动录像，远程回放，语音对讲和远程预览，本地备份，本地/远程关机/重启）
    //高（管理员）
    BYTE        sOriginalPassword[PASSWD_LEN];        // 原始密码
    BYTE        sKeypadPassword[PASSWD_LEN];        // 键盘密码
    BYTE        byUserEnabled;        // 用户是否开启使用：0-无效，1-开启，2-不开启
    BYTE        byRes2[135];                  // 保留字节
}NET_DVR_ALARM_DEVICE_USER, *LPNET_DVR_ALARM_DEVICE_USER;

typedef struct tagNET_DVR_KEYBOARD_USER
{
    DWORD     dwSize;     // 结构体大小
    DWORD    dwID;        // 键盘用户ID
    BYTE    byDefanceArea[MAX_ALARMHOST_ALARMIN_NUM]; //防区权限  按数组下标表示 最大支持512个防区 0 - 无权限 1- 有权限
    BYTE    byRes[560];        // 保留字节
}NET_DVR_KEYBOARD_USER, *LPNET_DVR_KEYBOARD_USER;

typedef struct tagNET_DVR_OPERATE_USER
{
    DWORD     dwSize;        // 结构体大小
    BYTE    sUserName[NAME_LEN];    // 用户名
    BYTE    sPassword[PASSWD_LEN];  // 密码
                                    BYTE   bySubSystemPermission;/*0-安装员权限 操作员权限（所有子系统）如下： 1-单布防，无布防报告，不能旁路 2-单撤防，无撤防报告，不能旁路 3-布撤防，无布撤防报告，不能旁路 
                                                                 4-单布防，有布//防报告，不能旁路 5-单撤防，有撤防报告，不能旁路 6-布撤防，有布撤防报告，不能旁路  7-单布防，无布撤防报告，允许旁路 
                                                                 8-单撤防，无布撤防报告，允许旁路 9-布撤防，无布撤防报告，允许旁路 10-单布防，有布防报告，允许旁路 11-单撤防，有撤防报告，允许旁路 1
                                    2-布撤防，有布撤防报告，允许旁路*/
                                    BYTE    byRes[63];             //  保留字节
}NET_DVR_OPERATE_USER, *LPNET_DVR_OPERATE_USER;

typedef struct tagNET_DVR_GATEWAY_CFG
{
    DWORD    dwSize;        // 结构体大小
    BYTE    byName[NAME_LEN];    //  门禁名称    
    BYTE    byEnable;    // 是否启用
    BYTE    byLocalEnable;  //  本地是否启用
    WORD    wDelayTime;    // 开启延时时间    单位为秒0-65535 0为一直开启
    BYTE    byLockWorkMode;//电锁工作模式，0-通电启动，1-断电启动
    BYTE    byRes[31];    // 保留字节
}NET_DVR_GATEWAY_CFG, *LPNET_DVR_GATEWAY_CFG;

typedef struct tagNET_DVR_SENSOR_ALARM
{
    DWORD   dwSize;                // 结构体大小
    DWORD   dwAbsTime;            // 绝对时标信息  OSD显示信息
    BYTE    byName[NAME_LEN];     // sensor 名称
    BYTE    bySensorChannel;    // 模拟量通道
    BYTE    byType;             // 模拟量类型
    BYTE    byAlarmType;        // 1-上4、2-上3、3-上2、4-上1、5-下1、6-下2、7-下3、8-下4 和当前模式有关
    // 例如当为1000时,有上1下1，2，3报警四种报警
    BYTE    byAlarmMode;        //报警模式，五种，-HHHH、-HHHL、-HHLL、HLLL、-LLLL， 作为平台报警程度判断功能,即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下) 
    float    fValue;                // 但前模拟量的值
    float   fOriginalValue; //原始电流电压值，保留小数点后三位，具体值表示电流还是电压根据NET_DVR_SENSOR_INFO的bySensorStandard类型
    BYTE    byRes2[28];		    // 保留字节
}NET_DVR_SENSOR_ALARM, *LPNET_DVR_SENSOR_ALARM;

typedef struct tagNET_DVR_RS485_PROTOCOL_VERSION
{
    DWORD  dwSize;
    BYTE   byProtocleVersion[PROTOCOL_VERTION_LEN];//RS485协议库版本信息
    BYTE   byRes[128];
}NET_DVR_RS485_PROTOCOL_VERSION, *LPNET_DVR_RS485_PROTOCOL_VESRION;

typedef struct 
{
    /*预留，目前报警主机的报警没有类型(布防网络序，监听主机序)*/
    DWORD  dwAlarmType;             
    /*数组0对应第1个输入端口*/
    BYTE   byAlarmInputNumber[MAX_ALARMHOST_ALARMIN_NUM];
    BYTE    byRes[160];
}NET_DVR_ALARMHOST_ALARMINFO,*LPNET_DVR_ALARMHOST_ALARMINFO;

typedef struct tagNET_DVR_SWITCH_ALARM
{
    DWORD dwSize;
    BYTE   byName[NAME_LEN];     // switch 名称
    WORD  wSwitchChannel;     // 开关量通道, 0-255
    BYTE    byAlarmType;        // 报警类型 0--正常，1--短路，2--断路,3-异常 
    BYTE     byRes[41];            // 保留字节
}NET_DVR_SWITCH_ALARM, *LPNET_DVR_SWITCH_ALARM;


typedef struct tagNET_DVR_ALARMHOST_EXCEPTION_ALARM
{
    DWORD   dwSize;             // 结构体大小
    // 异常参数  1-设备防拆报警 2-设备防拆后后恢复正常 3-主电源掉电报警 4-主电源掉电后恢复正常 5-内部通信故障报警 
    // 6-内部通信故障后恢复正常  7-电话线断线 8-电话线断线恢复 9-自检失败报警  10-自检失败后恢复正常    
    // 11蓄电池欠压  12蓄电池电压恢复正常，13-蓄电池故障；14-MBUS模块掉线；15-MBUS模块掉线恢复；16-键盘掉线；
    //17-键盘掉线恢复；18-设备被移动；19-设备被移动复位  20-485外设线路断报警  21-485外设线路断后恢复正常
    //25-子板1插上,26-子板1拔出, 27-子板2插上,28-子板2拔出
    DWORD   dwExceptionType;    
    BYTE   byRes[36];          // 保留
}NET_DVR_ALARMHOST_EXCEPTION_ALARM, *LPNET_DVR_ALARMHOST_EXCEPTION_ALARM;

typedef struct tagNET_DVR_PHONECENTERDIALCFG
{
    BYTE sCenterName[NAME_LEN];
    BYTE byPhoneNum[MAX_PHONE_NUM/*32*/];  //中心号码  
    BYTE byRepeatCall;          //重复拨号次数，1~15次
    BYTE byPstnProtocol;        //通信协议，0-CID；
    BYTE byDialDelay;           //拨号延时，最大150s, 0-150
    BYTE byPstnTransMode;       //传输方式，0-DTMF 5/S，1-DTMF 10/S；
    BYTE byEnable;       //使能，0-关闭，1-启用
    BYTE byRes1[5];
    BYTE byReceiverId[6];         //接收机识别账号；
    BYTE byRes2[32];
}NET_DVR_PHONECENTERDIALCFG, *LPNET_DVR_PHONECENTERDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALCFG
{
    DWORD dwSize;
    NET_DVR_PHONECENTERDIALCFG struPhoneCenterParam[MAX_CENTERNUM];//主中心参数
    WORD wReportPeriod;      //测试报告上传周期，小时，（最大值支持7天，即168小时), 范围；1-168
    WORD wFirstReportTime;     //从设备启动到第一条测试报告上传，1~3600分钟
    BYTE  byReportValid;    //0-不启用测试报告上传 1-启用测试报告上传
    BYTE  byRes[19];
}NET_DVR_ALARMHOSTDIALCFG, *LPNET_DVR_ALARMHOSTDIALCFG;

typedef struct tagNET_DVR_ALARMHOSTDIALSETUPMODE
{
    DWORD dwSize;
    BYTE byEnableMode;//启用方式，0：不启用，1：一直启用，2:网线断启用，正常时关闭；
    BYTE byCallType; //上传中心方式，1-单中心，2-双中心，3，一报一备
    BYTE byRes1[14];
}NET_DVR_ALARMHOSTDIALSETUPMODE, *LPNET_DVR_ALARMHOSTDIALSETUPMODE;

typedef struct tagNET_DVR_PU_CHAN_INFO
{
    NET_DVR_IPADDR  struIpAddr;     // ip地址
    WORD            wPort;          // 端口
    WORD            wChannel;       // 通道     
    BYTE            byRes[24];      // 
}NET_DVR_PU_CHAN_INFO, *LPNET_DVR_PU_CHAN_INFO;

typedef struct tagNET_DVR_PU_CHAN_LIST
{
    DWORD   dwSize;     // 结构体
    DWORD   dwNum;      // 前端通道个数
    NET_DVR_PU_CHAN_INFO struPuChanInfo[MAX_PU_CHAN_NUM];
}NET_DVR_PU_CHAN_LIST, *LPNET_DVR_PU_CHAN_LIST;

typedef struct tagNET_DVR_PTZ_CTRL
{
    BYTE    byEnable;   // 是否启用PTZ控制
    BYTE    byType;     // PTZ 控制的类型 1- 预置点 2 -巡航  3-轨迹
    BYTE    byPtzNo;    //  ptz 控制的预置点 巡航 轨迹号
    BYTE    byRes[5];    // 保留字节
}NET_DVR_PTZ_CTRL, *LPNET_DVR_PTZ_CTRL;

typedef struct tagNET_DVR_ALARM_CAM_INFO
{
    DWORD            dwCamID;      // 触发的CAM通道操作
    DWORD           dwRecordTime;   // 触发录像时间 单位为s  -1表示一直录像 0 表示不录像
    DWORD           dwMonID;      // 触发Cam到Mon号显示
    DWORD           dwResidentTime; // 轮巡停留时间单位为s  -1表示一直停留 0 表示不停留
    NET_DVR_PTZ_CTRL struPtzCtrl;    // PTZ控制信息
    BYTE            byAlarmOffMode;        // 报警切换上墙取消模式   0-立即取消，1-自动取消，2-手动取消 立即取消，报警取消时立即取消解码上墙   自动取消，报警取消时等待一定时间后取消解码上墙，我们约定是20秒  手动取消，用户通过手动的方式取消
    BYTE            byDevType;        // 当设备为智能设备时，生效表示智能报警设备取流源 1-解码卡     2-编码卡
    BYTE            byDecChan;        // 当为解码通道为解码通道号
    BYTE            byRes[17];      // 保留字节
}NET_DVR_ALARM_CAM_INFO, *LPNET_DVR_ALARM_CAM_INFO;

typedef struct tagNET_DVR_ALARM_CAM_CFG
{
    DWORD        dwSize;            // 结构体大小
    BYTE        byEnable;       // 是否启用报警触发CAM联动 设备默认不启用
    BYTE        byRes[7];       // 保留字节
    DWORD        dwNum;            // 触发CAM联动的个数 即取数组的前几个有效处理  
    NET_DVR_ALARM_CAM_INFO struAlarmCam[MAX_ALARM_CAM_NUM];
}NET_DVR_ALARM_CAM_CFG, *LPNET_DVR_ALARM_CAM_CFG;

typedef struct tagNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM
{
    DWORD         dwSize;
    BYTE        byEnterDoor[8];    // 下标表示门禁号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
    BYTE        byExitDoor[8];     // 下标表示门禁号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
    BYTE         byAlarmIn[MAX_ALARMHOST_ALARMIN_NUM/*512*/];  //关联报警输入，下标表示报警输入号，元素数值表示关联信息，0表示不关联， 1-8表示关联的音频号
    BYTE         byRes[128];
}NET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM, *LPNET_DVR_ALARMHOST_AUDIO_ASSOCIATE_ALARM;

typedef struct tagNET_DVR_UPLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byUploadType;    /*上传方式，1-根据文件名绝对地址读取数据文件上传， 2-从缓冲区读取数据上传*/
    BYTE        byDataType;        //数据类型：1-音频数据
    BYTE        byDataNum;        //数据编号，如：上传语音，则该参数表示语音号，增加三条语音号（晕倒、多人、人脸遮挡）
    BYTE        byAudioType;        //语音格式，0-wave
    char        sFileName[260];        //数据文件的全路径
    char        *lpBuffer;            //数据缓冲区
    DWORD        dwBufferSize;        //缓冲区大小
    BYTE        byRes2[128];
}NET_DVR_UPLOAD_PARAM, *LPNET_DVR_UPLOAD_PARAM;

typedef struct tagNET_DVR_ALARMHOST_PARAM
{
    DWORD         dwSize;
    BYTE        byDownType;        /*下载的数据保存方式，1-根据文件名绝对地址保存数据， 2-通过回调函数获取数据*/
    BYTE        byDataType;        //数据类型：1-音频数据
    BYTE        byDataNum;        //数据编号，如：下载语音，则该参数表示语音号，增加三条语音号（晕倒、多人、人脸遮挡）
    BYTE        byRes1;
    char        sFileName[260];        //数据文件的全路径
    DATADOWNLOAD lpDataCallBack; //下载时的回调函数句柄
    void*        pUserData;    //用户数据，将在回调函数中传回
    BYTE        byRes2[128];
}NET_DVR_DOWNLOAD_PARAM, *LPNET_DVR_DOWNLOAD_PARAM;

typedef struct tagNET_DVR_ALARMHOST_DOWNLOAD_PARAM
{
    DWORD         dwSize;
    BYTE        byDownType;        /*下载的数据保存方式，1-根据文件名绝对地址保存数据， 2-通过回调函数获取数据*/
    BYTE        byDataType;        //数据类型：1-音频数据
    BYTE        byDataNum;        //数据编号，如：下载语音，则该参数表示语音号，增加三条语音号（晕倒、多人、人脸遮挡）
    BYTE        byRes1;
    char        sFileName[260];        //数据文件的全路径
    DATADOWNLOAD lpDataCallBack; //下载时的回调函数句柄
    void*        pUserData;    //用户数据，将在回调函数中传回
    BYTE        byRes2[128];
}NET_DVR_ALARMHOST_DOWNLOAD_PARAM, *LPNET_DVR_ALARMHOST_DOWNLOAD_PARAM;



typedef struct tagNET_DVR_SWITCH_TIME
{
    BYTE    byValid;                // 该组定时时间是否有效，时间是成对设置的
    BYTE    byRes[3];
    NET_DVR_TIME_EX struTimeOn;     // 开机时间
    NET_DVR_TIME_EX struTimeOff;     // 关机时间
}NET_DVR_SWITCH_TIME, *LPNET_DVR_SWITCH_TIME;

typedef struct tagNET_DVR_LED_SWITCH_TIME
{
    DWORD        dwSize;
    NET_DVR_SWITCH_TIME struTimer[LED_TIMER_NUM /*3*/];         //定时开关机时间，结构体中只有小时和分钟两个参数有效，每组开机时间要早于该组的关机时间，但比前一组的关机时间要晚，例如：struTimer[0]的关机时间是10：00那么，struTimer[0]的开机时间须设置为10:00之前， struTimer[1]的开机时间须设置为10：:00以后。
    BYTE        byRes[64];
}NET_DVR_LED_SWITCH_TIME, *LPNET_DVR_LED_SWITCH_TIME;

typedef struct tagNET_DVR_LED_BRIGHTNESS_STEP
{
    DWORD         dwSize;
    BYTE        byValid;        //分时亮度调节是否有效
    BYTE        byRes1[3];
    BYTE         byBrightnessStep[TIME_SEGMENT_A_DAY /*48*/];     //将全天24个小时分为48个时段，每30分钟一个时段，用48个字节表示每个时段的亮度级别，亮度共16级，用0~15表示。
    BYTE        byRes2[48];
}NET_DVR_LED_BRIGHTNESS_STEP, *LPNET_DVR_LED_BRIGHTNESS_STEP;

typedef struct tagNET_DVR_LED_STATUS
{
    DWORD    dwSize;
    BYTE    bySwitchState;        //1-开机状态 2-关机状态
    BYTE    byBrightness;        //亮度值，范围0-15
    BYTE    byRes[62];
}NET_DVR_LED_STATUS, *LPNET_DVR_LED_STATUS;


typedef struct tagNET_DVR_DECCARD_ABILITY      /*高清解码卡能力集*/
{
    BYTE byCardType;      //解码卡类型(0:MD,1:MD+,2:HD)
    BYTE byDecNums;      //解码通道数
    BYTE byDispNums;      //显示通道数
    BYTE byDecStartIdx;     //首个解码通道在所有解码通道中的索引
    BYTE byDispStartIdx;     //首个显示通道在所有显示通道中的索引
    BYTE byDispResolution[80]; //输出模式支持的分辨率
    BYTE byDispFormat[8];     //支持的输出模式(按HD_DISPLAY_FORMAT)
    BYTE byWindowMode[4][8]; //支持的窗口模式(比如1,2,4,9,16))
    BYTE byRes[35];
} NET_DVR_DECCARD_ABILITY,*LPNET_DVR_DECCARD_ABILITY;

typedef struct tagNET_DVR_DECODESVR_ABILITY
{
    DWORD dwSize;      /* 结构体大小 */
    BYTE byCardNums;      /* 解码卡数 */
    BYTE byStartChan;     /* 起始通道号 */
    BYTE byRes1[2];
    NET_DVR_DECCARD_ABILITY struDecCardAbility[MAX_DECODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_DECODESVR_ABILITY, *LPNET_DVR_DECODESVR_ABILITY;

typedef struct tagNET_MATRIX_DEV_CHAN_INFO
{
    NET_DVR_IPADDR     struIP;            //DVR IP地址
    WORD     wDVRPort;                 //端口号
    BYTE     byChannel;                //通道号
    BYTE    byTransProtocol;        //传输协议类型0-TCP，1-UDP
    BYTE    byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE    byFactoryType;            /*前端设备厂家类型,通过接口获取*/
    BYTE    byUsedSlotNum;            //是否使用槽位号，0-不使用，1-使用
    BYTE    bySlotNum;//槽位号
    BYTE    byRes[68];
    BYTE    sUserName[NAME_LEN];    //监控主机登陆帐号
    BYTE    sPassword[PASSWD_LEN];    //监控主机密码
}NET_MATRIX_DEV_CHAN_INFO,*LPNET_MATRIX_DEV_CHAN_INFO;

typedef struct tagNET_MATRIX_PU_STREAM_CFG
{
    DWORD                            dwSize;
    NET_DVR_STREAM_MEDIA_SERVER_CFG    struStreamMediaSvrCfg;
    NET_MATRIX_DEV_CHAN_INFO        struDevChanInfo;
} NET_MATRIX_PU_STREAM_CFG,LPNET_MATRIX_PU_STREAM_CFG;

typedef struct tagNET_DVR_MATRIX_CAMERACFG
{
    DWORD                    dwGlobalIndex;//全局编号
    DWORD                    dwInterIndex;//局部编号
    BYTE                    sCamName[NAME_LEN];
    NET_MATRIX_PU_STREAM_CFG struPuStreamCfg;
} NET_DVR_MATRIX_CAMERACFG,*LPNET_DVR_MATRIX_CAMERACFG;

typedef struct tagNET_DVR_MATRIX_CAMERALIST
{
    DWORD            dwSize;
    BYTE            byRes[12];
    DWORD            dwCamNum;//CAM数量
    BYTE              *pBuffer;
    DWORD             dwBufLen;//所分配指针长度，输入参数
} NET_DVR_MATRIX_CAMERALIST,*LPNET_DVR_MATRIX_CAMERALIST;

typedef struct tagNET_DVR_DISP_CHAN_INFO
{
    NET_DVR_IPADDR    struIP;                /* 解码器 IP地址 */
    WORD     wDVRPort;                 /* 端口号 */
    BYTE     byDispChannel;            /* 显示通道号 */
    BYTE    byUsedSlotNum;            //是否使用槽位号，0-使用，1-不使用
    BYTE    bySlotNum;//槽位号
    BYTE    byRes[7];
    BYTE    sUserName[NAME_LEN];    /*登陆帐号 */
    BYTE    sPassword[PASSWD_LEN];    /*密码 */
}NET_DVR_DISP_CHAN_INFO,*LPNET_DVR_DISP_CHAN_INFO;

typedef struct tagNET_DVR_MATRIX_MONITORCFG
{
    DWORD                        dwGlobalIndex;//全局编号
    DWORD                        dwInterIndex;
    BYTE                        sMonName[NAME_LEN];
    NET_DVR_DISP_CHAN_INFO        struDispChanCfg;
} NET_DVR_MATRIX_MONITORCFG,*LPNET_DVR_MATRIX_MONITORCFG;

typedef struct tagNET_DVR_MATRIX_MONITORLIST
{
    DWORD        dwSize;
    BYTE        byRes[12];
    DWORD        dwMonNum;//MON数量
    BYTE          *pBuffer;
    DWORD         dwBufLen;//所分配指针长度，输入参数
} NET_DVR_MATRIX_MONITORLIST,*LPNET_DVR_MATRIX_MONITORLIST;

typedef struct tagNET_DVR_SUBMATRIXINFO
{
    BYTE        byMainMatrix;//是否是主系统，1-是，0-否
    BYTE        bySubMatrixSequence;//级联子视频综合平台系统序号
    BYTE        byLoginType;//注册类型，1-直连，2-DNS，3-花生壳
    BYTE        byRes1[9];
    NET_DVR_IPADDR  struSubMatrixIP;        /*IP地址（可修改）*/
    WORD        wSubMatrixPort;        /*子系统端口号（可修改）*/
    BYTE        byRes2[6];
    NET_DVR_IPADDR  struSubMatrixIPMask;    /*IP地址掩码*/
    NET_DVR_IPADDR    struGatewayIpAddr;         /* 网关地址 */    
    BYTE        sUserName[NAME_LEN];    /* 用户名 （此参数只能获取）*/
    BYTE        sPassword[PASSWD_LEN];    /*密码 （此参数只能获取）*/
    char        sDomainName[MAX_DOMAIN_NAME];//域名(可修改)
    char         sDnsAddress[MAX_DOMAIN_NAME];/*DNS域名或IP地址*/
    BYTE        sSerialNumber[SERIALNO_LEN];//序列号（此参数只能获取）
    BYTE        byRes3[16];
}NET_DVR_SUBMATRIXINFO, *LPNET_DVR_SUBMATRIXINFO;

typedef struct tagNET_DVR_ALLUNITEDMATRIXINFO
{
    DWORD dwSize;
    NET_DVR_SUBMATRIXINFO struSubMatrixInfo[MAX_SUBMATRIX_NUM];
    BYTE  byRes2[32];
}NET_DVR_ALLUNITEDMATRIXINFO, *LPNET_DVR_ALLUNITEDMATRIXINFO;

typedef struct tagNET_DVR_MATRIXGATEWAYNOTE
{
    WORD    wTrunkInToOutAbility;//干线带宽，按D1的标准衡量，如4表示支持4个D1
    WORD    wTrunkOutToInAbility;//干线带宽，按D1的标准衡量，如4表示支持4个D1，双向光纤时用到此值
    BYTE    byRes[4];
    NET_DVR_MATRIXSUBSYSTEMINFO struInputNote;
    NET_DVR_MATRIXSUBSYSTEMINFO struOutputNote;
}NET_DVR_MATRIXGATEWAYNOTE, *LPNET_DVR_MATRIXGATEWAYNOTE;

typedef struct tagNET_DVR_MATRIXGATEWAYINFO
{
    DWORD dwSize;
    NET_DVR_MATRIXGATEWAYNOTE struGatewayNote[MAX_GATEWAYTRUNKNUM];
    BYTE  byRes [32];
}NET_DVR_MATRIXGATEWAYINFO, *LPNET_DVR_MATRIXGATEWAYINFO;

typedef struct tagNET_DVR_MATRIXCODESYSTEMINFO
{
    BYTE   byMatrixNum;//视频综合平台号
    BYTE    bySubSystemNum;//子系统槽位号
    BYTE    byChan;//编码通道
    BYTE   byRes [13];
}NET_DVR_MATRIXCODESYSTEMINFO,*LPNET_DVR_MATRIXCODESYSTEMINFO;

typedef struct tagNET_DVR_MATRIXDECODESYSTEMINFO
{
    BYTE    byMatrixNum;//视频综合平台号
    BYTE    bySubSystemNum;//子系统槽位号
    BYTE    byDispChan;//显示通道
    BYTE    bySubDispChan;//显示通道子通道号
    BYTE    byRes [12];
}NET_DVR_MATRIXDECODESYSTEMINFO,*LPNET_DVR_MATRIXDECODESYSTEMINFO;

typedef struct tagNET_DVR_MATRIXSWITCH
{
    NET_DVR_MATRIXCODESYSTEMINFO struInputNote;
    NET_DVR_MATRIXDECODESYSTEMINFO struOutputNote;
    BYTE    byRes[32];
}NET_DVR_MATRIXSWITCH, *LPNET_DVR_MATRIXSWITCH;


typedef struct tagNET_DVR_MATRIXSWITCHCTRL
{
    DWORD dwCamId;//摄像机全局编号
    DWORD dwMonId;//监视器全局编号
    BYTE  bySubWindowNum;//监视器对应子窗口号
    BYTE   bySwitchType;/*切换类型，0:正常切换，1:报警触发切换，2:报警取消，0xff:表示此MON上所有报警全部取消*/
    WORD   wAlarmType;//报警设备类型，1:报警主机，2：智能设备
    DWORD  dwResidentTime;/* 显示驻留时间，0xFFFFFFFF 时 为常驻情况，保持显示*/
    BYTE   byVcaDevType;//当报警设备类型是"智能设备"时，按DEV_TYPE类型
    BYTE   byWallNo;//墙号
    BYTE   byRes[18];
}NET_DVR_MATRIXSWITCHCTRL, *LPNET_DVR_MATRIXSWITCHCTRL;

typedef struct tagNET_DVR_MATRIXDATABASE
{
    //配置文件类型，1-域数据库配置文件，2-子域数据库配置文件，3-平台数据库配置文件，4-场景配置文件，0xff最后一次失败的数据库语句
    DWORD dwDevType; 
    DWORD dwParam; //参数，代表域号、子域号、平台号，场景配置文件时此值无用
    BYTE  byFileType;//文件类型，1-sql语句，2-db语句，3-场景配置文件
    BYTE  byRes [3];
} NET_DVR_MATRIXDATABASE, *LPNET_DVR_MATRIXDATABASE;

typedef struct tagNET_DVR_SUBSYSTEMINFO_V40
{
/*子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，
    9-V6子系统，10-转码子系统，11-X86服务器子系统，12-超高清输入子系统，13-X86中心服务板，14- X86业务服务板，15-多相机拼接子系统， 16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，19-音频子系统，0-NULL（此参数只能获取）*/
    BYTE        bySubSystemType;
    //子系统通道数，对于码分子系统，代表485串口数量（此参数只能获取）
    BYTE        byChan;
    BYTE        byLoginType;//注册类型，1-直连，2-DNS，3-花生壳
    BYTE        bySlotNum ;//槽位号，此参数只能获取
    BYTE        byRes1[4];
    NET_DVR_IPADDR   struSubSystemIP;        /*IP地址（可修改）*/
    NET_DVR_IPADDR   struSubSystemIPMask;//子网掩码
    NET_DVR_IPADDR   struGatewayIpAddr;    /* 网关地址 */
    WORD        wSubSystemPort;        //子系统端口号（可修改）
    BYTE        byRes2[6];
    BYTE        sUserName[NAME_LEN];    /* 用户名 （此参数只能获取）*/
    BYTE        sPassword[PASSWD_LEN];    /*密码(可修改)*/
    char        sDomainName[MAX_DOMAIN_NAME];//域名(可修改)
    char        sDnsAddress[MAX_DOMAIN_NAME];/*DNS域名或IP地址*/
    BYTE        sSerialNumber[SERIALNO_LEN];//序列号（此参数只能获取）
    BYTE        byBelongBoard;//所属子板号，从1开始，0xff表示无效
    BYTE        byInterfaceType;//接口类型，0-无类型，1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，10-3GSDI, 11-VGA/DVI自适应，12-HDTVI，13-HDBaseT，14-DP，15-DVIT，16-TVI,17-VSCREEN,18-miniDP,0xff-无效
    BYTE        byInterfaceNums;//接口个数，0xff表示无效
    BYTE        byInterfaceStartNum;//接口起始号，0xff表示无效
    BYTE        byDeviceName[20];//子系统名称
    BYTE        byAudioChanNums; //音频通道个数
    BYTE        byAudioChanStartNum; //音频通道起始号
    BYTE        byAudioChanType;//音频通道类型，0-无效，1-音频输入，2-音频输出
    BYTE        byRes3[33];
}NET_DVR_SUBSYSTEMINFO_V40, *LPNET_DVR_SUBSYSTEMINFO_V40;

typedef struct tagNET_DVR_ALLSUBSYSTEMINFO_V40
{
    DWORD dwSize;
    NET_DVR_SUBSYSTEMINFO_V40 struSubSystemInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE byRes[8];
}NET_DVR_ALLSUBSYSTEMINFO_V40, *LPNET_DVR_ALLSUBSYSTEMINFO_V40;

typedef struct tagNET_DVR_SUBSYSTEM_BASIC_INFO
{
    DWORD       dwSize;
    /*子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-Fpga解码子系统，9-Fpga子系统，10-转码子系统，11-X86服务器子系统，12-超高清输入子系统，13-X86中心服务板， 14- X86业务服务板，15-多相机拼接子系统， 16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，19-信号接入子系统,0-NULL（此参数只能获取）*/
    BYTE        bySubSystemType;
    //子系统通道数，对于码分子系统，代表485串口数量（此参数只能获取）
    BYTE        bySubSystemNo;//子系统号，此参数只能获取
    BYTE        byInterfaceType;//接口类型，0-无类型，1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, 7-RGB, 8-YprPb, 9-VGA/HDMI/DVI自适应，10-3GSDI, 11-VGA/DVI自适应，12-HDTVI，13-HDBaseT，14-DP，15-DVIT，0xff-无效
    BYTE        byRes1;
    DWORD       dwChan;
    NET_DVR_IPADDR   struSubSystemIP; /*IP地址（可修改）*/
    NET_DVR_IPADDR   struSubSystemIPMask;//子网掩码
    NET_DVR_IPADDR   struGatewayIpAddr; /* 网关地址 */
    WORD        wSubSystemPort;        //子系统端口号（可修改）
    BYTE        byRes2[6];
    BYTE        sSerialNumber[SERIALNO_LEN];//序列号（此参数只能获取）
    BYTE        byBelongBoard;//所属子板号，从1开始，0xff表示无效，但当byBelongBoardH不为0时该字段可以为0xff
    BYTE        byBelongBoardH; //所属子板号高位
    BYTE        byRes3[2];
    BYTE        byDeviceName[20];//子系统名称
    DWORD       dwStartChanNo;//起始通道号
    BYTE        byDevNo; //设备号
    BYTE        byRes4[63];
}NET_DVR_SUBSYSTEM_BASIC_INFO, *LPNET_DVR_SUBSYSTEM_BASIC_INFO;

typedef struct NET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE
{
    DWORD dwSize;
    DWORD dwErrorCode; //错误
    BYTE   byDevNo; //设备号
    BYTE    bySubSystemNo;//子系统号
    BYTE   byRes[30];
} NET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE,*LPNET_DVR_SUBSYSTEM_BASIC_INFO_RESPONSE;

typedef struct NET_DVR_CAMERA_INFO_RESPONSE
{
    DWORD dwErrorCode; //错误
    DWORD dwCamId; /*cam 的统一编号*/
    BYTE   byRes[4];
} NET_DVR_CAMERA_INFO_RESPONSE,*LPNET_DVR_CAMERA_INFO_RESPONSE;

typedef struct NET_DVR_MONITOR_INFO_RESPONSE
{
    DWORD dwErrorCode; //错误
    DWORD dwMonId; /*mon 的统一编号*/
    BYTE   byRes[4];
} NET_DVR_MONITOR_INFO_RESPONSE, *LPNET_DVR_MONITOR_INFO_RESPONSE;

typedef struct tagNET_DVR_AUDIO_INFO
{
    DWORD    dwSize;
    BYTE    byAudioChanType;//音频通道类型，1-音频输入，2-音频输出
    BYTE       byRes1[3];
    DWORD    dwAudioNo; //音频号(1字节设备号+1字节子板号+2字节音频口号)
    BYTE      byRes2[16];
}NET_DVR_AUDIO_INFO, *LPNET_DVR_AUDIO_INFO;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO_V40
{
    /*子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，0-NULL（此参数只能获取）*/
    BYTE   bySubSystemType; 
    BYTE   byConnectStatus;//级联系统关联状态，1-连接正常，2-连接断开
    BYTE   byMatrixNum;//级联视频综合平台号，子系统类型是3或4时可用
    BYTE   bySubSystemNum;//级联子系统槽位号，0~79，子系统类型是3或4时可用
    NET_DVR_DECSUBSYSTEMJIONSTATUS struDecSub [MATRIX_MAXDECSUBSYSTEMCHAN];
    BYTE   byBindStatus;//绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
    BYTE   bySlotNum ;//槽位号，此参数只能获取
    //子系统类型为1的时可用，0-未关联，1-D1，2-720，3-1080
    BYTE   byDecodeAbility; 
    BYTE   byUsedTrunk;
    BYTE   byRes[64];
}NET_DVR_SINGLESUBSYSTEMJOININFO_V40,LPNET_DVR_SINGLESUBSYSTEMJOININFO_V40;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO_V40
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO_V40 struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE  byRes[48];
}NET_DVR_ALLDECSUBSYSTEMJOININFO_V40, *LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V40;

typedef struct tagNET_DVR_SUBSYSTEM_ABILITY
{
/*子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，
    10-转码子系统，11-X86服务器子系统，板， 14- X86业务服务板，15-多相机拼接子系统， 16-网络光纤交换子系统，17-X86拼接子系统，18-普通拼接子系统，0-NULL（此参数0-NULL（此参数只能获取）*/
    BYTE  bySubSystemType;
    BYTE  byChanNum;//子系统通道数
    BYTE  byStartChan;//子系统起始通道数
    BYTE  bySlotNum ;//槽位号 
    BYTE  byRes1[4];
    union
    {
        BYTE byRes[200];        
        struct
        {
            BYTE byDecode;        //是否是带解码功能的智能板,1-是，0-否
            BYTE byNeedPreAllocDec; //是否需要预分配解码资源，1-是，0-否
            BYTE byVACType;  //智能子系统类型，0-普通型，1-增强型
            BYTE byRes[197];
        }struVACSystemAbility;
        struct
        {
            BYTE  byVGANums;//VGA显示通道个数（从1开始）
            BYTE  byBNCNums;//BNC显示通道个数（从9开始）
            BYTE  byHDMINums;//HDMI显示通道个数（从25开始）
            BYTE  byDVINums;//DVI显示通道个数（从29开始）
            BYTE  byLayerNums ;//大屏拼接中，做主屏时所支持图层数
            BYTE  bySpartan;//畅显功能，0-不支持，1-支持
            BYTE  byDecType; //解码子系统类型，0-普通型,1-增强型(普通型分屏时前4窗口需使用自身资源，增强型无此限制，增强型最多可被其他子系统借16路D1解码资源
            //增强型被大屏关联为子屏后资源可被借用，普通型则不能被借用)
            //2-智能关联解码子系统，3-转码关联解码子系统（智能和转码关联子系统不能用于解码上墙）
            BYTE  byOutputSwitch;//是否支持HDMI/DVI互相切换，0-不支持，1-支持
            BYTE  bySDINums;//SDI显示通道个数（从33开始）
            BYTE  byRes1[38];               
            BYTE  byDecoderType ; //解码板是否支持多厂家码流解码，0-不支持，1-支持
            BYTE  byRes2[152];
        }struDecoderSystemAbility;
        struct
        {
            BYTE  byCoderType;//编码器类型，0-标清，1-高清, 2-模拟高清
            BYTE  byOptical;//光端机接入，0-否，1-是
            BYTE  byOpticalSubChan; //每个光口信道数            
            BYTE  bySupportAVSeparate;//是否支持音视频分离，0-不支持，1-支持
            BYTE  byRes[196];
        }struCoderSystemAbility;
        struct
        {
            WORD    wTrunkAbility;//干线带宽，按D1的标准衡量，如4表示支持4个D1
            BYTE    byOpticalFiberNum;//光纤条数
            BYTE    byRes[197];
        }struInputSystemAbility;
        struct
        {
            WORD    wTrunkAbility;//干线带宽，按D1的标准衡量，如4表示支持4个D1
            BYTE    byOpticalFiberNum;//光纤条数
            BYTE    byRes[197];
        }struOutputSystemAbility;
        struct
        {
            BYTE    by485Num;//码分子系统中485数量
            BYTE    bySlotNum;//每个485槽位数
            BYTE    byRes[198];
        }struCodeSpitterSystemAbility;
        struct
        {
            WORD    wAlarmInNums;
            WORD    wAlarmOutNums;
            /* 标识报警盒是否连接， 1表示已连接， 为0 表示未连接 */
            BYTE  byAlarmBoxEnable[4][8];
            BYTE  bySupportContact; /* 视频综合平台内部报警联动，0-不支持,1-支持 */
            BYTE  byRes[163];
        }struAlarmHostSystemAbility;
        struct
        {
            BYTE  byOpticalFiberNum;//光纤条数
            BYTE  byRes1[3];
            //光纤带宽，按D1的标准衡量，如4表示支持4个D1
            WORD    wTrunkAbility[MAX_OPTICALFIBER_NUM/*16*/];
            BYTE  byRes2[164];
        }struInOutputSystemAbility;
        struct
        {
            BYTE  bySupportRingProtocol;   //是否支持环网协议
            BYTE  bySupportRingNums; //支持环网数量
            BYTE  bySupportPortNums;  //支持的端口数量
            BYTE  byRes[1]; 
            DWORD dwPortSupportRingProto; //每个端口是否支持环网协议，按位算，1～32位分别表示1～32端口，0-不支持，1-表示支持 
            BYTE  byRes2[192];
        } struFiberSwitchSystemAbility;    
    }struAbility;
}NET_DVR_SUBSYSTEM_ABILITY, *LPNET_DVR_SUBSYSTEM_ABILITY;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY_V40
{
    DWORD   dwSize;
    BYTE    byCodeSubSystemNums;//编码子系统数量
    BYTE    byDecodeSubSystemNums;//解码子系统数量
    BYTE    bySupportNat;//是否支持NAT，0-不支持，1-支持
    BYTE    byInputSubSystemNums;//级联输入子系统数量
    BYTE    byOutputSubSystemNums;//级联输出子系统数量
    BYTE    byCodeSpitterSubSystemNums;//码分子系统数量
    BYTE    byAlarmHostSubSystemNums;//报警子系统数量
    BYTE    bySupportBigScreenNum;//所支持最多组成大屏的个数
    BYTE    byVCASubSystemNums;//智能子系统数量
    BYTE    byV6SubSystemNums;//V6子系统数量
    BYTE    byV6DecoderSubSystemNums;//V6解码子系统数量
    BYTE    bySupportBigScreenX;/*大屏拼接的模式：m×n*/
    BYTE    bySupportBigScreenY;
    BYTE    bySupportSceneNums;//支持场景模式的个数
    BYTE    byVcaSupportChanMode;//智能支持的通道使用模式，0-使用解码通道，1-使用显示通道及子通道号
    BYTE    bySupportScreenNums;//所支持的大屏的屏幕最大个数
    BYTE    bySupportLayerNums;//所支持的图层数，0xff-无效
    BYTE    byNotSupportPreview;//是否支持预览,1-不支持，0-支持
    BYTE    byNotSupportStorage;//是否支持存储,1-不支持，0-支持
    BYTE    byUploadLogoMode;//上传logo模式，0-上传给解码通道，1-上传给显示通道
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM_V40];
    BYTE    by485Nums;//485串口个数
    BYTE    by232Nums;//232串口个数
    BYTE    bySerieStartChan;//起始通道
    BYTE    byScreenMode;//大屏模式，0-主屏由客户端分配，1-主屏由设备端分配
    BYTE    byDevVersion;//设备版本，0-B10/B11/B12，1-B20
    BYTE    bySupportBaseMapNums;//所支持的底图数，底图号从1开始
    WORD    wBaseLengthX;//每个屏大小的基准值，B20使用
    WORD    wBaseLengthY;
    BYTE    bySupportPictureTrans;  //是否支持图片回显，0-不支持，1-支持    
    BYTE    bySupportPreAllocDec;   //是否支持智能解码资源预分配，0-不支持，1-支持
    BYTE    bySupportDecAutoManage; //是否支持解码资源管理
    BYTE    byTranDevSubSystemNums; //转码子系统数量
    BYTE    byFiberSwitchNums;  //网络光纤子系统数量
    BYTE    byRes2[625];
}NET_DVR_VIDEOPLATFORM_ABILITY_V40, *LPNET_DVR_VIDEOPLATFORM_ABILITY_V40;

typedef struct tagNET_DVR_VIDEOPLATFORM_ABILITY
{
    DWORD dwSize;
    BYTE  byCodeSubSystemNums;//编码子系统数量
    BYTE  byDecodeSubSystemNums;//解码子系统数量
    BYTE  bySupportNat;//是否支持NAT，0-不支持，1-支持
    BYTE  byInputSubSystemNums;//级联输入子系统数量
    BYTE  byOutputSubSystemNums;//级联输出子系统数量
    BYTE  byCodeSpitterSubSystemNums;//码分子系统数量
    BYTE  byAlarmHostSubSystemNums;//报警子系统数量
    BYTE  bySupportBigScreenNum;//所支持最多大屏拼接数量
    BYTE  byVCASubSystemNums;//智能子系统数量
    BYTE  byRes1[11];   
    NET_DVR_SUBSYSTEM_ABILITY struSubSystemAbility[MAX_SUBSYSTEM_NUM];
    BYTE  by485Nums;//485串口个数
    BYTE  by232Nums;//485串口个数
    BYTE  bySerieStartChan;//起始通道
    BYTE  byRes2[637];    
}NET_DVR_VIDEOPLATFORM_ABILITY, *LPNET_DVR_VIDEOPLATFORM_ABILITY;

typedef struct tagNET_DVR_HOLIDATE_MODEA
{
    BYTE    byStartMonth;    // 开始月 从1开始
    BYTE    byStartDay;        // 开始日 从1开始
    BYTE    byEndMonth;        // 结束月 
    BYTE    byEndDay;        // 结束日
    BYTE    byRes[4];        // 保留字节
}NET_DVR_HOLIDATE_MODEA, *LPNET_DVR_HOLIDATE_MODEA;

typedef struct tagNET_DVR_HOLIDATE_MODEB
{
    BYTE    byStartMonth;    // 从1开始
    BYTE    byStartWeekNum;    // 第几个星期 从1开始 
    BYTE    byStartWeekday;    // 星期几
    BYTE    byEndMonth;        // 从1开始
    BYTE    byEndWeekNum;    // 第几个星期 从1开始 
    BYTE    byEndWeekday;    // 星期几    
    BYTE    byRes[2];        // 保留字节 
}NET_DVR_HOLIDATE_MODEB, *LPNET_DVR_HOLIDATE_MODEB;

typedef struct tagNET_DVR_HOLIDATE_MODEC
{
    WORD    wStartYear;        // 年
    BYTE    byStartMon;        // 月
    BYTE    byStartDay;        // 日
    WORD    wEndYear;        // 年
    BYTE    byEndMon;        // 月
    BYTE    byEndDay;        // 日
}NET_DVR_HOLIDATE_MODEC, *LPNET_DVR_HOLIDATE_MODEC;



typedef struct tagNET_DVR_HOLIDAY_PARAM
{
    BYTE    byEnable;            // 是否启用
    BYTE    byDateMode;            // 日期模式 0-模式A 1-模式B 2-模式C
    BYTE    byRes1[2];            // 保留字节
    NET_DVR_HOLIDATE_UNION uHolidate;    // 假日日期
    BYTE    byName[NAME_LEN];    // 假日名称
    BYTE    byRes2[20];            // 保留字节
}NET_DVR_HOLIDAY_PARAM, *LPNET_DVR_HOLIDAY_PARAM;

typedef struct tagNET_DVR_HOLIDAY_PARAM_CFG
{
    DWORD    dwSize;            // 结构体大小
    NET_DVR_HOLIDAY_PARAM struHolidayParam[MAX_HOLIDAY_NUM];    // 假日参数
    DWORD    byRes[40];        // 保留参数
}NET_DVR_HOLIDAY_PARAM_CFG, *LPNET_DVR_HOLIDAY_PARAM_CFG;

typedef struct tagNET_DVR_HOLIDAY_HANDLE
{
    DWORD    dwSize;                // 结构体大小
    NET_DVR_SCHEDTIME              struAlarmTime[MAX_TIMESEGMENT_V30];    // 布防时间段
    BYTE    byRes2[240];        // 保留字节
}NET_DVR_HOLIDAY_HANDLE, *LPNET_DVR_HOLIDAY_HANDLE;

typedef struct tagNET_DVR_HOLIDAY_HANDLE_COND
{
    DWORD    dwSize;                // 结构体大小
    DWORD    dwChannel;            //通道号
    DWORD    dwSMDHandleType;    //简易智能假日布防类型 0-音频异常侦测，1-虚焦侦测，2-场景变更侦测
    BYTE     byRes2[32];        // 保留字节
}NET_DVR_HOLIDAY_HANDLE_COND, *LPNET_DVR_HOLIDAY_HANDLE_COND;

typedef struct tagNET_DVR_HOLIDAY_RECORD
{
    DWORD           dwSize;
    NET_DVR_RECORDDAY     struRecDay;     // 录像参数
    NET_DVR_RECORDSCHED   struRecordSched[MAX_TIMESEGMENT_V30]; // 录像时间段
    BYTE      byRes[20];      //  保留字节
}NET_DVR_HOLIDAY_RECORD, *LPNET_DVR_HOLIDAY_RECORD;

typedef struct tagNET_DVR_ONE_LINK
{
    NET_DVR_IPADDR  struIP;     // 客户端IP
    LONG            lChannel;   // 通道号
    BYTE            byRes[32];  // 保留字节
}NET_DVR_ONE_LINK, *LPNET_DVR_ONE_LINK;

typedef struct tagNET_DVR_LINK_STATUS
{
    DWORD   dwSize;      // 结构体大小
    WORD    wLinkNum;    // 连接的数目
    BYTE    byRes1[2];  // 保留字节
    NET_DVR_ONE_LINK struOneLink[MAX_LINK_V30];   // 连接的客户端信息
    BYTE    byRes[32];  // 保留字节
}NET_DVR_LINK_STATUS, *LPNET_DVR_LINK_STATUS;

typedef struct tagNET_DVR_ONE_BONDING
{
    BYTE    byMode;                // 工作模式0 - 网络容错 1 - 负载均衡
    BYTE    byUseDhcp;            // 是否使能dhcp
    BYTE    byMasterCard;        //  指定哪张网卡为主网卡        
    BYTE    byStatus;           // BONDING的状态  0 - 异常 1-正常 只能获取不能设置
    BYTE    byBond[MAX_NETWORK_CARD];// byBond[0]== 1 表示使用eh0  0表示不使用eh0
    NET_DVR_ETHERNET_V30    struEtherNet;        // 网卡参数
    NET_DVR_IPADDR    struGatewayIpAddr;  // 网关地址
    BYTE  byEnableDNS; //DNS使能, 0-关闭，1-打开 
    BYTE  byBondMode; //绑定方式, 0-无效，1-主备模式，2-轮转模式，3-XOR模式，4-广播模式，5-802.3ad模式，6-T1b模式，7-虚拟化模式
    BYTE  byRes1[2];
    BYTE  byBond2[MAX_NETWORK_CARD_EX/*12*/];// byBond2[0]== 1 表示使用eh4  0表示不使用eh4，基于byBond扩展
    BYTE  byRes[4];// 保留字节
}NET_DVR_ONE_BONDING, *LPNET_DVR_ONE_BONDING;

typedef struct tagNET_DVR_NETWORK_BONDING
{
    DWORD   dwSize;         // 结构体大小
    BYTE    byEnable;       // 是否启用bonding功能
    BYTE    byNum;          // Bonding网卡的个数
    BYTE    byRes1[2];         //  保留字节
    NET_DVR_ONE_BONDING struOneBond[MAX_BOND_NUM];
    BYTE    byRes2[40];        // 保留字节
}NET_DVR_NETWORK_BONDING, *LPNET_DVR_NETWORK_BONDING;

typedef struct tagNET_DVR_DISK_QUOTA 
{
    BYTE    byQuotaType;     // 磁盘配额类型,1 - 按容量 2-按比例，3-按时间
    BYTE    byRes1[5];       // 保留字节
    WORD    wStoragePeriod;  //录像存储周期，单位天，配额类型为按时间时有效
    DWORD   dwHCapacity;     // 分配的磁盘容量高32位 单位MB
    DWORD   dwLCapacity;     // 分配的磁盘容量低32位 单位MB
    DWORD   dwHUsedSpace;    // 已使用的磁盘大小高32位 单位MB
    DWORD   dwLUsedSpace;    // 已使用的磁盘大小低32位 单位MB
    BYTE    byQuotaRatio;    //    分配的磁盘比例,单位:%
    BYTE    byRes2[21];      // 保留字节
}NET_DVR_DISK_QUOTA, *LPNET_DVR_DISK_QUOTA;

typedef struct tagNET_DVR_DISK_QUOTA_CFG
{
    DWORD   dwSize;         // 结构体大小
    NET_DVR_DISK_QUOTA    struPicQuota;       //  图片配额
    NET_DVR_DISK_QUOTA    struRecordQuota;    //  录像配额
    NET_DVR_DISK_QUOTA    struAddInfoQuota;   //  附加信息配额 (用于云存储服务器，目前支持的附加信息有：热度图、客流量)
    BYTE    byRes[12];      //保留字节
}NET_DVR_DISK_QUOTA_CFG, *LPNET_DVR_DISK_QUOTA_CFG;

typedef struct tagNET_DVR_DISK_QUOTA_V60
{
    BYTE    byQuotaType;     // 磁盘配额类型,1 - 按容量 2-按比例，3-按时间
    BYTE    byRes1[5];       // 保留字节
    WORD    wStoragePeriod;  //录像存储周期，单位天，配额类型为按时间时有效
    DWORD   dwHCapacity;     // 分配的磁盘容量高32位 单位MB
    DWORD   dwLCapacity;     // 分配的磁盘容量低32位 单位MB
    DWORD   dwHUsedSpace;    // 已使用的磁盘大小高32位 单位MB
    DWORD   dwLUsedSpace;    // 已使用的磁盘大小低32位 单位MB
    BYTE    byQuotaRatio;    //    分配的磁盘比例,单位:%
    BYTE    byRes2[23];      // 保留字节
}NET_DVR_DISK_QUOTA_V60, *LPNET_DVR_DISK_QUOTA_V60;

typedef struct tagNET_DVR_DISK_QUOTA_CFG_V60
{
    DWORD  dwSize;         // 结构体大小
    NET_DVR_DISK_QUOTA_V60    struPicQuota;    //  图片配额
    NET_DVR_DISK_QUOTA_V60    struRecordQuota;    //  录像配额
    NET_DVR_DISK_QUOTA_V60   struAddInfoQuota;   //  附加信息配额 (用于云存储服务器，目前支持的附加信息有：热度图、客流量)
    NET_DVR_DISK_QUOTA_V60   struPubInfoFile; // 发布信息文件配额百分比
    BYTE   byRes[256];      //保留字节字节
}NET_DVR_DISK_QUOTA_CFG_V60, *LPNET_DVR_DISK_QUOTA_CFG_V60;

typedef struct tagNET_DVR_TIMING_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   // 定时抓图图片质量
    DWORD      dwPicInterval;  // 定时抓图时间间隔,单位s   1-1s 2-2s 3-3s 4-4s 5-5s 
    //    6-10m 7-30m 8-1h 9-12h 10-24h
    BYTE       byRes[12];      // 保留字节
}NET_DVR_TIMING_CAPTURE, *LPNET_DVR_TIMING_CAPTURE;

typedef struct tagNET_DVR_REL_CAPTURE_CHAN
{
    BYTE    byChan[16];    // 按位表示
    BYTE    byRes[20];          // 保留字节
}NET_DVR_REL_CAPTURE_CHAN, *LPNET_DVR_REL_CAPTURE_CHAN;

typedef struct  tagNET_DVR_REL_CAPTURE_CHAN_V40
{
    DWORD   dwMaxRelCaptureChanNum;  //最大可触发的关联通道数-只读属性
    DWORD   dwChanNo[MAX_CHANNUM_V40]; //触发的关联抓图通道号，按值表示，采用紧凑型排列,0xffffffff表示后续无效
    BYTE     byRes[32];
}NET_DVR_REL_CAPTURE_CHAN_V40, *LPNET_DVR_REL_CAPTURE_CHAN_V40;

typedef struct tagNET_DVR_EVENT_CAPTURE_V40
{
    NET_DVR_JPEGPARA  struJpegPara;   // 事件抓图图片质量
    DWORD   dwPicInterval;   // 事件抓图时间间隔  单位为秒 
    NET_DVR_REL_CAPTURE_CHAN_V40 struRelCaptureChan[MAX_PIC_EVENT_NUM];   // 数组下标 0 移动侦测触发抓图 1 视频遮挡触发抓图 2 视频丢失触发抓图,数组3表示PIR报警抓图，数组4表示无线报警抓图，数组5表示呼救报警抓图,数组6表示智能抓图
    NET_DVR_REL_CAPTURE_CHAN_V40 struAlarmInCapture[MAX_ALARMIN_CAPTURE];    // 报警输入触发抓图，下标0 代表报警输入1 依次类推
    DWORD   dwMaxGroupNum;  //设备支持的最大报警输入组数，每组16个报警输入
    BYTE      byCapTimes; //抓图张数
    BYTE      byRes[59];
}NET_DVR_EVENT_CAPTURE_V40, *LPNET_DVR_EVENT_CAPTURE_V40;

typedef struct tagNET_DVR_EVENT_CAPTURE
{
    NET_DVR_JPEGPARA  struJpegPara;   // 事件抓图图片质量
    DWORD       dwPicInterval;  // 事件抓图时间间隔  单位为秒  1-1s 2-2s 3-3s 4-4s 5-5s 
    //    6-10m 7-30m 8-1h 9-12h 10-24h
    /*
    数组下标 0 移动侦测触发抓图 1 视频遮挡触发抓图，2 视频丢失触发抓图,数组3表示PIR报警抓图，
    数组4表示无线报警抓图，数组5表示呼救报警抓图,数组6表示智能抓图,数组7 表示人脸侦测抓图，
    数组8 表示-越界侦测侦测抓图，数组9 表示区域入侵侦测抓图,数组10表示场景变更侦测抓图, 
    数组11-进入区域侦测,数组12-离开区域侦测,数组13-徘徊侦测,数组14-人员聚集侦测,数组15-快速运动侦测,
    数组16-停车侦测,数组17-物品遗留侦测,数组18-物品拿取侦测。
    */
    NET_DVR_REL_CAPTURE_CHAN struRelCaptureChan[MAX_PIC_EVENT_NUM]; 
    NET_DVR_REL_CAPTURE_CHAN struAlarmInCapture[MAX_ALARMIN_CAPTURE];    // 报警输入触发抓图，下标0 代表报警输入1 依次类推
    BYTE       byCapTimes; //抓图张数
    BYTE       byRes[59];
}NET_DVR_EVENT_CAPTURE, *LPNET_DVR_EVENT_CAPTURE;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG_V40
{
    DWORD                             dwSize;               //结构体长度
    NET_DVR_TIMING_CAPTURE        struTimingCapture;    
    NET_DVR_EVENT_CAPTURE_V40    struEventCapture;
    BYTE       byStreamType;//抓图码流类型 0-主码流，1-子码流
    BYTE       byRes3[19];     // 保留字节
}NET_DVR_JPEG_CAPTURE_CFG_V40, *LPNET_DVR_JPEG_CAPTURE_CFG_V40;

typedef struct tagNET_DVR_JPEG_CAPTURE_CFG
{
    DWORD      dwSize;         // 结构体大小
    NET_DVR_TIMING_CAPTURE struTimingCapture;    
    NET_DVR_EVENT_CAPTURE struEventCapture;
    BYTE       byStreamType;//抓图码流类型 0-主码流，1-子码流
    BYTE       byRes3[19];     // 保留字节
}NET_DVR_JPEG_CAPTURE_CFG, *LPNET_DVR_JPEG_CAPTURE_CFG;  

typedef struct tagNET_DVR_CAPTURE_DAY
{
    BYTE    byAllDayCapture;    // 是否全天抓图
    BYTE    byCaptureType;        // 抓图类型：0-定时抓图，1-移动侦测抓图，2-报警抓图，3-移动侦测或报警抓图，4-移动侦测和报警抓图，6-智能报警抓图,7-智能侦测抓图，8-全部事件 ,39-离线测温抓图,40-防区报警，41-紧急求助,42业务咨询  43-废气排放监测 44-灰度报警
    BYTE    byRes[2];
}NET_DVR_CAPTURE_DAY, *LPNET_DVR_CAPTURE_DAY;

typedef struct tagNET_DVR_CAPTURE_SCHED
{
    NET_DVR_SCHEDTIME struCaptureTime;        // 抓图时间段
    BYTE        byCaptureType;       // 抓图类型：0-定时抓图，1-移动侦测抓图，2-报警抓图，3-移动侦测或报警抓图，4-移动侦测和报警抓图，6-智能报警抓图,7-智能侦测抓图，8-全部事件  ,39-离线测温抓图 ,40-防区报警，41-紧急求助,42业务咨询 43-废气排放监测 44-灰度报警
    BYTE        byRes[3];           // 保留字节
}NET_DVR_CAPTURE_SCHED, *LPNET_DVR_CAPTURE_SCHED;

typedef struct tagNET_DVR_SCHED_CAPTURECFG
{
    DWORD  dwSize;     // 结构体
    BYTE    byEnable;    // 是否抓图
    BYTE    byRes1[3];    // 保留字节
    NET_DVR_CAPTURE_DAY    struCaptureDay[MAX_DAYS];    // 全天抓图计划
    NET_DVR_CAPTURE_SCHED    struCaptureSched[MAX_DAYS][MAX_TIMESEGMENT_V30];    // 时间段抓图布防计划
    NET_DVR_CAPTURE_DAY    struCaptureHoliday;            // 假日抓图计划
    NET_DVR_CAPTURE_SCHED    struHolidaySched[MAX_TIMESEGMENT_V30];    // 时间段假日抓图布防计划
    DWORD    dwRecorderDuration;    // 抓图保存最长时间 0xffffffff表示该值无效 
    DWORD    dwDelayTime;           /* 抓图延时时间 0- 无延时， 1-3秒， 2-4秒， 3-5秒， 4-10秒， 5-30秒， 6-60秒， 7- 120秒，8-300秒*/
    BYTE      byRes[36];            // 保留字节
}NET_DVR_SCHED_CAPTURECFG, *LPNET_DVR_SCHED_CAPTURECFG;

typedef struct tagNET_DVR_FLOW_TEST_PARAM
{
    DWORD  dwSize;              //结构大小
    LONG   lCardIndex;         //网卡索引
    DWORD  dwInterval;         //设备上传流量时间间隔, 单位:100ms
    BYTE   byRes[8];           //保留字节
}NET_DVR_FLOW_TEST_PARAM, *LPNET_DVR_FLOW_TEST_PARAM;

typedef struct tagNET_DVR_FLOW_INFO
{
    DWORD  dwSize;             //结构大小
    DWORD  dwSendFlowSize;     //发送流量大小,单位kbps
    DWORD  dwRecvFlowSize;     //接收流量大小,单位kbps
    BYTE   byRes[20];          //保留 
}NET_DVR_FLOW_INFO, *LPNET_DVR_FLOW_INFO;

typedef struct tagNET_DVR_RECORD_LABEL
{
    DWORD  dwSize;                    // 结构体大小
    NET_DVR_TIME  struTimeLabel;            // 标签的时间 
    BYTE    byQuickAdd;                // 是否快速添加 快速添加时标签名称无效
    BYTE    byRes1[3];                // 保留字节
    BYTE    sLabelName[LABEL_NAME_LEN];    // 标签的名称 长度为40字节  
    BYTE    byRes2[40];                // 保留字节
}NET_DVR_RECORD_LABEL, *LPNET_DVR_RECORD_LABEL;

typedef struct tagNET_DVR_LABEL_IDENTIFY
{
    BYTE    sLabelIdentify[LABEL_IDENTIFY_LEN];    // 64字节标识
    BYTE    byRes[8];               // 保留字节
}NET_DVR_LABEL_IDENTIFY, *LPNET_DVR_LABEL_IDENTIFY;

typedef struct tagNET_DVR_DEL_LABEL_PARAM
{
    DWORD   dwSize;       // 结构体大小
    BYTE    byMode;   // 按位表示,0x01表示按标识删除
    BYTE    byRes1;
    WORD    wLabelNum;      // 标签数目      
    NET_DVR_LABEL_IDENTIFY struIndentify[MAX_DEL_LABEL_IDENTIFY]; // 标签标识
    BYTE    byRes2[160];   //保留字节    
}NET_DVR_DEL_LABEL_PARAM, *LPNET_DVR_DEL_LABEL_PARAM;

typedef struct tagNET_DVR_MOD_LABEL_PARAM
{
    NET_DVR_LABEL_IDENTIFY struIndentify; //要修改的标签标识
    BYTE byRes1[24];
    BYTE sLabelName[LABEL_NAME_LEN];    //修改后的标签名称
    BYTE byRes2[40];                
}NET_DVR_MOD_LABEL_PARAM, *LPNET_DVR_MOD_LABEL_PARAM;

typedef struct tagNET_DVR_FIND_LABEL
{
    DWORD       dwSize;          // 结构体大小
    LONG        lChannel;        // 查找的通道
    NET_DVR_TIME    struStartTime;    // 开始时间
    NET_DVR_TIME    struStopTime;    // 结束时间
    BYTE        sLabelName[LABEL_NAME_LEN];    //  录像标签名称 如果标签名称为空，则搜索起止时间所有标签
    BYTE        byDrawFrame;        //0:不抽帧，1：抽帧
    BYTE   	    byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char cStartTimeDifferenceH;   //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    char cStartTimeDifferenceM;   //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    char cStopTimeDifferenceH;    //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    char cStopTimeDifferenceM;    //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    BYTE        byRes[34];        // 保留字节
}NET_DVR_FIND_LABEL, *LPNET_DVR_FIND_LABEL;

typedef struct tagNET_DVR_FINDLABEL_DATA
{
    BYTE    sLabelName[LABEL_NAME_LEN];    // 标签名称
    NET_DVR_TIME struTimeLabel;        // 标签时间
    NET_DVR_LABEL_IDENTIFY struLabelIdentify; // 标签标识
    BYTE   	    byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char cTimeDifferenceH;   //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    char cTimeDifferenceM;   //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    BYTE        byRes[29];            // 保留字节
}NET_DVR_FINDLABEL_DATA, *LPNET_DVR_FINDLABEL_DATA;




typedef struct tagNET_DVR_FIND_PICTURE_PARAM
{
    DWORD  dwSize;         // 结构体大小 
    LONG   lChannel;       // 通道号
    /* 查找的图片类型:0定时抓图1 移动侦测抓图 2 报警抓图，
    3 报警 | 移动侦测抓图 4 报警 & 移动侦测抓图 6 手动抓图 ,
    9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警, 
    0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，
    0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测,
    0x13-进入区域侦测,0x14-离开区域侦测,0x15-徘徊侦测,
    0x16-人员聚集侦测,0x17-快速运动侦测,0x18-停车侦测,
    0x19-物品遗留侦测,0x1a-物品拿取侦测, 0x1b-车牌侦测,
    0x1c-混行检测,0x1d-取证事件,0x1e-火点检测,0x1f-防破坏检测,
    0x20-船只检测，0x21-测温预警，0x22-测温报警, 0x23测差报警, 
    0x24违停检测,0x25-人脸抓拍,0x26-离线测温报警,0x2a-起身检测,
    0x2b-折线攀高,0x2c-如厕超时,0x2d-安全帽检测,0x2e-周界抓拍,
    0x2f-人体目标抓拍,0x30-人脸抓拍建模, 0x31-混合目标检测,
    0x32-防区报警, 0x33-紧急求助, 0x34-业务咨询,0x35-非法摆摊,
    0x36-人员密度（人数预警）,0x37-离岗检测,0x38-人数异常检测, 
    0x39-剧烈运动检测, 0x3a-违停, 0x3b-逆行,0x3c-压线,0x3d-机占非,0x3e-变道,0x3f-掉头,0x40-行人检测,0x41-路障,
    0x42-抛洒物,0x43-浓雾检测,0x44-施工,0x45-拥堵,0x46-交通事故检测, 0x47-侧方停车，0x48-手动触发报警,
    0x49-玩手机检测,0x4b-司机驾驶行为,0x4c-高级辅助驾驶,0x4d-挖沙船检测报警,
    0x52-排队检测人数,0x53-排队检测时长,0x54-车辆布控(包括手动布控，日常布控以及平台布控), 0x55-定时唤醒抓拍, 0x56-废气排放监测,
    0x57-灰度报警, 0x58-振动侦测,0x59-人员奔跑,0x5a-人员滞留,0x5b-间距异常,0x5c-人员倒地,0x5d-抽烟检测,0x5e-卡口,0x5f-闯禁令,
    0x60-占用应急车道,0x61-大车占道,0x62-禁止名单,0x63-占用专用车道,0x64-烟雾检测,0x65-ReID人员轨迹,0x66-通道定时抓图事件,
    0x67-AI开放平台事件,0x68-甲烷检测浓度异常,0x69-甲烷检测光强异常,0x70-通道定时抓图,0xff- 全部类型*/
    BYTE   byFileType;        
    BYTE   byNeedCard;     // 是否需要卡号
                           /*
                           0-保留，1-澳，2-京，3-渝，4-闽，5-甘，6-粤，7-桂，
                           8-贵，9-琼，10-冀，11-豫，12-黑，13-鄂，14-湘，
                           15-吉，16-苏，17-赣，18-辽，19-蒙，20-宁，21-青，
                           22-鲁，23-晋，24-陕，25-沪，26-川，27-台，28-津，
                           29-藏，30-港，31-新，32-云，33-浙，34-皖，0xff-全部
    */
    BYTE   byProvince;     //省份索引值
    BYTE   byEventType;      // 事件类型：0保留，1-交通事件；2-违章取证；3-其他事件
    BYTE   sCardNum[CARDNUM_LEN_V30];     // 卡号
    NET_DVR_TIME  struStartTime;//查找图片的开始时间
    NET_DVR_TIME  struStopTime;// 查找图片的结束时间
    //ITC3.7 新增
    DWORD    dwTrafficType; //图片检索生效项 参考 VCA_OPERATE _TYPE 
    DWORD    dwVehicleType; //车辆类型 参考 VCA_VEHICLE_TYPE
    //违规检测类型参考 VCA_ILLEGAL_TYPE 当前不支持复选
    DWORD    dwIllegalType;
    BYTE     byLaneNo;  //车道号(1~99)
    BYTE     bySubHvtType ;//0-保留,1-机动车(机动车子类型中支持车牌检索，省份检索),2-非机动车,3-行人
    BYTE     bySubDriveType;  //驾驶子类型
    //当byFileType为0x4b-司机驾驶行为时，含义为司机驾驶行为类型，具体定义：0-保留、1-抽烟、2-接打电话、3-疲劳驾驶、4-分神提醒、5-驾驶员异常、6-未系安全带、7-红外阻断墨镜、8-双手脱离方向盘、9-单手脱离方向盘、10-驾驶员身份异常、11-超时驾驶、12-驾驶员变更
    //当byFileType为0x4c-高级辅助驾驶时，含义为高级辅助驾驶类型，具体定义：0-保留、1-前向碰撞、2-车道偏离(左)、3-车道偏离(右)、4-车距过近、5-行人防撞、6-盲区检测(右后方)、7-盲区检测(左后方)、8-盲区检测(后方)
    BYTE   byRes2;//保留字节
    char     sLicense[MAX_LICENSE_LEN/*16*/];    //车牌号码
    BYTE     byRegion;     // 区域索引值 0-保留，1-欧洲(Europe Region)，2-俄语区域(Russian Region)，3-欧洲&俄罗斯(EU&CIS), 4-中东(Middle East),0xff-所有
    BYTE     byCountry;     // 国家索引值，参照：COUNTRY_INDEX 
    BYTE     byArea;  //地区
    BYTE   	    byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char cStartTimeDifferenceH;   //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    char cStartTimeDifferenceM;   //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    char cStopTimeDifferenceH;    //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    char cStopTimeDifferenceM;    //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
}NET_DVR_FIND_PICTURE_PARAM, *LPNET_DVR_FIND_PICTURE_PARAM;

typedef struct tagNET_DVR_FIND_FILE_PCNVR
{
    DWORD           dwSize;     //结构体大小
    NET_DVR_IPADDR  struIpAddr; //IP地址
    WORD            wIpPort;    //端口号
    BYTE            byRes[2];   //保留字节
    char            sDomainName[MAX_DOMAIN_NAME]; //域名(暂时没用)
    char            sSerial[SERIALNO_LEN]; //序列号

    DWORD           lChannel;               //通道号
    DWORD           dwFileType;            //录象文件类型0xff－全部，0－定时录像,1-移动侦测 ，2－报警触发，
    //3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像
    DWORD           dwIsLocked;            //是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
    DWORD           dwUseCardNo;           //是否使用卡号
    BYTE            sCardNumber[CARDNUM_LEN_V30];      //卡号
    NET_DVR_TIME    struStartTime;       //开始时间
    NET_DVR_TIME    struStopTime;        //结束时间
}NET_DVR_FILE_COND_PCNVR, *LPNET_DVR_FILE_COND_PCNVR;

typedef struct tagNET_DVR_FINDDATA_PCNVR
{
    char sFileName[100];//文件名
    NET_DVR_TIME struStartTime;//文件的开始时间
    NET_DVR_TIME struStopTime;//文件的结束时间
    DWORD dwFileSize;//文件的大小
    char sCardNum[CARDNUM_LEN_V30];
    BYTE byLocked;//9000设备支持,1表示此文件已经被锁定,0表示正常的文件
    BYTE byFileType;  //文件类型
    BYTE byRes[2];
}NET_DVR_FINDDATA_PCNVR, *LPNET_DVR_FINDDATA_PCNVR;


typedef struct tagNET_DVR_BACKUP_PICTURE_PARAM
{
    DWORD  dwSize;         // 结构体大小   
    DWORD  dwPicNum;
    NET_DVR_FIND_PICTURE struPicture[MAX_RECORD_PICTURE_NUM];
    BYTE   byDiskDes[DESC_LEN_32];
    BYTE   byWithPlayer;
    BYTE   byContinue;    /*是否继续备份 0不继续 1继续*/
    BYTE   byRes[34];
}NET_DVR_BACKUP_PICTURE_PARAM, *LPNET_DVR_BACKUP_PICTURE_PARAM;

typedef struct 
{    
    DWORD dwSize;           //结构体大小
    DWORD dwChannel;        //通道号
    BYTE  byCompressType;   //待获取的压缩参数类型1,主码流2,子码流3,事件
    BYTE  byRes[15];        //保留
    NET_DVR_COMPRESSIONCFG_V30  struCurrentCfg; //当前压缩参数配置
}NET_DVR_COMPRESSION_LIMIT, *LPNET_DVR_COMPRESSION_LIMIT;

typedef struct tagNET_DVR_VIDEO_EFFECT
{
    DWORD dwBrightValue;      //亮度[0,255]
    DWORD dwContrastValue;    //对比度[0,255]
    DWORD dwSaturationValue;  //饱和度[0,255]
    DWORD dwHueValue;         //色调[0,255]
    DWORD dwSharpness;          //锐度[0,255]
    DWORD dwDenoising;          //去噪[0,255]
    BYTE  byRes[12];
}NET_DVR_VIDEO_EFFECT, *LPNET_DVR_VIDEO_EFFECT;

typedef struct tagNET_DVR_VIDEO_INPUT_EFFECT
{    
    DWORD                    dwSize;                //结构体大小
    WORD                    wEffectMode;        //模式 0-标准 1-室内 2-弱光 3-室外  255-自定义
    BYTE                    byRes1[146];        //保留
    NET_DVR_VIDEO_EFFECT    struVideoEffect;    //视频效果参数
    BYTE                    byRes2[60];            //保留
}NET_DVR_VIDEO_INPUT_EFFECT, *LPNET_DVR_VIDEO_INPUT_EFFECT;

typedef struct tagNET_DVR_VIDEOPARA_V40
{
    DWORD    dwChannel;            // 通道号
    DWORD    dwVideoParamType;      // 视频参数类型 0-亮度 1-对比度 2-饱和度 3-色度 4-锐度 5-去噪
    DWORD    dwVideoParamValue;  //对应的视频参数值，范围依据能力集
    BYTE     byRes[12];
}NET_DVR_VIDEOPARA_V40, *LPNET_DVR_VIDEOPARA_V40;

typedef struct tagNET_DVR_DEFAULT_VIDEO_COND
{
    DWORD    dwSize;            // 结构体大小
    DWORD    dwChannel;        // 通道号
    DWORD    dwVideoMode;    // 模式
    BYTE    byRes[32];      // 保留
}NET_DVR_DEFAULT_VIDEO_COND, *LPNET_DVR_DEFAULT_VIDEO_COND;

typedef struct tagNET_DVR_ENCODE_JOINT_PARAM
{
    DWORD    dwSize;            // 结构体大小
    BYTE    byJointed;        //  0 没有关联 1 已经关联
    BYTE    byDevType;        // 被关联的设备类型  1 代表智能设备
    BYTE    byRes1[2];        // 保留字节
    NET_DVR_IPADDR    struIP;            // 关联的被取流设备IP地址
    WORD    wPort;            // 关联的被取流设备端口号
    WORD    wChannel;        // 关联的被取流设备通道号
    BYTE    byRes2[20];            // 保留字节
}NET_DVR_ENCODE_JOINT_PARAM, *LPNET_DVR_ENCODE_JOINT_PARAM;    

typedef struct tagNET_DVR_VCA_CHAN_WORKSTATUS
{
    BYTE    byJointed;                // 0-没有关联  1-已经关联
    BYTE    byRes1[3];
    NET_DVR_IPADDR    struIP;                    // 关联的取流设备IP地址
    WORD    wPort;                    // 关联的取流设备端口号
    WORD    wChannel;                // 关联的取流设备通道号
    BYTE    byVcaChanStatus;        // 0 - 未启用 1 - 启用
    BYTE    byRes2[19];                // 保留字节
}NET_DVR_VCA_CHAN_WORKSTATUS, *LPNET_DVR_VCA_CHAN_WORKSTATUS;

typedef struct tagNET_DVR_VCA_DEV_WORKSTATUS
{
    DWORD    dwSize;            // 结构体大小
    BYTE    byDeviceStatus;    // 设备的状态0 - 正常工作 1- 不正常工作
    BYTE    byCpuLoad;        // CPU使用率0-100 分别代表使用百分率
    NET_DVR_VCA_CHAN_WORKSTATUS struVcaChanStatus[MAX_VCA_CHAN];
    DWORD    dwRes[40];        // 保留字节
}NET_DVR_VCA_DEV_WORKSTATUS, *LPNET_DVR_VCA_DEV_WORKSTATUS;

typedef struct tagNET_DVR_VGA_DISP_CHAN_CFG_V40
{        
    DWORD    dwSize; 
    BYTE   byAudio;            /*音频是否开启*/
    BYTE   byAudioWindowIdx;      /*音频开启子窗口*/
    BYTE     byVgaResolution;      /*分辨率，从能力集获取*/
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL，0-NULL*/
    DWORD    dwWindowMode;        /*画面模式，能力集获取*/       
    BYTE      byJoinDecChan[MAX_WINDOWS];/*各个子窗口关联的解码通道*/
    BYTE    byEnlargeStatus;          /*是否处于放大状态，0：不放大，1：放大*/
    BYTE    byEnlargeSubWindowIndex;//放大的子窗口号
    BYTE    byScale; /*显示模式，0---真实显示，1---缩放显示( 针对BNC )*/
    /*区分共用体，0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置*/
    BYTE    byUnionType;
    union
    {
        BYTE byRes[160];
        struct
        {
            /*各个子窗口对应解码通道所对应的解码子系统的槽位号(对于视频综合平台中解码子系统有效)*/
            BYTE    byJoinDecoderId[MAX_WINDOWS];
            //显示窗口所解视频分辨率，1-D1,2-720P,3-1080P，设备端需要根据此//分辨率进行解码通道的分配，如1分屏配置成1080P，则设备会把4个解码通
            //道都分配给此解码通道
            BYTE    byDecResolution;
            BYTE    byRes[143];
        }struVideoPlatform;
        struct
        {
            BYTE    byRes[160];
        }struNotVideoPlatform;
    }struDiff;
    BYTE    byRes[120];
}NET_DVR_VGA_DISP_CHAN_CFG_V40,*LPNET_DVR_VGA_DISP_CHAN_CFG_V40;

typedef struct tagNET_DVR_V6SUBSYSTEMPARAM
{
    BYTE        bySerialTrans;//是否透传，0-否，1-是
    BYTE        byRes[35];
}NET_DVR_V6SUBSYSTEMPARAM, *LPNET_DVR_V6SUBSYSTEMPARAM;

typedef struct tagNET_DVR_CORRECT_DEADPIXEL_PARAM
{
    DWORD dwSize;
    DWORD dwCommand; //命令：0-进入坏点模式，1-添加坏点，2-保存坏点，3-退出坏点
    DWORD dwDeadPixelX; //坏点X坐标
    DWORD dwDeadPixelY; //坏点Y坐标
    BYTE byRes[12]; //保留
}NET_DVR_CORRECT_DEADPIXEL_PARAM, *LPNET_DVR_CORRECT_DEADPIXEL_PARAM;

typedef struct tagNET_DVR_CORRECT_PARAMS
{
    BYTE byYellowIntervalTime;//黄灯的间隔时间，单位是秒（s）
    BYTE byDigTrafficLight;//是否是交通数字黄灯，0-不是，1-是
    BYTE byRes[2];
}NET_DVR_CORRECT_PARAMS,*LPNET_DVR_CORRECT_PARAMS;

typedef struct tagNET_DVR_REDAREACFG
{
    DWORD dwSize;
    DWORD dwCorrectEnable; //是否开启校正功能，0-关闭，1-开启
    DWORD dwCorrectLevel; //校正级别，1(校正度最低)-10(校正度最高),默认为5
    DWORD dwAreaNum; //校正区域个数
    NET_VCA_RECT struLaneRect[MAX_REDAREA_NUM]; //校正区域
    NET_DVR_CORRECT_PARAMS struCorrectParam[MAX_REDAREA_NUM/*6*/]; //校正区域属性和校正区域对应
    BYTE   byRes2[8]; //保留
}NET_DVR_REDAREACFG, *LPNET_DVR_REDAREACFG;

typedef struct tagNET_DVR_HISTORICDATACFG
{
    DWORD dwSize;
    DWORD dwTotalNum;  //历史数据个数
    BYTE byRes[16];
}NET_DVR_HISTORICDATACFG, *LPNET_DVR_HISTORICDATACFG;

typedef struct tagNET_DVR_INQUEST_ROOM
{
    BYTE        byRoomIndex;     //审讯室编号
    BYTE        byFileType;        //0-审讯文件，1-开庭上传文件
    BYTE        byMode;     /* 0 使用已有常规配置; 非0，按照mode值，  1-电影 2-画中画1  3-画中画2    4-双画面   5-三画面1   6-三画面2   7-四画面1   8-四画面2 */
    BYTE        byQuick;     /* 是否为快速配置， 1-快速配置（不配置参数到flash），0-常规配置（配置参数到Flash） ， 仅在mode 非 0 有效*/
    BYTE        byRes[20];       //保留
}NET_DVR_INQUEST_ROOM, *LPNET_DVR_INQUEST_ROOM;

typedef struct tagNET_DVR_INQUEST_MESSAGE
{
    char         sMessage[INQUEST_MESSAGE_LEN]; //重点标记信息
    BYTE    byRes[46];                     //保留
}NET_DVR_INQUEST_MESSAGE, *LPNET_DVR_INQUEST_MESSAGE;

typedef struct tagNET_DVR_INQUEST_SENSOR_DEVICE
{
    WORD    wDeviceType;    //数据采集设备型号:0-无 1-米乐 2-镭彩 3-优力 4-佳盟 5-永控、6-垅上、7-维纳斯达
    WORD    wDeviceAddr;    //数据采集设备地址    
    BYTE     byRes[28];        //保留
}NET_DVR_INQUEST_SENSOR_DEVICE, *LPNET_DVR_INQUEST_SENSOR_DEVICE;

typedef struct tagNET_DVR_INQUEST_SENSOR_INFO
{
    NET_DVR_INQUEST_SENSOR_DEVICE struSensorDevice[INQUEST_MAX_ROOM_NUM];
    DWORD   dwSupportPro;      //支持协议类型,按位表示, 新版本走能力集，不再扩展此字段
    //0x1:米乐 0x2:镭彩 0x4:优力
    BYTE    byRes[120];        //保留
}NET_DVR_INQUEST_SENSOR_INFO, *LPNET_DVR_INQUEST_SENSOR_INFO;

typedef struct tagNET_DVR_INQUEST_ROOM_INFO
{
    char        szCDName[NAME_LEN];    //光盘名称，单室双刻光盘名称是一样的
    union
    {
        BYTE     byBitRate;    // byCalcType为0时有效，(0-32、1-48、2-64、3-80、4-96、5-128、
                                //6-160、7-192、8-224、9-256、10-320、11-384、12-448、
                                //13-512、14-640、15-768、16-896前16个值保留)17-1024、18-1280、19-1536、
                                //20-1792、21-2048、22-3072、23-4096、24-8192
        BYTE    byInquestTime;  // byCalcType为1时有效，0-1小时, 1-2小时,2-3小时,3-4小时, 4-6小时,5-8小时,6-10小时,7-12小时
        //8-16小时, 9-20小时,10-22小时,11-24小时
    }uCalcMode;
    BYTE        byCalcType;            //刻录计算类型0-按码率 1-按时间
    BYTE        byAutoDelRecord;    // 是否自动删除录像，0-不删除，即结束时保存录像 1-删除
    BYTE        byAlarmThreshold;        // 声音报警阀值
    BYTE        byInquestChannelResolution;     //审讯通道分辨率，0:720P,1:1080P,2:CIF,3:4CIF,4:WD1,5-VGA
    BYTE        byAutoOpenTray;        //是否自动弹仓 0-否，1-是
    BYTE        byCDPrintEnabled;      //恢复完成后，是否使能光盘封面打印功能 0-否 1-开启
    BYTE        byRes[9];
}NET_DVR_INQUEST_ROOM_INFO, *LPNET_DVR_INQUEST_ROOM_INFO;

typedef struct tagNET_DVR_INQUEST_SYSTEM_INFO
{
    DWORD    dwRecordMode;         //刻录模式:1 单室双刻模式 2 单室轮刻模式 3 双室双刻模式（修改需要重启设备）
    DWORD    dwWorkMode;           //工作模式:0 标准模式 1 通用模式(保留，目前只有标准模式)
    DWORD    dwResolutionMode;     //设备分辨率，0:标清 1:D1 2:720P 3:1080P（高清审讯机不用此字段）
    NET_DVR_INQUEST_SENSOR_INFO struSensorInfo;  //温湿度传感器配置    
    NET_DVR_INQUEST_ROOM_INFO     struInquestRoomInfo[INQUEST_MAX_ROOM_NUM];
    BYTE    byEnableHashCheck;        //是否启用对光盘数据HASH值校验 0-无意义，1-不启用，2-启用
    BYTE    byEnableInitCD;        //是否启用初始化光盘 0-无意义，1-不启用，2-启用
    BYTE    byCDProcessingMode;  //1.存盘模式 2-出盘模式 存盘模式：刻录完成的光盘归档到出盘桶上；刻录失败的光盘，机械臂将坏盘直接通过中间的出盘位置弹出。出盘模式：将刻录好的光盘从中间的出盘位置出盘，刻录失败的光盘放到出盘桶里
    BYTE    byRes[21];             //保留
}NET_DVR_INQUEST_SYSTEM_INFO, *LPNET_DVR_INQUEST_SYSTEM_INFO;

typedef struct _NET_DVR_INQUEST_ALARM_
{
    DWORD dwSize;
    DWORD dwAlarmType;    /*报警类型 0-光盘满 1-光盘错误 2-审讯超时提醒*/
    BYTE byTrayNo;     /*光驱号*/
    BYTE byRes[3];   
    DWORD dwInquestTime;   /*已审讯时间,当dwAlarmType=2时有效,单位:秒*/
    DWORD dwNotifyChannel; /*审讯时间超时提醒通道号*/
    BYTE byRes1[244];
}NET_DVR_INQUEST_ALARM, *LPNET_DVR_INQUEST_ALARM;

typedef struct _NET_DVR_VIDEO_PARKING_POLE_ALARM_
{
    DWORD  dwSize;  //结构体大小
    NET_DVR_TIME_V30  struTime;  //触发时间
    BYTE  byParkingNum[32];  //车位编号
    BYTE  byAlarmType;  //报警类型，0-未知，1-镜头遮挡报警，2-按钮报警，3-非法占用报警，4-车位状态变化
    BYTE  byVehicleEnterState; //车辆进入状态，0-未知，1-进入，2-离开
    BYTE  byRes[78];
}NET_DVR_VIDEO_PARKING_POLE_ALARM, *LPNET_DVR_VIDEO_PARKING_POLE_ALARM;

typedef struct tagNET_DVR_INQUEST_RESUME_SEGMENT
{
    NET_DVR_TIME  struStartTime; //事件起始时间
    NET_DVR_TIME  struStopTime;  //事件终止时间
    BYTE    byRoomIndex;         //审讯室编号,从1开始
    BYTE    byDriveIndex;        //刻录机编号,从1开始
    WORD    wSegmetSize;         //本片断的大小, 单位M 
    DWORD   dwSegmentNo;         //本片断在本次审讯中的序号,从1开始 
    BYTE    byRes[24];           //保留
}NET_DVR_INQUEST_RESUME_SEGMENT, *LPNET_DVR_INQUEST_RESUME_SEGMENT;

typedef struct tagNET_DVR_INQUEST_RESUME_EVENT
{
    DWORD   dwResumeNum;       //需恢复的事件个数
    NET_DVR_INQUEST_RESUME_SEGMENT struResumeSegment[MAX_RESUME_SEGMENT];
    BYTE    byResumeMode;        //恢复模式，0-单光盘恢复，1-双光盘恢复
    BYTE    byCDPrintEnbled;    //恢复完成后，是否使能光盘封面打印功能 0-否 1-开启
    BYTE    byRes[198];        //保留
}NET_DVR_INQUEST_RESUME_EVENT, *LPNET_DVR_INQUEST_RESUME_EVENT;

typedef struct tagNET_DVR_INQUEST_DEVICE_VERSION
{
BYTE  byMainVersion;         /*基线主版本.
                             0 : 未知
                             1 : 8000审讯DVR
                             次版本: 1 : 8000HD-S
                             2 : 8100审讯DVR 
                             次版本: 1 : 审讯81SNL
                             2 : 审讯81SH
                             3 : 审讯81SFH
                             3 : 8608高清审讯机NVR 
                             次版本: 1 : DS-8608SN-SP
                             2 : DS-8608SN-ST
*/
BYTE  bySubVersion;          //基线次版本
BYTE  byUpgradeVersion;      //升级版本,未升级为0
BYTE  byCustomizeVersion;     //定制版本,非定制为0
BYTE  byRes[60];             //保留
}NET_DVR_INQUEST_DEVICE_VERSION, *LPNET_DVR_INQUEST_DEVICE_VERSION;

typedef struct tagNET_DVR_DISK_RAID_INFO 
{
    DWORD dwSize;   //结构体大小
    BYTE byEnable;  //磁盘Raid是否禁用
    BYTE bySleepStatus;    //0-无效， 1-休眠，2-不休眠
    BYTE byRes[34];  //保留字节
}NET_DVR_DISK_RAID_INFO, *LPNET_DVR_DISK_RAID_INFO;

typedef struct tagNET_DVR_SYNCHRONOUS_IPC
{
    DWORD dwSize;    //结构体大小
    BYTE  byEnable;  //是否启用：为前端IPC同步设备参数
    BYTE  byRes[7];  //保留
}NET_DVR_SYNCHRONOUS_IPC, *LPNET_DVR_SYNCHRONOUS_IPC;

typedef struct tagNET_DVR_IPC_PASSWD
{
    DWORD dwSize;    //结构体大小
    char sOldPasswd[PASSWD_LEN];  //IPC的旧密码，传给DVR让DVR验证
    char sNewPasswd[PASSWD_LEN];  //IPC的新密码
    BYTE byRes[32];
}NET_DVR_IPC_PASSWD, *LPNET_DVR_IPC_PASSWD;

typedef struct tagNET_DEVICE_NET_USING_INFO 
{
    DWORD dwSize;    //结构体大小
    DWORD dwPreview;   //预览
    DWORD dwPlayback;  //回放
    DWORD dwIPCModule; //IPC接入
    DWORD dwNetDiskRW; //网盘读写
    BYTE res[32];
}NET_DVR_DEVICE_NET_USING_INFO, *LPNET_DVR_DEVICE_NET_USING_INFO;

typedef struct tagNET_DVR_IPC_NETCFG
{
    DWORD dwSize;      //结构体大小
    NET_DVR_IPADDR struIP;       //IPC的IP地址
    WORD wPort;       //IPC的端口
    char res[126];  
}NET_DVR_IPC_NETCFG, *LPNET_DVR_IPC_NETCFG;

typedef struct tagNET_DVR_TIME_LOCK
{
    DWORD dwSize;      //结构体大小
    NET_DVR_TIME strBeginTime;
    NET_DVR_TIME strEndTime;
    DWORD   dwChannel;        //通道号, 0xff表示所有通道
    DWORD   dwRecordType;     //录像类型:  0xffffffff－全部，0－定时录像，1-移动侦测，2－报警触发，3-报警触发或移动侦测，4-报警触发和移动侦测，5-命令触发，6-手动录像，7-智能录像(同文件查找)
    DWORD   dwLockDuration;   //锁定持续时间,单位秒,0xffffffff表示永久锁定
    NET_DVR_TIME_EX strUnlockTimePoint;    //加锁时有效，当dwLockDuration不为永久锁定时，锁定持续的时间到此时间点就自动解锁
    BYTE    byRes[4];
}NET_DVR_TIME_LOCK, *LPNET_DVR_TIME_LOCK;

typedef struct tagNET_DVR_LOCK_RETURN
{
    DWORD dwSize;      //结构体大小
    NET_DVR_TIME strBeginTime; 
    NET_DVR_TIME strEndTime;
    BYTE         byISO8601;      		//是否是8601的时间格式，即时差字段是否有效,0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char         cTimeDifferenceH;      //与UTC的时差（小时），-12 ... +14，+表示东区, byISO8601为1时有效
    char         cTimeDifferenceM;      //与UTC的时差（分钟），-30, 30, 45，+表示东区, byISO8601为1时有效
    BYTE    byRes[17];
}NET_DVR_LOCK_RETURN, *LPNET_DVR_LOCK_RETURN;





typedef struct tagNET_DVR_PANORAMIC_STITCH_UPLOAD
{
    DWORD     dwSize;
    DWORD        dwChannel;// 通道号
    BYTE        byRes[128];
}NET_DVR_PANORAMIC_STITCH_UPLOAD, *LPNET_DVR_PANORAMIC_STITCH_UPLOAD;

typedef struct NET_DVR_FD_DATA_COND
{
    DWORD       dwSize;
    char        szFDID[NET_SDK_MAX_FDID_LEN/*256*/];   //人脸库ID
    char        szCheckCode[NET_SDK_CHECK_CODE_LEN/*128*/];   //校验码
    BYTE         byCover;//是否覆盖式导入 0-否，1-是
    BYTE        byRes[127];
}NET_DVR_FD_DATA_COND, *LPNET_DVR_FD_DATA_COND;

typedef struct NET_DVR_UPLOAD_FACE_DATA
{
    DWORD       dwSize;
    char        szFDID[NET_SDK_MAX_FDID_LEN/*256*/];   //人脸库ID
    BYTE        byFDLibType; //人脸库类型0-保留;1-禁止名单；2-允许名单
    BYTE        byRes1[3];
    char        szCustomInfo[NET_SDK_FDPIC_CUSTOM_INFO_LEN/*96*/];   //人脸库图片自定义信息
    BYTE        byRes[512];
}NET_DVR_UPLOAD_FACE_DATA, *LPNET_DVR_UPLOAD_FACE_DATA;

typedef struct NET_DVR_UPLOAD_FACE_DATA_OUT
{
    char        szPicID[NET_SDK_MAX_PICID_LEN/*256*/];   //图片ID
    BYTE        byRes[128];
}NET_DVR_UPLOAD_FACE_DATA_OUT, *LPNET_DVR_UPLOAD_FACE_DATA_OUT;

typedef struct NET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT
{
    DWORD       dwSize;
    DWORD       dwPID;//图片ID
    DWORD       dwFaceAnalysisNum;//识别出的人脸区域个数
    NET_VCA_RECT       struVcaRect[NET_DVR_MAX_FACE_ANALYSIS_NUM];  //识别出来的人脸目标，紧凑排列
    BYTE        byRes[128];
}NET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT, *LPNET_DVR_UPLOAD_FACE_ANALYSIS_DATA_OUT;

typedef struct NET_DVR_SECURITY_CFG_FILE_COND
{
    DWORD       dwSize;
    char        szSecretKey[NET_SDK_SECRETKEY_LEN/*128*/];//校验密钥
    BYTE        byRes[128];
}NET_DVR_SECURITY_CFG_FILE_COND, *LPNET_DVR_SECURITY_CFG_FILE_COND;

typedef struct tagNET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM_
{
    DWORD     dwSize;
    BYTE      byType;   //日志类型，0-全部，1-精简，2-默认
    BYTE      byRes[255];
}NET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM, *LPNET_DVR_DOWNLOAD_CLUSTER_MAINTENANCE_LOG_PARAM;

typedef struct tagNET_DVR_BONJOUR_CFG
{
    DWORD    dwSize;                // 结构体大小
    BYTE    byEnableBonjour;        // Bonjour使能 0 ：开启 1：关闭
    BYTE     byRes1[3];                
    BYTE     byFriendlyName[MAX_DOMAIN_NAME];     // 服务名
    BYTE     byRes2[128];
}NET_DVR_BONJOUR_CFG, *LPNET_DVR_BONJOUR_CFG;

typedef struct tagNET_DVR_SOCKS_CFG
{
    DWORD            dwSize;                // 结构体大小
    BYTE            byEnableSocks;          // 使能 0：关闭 1：开启
    BYTE             byVersion;              // SOCKS版本 4：SOCKS4   5：SOCKS5
    WORD            wProxyPort;                // 代理端口，默认1080
    BYTE            byProxyaddr[MAX_DOMAIN_NAME];      // 代理IP地址，可以是域名
    BYTE             byUserName[MAX_DOMAIN_NAME];     // 用户名 SOCKS才用
    BYTE             byPassword[NAME_LEN];            // 密码SOCKS5才用
    BYTE             byLocalAddr[MAX_LOCAL_ADDR_LEN];  //不使用socks代理的网段，格式为"ip/netmask;ip/netmask;…"
    BYTE             byRes[128];
}NET_DVR_SOCKS_CFG, *LPNET_DVR_SOCKS_CFG;

typedef struct tagNET_DVR_QOS_CFG
{
    DWORD        dwSize;
    BYTE        byManageDscp;   // 管理数据的DSCP值 [0-63]
    BYTE        byAlarmDscp;    // 报警数据的DSCP值 [0-63]
    BYTE        byVideoDscp;    // 视频数据的DSCP值 [0-63]，byFlag为0时，表示音视频
    BYTE        byAudioDscp;    // 音频数据的DSCP值 [0-63]，byFlag为1时有效
    BYTE        byFlag;            // 0：音视频合一，1：音视频分开
    BYTE        byEnable;
    BYTE         byRes[126];
}NET_DVR_QOS_CFG, *LPNET_DVR_QOS_CFG;

typedef struct tagNET_DVR_HTTPS_CFG
{
    DWORD        dwSize;
    WORD        wHttpsPort;        // HTTPS端口
    BYTE        byEnable;        // 使能 0：关闭 1：开启
    BYTE        byRes[125];
}NET_DVR_HTTPS_CFG, *LPNET_DVR_HTTPS_CFG;

typedef struct tagNET_DVR_CERT_NAME
{
    BYTE    byCountry[MAX_COUNTRY_NAME_LEN];              //国家代号 CN等
    BYTE     byState[MAX_DOMAIN_NAME];                //洲或省
    BYTE     byLocality[MAX_DOMAIN_NAME];            //地区
    BYTE     byOrganization[MAX_DOMAIN_NAME];        //组织
    BYTE     byUnit[MAX_DOMAIN_NAME];                //单位
    BYTE     byCommonName[MAX_DOMAIN_NAME];
    BYTE     byEmail[MAX_DOMAIN_NAME];  
    BYTE     byRes[128];
}NET_DVR_CERT_NAME, *LPNET_DVR_CERT_NAME ;

typedef struct tagNET_DVR_CERT_ADDITION_PARAM
{
    DWORD dwSize;
    char  csCustomID[64]; //用户自定义ID
    BYTE  byRes1[2];
    BYTE  byCertificateMode;//wCertType为1-Certificate时有效，0-自签名证书，1-证书和私钥方式
    BYTE  byPrivateKeyMode;// byCertificateMode为1-证书和私钥方式时有效 0-独立key 1-PKCS#12
    BYTE  byPassword[64];  //密码，当PrivateKeyMode为0时为私钥的密码，为1时为PKCS#12的密码
    BYTE  byRes[128];
}NET_DVR_CERT_ADDITION_PARAM, *LPNET_DVR_CERT_ADDITION_PARAM;

typedef struct tagNET_DVR_CERT_PARAM
{
    DWORD dwSize;
    WORD wCertFunc; //证书种类，0-802.1x(应用于WIFI接入证书),1-HTTPS, 3-ieee802.1x(应用于有线LAN接入认证)
    WORD wCertType; //证书类型，0-CA，1-Certificate,2-私钥文件
    BYTE byFileType; //证书文件类型，0-PEM,1-PFX
    BYTE byRes1[2];//保留字节
    BYTE byAddition;//是否使用附加结构体，0-不使用;1-使用
    NET_DVR_CERT_ADDITION_PARAM * pStruAdditionParam;//附加信息结构体指针
    BYTE byRes[28];
}NET_DVR_CERT_PARAM, *LPNET_DVR_CERT_PARAM;

typedef struct tagNET_DVR_CERT_INFO
{
    DWORD                 dwSize;
    NET_DVR_CERT_PARAM     struCertParam;    //证书参数
    DWORD                dwValidDays;   //有效天数，类型为自签名时有效
    BYTE                 byPasswd[NAME_LEN];   //私钥密码
    NET_DVR_CERT_NAME     struCertName;    // 证书名称
    NET_DVR_CERT_NAME     struIssuerName;    // 证书发行者名称（自签名证书信息获取时有效）
    NET_DVR_TIME_EX         struBeginTime;   //证书创建时间（自签名证书信息获取时有效）
    NET_DVR_TIME_EX         struEndTime;   //证书截止时间（自签名证书信息获取时有效）
    BYTE                 serialNumber[NAME_LEN];   //证书标识码（自签名证书信息获取时有效）
    BYTE                 byVersion; 
    BYTE                 byKeyAlgorithm;            //加密类型 0-RSA  1-DSA
    BYTE                  byKeyLen;                //加密长度 0-512  1-1024、 2-2048
    BYTE                 bySignatureAlgorithm; //签名算法类型（自签名证书信息获取时有效）
    BYTE                 byRes[128];
}NET_DVR_CERT_INFO, *LPNET_DVR_CERT_INFO;

typedef struct tagNET_DVR_CHANS_RECORD_STATUS
{
    BYTE    byValid;       //是否有效
                           /*(只读)录像类型:0: 不在录像；1：在录像 2-空闲 
                           3-无连接 4-无输入视频 5-未加载 6-存档中 7-回传中 
    8-用户名或密码错 9-未验证,10-存档中和录像中 11-录像回传中和录像中 12-token认证失败*/
    BYTE    byRecord;     
    WORD    wChannelNO;   //通道号
    DWORD   dwRelatedHD;  //关联磁盘
    BYTE    byOffLineRecord;  //断网录像功能 0-关闭 1-开启
    BYTE    byRes[7];      //保留字节
}NET_DVR_CHANS_RECORD_STATUS, *LPNET_DVR_CHANS_RECORD_STATUS;

typedef struct tagNET_DVR_IP_ALARM_GROUP_NUM
{
    DWORD dwSize; 
    DWORD dwIPAlarmInGroup;      //IP通道报警输入组数
    DWORD dwIPAlarmInNum;       //IP通道报警输入个数
    DWORD dwIPAlarmOutGroup;     //IP通道报警输出组数
    DWORD dwIPAlarmOutNum;      //IP通道报警输出个数
    BYTE byRes[64];  
}NET_DVR_IP_ALARM_GROUP_NUM, *LPNET_DVR_IP_ALARM_GROUP_NUM;

typedef struct tagNET_DVR_CHAN_GROUP_RECORD_STATUS
{
    DWORD dwSize; //结构体大小
    NET_DVR_CHANS_RECORD_STATUS struChanStatus[MAX_CHANNUM_V30]; //一组64个
}NET_DVR_CHAN_GROUP_RECORD_STATUS, *LPNET_DVR_CHAN_GROUP_RECORD_STATUS;

typedef struct tagNET_DVR_RECTCFG
{
    WORD wXCoordinate; /*矩形左上角起始点X坐标*/
    WORD wYCoordinate; /*矩形左上角Y坐标*/
    WORD wWidth;       /*矩形宽度*/
    WORD wHeight;      /*矩形高度*/
}NET_DVR_RECTCFG, *LPNET_DVR_RECTCFG;

typedef struct tagNET_DVR_WINCFG
{
    DWORD dwSize;
    BYTE  byVaild;
    BYTE  byInputIdx;          /*输入源索引*/
    BYTE  byLayerIdx;          /*图层，0为最底层*/
    BYTE  byTransparency; //透明度，0～100 
    NET_DVR_RECTCFG  struWin;//目的窗口(相对显示墙)
    WORD wScreenHeight;//大屏高
    WORD wScreenWidth;//大屏宽
    BYTE  byRes[20];
}NET_DVR_WINCFG, *LPNET_DVR_WINCFG;

typedef struct tagNET_DVR_ALLWINCFG
{
    DWORD dwSize;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    BYTE  byRes2[24];
}NET_DVR_ALLWINCFG, *LPNET_DVR_ALLWINCFG;

typedef struct tagNET_DVR_SCREENZOOM
{
    DWORD dwSize;
    DWORD dwScreenNum;//大屏号
    NET_DVR_POINT_FRAME struPointFrame;
    BYTE  byLayer;//图层号
    BYTE  byRes[11];
}NET_DVR_SCREENZOOM, *LPNET_DVR_SCREENZOOM;

typedef struct tagNET_MATRIX_CAMERAINFO
{  
    DWORD dwGlobalCamId;      /* cam的全局编号*/
    BYTE  sCamName[NAME_LEN]; /*cam的名称*/
    DWORD dwMatrixId;          /*cam对应矩阵的编号*/
    DWORD dwLocCamId;         /*cam对应矩阵的内部编号*/ 
    BYTE  byValid;    /*是否有效，0-否，1-是*/
    BYTE  byPtzCtrl; /* 是否可控，0-否，1-是*/
    BYTE  byUseType; //*使用类型，0-不作为干线使用，1-BNC，2-SP3,3-V6光纤，4-其他光纤*/ 
    BYTE  byUsedByTrunk;//当前使用状态，0-没有被使用，1-被干线使用 
    BYTE  byTrunkReq; /*摄像机分辨率,以D1为单位：1 - 1个D1，2- 2个D1，作为干线使用时，指的是干线的带宽*/
    BYTE  byRes1[3];
    NET_DVR_TIME struInstallTime;//安装时间
    BYTE  sPurpose[NAME_LEN];/*用途描述*/
    BYTE  byRes2[20];  
}NET_MATRIX_CAMERAINFO, *LPNET_MATRIX_CAMERAINFO;

typedef struct tagNET_MATRIX_MONITORINFO 
{
    DWORD    dwGloalMonId; /*mon 的统一编号*/
    BYTE    sMonName[NAME_LEN];
    DWORD    dwMatrixId;  /*mon所在矩阵的编号*/
    DWORD    dwLocalMonId; /*mon的内部编号*/
    BYTE    byValid;    /*是否有效，0-否，1-是*/
    BYTE    byTrunkType; /*使用类型，0-不作为干线使用，1-BNC，2-SP3,3-V6光纤，4-其他光纤*/ 
    BYTE    byUsedByTrunk;//当前使用状态，0-没有被使用，1-被干线使用 
    BYTE    byTrunkReq; /*分辨率, 以D1为单位：1- 1个D1，2- 2个D1，作为干线使用时，指的是干线的带宽*/
    NET_DVR_TIME struInstallTime;//安装时间
    BYTE    sPurpose[NAME_LEN];/*用途描述*/
    BYTE    byRes[20];  
}NET_MATRIX_MONITORINFO, *LPNET_MATRIX_MONITORINFO;

typedef struct tagNET_MATRIX_DIGITALMATRIX
{
    NET_DVR_IPADDR  struAddress; /*设备为数字设备时的IP信息*/
    WORD    wPort;
    BYTE    byNicNum; /*0 - eth0, 1 - eth1, 考虑双网口如何通信加入绑定的网口*/
    BYTE    byRes[69];   
}NET_MATRIX_DIGITALMATRIX, *LPNET_MATRIX_DIGITALMATRIX;

typedef struct tagNET_MATRIX_ANALOGMATRIX
{
    BYTE    bySerPortNum;   /*连接的串口号  0xff-环通接入*/
    BYTE    byMatrixSerPortType;/* 矩阵接入网关的串口与模拟矩阵的键盘口(键盘协议)连接还是与矩阵通信口（矩阵协议）连接 ，0 --- 矩阵协议通讯口 1 --- 键盘通讯口*/
    BYTE    byRes1[2];
    NET_DVR_SINGLE_RS232 struRS232;    //232串口参数  环通接入时此参数无效
    BYTE    byRes2[200];      
}NET_MATRIX_ANALOGMATRIX, *LPNET_MATRIX_ANALOGMATRIX;


typedef struct tagNET_MATRIX_MATRIXINFO 
{
    DWORD   dwSize;
    DWORD    dwMatrixId;  /*矩阵编号*/
    BYTE    sDevName[NAME_LEN];
    BYTE    byCtrlType; /*指通讯方式是串口通信, 还是网络通信*/
    BYTE    byProtocolType;/*设置通信控制协议*/
    BYTE    byRes1[6];   /*预留*/
    NET_MATRIX_UNION struMatrixUnion;
    DWORD    dwMaxPortsIn; /*矩阵输入数*/
    DWORD    dwMaxPortsOut;/*矩阵输出数*/
    BYTE    sUserName[NAME_LEN];   /*登录用户名*/
    BYTE    sPassword[PASSWD_LEN];  /*登录密码*/        
    NET_DVR_TIME struInstallTime;//安装时间
    BYTE    sPurpose[NAME_LEN];/*用途描述*/
    BYTE    byRes2[20];   /*预留*/
}NET_MATRIX_MATRIXINFO, *LPNET_MATRIX_MATRIXINFO;

typedef struct tagNET_DVR_MATRIXLIST
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwMatrixNum;//设备返回的矩阵数量
    BYTE    *pBuffer;//矩阵信息缓冲区
    DWORD   dwBufLen;//所分配指针长度，输入参数
}NET_DVR_MATRIXLIST,*LPNET_DVR_MATRIXLIST;

typedef struct tagNET_MATRIX_UARTPARAM
{    
    DWORD dwSize;
    BYTE  byPortName[NAME_LEN];
    WORD  wUserId; /*用户编号，当连接设备为键盘时，绑定一个用户，用于权限管理*/
    BYTE  byPortType;    /*串口类型，三种0-RS232/1-RS485/2-RS422*/
    BYTE  byFuncType; /*串口连接的设备的类型0-空闲，1-键盘，2-用作透明通道(485串口不可配置成透明通道),3-模拟矩阵*/     
    BYTE  byProtocolType;  /*串口支持的协议类型, 当连接键盘设备时需要该信息,获取键盘支持协议的编号及描述符*/
    BYTE  byBaudRate;
    BYTE  byDataBits;
    BYTE  byStopBits;   /*停止位*/
    BYTE  byParity;      /*校验*/
    BYTE  byFlowCtrl;   /*流控，软件流控，无流控*/
    BYTE  byRes[22];     /*预留*/
}NET_MATRIX_UARTPARAM, *LPNET_MATRIX_UARTPARAM;

typedef struct tagNET_MATRIX_USERPARAM 
{
    DWORD dwSize;
    BYTE    sUserName[NAME_LEN];
    BYTE    sPassword[PASSWD_LEN/*16*/];
    BYTE    byRole;/*用户角色:0-管理员,1-操作员；只有一个系统管理员，255个操作员*/
    BYTE    byLevel;  /*统一级别，用于操作级别管理,1- 255*/
    BYTE    byRes[18];
}NET_MATRIX_USERPARAM, *LPNET_MATRIX_USERPARAM;

typedef struct tagNET_MATRIX_RESOURSEGROUPPARAM
{
    DWORD dwSize;
    BYTE  byGroupName[NAME_LEN];
    BYTE  byGroupType;/*0-摄像机CAM组，1-监视器MON组*/
    BYTE  byRes1;
    WORD  wMemNum;
    DWORD dwGlobalId[512];
    BYTE  byRes2[20];
}NET_MATRIX_RESOURCEGROUPPARAM,*LPNET_MATRIX_RESOURSEGROUPPARAM;

typedef struct tagNET_MATRIX_USERGROUPPARAM
{
    DWORD dwSize;
    BYTE  sGroupName[NAME_LEN];
    WORD  wUserMember[255];  /*包含的用户成员*/
    WORD  wResorceGroupMember[255]; /*包含的资源组成员*/
    BYTE  byPermission[32];//权限，数组0-ptz权限、切换权限、查询权限
    BYTE  byRes[20];
} NET_MATRIX_USERGROUPPARAM, *LPNET_MATRIX_USERGROUPPARAM;

typedef struct tagNET_MATRIX_TRUNKPARAM
{
    DWORD    dwSize;
    DWORD    dwTrunkId;
    BYTE    sTrunkName[NAME_LEN];
    DWORD    dwSrcMonId;
    DWORD    dwDstCamId;
    BYTE    byTrunkType;  /*使用类型  1-BNC，2-SP3光纤高清，3-SP3光纤D1， 4-V6光纤，5-其他光纤*/
    BYTE    byAbility;     /*表示光纤的带宽，可以传输几路*/
    BYTE    bySubChan;   /*针对光纤干线而言，表示子通道号*/
    BYTE    byLevel;        /* 干线级别 1-255*/
    WORD    wReserveUserID;    //预留的用户ID： 1~256 ，0表示释放预留
    BYTE   byRes[18]; 
} NET_MATRIX_TRUNKPARAM, *LPNET_MATRIX_TRUNKPARAM;

typedef struct tagNET_DVR_MATRIX_TRUNKLIST
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwTrunkNum;//设备返回的干线数量
    BYTE    *pBuffer;//干线信息缓冲区
    DWORD   dwBufLen;//所分配指针长度，输入参数
}NET_DVR_MATRIX_TRUNKLIST,*LPNET_DVR_MATRIX_TRUNKLIST;

typedef struct tagNET_DVR_PROTO_TYPE_EX
{ 
    WORD wType;               /*ipc协议值*/  
    WORD wCommunitionType;        /*0：模拟 1：数字 2：兼容模拟、数字*/
    BYTE  byDescribe[DESC_LEN]; /*协议描述字段*/    
}NET_DVR_PROTO_TYPE_EX, LPNET_DVR_PROTO_TYPE_EX;

typedef struct tagNET_DVR_MATRIXMANAGE_ABIILITY
{
    DWORD    dwSize;
    DWORD    dwMaxCameraNum;//最大Camera数量
    DWORD    dwMaxMonitorNum;//最大监视器数量
    WORD    wMaxMatrixNum;//最大矩阵数量
    WORD    wMaxSerialNum;//串口数量
    WORD    wMaxUser;//最大用户数
    WORD    wMaxResourceArrayNum;//最大资源组数
    WORD    wMaxUserArrayNum;//最大用户组数
    WORD    wMaxTrunkNum;//最大干线数
    BYTE    nStartUserNum;//起始用户号
    BYTE    nStartUserGroupNum;//起始用户组号
    BYTE    nStartResourceGroupNum;//起始资源组号
    BYTE    nStartSerialNum;//起始串口号
    DWORD   dwMatrixProtoNum;     /*有效的矩阵协议数目，从0开始*/
    NET_DVR_PROTO_TYPE_EX struMatrixProto[MATRIX_PROTOCOL_NUM];/*最大协议列表长度*/    
    DWORD   dwKeyBoardProtoNum;     /*有效的键盘协议数目，从0开始*/
    NET_DVR_PROTO_TYPE_EX struKeyBoardProto[KEYBOARD_PROTOCOL_NUM];/*最大协议列表长度*/   
    BYTE   byDelMonitorLongCfg;  //是否支持删除monitor长连接配置
    BYTE   byDelCamonitorLongCfg;//是否支持删除camera长连接配置
    BYTE   byAudioSwitchContorl;//是否支持音频开关控制
    BYTE    byRes[29];
} NET_DVR_MATRIXMANAGE_ABILITY, *LPNET_DVR_MATRIXMANAGE_ABILITY;

typedef struct tagNET_VCA_SINGLE_FACESNAPCFG
{
    BYTE byActive;                //是否激活规则：0-否，1-是
    /********* IPC5.1.7 新增参数 Begin 2014-03-21***********/
    //人脸自动ROI开关使能
    BYTE byAutoROIEnable;//0-关闭,1-开启
    BYTE byRes[2]; //保留
    /********* IPC5.1.7 新增参数 End 2014-03-21***********/
    NET_VCA_SIZE_FILTER struSizeFilter;   //尺寸过滤器
    NET_VCA_POLYGON     struVcaPolygon;        //人脸识别区域
}NET_VCA_SINGLE_FACESNAPCFG, *LPNET_VCA_SINGLE_FACESNAPCFG;

typedef struct tagNET_VCA_FACESNAPCFG
{
    DWORD dwSize;
    BYTE bySnapTime;                    //单个目标人脸的抓拍次数0-10
    BYTE bySnapInterval;                 //抓拍间隔，单位：帧
    BYTE bySnapThreshold;               //抓拍阈值，0-100
    BYTE byGenerateRate;         //目标生成速度,范围[1, 5]    
    BYTE bySensitive;            //目标检测灵敏度，范围[1, 5]
    BYTE byReferenceBright; //2012-3-27参考亮度[0,100]
    BYTE byMatchType;         //2012-5-3比对报警模式，0-目标消失后报警，1-实时报警
    BYTE byMatchThreshold;  //2012-5-3实时比对阈值，0~100
    NET_DVR_JPEGPARA  struPictureParam; //图片规格结构
    NET_VCA_SINGLE_FACESNAPCFG struRule[MAX_RULE_NUM]; //人脸抓拍规则
    //人脸曝光最短持续时间（两个字节）
    WORD wFaceExposureMinDuration;//范围(1~3600秒，默认60)生效于自动模式下
    //人脸曝光模式
    BYTE byFaceExposureMode;//1-关闭，2-开启，0-自动（根据人脸判断）
    BYTE byBackgroundPic;//背景图上传使能 0-默认值（开启），1-禁止
    DWORD dwValidFaceTime;    //有效人脸最短持续时间，单位：秒
    DWORD dwUploadInterval; //人脸抓拍统计数据上传间隔时间，单位：秒，默认900秒
    DWORD dwFaceFilteringTime;//人脸停留时间过滤,默认5秒，范围0-100秒。0秒表示不过滤
    BYTE  bySceneID;     //场景号,目前支持1~4场景，0为无效
    BYTE byInvalCapFilterEnable;//无效抓拍过滤使能，0为关闭，1为开启，默认为0
    BYTE byInvalCapFilterThreshold;//无效抓拍过滤阈值，0~100，当byInvalCapFilterEnable为1时生效
    BYTE byRes2[81];
}NET_VCA_FACESNAPCFG, *LPNET_VCA_FACESNAPCFG;

typedef struct tagNET_DVR_FIRMWARE_VERSION_IFNO
{
    DWORD       dwSize;//结构体大小
    char        szFirmwareVersion[LEN_PROPERTY/*128*/];  //主控版本属性 只读
    BYTE        byRes2[128];
}NET_DVR_FIRMWARE_VERSION_IFNO, *LPNET_DVR_FIRMWARE_VERSION_IFNO;



typedef struct tagNET_DVR_LLI_PARAM
{
    float fSec;//秒[0.000000,60.000000]
    BYTE byDegree;//度:纬度[0,90] 经度[0,180]
    BYTE byMinute;//分[0,59]
    BYTE byRes[6];
}NET_DVR_LLI_PARAM, *LPNET_DVR_LLI_PARAM;

typedef struct tagNET_DVR_LLPOS_PARAM
{
    BYTE   byLatitudeType;//纬度类型，0-北纬，1-南纬
    BYTE   byLongitudeType;//经度类型，0-东经，1-西经
    BYTE   byRes1[2];
    NET_DVR_LLI_PARAM    struLatitude;    /*纬度*/
    NET_DVR_LLI_PARAM    struLongitude; /*经度*/
    BYTE   byRes[16];
}NET_DVR_LLPOS_PARAM, *LPNET_DVR_LLPOS_PARAM;

typedef struct tagNET_VCA_FACESNAP_ADDINFO
{
    //人脸矩形框,该坐标为人脸小图(头肩照)中人脸的坐标
    NET_VCA_RECT  struFacePicRect;
    int    iSwingAngle;//旋转角, -90~90度
    int    iTiltAngle;//俯仰角, -90~90度
    DWORD  dwPupilDistance;//瞳距,范围为：最小值为10像素,最大值为当前分辨率宽度/1.6
    BYTE   byBlockingState;//目标遮挡状态， 0-表示“未知”（算法不支持）,1~无遮挡,2~瞬时轻度遮挡，3~持续轻度遮挡，4~严重遮挡
    BYTE   byFaceSnapThermometryEnabled;//人脸抓拍测温使能 1-开启 0-关闭
    BYTE   byIsAbnomalTemperature;//人脸抓拍测温是否温度异常 1-是 0-否
    BYTE   byThermometryUnit;//测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
    NET_DVR_TIME_EX  struEnterTime;   // 最佳抓拍下进入时间
    NET_DVR_TIME_EX  struExitTime;    // 最佳抓拍下离开时间
    float       fFaceTemperature; // 人脸温度（ - 20.0℃~150.0℃，精确到小数点后1位。其中0xffff（65535）表示无效，开启隐藏温度值功能时返回）
    float       fAlarmTemperature;// 测温报警警阈值（精确到小数点后1位）
    DWORD   dwThermalPicLen;//热成像图片长度
    BYTE    *pThermalPicBuff;// 热成像图片指针
    BYTE    szCustomChanID[65];// 自定义监控点通道号  string  max.len = 64
    BYTE    byRes1[3];// 保留字节
    NET_DVR_LLPOS_PARAM struLLPos;//设备经纬度位置信息
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    char*    pEventNotificationAlertBuff; //其Buff对应EventNotificationAlert JSON Block("eventType":  "faceCapture")
#else
    char*   pEventNotificationAlertBuff; //其Buff对应EventNotificationAlert JSON Block("eventType":  "faceCapture")
    BYTE    byRes2[4];
#endif
    DWORD   dwEventNotificationAlertLen;//长度对应EventNotificationAlert JSON Block("eventType":  "faceCapture")数据长度
    BYTE    byRes[340];// 保留字节
}NET_VCA_FACESNAP_ADDINFO, *LPNET_VCA_FACESNAP_ADDINFO;

typedef struct tagNET_VCA_FACESNAP_RESULT
{
    DWORD   dwSize;             // 结构大小
    DWORD     dwRelativeTime;     // 相对时标
    DWORD    dwAbsTime;            // 绝对时标
    DWORD   dwFacePicID;       //人脸图ID
    DWORD   dwFaceScore;        //人脸评分,0-100
    NET_VCA_TARGET_INFO  struTargetInfo;//报警目标信息
    NET_VCA_RECT         struRect;      //人脸子图区域
    NET_VCA_DEV_INFO       struDevInfo;    //前端设备信息
    DWORD   dwFacePicLen;        //人脸子图的长度，为0表示没有图片，大于0表示有图片
    DWORD   dwBackgroundPicLen; //背景图的长度，为0表示没有图片，大于0表示有图片(保留)
    BYTE    bySmart;            //IDS设备返回0(默认值)，Smart Functiom Return 1
    BYTE    byAlarmEndMark;//报警结束标记0-保留，1-结束标记（该字段结合人脸ID字段使用，表示该ID对应的下报警结束，主要提供给NVR使用，用于判断报警结束，提取识别图片数据中，清晰度最高的图片）
    BYTE    byRepeatTimes;   //重复报警次数，0-无意义
    BYTE    byUploadEventDataType;//人脸图片数据长传方式：0-二进制数据，1-URL
    NET_VCA_HUMAN_FEATURE   struFeature;  //人体属性
    float   fStayDuration;  //停留画面中时间(单位: 秒)
    char    sStorageIP[16];        //存储服务IP地址
    WORD    wStoragePort;            //存储服务端口号
    WORD    wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    /*人脸子图图片质量评估等级，0-低等质量,1-中等质量,2-高等质量,
    新增人脸抓拍质量评分机制与原有的人脸评分区别：
    原有的人脸评分是在人脸抓拍中实现，目的是确保一次人脸抓拍中获取最好的图像效果，是一个相对图像质量的评分；新增人脸抓拍质量评分机制是针对已经抓拍完成的人脸图片，使用图像算法对图像中人脸，人眼，肩宽等相对重要的信息进行分析，按照统一的标准对人脸图片效果质量进行评分*/
    BYTE    byFacePicQuality;
    BYTE    byUIDLen;     // 上传报警的标识长度
    BYTE    byLivenessDetectionStatus;// 活体检测状态：0-保留，1-未知(检测失败)，2-非真人人脸，3-真人人脸，4-未开启活体检测
    /*附加信息标识位（即是否有NET_VCA_FACESNAP_ADDINFO结构体）,0-无附加信息, 1-有附加信息。*/
    BYTE    byAddInfo;
    BYTE    *pUIDBuffer;  //标识指针
    //附加信息指针,指向NET_VCA_FACESNAP_ADDINFO结构体
    BYTE   *pAddInfoBuffer;
    BYTE    byTimeDiffFlag;      /*时差字段是否有效  0-时差无效， 1-时差有效 */
    char    cTimeDifferenceH;         /*与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效*/
    char    cTimeDifferenceM;      	/*与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效*/
    BYTE    byBrokenNetHttp;     //断网续传标志位，0-不是重传数据，1-重传数据
    BYTE*   pBuffer1;  //人脸子图的图片数据
    BYTE*   pBuffer2;  //背景图的图片数据（保留，通过查找背景图接口可以获取背景图）
}NET_VCA_FACESNAP_RESULT, *LPNET_VCA_FACESNAP_RESULT;

typedef struct tagNET_VCA_SUB_PROCIMG_V50
{
    DWORD dwImageLen;  //图片数据长度
    DWORD dwFaceScore;        //人脸评分,0-100
    NET_VCA_RECT struVcaRect; //人脸子图区域
    NET_VCA_POINT struLeftEyePoint;  //左眼位置
    NET_VCA_POINT struRightEyePoint; //右眼位置
    BYTE       byDistance;           //两眼间距
    BYTE       bySex;
    BYTE       byAgeGroup; 
    BYTE       byEyeGlass; 
    NET_VCA_RECT struPosRect;  //人脸位置区域
    BYTE       byRes[20];  //保留
    BYTE       *pImage;  //图片数据
}NET_VCA_SUB_PROCIMG_V50, *LPNET_VCA_SUB_PROCIMG_V50;

typedef struct tagNET_DVR_FACE_DETECTION
{
    DWORD     dwSize; //结构大小
    DWORD        dwRelativeTime; //相对时标
    DWORD       dwAbsTime; //绝对时标
    DWORD      dwBackgroundPicLen; //背景图的长度，为0表示没有图片，大于0表示有图片
    NET_VCA_DEV_INFO  struDevInfo;   //前端设备信息
    NET_VCA_RECT   struFacePic[MAX_FACE_PIC_NUM/*30*/];//人脸子图区域
    BYTE   byFacePicNum;//子图数量
    BYTE   byUploadEventDataType;//图片数据长传方式：0-二进制数据，1-URL
    WORD   wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    BYTE   byTimeDiffFlag;      /*时差字段是否有效  0-时差无效， 1-时差有效 */
    char   cTimeDifferenceH;         /*与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效*/
    char   cTimeDifferenceM;      	/*与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效*/
    BYTE   byRes[249];
    BYTE*  pBackgroundPicpBuffer; //背景图的图片数据
}NET_DVR_FACE_DETECTION,*LPNET_DVR_FACE_DETECTION;

typedef struct tagNET_DVR_UPGRADE_PARAM
{
    DWORD dwUpgradeType;
    char *sFileName;
    void *pInbuffer;
    DWORD dwBufferLen;
    char *pUnitIdList[64];
    BYTE  byRes[112];
}NET_DVR_UPGRADE_PARAM, *LPNET_DVR_UPGRADE_PARAM;

typedef struct tagNET_VCA_FD_PROCIMG_RESULT_V50
{
    DWORD dwSize;   //结构大小
    DWORD dwImageId; //大图ID
    BYTE byRes[20]; //保留
    DWORD dwSubImageNum;  //人脸子图张数
    NET_VCA_SUB_PROCIMG_V50  struProcImg[MAX_TARGET_NUM];  //单张子图信息
}NET_VCA_FD_PROCIMG_RESULT_V50, *LPNET_VCA_FD_PROCIMG_RESULT_V50;

typedef struct  tagNET_DVR_DEFOCUS_ALARM
{
    DWORD   dwSize;     /*结构长度*/
    NET_VCA_DEV_INFO       struDevInfo;/*设备信息*/
    WORD    wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    BYTE    byRes1[2];     //保留字节
    DWORD  dwRelativeTime; //相对时标
    DWORD     dwAbsTime; //绝对时标
    BYTE    byTimeDiffFlag;      /*时差字段是否有效  0-时差无效， 1-时差有效 */
    char    cTimeDifferenceH;         /*与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效*/
    char    cTimeDifferenceM;      	/*与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效*/
    BYTE    byRes[49];        // 保留字节
}NET_DVR_DEFOCUS_ALARM, *LPNET_DVR_DEFOCUS_ALARM;

typedef struct  tagNET_DVR_DENSEFOGDETECTION_ALARM
{
    DWORD   dwSize;     /*结构长度*/
    NET_VCA_DEV_INFO       struDevInfo;/*设备信息*/
    DWORD  dwRelativeTime; //相对时标
    DWORD     dwAbsTime; //绝对时标
    BYTE    byFogLevel; //雾的等级，0-无雾~薄雾 ，1-薄雾~中雾， 2-大雾~浓雾， 3-浓雾及以上
    BYTE    byRes[259];  // 保留字节
}NET_DVR_DENSEFOGDETECTION_ALARM, *LPNET_DVR_DENSEFOGDETECTION_ALARM;

typedef struct  tagNET_DVR_AUDIOEXCEPTION_ALARM
{
    DWORD      dwSize;     /*结构长度*/
    BYTE  byAlarmType;//报警类型，1-音频输入异常，2-音频输入突变（声强陡升），3-声强陡降，4-音频丢失
    BYTE  byRes1;
    WORD wAudioDecibel;//声音强度（音频输入突变时用到）
    NET_VCA_DEV_INFO       struDevInfo;/*设备信息*/
    WORD    wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    BYTE    byRes[62];        // 保留字节
}NET_DVR_AUDIOEXCEPTION_ALARM, *LPNET_DVR_AUDIOEXCEPTION_ALARM;

typedef struct  tagNET_BUTTON_DOWN_EXCEPTION_ALARM
{
    DWORD      dwSize;     /*结构长度*/
    NET_VCA_DEV_INFO       struDevInfo;/*设备信息*/
    BYTE    byRes[64];        // 保留字节
}NET_BUTTON_DOWN_EXCEPTION_ALARM, *LPNET_BUTTON_DOWN_EXCEPTION_ALARM;

typedef struct tagNET_VCA_FD_IMAGE_CFG
{
    DWORD   dwWidth;                  //灰度图像数据宽度
    DWORD   dwHeight;                 //灰度图像高度
    DWORD   dwImageLen;  //灰度图像数据长度
    BYTE     byRes[20];  //保留
    BYTE     *pImage;    //灰度图像数据
}NET_VCA_FD_IMAGE_CFG, *LPNET_VCA_FD_IMAGE_CFG;

typedef struct tagNET_VCA_FD_PROCIMG_CFG
{
    DWORD    dwSize;           //结构大小
    BYTE     byEnable;         //是否激活规则;
    BYTE     bySensitivity;      //检测灵敏度，[0,5]
    BYTE     byRes1[22];       //保留字节 
    NET_VCA_SIZE_FILTER  struSizeFilter;  //尺寸过滤器
    NET_VCA_POLYGON   struPolygon;    //多边形
    NET_VCA_FD_IMAGE_CFG struFDImage;  //图片信息
    BYTE     byRes2[20];    //保留
}NET_VCA_FD_PROCIMG_CFG, *LPNET_VCA_FD_PROCIMG_CFG;

typedef struct tagNET_VCA_SUB_PROCIMG
{
    DWORD dwImageLen;  //图片数据长度
    DWORD dwFaceScore;        //人脸评分,0-100
    NET_VCA_RECT struVcaRect; //人脸子图区域
    BYTE  byRes[20];  //保留
    BYTE  *pImage;  //图片数据
}NET_VCA_SUB_PROCIMG, *LPNET_VCA_SUB_PROCIMG;

typedef struct tagNET_VCA_FD_PROCIMG_RESULT
{
    DWORD dwSize;   //结构大小
    DWORD dwImageId; //大图ID
    BYTE byRes[20]; //保留
    DWORD dwSubImageNum;  //人脸子图张数
    NET_VCA_SUB_PROCIMG  struProcImg[MAX_TARGET_NUM];  //单张子图信息
}NET_VCA_FD_PROCIMG_RESULT, *LPNET_VCA_FD_PROCIMG_RESULT;

typedef struct tagNET_VCA_PICMODEL_RESULT
{
    DWORD dwImageLen;  //图片数据长度
    DWORD dwModelLen;  //模型数据长度
    BYTE  byRes[20]; //保留
    BYTE  *pImage;  //人脸图片数据指针
    BYTE  *pModel;  //模型数据指针
}NET_VCA_PICMODEL_RESULT, *LPNET_VCA_PICMODEL_RESULT;

typedef struct tagNET_VCA_REGISTER_PIC
{
    DWORD dwImageID; //大图ID
    DWORD dwFaceScore;        //人脸评分,0-100
    NET_VCA_RECT struVcaRect;  //人脸子图区域
    BYTE  byRes[20];  //保留
}NET_VCA_REGISTER_PIC, *LPNET_VCA_REGISTER_PIC;

typedef struct tagNET_DVR_AREAINFOCFG
{ 
    WORD wNationalityID; //国籍
    WORD wProvinceID; //省
    WORD wCityID; //市
    WORD wCountyID; //县
	/*
	if (dwCode != 0) dwCode 赋值参照 “全国各省份城市列表.txt”
	else dwCode 赋值解析参照 PROVINCE_CITY_IDX
	*/
    DWORD dwCode;
}NET_DVR_AREAINFOCFG, *LPNET_DVR_AREAINFOCFG;

typedef struct tagNET_VCA_HUMAN_ATTRIBUTE
{
    BYTE   bySex; //性别：0-男，1-女，0xff-未知
    BYTE   byCertificateType; //证件类型：0-身份证，1-警官证，2-军官证，3-护照，4-其他，0xff-未知
    BYTE   byBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //出生年月，如：201106
    BYTE   byName[NAME_LEN]; //姓名
    NET_DVR_AREAINFOCFG struNativePlace; //籍贯参数
    BYTE   byCertificateNumber[NAME_LEN];  //证件号
	/*
	dwPersonInfoExtendLen && pPersonInfoExtend 对应URL(/ISAPI/System/Video/inputs/channels/<ID>/faceContrast/personInfoExtend)表示的 PersonInfoExtendList XML Block
	意义所在：平台中心管理的时候，导入picture数据的自定义信息，在设备检测匹配报警后，携带作为匹配信息一并上传；平台中心管理匹配；
	*/
    DWORD  dwPersonInfoExtendLen;// 人员标签信息扩展长度
    BYTE   *pPersonInfoExtend;  //人员标签信息扩展信息
    BYTE   byAgeGroup;//年龄段，详见HUMAN_AGE_GROUP_ENUM，如传入0xff表示未知
    BYTE   byRes2[3]; //保留字节
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    BYTE*  pThermalData;//热成像图片指针
#else
    BYTE*  pThermalData;//热成像图片指针
    BYTE   byRes3[4];//保留字节
#endif
}NET_VCA_HUMAN_ATTRIBUTE, *LPNET_VCA_HUMAN_ATTRIBUTE;

typedef struct tagNET_VCA_HUMANATTRIBUTE_COND
{
    BYTE   bySex; //性别：0-不启用，1-男，2-女
    BYTE   byCertificateType; //证件类型：0-不启用，1-身份证，2-警官证
    BYTE   byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //起始出生年月，如：201106
    BYTE   byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //截止出生年月，如201106
    BYTE   byName[NAME_LEN]; //姓名
    NET_DVR_AREAINFOCFG struNativePlace; //籍贯参数
    BYTE   byCertificateNumber[NAME_LEN];  //证件号
    BYTE   byRes[20];
}NET_VCA_HUMANATTRIBUTE_COND, *LPNET_VCA_HUMANATTRIBUTE_COND;

typedef struct tagNET_VCA_BLOCKLIST_INFO
{
    DWORD  dwSize;   //结构大小
    DWORD  dwRegisterID;  //名单注册ID号（只读）
    DWORD  dwGroupNo; //分组号
    BYTE   byType; //名单标志：0-全部，1-允许名单，2-禁止名单
    BYTE   byLevel; //禁止名单等级，0-全部，1-低，2-中，3-高
    BYTE   byRes1[2];  //保留
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //人员信息
    BYTE   byRemark[NAME_LEN]; //备注信息
    DWORD  dwFDDescriptionLen;//人脸库描述数据长度
    BYTE   *pFDDescriptionBuffer;//人脸库描述数据指针
    DWORD  dwFCAdditionInfoLen;//抓拍库附加信息长度
    BYTE   *pFCAdditionInfoBuffer;//抓拍库附加信息数据指针（FCAdditionInfo中包含相机PTZ坐标、GPS信息）
    DWORD  dwThermalDataLen;//热成像图片长度，仅人脸比对事件上报支持
}NET_VCA_BLOCKLIST_INFO, *LPNET_VCA_BLOCKLIST_INFO;

typedef struct tagNET_VCA_BLOCKLIST_PARA
{
    DWORD dwSize;   //结构大小
    NET_VCA_BLOCKLIST_INFO struBlockListInfo;  //禁止名单基本参数
    DWORD dwRegisterPicNum;  //禁止名单图个数
    NET_VCA_PICMODEL_RESULT struRegisterPic[MAX_HUMAN_PICTURE_NUM];  //禁止名单图片信息
    BYTE  byRes[40]; //保留
}NET_VCA_BLOCKLIST_PARA, *LPNET_VCA_BLOCKLIST_PARA;

typedef struct tagNET_VCA_BLOCKLIST_COND
{
    LONG  lChannel; //通道号
    DWORD dwGroupNo; //分组号
    BYTE  byType; //名单标志：0-全部，1-允许名单，2-禁止名单
    BYTE  byLevel; //禁止名单等级，0-全部，1-低，2-中，3-高
    BYTE  byRes1[2];  //保留
    NET_VCA_HUMAN_ATTRIBUTE struAttribute; //人员信息
    BYTE  byRes[20];
}NET_VCA_BLOCKLIST_COND, *LPNET_VCA_BLOCKLIST_COND;

typedef struct tagNET_VCA_BLOCKLIST_PIC
{
    DWORD dwSize;   //结构大小
    DWORD dwFacePicNum;  //人脸图个数
    BYTE  byRes[20]; //保留
    NET_VCA_PICMODEL_RESULT  struBlockListPic[MAX_HUMAN_PICTURE_NUM];  //单张照片信息
}NET_VCA_BLOCKLIST_PIC, *LPNET_VCA_BLOCKLIST_PIC;

typedef struct tagNET_VCA_FIND_PICTURECOND
{
    LONG lChannel;//通道号
    NET_DVR_TIME struStartTime;//开始时间
    NET_DVR_TIME struStopTime;//结束时间
    BYTE byRes[12]; //保留
}NET_VCA_FIND_PICTURECOND, *LPNET_VCA_FIND_PICTURECOND;

typedef struct tagNET_VCA_SUB_SNAPPIC_DATA
{
    DWORD dwFacePicID; //人脸图ID
    DWORD dwFacePicLen;  //人脸图数据长度
    NET_DVR_TIME struSnapTime;  //抓拍时间
    DWORD dwSimilarity; //相似度
    BYTE  byRes[16];  //保留
    char  sPicBuf[MAX_FACE_PIC_LEN];  //图片数据
}NET_VCA_SUB_SNAPPIC_DATA, *LPNET_VCA_SUB_SNAPPIC_DATA;

typedef struct tagNET_VCA_ADVANCE_FIND
{
    DWORD dwFacePicID; //人脸图片ID
    BYTE  byRes[36];
}NET_VCA_ADVANCE_FIND, *LPNET_VCA_ADVANCE_FIND;

typedef struct tagNET_VCA_NORMAL_FIND
{
    DWORD dwImageID; //大图ID
    DWORD dwFaceScore;  //人脸评分
    NET_VCA_RECT struVcaRect; //人脸子图区域
    BYTE byRes[20];
}NET_VCA_NORMAL_FIND, *LPNET_VCA_NORMAL_FIND;



typedef struct tagNET_VCA_FIND_PICTURECOND_ADVANCE
{
    LONG lChannel;//通道号
    NET_DVR_TIME struStartTime;//开始时间
    NET_DVR_TIME struStopTime;//结束时间
    BYTE byThreshold;  //阈值，0-100
    BYTE byRes[23]; //保留
    VCA_FIND_SNAPPIC_TYPE dwFindType;//检索类型，详见VCA_FIND_SNAPPIC_TYPE
    NET_VCA_FIND_SNAPPIC_UNION uFindParam; //检索参数
}NET_VCA_FIND_PICTURECOND_ADVANCE, *LPNET_VCA_FIND_PICTURECOND_ADVANCE;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM
{
    DWORD dwRelativeTime;     // 相对时标
    DWORD dwAbsTime;            // 绝对时标
    DWORD dwSnapFacePicID;       //抓拍人脸图ID
    DWORD dwSnapFacePicLen;        //抓拍人脸子图的长度，为0表示没有图片，大于0表示有图片
    NET_VCA_DEV_INFO struDevInfo;        //前端设备信息
    BYTE  byFaceScore;        //人脸评分，指人脸子图的质量的评分,0-100
    BYTE bySex;//性别，0-未知，1-男，2-女,0xff-算法支持，但是没有识别出来
    BYTE byGlasses;//是否带眼镜，0-未知，1-是，2-否,3-戴墨镜, 0xff-算法支持，但是没有识别出来
	/*
	识别人脸的年龄段范围[byAge-byAgeDeviation,byAge+byAgeDeviation]
	*/
    BYTE byAge;//年龄,0-表示“未知”（算法不支持）,0xff-算法支持，但是没有识别出来
    BYTE byAgeDeviation;//年龄误差值
    BYTE byAgeGroup;//年龄段，详见HUMAN_AGE_GROUP_ENUM，若传入0xff表示未知
    /*人脸子图图片质量评估等级，0-低等质量,1-中等质量,2-高等质量,
    该质量评估算法仅针对人脸子图单张图片,具体是通过姿态、清晰度、遮挡情况、光照情况等可影响人脸识别性能的因素综合评估的结果*/
    BYTE byFacePicQuality;
    BYTE  byRes; 
    DWORD dwUIDLen; // 上传报警的标识长度
    BYTE  *pUIDBuffer;  //标识指针
    float fStayDuration;  //停留画面中时间(单位: 秒)
    BYTE  *pBuffer1;  //抓拍人脸子图的图片数据
}NET_VCA_FACESNAP_INFO_ALARM, *LPNET_VCA_FACESNAP_INFO_ALARM;

typedef struct tagNET_VCA_BLOCKLIST_INFO_ALARM
{
    NET_VCA_BLOCKLIST_INFO struBlockListInfo; //禁止名单基本信息
    DWORD dwBlockListPicLen;       //禁止名单人脸子图的长度，为0表示没有图片，大于0表示有图片
    DWORD  dwFDIDLen;// 人脸库ID长度
    BYTE  *pFDID;  //人脸库Id指针
    DWORD  dwPIDLen;// 人脸库图片ID长度
    BYTE  *pPID;  //人脸库图片ID指针
    WORD  wThresholdValue; //人脸库阈值[0,100]
    BYTE  byIsNoSaveFDPicture;//0-保存人脸库图片,1-不保存人脸库图片, 若开启了导入图片或者建模时不保存原图功能时,该字段返回1,此时人脸库图片将不再返回
    BYTE  byRealTimeContrast;//是否实时报警 0-实时 1-非实时
    BYTE  *pBuffer1;  //禁止名单人脸子图的图片数据
}NET_VCA_BLOCKLIST_INFO_ALARM, *LPNET_VCA_BLOCKLIST_INFO_ALARM;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM
{
    DWORD dwSize;             // 结构大小
    float fSimilarity; //相似度，[0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM  struSnapInfo; //抓拍信息
    NET_VCA_BLOCKLIST_INFO_ALARM struBlockListInfo; //禁止名单信息
    char         sStorageIP[16];        //存储服务IP地址
    WORD            wStoragePort;            //存储服务端口号
    BYTE  byMatchPicNum; //匹配图片的数量，0-保留（老设备这个值默认0，新设备这个值为0时表示后续没有匹配的图片信息）
    BYTE  byPicTransType;//图片数据传输方式: 0-二进制；1-url
    DWORD dwSnapPicLen;//设备识别抓拍图片长度
    BYTE  *pSnapPicBuffer;//设备识别抓拍图片指针
    NET_VCA_RECT  struRegion;//目标边界框，设备识别抓拍图片中，人脸子图坐标
    DWORD dwModelDataLen;//建模数据长度
    BYTE  *pModelDataBuffer;// 建模数据指针
    BYTE  byModelingStatus;// 建模状态
    BYTE  byLivenessDetectionStatus;//活体检测状态：0-保留，1-未知（检测失败），2-非真人人脸，3-真人人脸，4-未开启活体检测
    char  cTimeDifferenceH;         /*与UTC的时差（小时），-12 ... +14， +表示东区,0xff无效*/
    char  cTimeDifferenceM;      	/*与UTC的时差（分钟），-30, 30, 45， +表示东区，0xff无效*/
    BYTE  byMask;                //抓拍图是否戴口罩，0-保留，1-未知，2-不戴口罩，3-戴口罩
    BYTE  bySmile;               //抓拍图是否微笑，0-保留，1-未知，2-不微笑，3-微笑
    BYTE  byContrastStatus;      //比对结果，0-保留，1-比对成功，2-比对失败
    BYTE  byBrokenNetHttp;     //断网续传标志位，0-不是重传数据，1-重传数据
}NET_VCA_FACESNAP_MATCH_ALARM, *LPNET_VCA_FACESNAP_MATCH_ALARM;

typedef struct tagNET_VCA_BLOCKLIST_INFO_ALARM_LOG
{
    NET_VCA_BLOCKLIST_INFO struBlockListInfo; //禁止名单基本信息
    DWORD dwBlockListPicID;       //禁止名单人脸子图ID，用于查找图片
       BYTE  byRes[20];              // 保留字节
}NET_VCA_BLOCKLIST_INFO_ALARM_LOG, *LPNET_VCA_BLOCKLIST_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_INFO_ALARM_LOG
{
    DWORD dwRelativeTime;     // 相对时标
    DWORD dwAbsTime;            // 绝对时标
    DWORD dwSnapFacePicID;       //抓拍人脸图ID
    NET_VCA_DEV_INFO       struDevInfo;        //前端设备信息
       BYTE  byRes[20];              // 保留字节
}NET_VCA_FACESNAP_INFO_ALARM_LOG, *LPNET_VCA_FACESNAP_INFO_ALARM_LOG;

typedef struct tagNET_VCA_FACESNAP_MATCH_ALARM_LOG
{
    DWORD dwSize;             // 结构大小
    float fSimilarity; //相似度，[0.001,1]
    NET_VCA_FACESNAP_INFO_ALARM_LOG  struSnapInfoLog; //抓拍信息
    NET_VCA_BLOCKLIST_INFO_ALARM_LOG struBlockListInfoLog; //禁止名单信息
    BYTE  byRes[60];              // 保留字节
}NET_VCA_FACESNAP_MATCH_ALARM_LOG, *LPNET_VCA_FACESNAP_MATCH_ALARM_LOG;

typedef struct tagNET_VCA_FACEMATCH_PICCOND
{
    DWORD dwSize;             // 结构大小
       DWORD dwSnapFaceID; //抓拍人脸子图ID
    DWORD dwBlockListID; //匹配的禁止名单ID
    DWORD dwBlockListFaceID; //比对的禁止名单人脸子图ID
    BYTE  byRes[20];              // 保留字节
}NET_VCA_FACEMATCH_PICCOND, *LPNET_VCA_FACEMATCH_PICCOND;

typedef struct tagNET_VCA_FACEMATCH_PICTURE
{
    DWORD dwSize;             // 结构大小
       DWORD dwSnapFaceLen; //抓拍人脸子图长度
    DWORD dwBlockListFaceLen; //比对的禁止名单人脸子图长度
    BYTE  byRes[20];              //保留字节
    BYTE *pSnapFace;  //抓拍人脸子图的图片数据
    BYTE *pBlockListFace;  //比对的禁止名单人脸子图数据
}NET_VCA_FACEMATCH_PICTURE, *LPNET_VCA_FACEMATCH_PICTURE;

typedef struct tagNET_VCA_BLOCKLIST_FASTREGISTER_PARA
{
    DWORD dwSize;   //结构大小
    NET_VCA_BLOCKLIST_INFO struBlockListInfo;  //禁止名单基本参数
    DWORD dwImageLen;  //图像数据长度
    BYTE  byRes[124];  //保留
    BYTE  *pImage;    //图像数据
}NET_VCA_BLOCKLIST_FASTREGISTER_PARA, *LPNET_VCA_BLOCKLIST_FASTREGISTER_PARA;

typedef struct tagNET_DVR_FRAMES_PEOPLE_COUNTING
{
    DWORD  dwSize;          // 结构体大小
    NET_VCA_DEV_INFO   struDevInfo;//前端设备信息
    DWORD  dwRelativeTime; //相对时标
    DWORD  dwAbsTime;      // 绝对时标
    DWORD  dwPeopleCountingNum; //画面中的人数统计数量
    DWORD  dwPicLen;       //设备识别抓拍的全景图片数据长度
    BYTE   *pPicBuffer;    //设备识别抓拍的全景图片数据指针
    BYTE   byRes[512];     // 保留字节
}NET_DVR_FRAMES_PEOPLE_COUNTING, *LPNET_DVR_FRAMES_PEOPLE_COUNTING;

typedef struct tagNET_VCA_SINGLE_PATH
{
    BYTE  byActive;  // 是否可用,0-否,1-是 
    BYTE  byType;   //0-存储抓拍，1-存储禁止名单比对报警，2-存储抓拍和禁止名单比对报警，0xff-无效
    BYTE  bySaveAlarmPic; //是否用于保存断网的报警图片，0-否，1-是
    BYTE  byRes1[5]; //保留
    DWORD dwDiskDriver;   //盘符号，从0开始
    DWORD dwLeftSpace;   //预留容量（单位为G）
    BYTE  byRes2[8]; //保留
}NET_VCA_SINGLE_PATH, *LPNET_VCA_SINGLE_PATH;

typedef struct tagNET_VCA_SAVE_PATH_CFG
{ 
    DWORD dwSize;   //结构大小
    NET_VCA_SINGLE_PATH  struPathInfo[MAX_DISKNUM_V30]; //单个分区
    BYTE  byRes[40]; //保留
}NET_VCA_SAVE_PATH_CFG, *LPNET_VCA_SAVE_PATH_CFG;

typedef struct tagNET_DVR_DEV_ACCESS_CFG
{
    DWORD   dwSize;
    NET_DVR_IPADDR     struIP;        //接入设备的IP地址
    WORD     wDevicePort;                 //端口号
    BYTE    byEnable;                 //是否启用，0-否，1-是
    BYTE     byRes1;                //保留
    BYTE    sUserName[NAME_LEN];    //接入设备的登录帐号
    BYTE    sPassword[PASSWD_LEN];    //接入设备的登录密码
    BYTE    byRes2[60];
}NET_DVR_DEV_ACCESS_CFG,*LPNET_DVR_DEV_ACCESS_CFG;

typedef struct tagNET_DVR_DISPWINDOWMODE
{
    BYTE byDispChanType;//显示通道类型：0-BNC, 1-VGA, 2-HDMI, 3-DVI 4-SDI
    BYTE byDispChanSeq;//显示通道序号,从1开始，如果类型是VGA，则表示第几个VGA
    BYTE byRes[2];
    BYTE byDispMode[MAX_WINDOWS_NUM/*12*/];
}NET_DVR_DISPWINDOWMODE, *LPNET_DVR_DISPWINDOWMODE;

typedef struct tagNET_DVR_DISPINFO
{
    BYTE  byChanNums;//通道个数
    BYTE  byStartChan;//起始通道
    BYTE  byRes[2];
    DWORD    dwSupportResolution[MAX_SUPPORT_RES/*32*/];//支持分辨率
}NET_DVR_DISPINFO, *LPNET_DVR_DISPINFO;

typedef struct tagNET_DVR_SCREENINFO
{
    BYTE  bySupportBigScreenNums;//最多大屏拼接数量
    BYTE  byStartBigScreenNum;//大屏拼接起始号
    BYTE  byMaxScreenX;//大屏拼接模式
    BYTE  byMaxScreenY;
    BYTE  byRes[8];
}NET_DVR_SCREENINFO, *LPNET_DVR_SCREENINFO;

typedef struct tagNET_DVR_SDI_INFO
{
    BYTE  byChanNums;//通道个数
    BYTE  byStartChan;//起始通道
    BYTE  byRes[2];
    DWORD dwSupportResolution[MAX_SDI_RES/*16*/];//支持分辨率
}NET_DVR_SDI_INFO,*LPNET_DVR_SDI_INFO;

typedef struct tagNET_DVR_MATRIX_ABILITY_V41
{
    DWORD dwSize;
    BYTE  byDspNums;//DSP个数  
    BYTE  byDecChanNums;//解码通道数
    BYTE  byStartChan;//起始解码通道
    BYTE  byRes1[5];
    NET_DVR_DISPINFO struVgaInfo;//VGA显示通道信息
    NET_DVR_DISPINFO struBncInfo;//BNC显示通道信息
    NET_DVR_DISPINFO struHdmiInfo;//HDMI显示通道信息
    NET_DVR_DISPINFO struDviInfo;//DVI显示通道信息
    NET_DVR_DISPWINDOWMODE struDispMode[MAX_DISPNUM_V41/*32*/];
    NET_DVR_SCREENINFO struBigScreenInfo;
    BYTE  bySupportAutoReboot; //是否支持自动重启，0-不支持，1-支持
    BYTE  byRes2[3];
    NET_DVR_SDI_INFO struSDIInfo;//SDI显示通道信息
    BYTE  byRes3[48];
} NET_DVR_MATRIX_ABILITY_V41, *LPNET_DVR_MATRIX_ABILITY_V41;


typedef struct tagNET_DVR_MATRIX_VOUTCFG
{        
    DWORD    dwSize; 
    BYTE    byAudio;            /*音频是否开启*/
    BYTE    byAudioWindowIdx;      /*音频开启子窗口*/
    BYTE    byDispChanType;      /*显示通道类型：0-BNC，1-VGA，2-HDMI，3-DVI，4-YPbPr(解码卡服务器DECODER_SERVER专用)*/   
    BYTE    byVedioFormat;         /*1:NTSC,2:PAL，0-NULL*/
    DWORD    dwResolution;//分辨率
    DWORD    dwWindowMode;        /*画面模式，能力集获取*/       
    BYTE    byJoinDecChan[MAX_WINDOWS_V41];/*各个子窗口关联的解码通道,设备支持解码资源自动分配时此参数不用填充*/
    BYTE    byEnlargeStatus;          /*是否处于放大状态，0：不放大，1：放大*/
    BYTE    byEnlargeSubWindowIndex;//放大的子窗口号
    BYTE    byScale; /*显示模式，0---真实显示，1---缩放显示( 针对BNC )*/
    BYTE    byUnionType;/*区分共用体,0-视频综合平台内部解码器显示通道配置，1-其他解码器显示通道配置*/
    NET_DVR_VIDEO_PLATFORM        struDiff;
    DWORD   dwDispChanNum; //显示输出号，此参数在全部获取时有效
    WORD     wLEDWidth;     //LED分辨率宽，0为无效   
    WORD     wLEDHeight;    //LED分辨率高，0为无效
    BYTE      byEnableVideoEffect;  //显示效果使能， 0-不使能， !0-使能
    BYTE      byRes[3];  //保留字段
    NET_DVR_VIDEOEFFECT struVideoEffect;   //显示效果
    BYTE    byRes2[60];
}NET_DVR_MATRIX_VOUTCFG,*LPNET_DVR_MATRIX_VOUTCFG;

typedef struct tagNET_DVR_DISP_CHAN_STATUS_V41
{
    BYTE  byDispStatus;      /*显示状态：0：未显示，1：启动显示*/
    BYTE  byBVGA;              /*0-BNC，1-VGA， 2-HDMI，3-DVI，4-SDI 0xff-无效*/
    BYTE  byVideoFormat;     /*视频制式，1:NTSC,2:PAL,0-NON*/
    BYTE  byWindowMode;       /*画面模式*/
    BYTE  byJoinDecChan[MAX_WINDOWS_V41];   /*各个子画面关联的解码通道*/
    BYTE  byFpsDisp[MAX_WINDOWS_V41];        /*每个子画面的显示帧率*/
    BYTE  byScreenMode;        /*屏幕模式0-普通 1-大屏*/
    BYTE  byRes1[3];
    DWORD  dwDispChan; /*获取全部显示通道状态时有效，设置时可填0*/
    BYTE  byRes2[24];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
}NET_DVR_DISP_CHAN_STATUS_V41, *LPNET_DVR_DISP_CHAN_STATUS_V41;

typedef struct tagNET_DVR_DECODER_WORK_STATUS_V41
{
    DWORD dwSize;
    NET_DVR_MATRIX_CHAN_STATUS struDecChanStatus[32];     /*解码通道状态*/
    /*显示通道状态*/
    NET_DVR_DISP_CHAN_STATUS_V41   struDispChanStatus[MAX_DISPNUM_V41/*32*/];     
    BYTE byAlarmInStatus[32];         /*报警输入状态*/
    BYTE byAlarmOutStatus[32];       /*报警输出状态*/
    BYTE byAudioInChanStatus;          /*语音对讲状态*/
    BYTE byRes[127];
}NET_DVR_DECODER_WORK_STATUS_V41,*LPNET_DVR_DECODER_WORK_STATUS_V41;

typedef struct tagNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struIP;        /* DVR IP地址 */    
    WORD    wDVRPort;            /* 端口号 */    
    BYTE    byChannel;            /* 通道号 */
    BYTE     byReserve;
    BYTE    sUserName[NAME_LEN];        /* 用户名 */
    BYTE    sPassword[PASSWD_LEN];        /* 密码 */
    DWORD    dwPlayMode;       /* 0－按文件 1－按时间*/            
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
    char    sFileName[128];
    BYTE    byRes[64];        /*保留*/
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_V41, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V41;

typedef struct tagNET_DVR_RECTCFG_SCENE
{
    WORD wXCoordinate; /*矩形左上角起始点X坐标*/
    WORD wYCoordinate; /*矩形左上角Y坐标*/
    WORD wWidth;       /*矩形宽度*/
    WORD wHeight;      /*矩形高度*/
}NET_DVR_RECTCFG_SCENE, *LPNET_DVR_RECTCFGSCENE;

typedef struct tagNET_DVR_SCENEDISPCFG
{       
    BYTE    byEnable;//是否启用，0-不启用，1-启用
    BYTE    bySoltNum;//槽位号
    BYTE    byRes1[2]; 
    BYTE    byDispChanNum; 
    BYTE    byAudio;                /*音频是否开启,0-否，1-是*/
    BYTE    byAudioWindowIdx;      /*音频开启子窗口*/
    BYTE    byVedioFormat;          /*1:NTSC,2:PAL，0-NULL*/
    BYTE    byWindowMode;            /*画面模式，从能力集获取*/   
    BYTE    byEnlargeStatus;         /*是否处于放大状态，0：不放大，1：放大*/
    BYTE    byEnlargeSubWindowIndex;//放大的子窗口号    
    BYTE    byScale; /*显示模式，0-真实显示，1-缩放显示( 针对BNC )*/
    DWORD   dwResolution;//分辨率
    BYTE    byJoinDecChan[MAX_WINDOWS_V41];/*各个子窗口关联的解码通道*/
    BYTE    byJoinDecoderId[MAX_WINDOWS_V41];/*槽位号*/
    //显示窗口所解视频分辨率，1-D1,2-720P,3-1080P，设备端需要根据此//分辨率进行解码通道的分配，如1分屏配置成1080P，则设备会把4个解码通道都分配给此解码通道
    BYTE    byDecResolution[MAX_WINDOWS_V41];
    BYTE    byRow;//大屏所在的行的序号
    BYTE    byColumn;//大屏所在的列的序号
    BYTE    byRes2[5];
    NET_DVR_RECTCFG struDisp; //电视墙显示位置
} NET_DVR_SCENEDISPCFG,*LPNET_DVR_SCENEDISPCFG;

typedef struct tagDEV_CHAN_INFO_SCENE
{
    NET_DVR_IPADDR struIP;                /* DVR IP地址 */
    WORD     wDVRPort;                 /* 端口号 */
    BYTE     byChannel;        /* 通道号，对于9000等设备的IPC接入，通道号从33开始 */
    BYTE    byTransProtocol;        /* 传输协议类型0-TCP，1-UDP ，2-MCAST，3-RTP*/
    BYTE    byTransMode;            /* 传输码流模式 0－主码流 1－子码流*/
    BYTE    byFactoryType;                /*前端设备厂家类型*/
    BYTE    byDeviceType;            //设备类型，1-IPC，2- ENCODER
    BYTE    byRes[5];
    BYTE    sUserName[NAME_LEN];    /* 监控主机登陆帐号 */
    BYTE    sPassword[PASSWD_LEN];    /* 监控主机密码 */
} NET_DVR_DEV_CHAN_INFO_SCENE,*LPNET_DVR_DEV_CHAN_INFO_SCENE;

typedef struct tagSTREAM_MEDIA_SERVER_CFG_SCENE
{
    BYTE    byValid;            /*是否启用流媒体服务器取流,0表示无效*/
    BYTE    byRes1[3];
    NET_DVR_IPADDR struDevIP;    /*流媒体服务器地址*/
    WORD    wDevPort;            /*流媒体服务器端口*/
    BYTE    byTransmitType;        /*传输协议类型0-TCP，1-UDP */
    BYTE    byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE;

typedef struct tagPU_STREAM_CFG_SCENE
{
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE    streamMediaServerCfg;
    NET_DVR_DEV_CHAN_INFO_SCENE                struDevChanInfo;
}NET_DVR_PU_STREAM_CFG_SCENE,*LPNET_DVR_PU_STREAM_CFG_SCENE;

typedef struct  tagNET_DVR_CYC_SUR_CHAN_ELE_SCENE
{
    BYTE                            byEnable;    /* 是否启用 0－否 1－启用*/
    BYTE                            byRes[3];
    NET_DVR_STREAM_MEDIA_SERVER_CFG_SCENE    struStreamMediaSvrCfg;    
    NET_DVR_DEV_CHAN_INFO_SCENE            struDecChanInfo;    /*轮巡解码通道信息*/
}NET_DVR_CYC_SUR_CHAN_ELE_SCENE,*LPNET_DVR_CYC_SUR_CHAN_ELE_SCENE;

typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_SCENE
{
    WORD    wPoolTime;        /*轮询间隔*/
    BYTE    byRes1[2];
    NET_DVR_CYC_SUR_CHAN_ELE_SCENE    struChanArray[MAX_CYCLE_CHAN/*16*/];
    BYTE    byRes2[4];
} NET_DVR_MATRIX_LOOP_DECINFO_SCENE,*LPNET_DVR_MATRIX_LOOP_DECINFO_SCENE;

typedef struct tagNET_DVR_DECODECHANCFG_SCENE/*struct size : 2064*/
{
    BYTE    byDecodeEnable;//解码起停标志，0-停止，1-启用动态解码，2-启用轮巡解码
    BYTE    bySlotNum;//槽位号
    BYTE    byDecChan;
    BYTE    byJointAllDecodeChan;        //是否关联万能解码通道 0-不关联，1-关联
    BYTE    byJointSlotNum;            //关联的槽位号（万能解码板的槽位号）
    BYTE    byJointChanNum;        //关联的通道号（万能解码板通道号）
    BYTE    byRes[2];
    union
    {
        NET_DVR_PU_STREAM_CFG_SCENE struSceneDynamicDecCfg; 
        NET_DVR_MATRIX_LOOP_DECINFO_SCENE struSceneCycDecCfg;
    } struDecCfg;
}NET_DVR_DECODECHANCFG_SCENE,*LPNET_DVR_DECODECHANCFG_SCENE;

typedef struct tagNET_DVR_BIGSCREENCFG_SCENE
{
    BYTE byAllValid; /*漫游使能标志 */
    BYTE byAssociateBaseMap;//关联的底图序号，0代表不关联
    BYTE byEnableSpartan;//大屏畅显使能，1-开，0-关
    BYTE byRes;
    NET_DVR_WINCFG struWinCfg[MAX_LAYERNUMS];
    NET_DVR_BIGSCREENCFG struBigScreen;
}NET_DVR_BIGSCREENCFG_SCENE, *LPNET_DVR_BIGSCREENCFG_SCENE;

typedef struct tagNET_DVR_MATRIX_SCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];
    BYTE  byBigScreenNums;//大屏的个数，最大值通过能力集获取
    BYTE  byRes1[3];
    WORD  wDecChanNums;//场景中解码通道的个数
    WORD  wDispChanNums;//场景中显示通道的个数
    BYTE  byRes2[12];
    BYTE  *pBigScreenBuffer;//大屏配置缓冲区, byBigScreenNums×sizeof(NET_DVR_BIGSCREENCFG_SCENE)
    BYTE  *pDecChanBuffer;//解码通道配置缓冲区, wDecChanNums×sizeof(NET_DVR_DECODECHANCFG_SCENE)
    BYTE  *pDispChanBuffer;//显示通道配置缓冲区, wDispChanNums×sizeof(NET_DVR_SCENEDISPCFG)
}NET_DVR_MATRIX_SCENECFG, *LPNET_DVR_MATRIX_SCENECFG;

typedef struct tagNET_DVR_BIGSCREENASSOCIATECFG
{
    DWORD dwSize;
    BYTE  byEnableBaseMap;//使能底图显示
    BYTE  byAssociateBaseMap;//关联的底图序号，0代表不关联
    BYTE  byEnableSpartan;//大屏畅显使能，1-开，0-关
    BYTE  byRes[21];
} NET_DVR_BIGSCREENASSOCIATECFG, *LPNET_DVR_BIGSCREENASSOCIATECFG;

typedef struct tagNET_DVR_SCREEN_WINCFG
{
    DWORD    dwSize;
    BYTE    byVaild;
    BYTE    byInputType;        //见CAM_MDOE
    WORD    wInputIdx;            /*输入源索引*/
    DWORD    dwLayerIdx;            /*图层，0为最底层*/
    NET_DVR_RECTCFG  struWin;    //目的窗口(相对显示墙)
    BYTE    byWndIndex;            //窗口号
    BYTE    byCBD;                //0-无，1-带背景，2-不带背景
    BYTE    bySubWnd;            //0不是，1是
    BYTE    byRes1;
    DWORD   dwDeviceIndex;//设备序号
    BYTE    byRes2[16];
}NET_DVR_SCREEN_WINCFG, *LPNET_DVR_SCREEN_WINCFG;

typedef struct tagNET_DVR_WINLIST
{
    DWORD    dwSize;
    WORD    wScreenSeq;    //设备序号
    BYTE    byRes[10];
    DWORD    dwWinNum;    //设备返回的窗口数量
    BYTE    *pBuffer;    //窗口信息缓冲区，最大为224*sizeof(NET_DVR_WINCFG)
    DWORD   dwBufLen;    //所分配指针长度
}NET_DVR_WINLIST,*LPNET_DVR_WINLIST;

typedef struct tagNET_DVR_LAYOUTCFG
{
    DWORD dwSize;
    BYTE  byValid;                                //布局是否有效
    BYTE  byRes1[3];
    BYTE  byLayoutName[NAME_LEN/*32*/];            //布局名称            
    NET_DVR_SCREEN_WINCFG struWinCfg[MAX_WIN_COUNT/*224*/];    //布局内窗口参数
    BYTE  byRes2[16];
}NET_DVR_LAYOUTCFG, *LPNET_DVR_LAYOUTCFG;

typedef struct tagNET_DVR_LAYOUT_LIST
{
    DWORD dwSize;
    NET_DVR_LAYOUTCFG struLayoutInfo[MAX_LAYOUT_COUNT/*16*/];   //所有布局
    BYTE byRes[4];
}NET_DVR_LAYOUT_LIST, *LPNET_DVR_LAYOUT_LIST;


typedef struct tagNET_DVR_INPUTSTREAMCFG
{
    DWORD    dwSize ;
    BYTE    byValid;
    BYTE    byCamMode;                        //信号输入源类型，见NET_DVR_CAM_MODE
    WORD    wInputNo;                        //信号源序号0-224
    BYTE    sCamName[NAME_LEN] ;            //信号输入源名称
    NET_DVR_VIDEOEFFECT struVideoEffect;    //视频参数
    NET_DVR_PU_STREAM_CFG    struPuStream;    //ip输入时使用
    WORD    wBoardNum ;                        //信号源所在的板卡号
    WORD    wInputIdxOnBoard;                //信号源在板卡上的位置
    DWORD   dwResolution;//分辨率
    BYTE    byVideoFormat;//视频制式，见VIDEO_STANDARD
    BYTE    byStatus;    //信号源状态，0-字段无效 1-有信号 2-无信号 3-异常 
    BYTE    sGroupName[NAME_LEN/*32*/];    //网络信号源分组 组名
    BYTE    byJointMatrix;            //  关联矩阵 ，0-不关联  1-关联
    BYTE    byRes;  
}NET_DVR_INPUTSTREAMCFG, *LPNET_DVR_INPUTSTREAMCFG;

typedef struct tagNET_DVR_INPUTSTREAM_LIST
{
    DWORD dwSize;
    NET_DVR_INPUTSTREAMCFG struInputStreamInfo[MAX_CAM_COUNT]; //所有信号源
    BYTE byRes[4];
}NET_DVR_INPUTSTREAM_LIST, *LPNET_DVR_INPUTSTREAM_LIST;

typedef struct tagNET_DVR_OUTPUTPARAM
{
    DWORD  dwSize;
    BYTE   byMonMode;        /*输出连接模式,1-BNC,2-VGA,3-DVI,4-HDMI*/
    BYTE   byRes1[3];
    DWORD  dwResolution;    /*分辨率，根据能力集获取所支持的进行设置*/
    NET_DVR_VIDEOEFFECT  struVideoEffect;    /*输出通道视频参数配置*/
    BYTE    byRes2[32];
}NET_DVR_OUTPUTPARAM, *LPNET_DVR_OUTPUTPARAM;

typedef struct tagNET_DVR_OUTPUTCFG
{
    DWORD    dwSize;
    BYTE    byScreenLayX;                        //大屏布局-横坐标
    BYTE    byScreenLayY;                        //大屏布局-纵坐标
    WORD    wOutputChanNum;                    //输出通道个数，0表示设备支持的最大输出通道个数，最大个数从能力集获取，其他值表示实际输出通道个数
    BYTE    byRes1[4];
    NET_DVR_OUTPUTPARAM  struOutputParam;    /*输出通道视频参数配置*/
    BYTE    sWallName[16];                    //电视墙名称
    BYTE    byRes2[8];
}NET_DVR_OUTPUTCFG, *LPNET_DVR_OUTPUTCFG;

typedef struct tagNET_DVR_SCREENSERVER_ABILITY
{
    DWORD dwSize;               /*结构长度*/
    BYTE byIsSupportScreenNum; /*所支持大屏控制器的数目*/
    BYTE bySerialNums;            //串口个数
    BYTE byMaxInputNums;
    BYTE byMaxLayoutNums;
    BYTE byMaxWinNums;
    BYTE byRes1[19];
    BYTE byMaxScreenLayX;//大屏布局-最大横坐标大屏数
    BYTE byMaxScreenLayY;//大屏布局-最大纵坐标大屏数
    WORD wMatrixProtoNum; /*有效的大屏协议数目*/
    NET_DVR_PROTO_TYPE struScreenProto[SCREEN_PROTOCOL_NUM];/*最大协议列表*/
    BYTE byRes2[24];
}NET_DVR_SCREENSERVER_ABILITY, *LPNET_DVR_SCREENSERVER_ABILITY;

typedef struct tagNET_DVR_SCREENCONTROL_ABILITY
{
    DWORD dwSize;           /*结构长度*/
    BYTE byLayoutNum;         /* 布局个数*/
    BYTE byWinNum;             /*屏幕窗口个数*/
    BYTE byOsdNum;          /*OSD个数*/
    BYTE byLogoNum;         /*Logo个数*/
    BYTE byInputStreamNum;  //输入源个数 ---设备支持最大输入通道个数（包括本地输入源和网络输入源）
    BYTE byOutputChanNum;    //输出通道个数---设备支持最大输出通道个数
    BYTE byCamGroupNum;        /*分组个数*/
    BYTE byPlanNum;            /*预案个数*/
    BYTE byRes1[5];
    BYTE byIsSupportPlayBack;  /*是否支持回放*/    
    BYTE byMatrixInputNum;  //支持输入矩阵最大个数
    BYTE byMatrixOutputNum; //支持输出矩阵最大个数
    NET_DVR_DISPINFO struVgaInfo;//VGA输出信息
    NET_DVR_DISPINFO struBncInfo;//BNC输出信息
    NET_DVR_DISPINFO struHdmiInfo;//HDMI输出信息
    NET_DVR_DISPINFO struDviInfo;//DVI输出信息
    BYTE byMaxUserNums;//支持用户数
    BYTE byPicSpan;        //底图跨度，一张底图最多可覆盖的屏幕数
    WORD wDVCSDevNum;    //分布式大屏控制器最大设备数
    WORD wNetSignalNum;    //最大网络输入源个数
    WORD wBaseCoordinateX;//基准坐标
    WORD wBaseCoordinateY; 
    BYTE byExternalMatrixNum;    //最大外接矩阵个数
    BYTE byRes2[49];
}NET_DVR_SCREENCONTROL_ABILITY, *LPNET_DVR_SCREENCONTROL_ABILITY;

typedef struct tagNET_DVR_ANALOGINPUTSTATUS
{
    DWORD    dwLostFrame;        /*视频输入丢帧数*/
    BYTE    byHaveSignal;        /*是否有视频信号输入*/
    BYTE    byVideoFormat;        /*视频制式，1：NTSC,2：PAL,0：无*/
    BYTE    byRes[46];
} NET_DVR_ANALOGINPUTSTATUS, *LPNET_DVR_ANALOGINPUTSTATUS;


typedef struct tagNET_DVR_INPUTSTATUS
{
    WORD    wInputNo;        /*信号源序号*/
    BYTE    byInputType;    //见NET_DVR_CAM_MODE
    BYTE    byRes1[9];
    NET_DVR_INPUTSTATUS_UNION struStatusUnion;
    BYTE    byRes2[16];
} NET_DVR_INPUTSTATUS, *LPNET_DVR_INPUTSTATUS;

typedef struct tagNET_DVR_SCREENINPUTSTATUS
{
    DWORD    dwSize;
    BYTE    byRes[12];
    DWORD    dwNums;        //设备返回的输入源状态的数量
    BYTE    *pBuffer;    //缓冲区
    DWORD   dwBufLen;    //所分配指针长度，输入参数
}NET_DVR_SCREENINPUTSTATUS,*LPNET_DVR_SCREENINPUTSTATUS;

typedef struct tagNET_DVR_SCREENALARMCFG
{
    DWORD    dwSize;
    BYTE    byAlarmType;    //报警类型，1-子板拔出，2-子板插入，3-子系统状态异常，4-子系统恢复恢复 5-输入源异常   6-温度报警 7-FPGA版本不匹配 8-预案开始 9-预案结束 10-解码板断网 11-解码板IP地址冲突，12-风扇异常
    BYTE    byBoardType;    // 1-输入板 2-输出板 ，3-主板，4-背板，报警类型为1，2，3，6的时候使用 
    BYTE    bySubException;    //输入异常时具体子异常 1- 分辨率正常改变 2-输入端口类型改变3-分辨率错误4-分辨率改变导致解码资源不足，关闭该输入源对应窗口。5-分辨率改变，导致已开窗的缩放比例不在1/8到8倍范围。6-分辨率恢复正常,7-分辨率改变导致输出板数据量超限,设备关闭窗口 
    BYTE    byRes1;
    WORD    wStartInputNum; // 异常输入源（异常起点） 
    WORD    wEndInputNum;    // 异常输入源（异常终点） 
    BYTE    byRes2[16];       
}NET_DVR_SCREENALARMCFG, *LPNET_DVR_SCREENALARMCFG;

typedef struct tagNET_DVR_MATRIX_CFG
{
    BYTE  byValid;                //判断是否是模拟矩阵（是否有效）
    BYTE  byCommandProtocol;    //模拟矩阵的指令（4种）
    BYTE  byScreenType;            //保留    
    BYTE  byRes1;
    BYTE  byScreenToMatrix[32];    //模拟矩阵的输出与屏幕的对应关系
    BYTE  byRes2[4];
}NET_DVR_MATRIX_CFG, *LPNET_DVR_MATRIX_CFG;

typedef struct tagNET_DVR_DIGITALSCREEN
{
    NET_DVR_IPADDR  struAddress;/*设备为数字设备时的IP信息*/
    WORD            wPort;        //通道号
    BYTE            byRes[26];  //保留
}NET_DVR_DIGITALSCREEN, *LPNET_DVR_DIGITALSCREEN;

typedef struct tagNET_DVR_ANALOGSCREEN
{
    BYTE    byDevSerPortNum;   /*连接设备的串口号*/
    BYTE    byScreenSerPort;  /*连接大屏的串口号*/
    BYTE    byRes[130];   
    NET_DVR_MATRIX_CFG struMatrixCfg;
}NET_DVR_ANALOGSCREEN, *LPNET_DVR_ANALOGSCREEN;


typedef struct tagNET_DVR_SCREEN_SCREENINFO
{
    DWORD dwSize;
    BYTE byValid;                //是否有效
    BYTE nLinkMode;                //连接方式，0-串口，1-网口
    BYTE byDeviceType;            //设备型号，能力集获取
    BYTE byScreenLayX;            //大屏布局-横坐标
    BYTE byScreenLayY;            //大屏布局-纵坐标
    BYTE byRes1[3];
    BYTE sUserName[NAME_LEN];    /*登录用户名*/
    BYTE sPassword[PASSWD_LEN]; /*登录密码*/   
    BYTE sDevName[NAME_LEN];    /*设备名称*/
    NET_DVR_SCREEN_UNION struScreenUnion;
    BYTE byInputNum;            // 输入源个数
    BYTE byOutputNum;            // 输出源个数
    BYTE byCBDNum;                //CBD个数
    BYTE byRes2[29];
} NET_DVR_SCREEN_SCREENINFO, *LPNET_DVR_SCREEN_SCREENINFO;

typedef struct tagNET_DVR_BASEMAP_CFG
{    
    BYTE byScreenIndex;         //屏幕的序号
    BYTE byMapNum;                /*被分割成了多少块 */
    BYTE res[2];
    WORD wSourWidth;            /* 原图片的宽度 */
    WORD wSourHeight;            /* 原图片的高度 */
}NET_DVR_BASEMAP_CFG, LPNET_DVR_BASEMAP_CFG;

typedef struct tagNET_DVR_PICCFG
{
    DWORD    dwSize;        //大小
    BYTE    byUseType;    //1-底图，2-GIF图片，3-CAD图片 4-输出口图片
    BYTE    bySequence;//序号  
    BYTE    byOverlayEnabled; //图片叠加使能，是否在上传图片包含图片叠加参数 1-包含叠加参数，0-不包含
    BYTE    byRes[1];
    NET_DVR_BASEMAP_CFG    struBasemapCfg;   //底图参数对合码器设备无效
    BYTE    sPicName[NAME_LEN];//图片名称
    DWORD   dwVideoWall;       //墙号（1字节墙号（对于合码器，该值固定为1即可）+1字节通道输出（合码通道号）+2字节窗口号）
    BYTE   	byFlash; //图片闪烁使能，1-闪烁，0-不闪烁
    BYTE   	byTranslucent; //图片半透明使能，1-半透明，0-不半透明
    BYTE    byShowEnabled; //图片显示使能，1-显示，0-隐藏
    BYTE    byPictureType; //图片类型，1-bmp，2-jpg，3-png，……
    BYTE    byRes2[24];
}NET_DVR_PICTURECFG, *LPNET_DVR_PICTURECFG;

typedef struct tagNET_DVR_OSDCFG
{
    DWORD   dwSize;
    BYTE    byValid;    /*是否有效 0无效 1有效*/
    BYTE    byDispMode;  //显示模式，1-透明，2-半透明，3-覆盖三种模式
    BYTE    byFontColorY; /*字体颜色Y,0-255*/
    BYTE    byFontColorU; /*字体颜色U,0-255*/
    BYTE    byFontColorV; /*字体颜色V,0-255*/
    BYTE    byBackColorY; /*背景颜色Y,0-255*/
    BYTE    byBackColorU; /*背景颜色U,0-255*/
    BYTE    byBackColorV; /*背景颜色V,0-255*/
    WORD    wXCoordinate;   /*OSD在屏幕左上角位置x*/
    WORD    wYCoordinate;   /*OSD在屏幕左上角位置y*/
    WORD    wWidth;       /*OSD宽度*/
    WORD    wHeight;      /*OSD高度*/
    DWORD   dwCharCnt;     /*字符的个数*/
    WORD    wOSDChar[MAX_OSDCHAR_NUM];       /*OSD字符内容*/
    BYTE    byRes[32];
}NET_DVR_OSDCFG, *LPNET_DVR_OSDCFG;

typedef struct tagNET_DVR_SERIAL_CONTROL
{ 
    DWORD    dwSize ;
    BYTE    bySerialNum;        // 串口个数
    BYTE    byRes1[3];
    BYTE    bySerial[32];
    BYTE    byRes2[32];
}NET_DVR_SERIAL_CONTROL, *LPNET_DVR_SERIAL_CONTROL;


typedef struct tagNET_DVR_INPUT_INTERFACE_CTRL
{
    BYTE    byInputSourceType;    //见INPUT_INTERFACE_TYPE
    BYTE    byRes[15];
}NET_DVR_INPUT_INTERFACE_CTRL, *LPNET_DVR_INPUT_INTERFACE_CTRL;

typedef struct tagNET_DVR_DISPLAY_COLOR_CTRL
{
    BYTE    byColorType;        //1-亮度 2-对比度 3-饱和度 4-清晰度
    char    byScale;            //-1 、0、+1三个值
    BYTE    byRes[14];
}NET_DVR_DISPLAY_COLOR_CTRL, *LPNET_DVR_DISPLAY_COLOR_CTRL;

typedef struct tagNET_DVR_DISPLAY_POSITION_CTRL
{
    BYTE    byPositionType;    //1-水平位置 2-垂直位置，
    char    byScale;            //-1 、0、+1三个值
    BYTE    byRes[14];
}NET_DVR_DISPLAY_POSITION_CTRL, *LPNET_DVR_DISPLAY_POSITION_CTRL;

typedef struct tagNET_DVR_RECTCFG_EX 
{
    DWORD dwXCoordinate; /*矩形左上角起始点X坐标*/
    DWORD dwYCoordinate; /*矩形左上角Y坐标*/
    DWORD dwWidth;       /*矩形宽度*/
    DWORD dwHeight;      /*矩形高度*/
    BYTE  byRes[4];
}NET_DVR_RECTCFG_EX, *LPNET_DVR_RECTCFG_EX;


typedef struct  tagNET_DVR_PLAN_INFO
{
    BYTE      byValid;          // 该项是否有效
    BYTE      byType;           // 见定义NET_DVR_PLAN_OPERATE_TYPE
    WORD      wLayoutNo;      // 布局号
    BYTE    byScreenStyle;    //屏幕型号，开关机所用，1是低亮，2是高亮
    BYTE  byBaseMapType;  //底图类型，1-图片底图，2-超高清输入底图，底图切换时有效
    BYTE  byRes1[2];
    DWORD      dwDelayTime;      // 一个项的运行时间, 单位秒
    DWORD   dwSerialNo;        //串口号，屏幕控制时使用
    DWORD  dwBaseMapWndNo; //底图窗口号，底图切换时有效
    DWORD  dwBaseMapNo;   //底图号，底图切换时有效；底图类型为1时，此参数为图片序号，底图类型为2时此参数为超高清输入子系统输入号（1字节设备号+1字节子板号+2字节显示输入序号）
    BYTE    byRes2[20];
} NET_DVR_PLAN_INFO, *LPNET_DVR_PLAN_INFO;

typedef struct tagNET_DVR_CYCLE_TIME
{
    BYTE    byValid; 
    BYTE    byRes[3];
    NET_DVR_TIME_EX struTime;
}NET_DVR_CYCLE_TIME, *LPNET_DVR_CYCLE_TIME;

typedef struct tagNET_DVR_PLAN_CFG
{
    DWORD     dwSize;
    BYTE      byValid;          // 该预案是否有效
    BYTE      byWorkMode;      // 预案工作模式 1表示手动，2自动，3预案循环
    BYTE    byWallNo;        //电视墙号，从1开始
    BYTE    byPlanNo;    //预案号，获取预案列表时有效，0-无效或不支持
    BYTE      byPlanName[NAME_LEN/*32*/]; //预案名称
    NET_DVR_TIME_EX struTime; // 工作模式为自动时使用
    NET_DVR_CYCLE_TIME struTimeCycle[DAYS_A_WEEK/*7*/]; /*循环时间，周期为一个星期，年、月、日三个参数不使用。如：struTimeCycle[0]中的byValid的值是1，表示星期天执行该预案。星期取值区间为[0,6]，其中0代表星期天，1代表星期一，以此类推*/
    DWORD     dwWorkCount;      // 预案内容执行次数
    NET_DVR_PLAN_INFO strPlanEntry[MAX_PLAN_ACTION_NUM/*32*/];  // 预案执行的内容
    DWORD		dwPlanNo; //4字节预案号，客户端统一使用4字节的预案号，单字节的预案号不再使用
    BYTE		byRes2[60];
}NET_DVR_PLAN_CFG, *LPNET_DVR_PLAN_CFG;

typedef struct tagNET_DVR_PLAN_LIST
{
    DWORD        dwSize;
    DWORD        dwPlanNums;            //设备输入信号源数量
    BYTE          *pBuffer;            //指向dwInputSignalNums个NET_DVR_PLAN_CFG结构大小的缓冲区
    BYTE        byWallNo;            //墙号，从1开始
    BYTE        byRes1[2];
    DWORD         dwBufLen;            //所分配缓冲区长度，输入参数（大于等于dwInputSignalNums个NET_DVR_PLAN_CFG结构大小）
    BYTE        byRes2[64];
} NET_DVR_PLAN_LIST,*LPNET_DVR_PLAN_LIST;

typedef struct tagNET_DVR_CONTROL_PARAM
{
    DWORD    dwSize;
    BYTE    sDeviceID[NAME_LEN]; //被控设备的设备ID
    WORD    wChan;                 //被控通道
    BYTE    byIndex;             //控制索引，根据命令确定具体表示什么索引
    BYTE    byRes1;
    DWORD    dwControlParam;
    BYTE    byMandatoryAlarm;    //1-使能  0-不使能
    BYTE      byRes2;
    WORD     wZoneIndex;            //防区号
    BYTE      byOperatorCode[16];   //回控码
    DWORD	dwPlanNo; //4字节预案号，客户端统一使用4字节的预案号，单字节的预案号不再使用
    BYTE	byRes3[8];
}NET_DVR_CONTROL_PARAM, *LPNET_DVR_CONTROL_PARAM;

typedef struct tagNET_DVR_DEVICE_RUN_STATUS
{
    DWORD 	dwSize;
    DWORD   dwMemoryTotal;		    //内存总量，单位Kbyte
    DWORD	dwMemoryUsage;		    //内存使用量，单位Kbyte
    BYTE	byCPUUsage;			    //CPU使用率，0-100
    BYTE    byMainFrameTemp;   	    //机箱温度，单位：摄氏度
    BYTE    byBackPanelTemp;    	//背板温度，单位：摄氏度
    BYTE    byRes1;
    BYTE    byLeftDecResource[32];	//各解码板剩余解码资源，以解D1分辨率资源为单位，byLeftDecResource[i],表示槽位号i解码板剩余资源，0xff表示无效（非解码板或没插板子）
    float	fNetworkFlow; 		    //网络流量，单位：KB/s，归一化处理，保留小数点后两位
    BYTE	byRes2[88];
}NET_DVR_DEVICE_RUN_STATUS, *LPNET_DVR_DEVICE_RUN_STATUS;

typedef struct tagNET_DVR_ACCESS_CAMERA_INFO
{
    DWORD dwSize;
       char  sCameraInfo[32];        // 前端相机信息
    BYTE  byInterfaceType;        // 前端接入接口类型，1:VGA, 2:HDMI, 3:YPbPr 4:SDI 5:FC
    BYTE  byRes1[3];
    DWORD dwChannel;
       BYTE  byRes[24];
}NET_DVR_ACCESS_CAMERA_INFO, *LPNET_DVR_ACCESS_CAMERA_INFO;

typedef struct tagNET_DVR_AUDIO_INPUT_PARAM
{
    BYTE  byAudioInputType;  //音频输入类型，0-mic in，1-line in
    BYTE  byVolume; //volume,[0-100]
    BYTE  byEnableNoiseFilter; //是否开启声音过滤-关，-开
    BYTE  byres[5];
}NET_DVR_AUDIO_INPUT_PARAM, *LPNET_DVR_AUDIO_INPUT_PARAM;

typedef struct tagNET_DVR_CAMERA_DEHAZE_CFG
{
    DWORD dwSize;
    BYTE byDehazeMode; //0-不启用，1-自动模式，2-开
    BYTE byLevel; //等级，0-100
    BYTE byRes[6]; 
}NET_DVR_CAMERA_DEHAZE_CFG, *LPNET_DVR_CAMERA_DEHAZE_CFG;

typedef struct tagNET_DVR_INPUT_SIGNAL_LIST
{
    DWORD        dwSize;
    DWORD        dwInputSignalNums;    //设备输入信号源数量
    BYTE          *pBuffer;            //指向dwInputSignalNums个NET_DVR_INPUTSTREAMCFG结构大小的缓冲区
    BYTE        byRes1[3];
    DWORD         dwBufLen;            //所分配缓冲区长度，输入参数（大于等于dwInputSignalNums个NET_DVR_INPUTSTREAMCFG结构大小）
    BYTE        byRes2[64];
} NET_DVR_INPUT_SIGNAL_LIST,*LPNET_DVR_INPUT_SIGNAL_LIST;

typedef struct tagNET_DVR_RECORD_TIME_SPAN_INQUIRY
{
    DWORD    dwSize;    //结构体大小
    BYTE    byType;    //0 正常音视频录像, 1图片通道录像, 2ANR通道录像, 3抽帧通道录像
    BYTE     byRes[63]; //保留
}NET_DVR_RECORD_TIME_SPAN_INQUIRY, *LPNET_DVR_RECORD_TIME_SPAN_INQUIRY;

typedef struct tagNET_DVR_RECORD_TIME_SPAN
{
    DWORD          dwSize;        //结构体大小
    NET_DVR_TIME  strBeginTime;  //开始时间
    NET_DVR_TIME  strEndTime;    //结束时间
    BYTE          byType;        //0 正常音视频录像, 1图片通道录像, 2ANR通道录像, 3抽帧通道录像
    BYTE           byRes[35];     //保留
}NET_DVR_RECORD_TIME_SPAN, *LPNET_DVR_RECORD_TIME_SPAN;

typedef struct tagNET_DVR_DRAWFRAME_DISK_QUOTA_CFG
{
    DWORD    dwSize;                    //结构体大小
    BYTE     byPicQuota;                //图片百分比     [0%,  30%]
    BYTE     byRecordQuota;                //普通录像百分比 [20%, 40%]
    BYTE     byDrawFrameRecordQuota;    //抽帧录像百分比 [30%, 80%]
    BYTE     byRes[61];                    //保留字节
}NET_DVR_DRAWFRAME_DISK_QUOTA_CFG, *LPNET_DVR_DRAWFRAME_DISK_QUOTA_CFG;

typedef struct tagNET_DVR_NAT_PORT
{
    WORD wEnable;         //该端口是否使能映射
    WORD wExtPort;        //映射的外部端口号
    BYTE byRes[12];       //保留
}NET_DVR_NAT_PORT, *LPNET_DVR_NAT_PORT;

typedef struct  tagNET_DVR_NAT_CFG
{
    DWORD dwSize;          //结构体大小
    WORD wEnableUpnp;     //UPNP功能是否启用
    WORD wEnableNat;        //UPNP端口映射（NAT）功能是否启用(保留，与wEnableUpnp保持一致)
    NET_DVR_IPADDR  struIpAddr;      //NAT路由器LAN IP地址
    NET_DVR_NAT_PORT    struHttpPort;   //web server http端口映射配置
    NET_DVR_NAT_PORT    struCmdPort; //命令端口映射配置(8000)
    NET_DVR_NAT_PORT    struRtspPort;  //rtsp端口映射配置
    BYTE byFriendName[64]; //服务名
    BYTE byNatType; //UPNP端口映射类型，0-手动，1-自动
    BYTE            byRes1[3];    //保留
    NET_DVR_NAT_PORT    struHttpsPort;     //https端口映射配置
    NET_DVR_NAT_PORT    struSDKOverTLSPort;  //SDKOverTLS端口映射配置
    NET_DVR_NAT_PORT    struRtspsPort;  //Rtsps端口映射配置
    BYTE                byres[44];    //保留
}NET_DVR_NAT_CFG, *LPNET_DVR_NAT_CFG;



typedef struct tagNET_DVR_PLAYCOND
{
    DWORD             dwChannel;
    NET_DVR_TIME     struStartTime;
    NET_DVR_TIME     struStopTime;
    BYTE             byDrawFrame;  //0:不抽帧，1：抽帧
    BYTE             byStreamType ; //码流类型，0-主码流 1-子码流 2-码流三
    BYTE             byStreamID[STREAM_ID_LEN];
    BYTE             byCourseFile;    //课程文件0-否，1-是
    BYTE             byDownload;    //是否下载 0-否，1-是
    BYTE             byOptimalStreamType;    //是否按最优码流类型回放 0-否，1-是（对于双码流设备，某一段时间内的录像文件与指定码流类型不同，则返回实际码流类型的录像）
    BYTE             byVODFileType; // 下载录像文件，文件格式 0-PS码流格式，1-3GP格式 
    BYTE             byRes[26];    //保留
}NET_DVR_PLAYCOND, *LPNET_DVR_PLAYCOND;

typedef struct tagNET_DVR_ATMFINDINFO
{
    BYTE    byTransactionType;       //交易类型 0-全部，1-查询， 2-取款， 3-存款， 4-修改密码，5-转账， 6-无卡查询 7-无卡存款， 8-吞钞 9-吞卡 10-自定义
    BYTE    byRes[3] ;    //保留
    DWORD  dwTransationAmount ;     //交易金额 ;
} NET_DVR_ATMFINDINFO, *LPNET_DVR_ATMFINDINFO ;


typedef struct tagNET_DVR_FILECOND_V40
{
    LONG           lChannel;
    DWORD          dwFileType;/*不带卡号录象文件类型0xff-全部，0-定时录像，1-移动侦测，2-报警触发，3-报警触发或移动侦测，4-报警触发和移动侦测，5-命令触发，6-手动录像，
    7-智能录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件，15-越界侦测，16-区域入侵，17-声音异常，18-场景变更侦测，19-智能侦测（越界侦测|区域入侵|人脸侦测|声音异常|场景变更侦测），
    20-人脸侦测， 21-信号量，22-回传，23-回迁录像，24-遮挡，25-pos录像，26-进入区域侦测, 27-离开区域侦测,28-徘徊侦测,29-人员聚集侦测,30-快速运动侦测,31-停车侦测,32-物品遗留侦测,33-物品拿取侦测, 
    34-火点侦测，35-防破坏检测，36-船只检测，37-测温预警,38-测温报警,39-打架斗殴报警，40-起身检测，41-瞌睡检测，42-温差报警，43-离线测温报警,44-防区报警，45-紧急求助,46-业务咨询,47-起身检测,48-折线攀高,49-如厕超时，50-奔跑检测，51-滞留检测，52-人脸抓拍, 53-非法摆摊, 54-目标识别,
    55-剧烈运动，56-离岗检测，57-起立，58-人数变化，59-违停, 60-逆行,61-压线,62-机占非,63-变道,64-掉头,65-行人检测,66-路障,67-抛洒物,68-浓雾检测,69-施工,70-拥堵,71-交通事故检测, 72-侧方停车，73-手动触发报警,74-交通违章，75-挖沙船检测报警 76-废气排放监测77-灰度报警,78-振动侦测,
    79-烟雾检测,80-通道定时录像事件,81-AI开放平台事件
*/
    DWORD          dwIsLocked;
    DWORD          dwUseCardNo;//是否带ATM信息进行查询：0-不带ATM信息，1-按交易卡号查询，2-按交易类型查询，3-按交易金额查询，4-按卡号、交易类型及交易金额的组合查询 5-按课程名称查找，此时卡号表示课程名称
    BYTE           sCardNumber[CARDNUM_LEN_OUT];
    NET_DVR_TIME   struStartTime;
    NET_DVR_TIME   struStopTime;
    BYTE           byDrawFrame; //0:不抽帧，1：抽帧
    BYTE        byFindType; //0:查询普通卷，1：查询存档卷
    BYTE        byQuickSearch; //0:普通查询，1：快速（日历）查询
    BYTE        bySpecialFindInfoType ;    //专有查询条件类型 0-无效， 1-带ATM查询条件  
    DWORD       dwVolumeNum;  //存档卷号
    BYTE        byWorkingDeviceGUID[GUID_LEN];    //工作机GUID，通过获取N+1得到
    NET_DVR_SPECIAL_FINDINFO_UNION uSpecialFindInfo ;   //专有查询条件
    BYTE        byStreamType;    //0-同一个时间段只返回一种录像，优先级顺序为：主码流、子码流、三码流，1-子码流，2-三码流，3-主码流，254-双码流搜索(优先返回主码流录像，没有主码流录像时返回子码流录像)
    BYTE        byAudioFile;                //音频文件 0-非音频文件，1-音频文件
    BYTE        byRes2[30];    //保留
}NET_DVR_FILECOND_V40, *LPNET_DVR_FILECOND_V40;

typedef struct tagNET_DVR_FILECOND_V50
{
    NET_DVR_STREAM_INFO struStreamID; //流ID或通道号
    NET_DVR_TIME_SEARCH_COND    struStartTime; //开始时间
    NET_DVR_TIME_SEARCH_COND    struStopTime; //结束时间
    BYTE  byFindType; //0-查询普通卷，1-查询存档卷 2-查询N+1录像文件
    BYTE  byDrawFrame; //是否抽帧 0-不抽帧 1-抽帧
    BYTE  byQuickSearch; //0-普通查询，1-快速（日历）查询
    BYTE  byStreamType; //0-主码流，1-子码流，2-3码流，0xff-全部
    DWORD  dwFileType; // 文件类型
    DWORD  dwVolumeNum; //存档卷号，byFindType为1时有效
    BYTE  byIsLocked; //是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
    BYTE  byNeedCard; //是否需要查询卡，0-不需要 1-需要
    BYTE  byOnlyAudioFile;        //音频文件 0-视频文件 1-音频文件
    BYTE  bySpecialFindInfoType; //0-无效， 1-带ATM查询条件
    char  szCardNum[32];  //卡号，byNeedCard为1时有效
    char    szWorkingDeviceGUID[16]; //工作机GUID，通过获取N+1得到，byFindType为2时有效
    NET_DVR_SPECIAL_FINDINFO_UNION    uSpecialFindInfo; //专有查询条件联合体
    DWORD dwTimeout; //查找超时时间（指定NET_DVR_FindNextFile_V30/NET_DVR_FindNextFile_V40/NET_DVR_FindNextFile_V50接口的超时时间返回）；单位：毫秒，不填写（默认为0时），接口行为跟以前一样 ;有效值：0, [5000 – 15000]
    BYTE                              byRes[252];
}NET_DVR_FILECOND_V50, *LPNET_DVR_FILECOND_V50;

typedef struct 
{
    BYTE    sAESKey[16];        /*码流加密密钥*/
    BYTE    byRes[64];          /*保留字节*/
}NET_DVR_AES_KEY_INFO, *LPNET_DVR_AES_KEY_INFO;



typedef struct  
{
    DWORD    dwEnable; /* 是否启用 0－否 1－启用*/
    BYTE    byType; //设备类型 0: DEV_SDK  1:DEV_DAHUA  2:DEV_EHOME    3:DEV_OTHERES
    BYTE    byRes[3];  //保留
    NET_DVR_STREAM_MEDIA_SERVER_CFG streamMediaServerCfg; 
    NET_DVR_DEV_CHAN_INFO  struDevChanInfo; /* 轮循解码通道信息 */
    BYTE    sRtspUrl[128];//流地址
}NET_DVR_MATRIX_CHAN_INFO_EX,*LPNET_DVR_MATRIX_CHAN_INFO_EX;



typedef struct tagNET_DVR_MATRIX_TRUNKCFG
{
    DWORD     dwGlobalIndex;  //主键
    DWORD     dwInterIndex;   //本地全局编号
    BYTE      sTrunkName[NAME_LEN];
    BYTE      byType;   //设备类型1-bnc, 2-SP3, 3-V6
    BYTE      byDir;   //干线方向 1-输入2-输出
    BYTE      byAbility;   //干线能力，D1衡量
    BYTE      bySubsys;   //子系统ID
    BYTE      byChan;     //通道ID
    BYTE      byRes[255];     //预留
} NET_DVR_MATRIX_TRUNKCFG,*LPNET_DVR_MATRIX_TRUNKCFG;

typedef struct tagNET_DVR_DECSUBSYSTEMJIONSTATUS_V41
{
    BYTE        byJoinStatus;//关联状态，0-没有关联，1-已经关联，通过其他字段判断被自己关联或被其他子系统关联，2-被占用，byDecodeAbility大于1时有效，3-被大屏主屏关联，4-被大屏子屏关联
    BYTE        byJoinSubSystem;// 所关联或占用的子系统槽位号
    BYTE        byJoinDispNum;// 所关联或占用的显示通道号
    BYTE        byJoinSubWindowNum;// 所关联或占用的子窗口号
    BYTE        byDecodeAbility;   //解码通道的当前解码能力，0-未关联，1-D1，2-720，3-1080
    BYTE        byRes[15];
}NET_DVR_DECSUBSYSTEMJIONSTATUS_V41,LPNET_DVR_DECSUBSYSTEMJIONSTATUS_V41;

typedef struct tagNET_DVR_SINGLESUBSYSTEMJOININFO_V41
{
    /*子系统类型，1-解码用子系统，2-编码用子系统，3-级联输出子系统，4-级联输入子系统，5-码分器子系统，6-报警主机子系统，7-智能子系统，8-V6解码子系统，9-V6子系统，0-NULL（此参数只能获取）*/
    BYTE    bySubSystemType; 
    BYTE    byConnectStatus;//级联系统关联状态，1-连接正常，2-连接断开
    BYTE    byMatrixNum;//级联视频综合平台号，子系统类型是3或4时可用
    BYTE    bySubSystemNum;//级联子系统槽位号，子系统类型是3或4时可用
    NET_DVR_DECSUBSYSTEMJIONSTATUS_V41 struSubSystem[MAX_DECODECHANNUM];
    BYTE    byBindStatus;//绑定状态，0-没有绑定，1-已经绑定（大屏拼接时用到）
    BYTE    bySlotNum ;//槽位号，此参数只能获取
    BYTE    byUsedTrunk;//是否被干线使用，0-未被使用，1-被使用
    BYTE    byRes[65];
}NET_DVR_SINGLESUBSYSTEMJOININFO_V41,LPNET_DVR_SINGLESUBSYSTEMJOININFO_V41;

typedef struct tagNET_DVR_ALLDECSUBSYSTEMJOININFO_V41
{
    DWORD dwSize;
    NET_DVR_SINGLESUBSYSTEMJOININFO_V41 struSingleSubSystemJoinInfo[MAX_SUBSYSTEM_NUM_V40];
    BYTE  byRes[48];
}NET_DVR_ALLDECSUBSYSTEMJOININFO_V41,*LPNET_DVR_ALLDECSUBSYSTEMJOININFO_V41;

typedef struct tagNET_DVR_PUBLIC_SUB_SYSTEM
{
    //关联子系统号，按位表示，bit0表示该公共子系统关联子系统1.
    DWORD    dwJointSubSystem;
    BYTE    byRes[16];
}NET_DVR_PUBLIC_SUB_SYSTEM, *LPNET_DVR_PUBLIC_SUB_SYSTEM;

typedef struct tagNET_DVR_NOAMAL_SUB_SYSTEM
{
    //表示被哪些公共子系统关联，按位表示，bit0 表示，该子系统.被关联到公共子系统1
    DWORD    dwBeJoinedSubSystem;
    BYTE    byRes[16];    
}NET_DVR_NOAMAL_SUB_SYSTEM, *LPNET_DVR_NOAMAL_SUB_SYSTEM;


typedef struct tagNET_DVR_ALARMSUBSYSTEMPARAM
{
    DWORD        dwSize;
    WORD        wEnterDelay;                    //进入延时,单位:秒, 范围：10-150 动环报警主机和自助行报警主机的延时时间在 NET_DVR_ALARMIN_PARAM 中的dwParam来设置延时时间
    //具体用哪种设置方式通过能力集中的bySupportAlarmInDelay字段来区别
    WORD        wExitDelay;//退出延时,单位:秒， 范围10-300
    BYTE        byHostageReport;                //挟持报告，0禁能 1使能
    BYTE        bySubsystemEnable;                //子系统使能
    BYTE        byKeyToneOfArmOrDisarm;            // 成功发送布撤防报告是否键盘提示，0-键盘不提示 1-键盘输出提示音
    BYTE        byKeyToneOfManualTestReport;    //成功发送测试报告是否键盘提示，0-键盘不提示 1-键盘输出提示音
    WORD        wDelayTime;                        //警号输出延时，当能力集中dwSupport1中的bit0位为1时，使用该参数设置警号输出时间。bit0为0时，使用NET_DVR_SIREN_PARAM中的wDelay参数设置警号输出时间
    BYTE        byEnableAlarmInDelay;//0--不启用(使用子系统延时),1--启用(使用防区延时)，默认不启用
    BYTE         byPublicAttributeEnable;        //是否为公共子系统
    NET_DVR_JOINT_SUB_SYSTEM struJointSubSystem;        
    BYTE        byKeyZoneArm;                    //是否支持钥匙防区对子系统进行布防操作
    BYTE        byKeyZoneArmReport;                //是否支持钥匙防区对子系统布防时发送布防报告
    BYTE        byKeyZoneDisarm;                //是否支持钥匙防区对子系统进行撤防操作
    BYTE        byKeyZoneDisarmReport;            //是否支持钥匙防区对子系统进行撤防操作时发送撤防报告
    BYTE        bySubSystemID[MAX_SUBSYSTEM_ID_LEN];    //子系统ID
    BYTE        byKeyZoneArmReportEnable;    //钥匙防区上传布防报告使能 0-禁能 1-使能
    BYTE        byKeyZoneArmEnable;    //钥匙防区使能， 0 -禁能 1-使能
    BYTE        byOneKeySetupAlarmEnable;          //一键布防使能
    BYTE        bySingleZoneSetupAlarmEnable;       //单防区布撤防使能
    BYTE        byCenterType;                    //0-无效, 1-中心账号(长度6),2-扩展的中心账号(长度9)
    BYTE        sCenterAccount[ACCOUNTNUM_LEN/*6*/];    //中心帐号
    BYTE        sCenterAccountV40[ACCOUNTNUM_LEN_32/*32*/];    //中心账号V40,使用此字段时sCenterAccount无效
    BYTE        byRes2[565];                    // 保留字节
}NET_DVR_ALARMSUBSYSTEMPARAM, *LPNET_DVR_ALARMSUBSYSTEMPARAM;

typedef struct tagNET_DVR_REMIND_TIME//8
{
    BYTE byEnable;//是否启用本次提醒 0-不启用，1-启用
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
}NET_DVR_REMIND_TIME,*LPNET_DVR_REMIND_TIME;

typedef struct tagNET_DVR_SUBSYSTEM_PARAM_EX
{
    DWORD     dwSize;
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; //布撤防时间
    BYTE    byAlarmInAdvance;            // 布撤防提前提示时间0~45分
    BYTE    byRes1[3];
    BYTE     byJointAlarmIn[MAX_ALARMHOST_ALARMIN_NUM / 8];//按位，表示子系统关联的报警输入通道号，0-不加入，1-加入
    BYTE     byJointKeyboard[MAX_ALARMHOSTKEYBOARD/*64*/ / 8];//按位，表示支持的键盘号，0-不加入，1-加入
    BYTE    byJointOpetaterUser[MAX_KEYBOARD_USER_NUM/8];//按位表示，bit0表示键盘操作用户1 ，0-不关联 1-关联
    NET_DVR_REMIND_TIME    struAlarmRemindTime[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/];//MAX_TIMESEGMENT_V30表示每天最多支持8个提醒
    BYTE	    byJointNetUser[NET_SDK_MAX_NET_USER_NUM / 8];//关联网络用户（按位表示，bit0表示网络用户1；0-不关联 1-关联）
    BYTE    byRes2[280];            // 保留字节
}NET_DVR_SUBSYSTEM_PARAM_EX, *LPNET_DVR_SUBSYSTEM_PARAM_EX;

typedef struct tagNET_DVR_ALARMHOST_PRINTER_CFG
{
    DWORD     dwSize;
    BYTE     byPrinterEnable;        //是否启用打印机
    BYTE    byPrintTime;            //是否打印时间
    BYTE     byFaultDetect;            //是否检测打印机故障
    BYTE    byRes1;
    DWORD    dwAlarmInfo;            //报警信息，按位表示。bit0-防区报警，bit1-防区报警恢复，bit2-紧急报警，bit-3挟持报警
    DWORD    dwDeviceInfo;            //设备信息，按位表示。bit0-交流电断电、bit1-交流电断电恢复，bit2-蓄电池欠压、bit3-蓄电池欠压恢复，bit4-电话线断线、bit5-电话线断线恢复，bit6-测试报告、bit7-防拆、bit8-防拆恢复、bit9-485设备掉线、bit10-485设备掉线恢复、bit11-无线网络异常、bit12-无线网络恢复正常、bit13-有线网络异常、bit14-有线网络恢复正常、bit15-扩展总线异常、bit17-扩展总线恢复正常、bit17-硬盘故障、bit18-硬盘故障恢复、bit19-键盘锁定
    DWORD    dwOperateInfo;            //操作信息，按位表示。bit0-布防、bit1-撤防、bit2-消警、bit3-旁路、bit4-旁路恢复、bit5-进入编程、bit6-退出编程、bit7-主机复位
    BYTE     byRes2[256];            // 保留字节
}NET_DVR_ALARMHOST_PRINTER_CFG, *LPNET_DVR_ALARMHOST_PRINTER_CFG;

typedef struct tagNET_DVR_ALARMHOST_NETPARAM
{ 
    DWORD dwSize;
    NET_DVR_IPADDR struIP;
    WORD    wPort;
    BYTE    byAddressType;    //0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
    BYTE    byRes1[1];
    BYTE    byDomainName[MAX_DOMAIN_NAME/*64*/]; //域名，GPRS参数配置、网络参数配置时该字段均有效
    BYTE    byReportProtocol;        //1-private 2-NAL2300, 3-Ehome
    BYTE    byDevID[ACCOUNTNUM_LEN_32/*32*/]; //协议为NAL2300时有效
    BYTE    byRes2[7]; //GPRS的域名解析是在固定的服务器上进行的，所以不需要给解析服务器的信息预留一些字段
}NET_DVR_ALARMHOST_NETPARAM,  *LPNET_DVR_ALARMHOST_NETPARAM;

typedef struct tagNET_DVR_REGISTER_RS485CFG
{
    DWORD   dwSize;                 // 结构体大小
    WORD    wDeviceProtocol;        // 前端设备协议 通过获取协议列表获取    
    BYTE    byRes[2];
    DWORD   dwBaudRate;             //波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k 
    BYTE    byRes1[124];              // 保留字节
}NET_DVR_REGISTER_RS485CFG, *LPNET_DVR_REGISTER_RS485CFG;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG
{
    DWORD    dwSize;
    NET_DVR_ALARMHOST_NETPARAM struNetCenter[MAX_CENTERNUM]; //中心 GPRS网络相关参数的配置 
    BYTE     byAPNName[APN_NAME_LEN/*32*/];
    BYTE    byAPNUserName[APN_USERNAME_LEN/*24*/];
    BYTE    byAPNPassWord[APN_USERPASSWORD_LEN/*16*/];
    BYTE    byReconnTime;    //重连时间，连接失效后启用重连的时间，10秒为单位,取值范围1-30
    BYTE    byOverTime;        //超时时间，超过OverTime时间没有收到有效数据则重连，范围1-254，单位30秒
    BYTE    byDetectLinkTime;    //    //探测链路是否还保持，范围1-30，单位10s
    BYTE    byRes1;
    BYTE    bySIMNum[NAME_LEN/*32*/]; //SIM卡号（手机号）
    NET_DVR_IPADDR    struSIMIP;      //登陆网络后网络给分配的IP地址，只能获取
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG, *LPNET_DVR_ALARMHOST_WIRELESS_NETWORK_CFG;

typedef struct tagNET_DVR_ALARMHOST_NETCFG
{
    DWORD dwSize;
    NET_DVR_ALARMHOST_NETPARAM     struNetCenter[MAX_CENTERNUM];
    BYTE    byRes1[32];
}NET_DVR_ALARMHOST_NETCFG,  *LPNET_DVR_ALARMHOST_NETCFG;

typedef struct tagNET_DVR_ALARMHOST_REPORTCENTER_CFG
{
    DWORD    dwSize;
    BYTE    byValid;                //是否启用
    BYTE    byRes[3]; //保留1
    BYTE    byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];    //中心组报警通道， 1-T1、2-T2、 3-N1、 4-N2、5-G1、 6-G2
    BYTE    byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //向指定中心组发送失败报告，用数组下标表示是哪个中心组，0-不选择、1-选择
    BYTE    byDataType;    //1-报警数据 2-非报警数据 3-所有数据
    BYTE    byRes2[15];    //保留2
}NET_DVR_ALARMHOST_REPORTCENTER_CFG, *LPNET_DVR_ALARMHOST_REPORTCENTER_CFG;

typedef struct tagNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40
{
    DWORD        dwSize;            
    BYTE        byValid;            //是否启用
    BYTE        byDataType;            //1-所有报警数据 2-所有非报警数据 3-所有数据，4-防区报警报告，5-非防区报警报告
    BYTE        byRes[2];             //保留1
    BYTE        byChanAlarmMode[MAX_REPORTCHAN_NUM/*4*/];    //中心组报警通道， 1-T1、2-T2、 3-N1、 4-N2、5-G1、 6-G2、7-N3、 8-N4、9-CMK-4G、10-CMK-NET(如果设备支持3G，G1，G2表示3G模块，如果不支持，表示GPRS模块，一款设备中3G模块和GPRS模块只会出现一种)
    BYTE        byDealFailCenter[MAX_CENTERGROUP_NUM/*16*/]; //向指定中心组发送失败报告，用数组下标表示是哪个中心组，0-不选择、1-选择
    BYTE         byZoneReport[MAX_ALARMHOST_ALARMIN_NUM];    //防区报告类型，0-不上传，1-上传 
    BYTE        byNonZoneReport[MAX_EVENT_NUM]; //非防区报警报告, 每一个元素表示一种事件类型，0-不上传，1-上传，byNonZoneReport[0]-软防区报告 byNonZoneReport[1]-系统状态报告 byNonZoneReport[2]-取消报告 byNonZoneReport[3]-测试报告 byNonZoneReport[4]-布防报告 byNonZoneReport[5]-撤防报告 byNonZoneReport[6]-挟持报告 byNonZoneReport[7]-报警恢复报告 byNonZoneReport[8]-旁路报告 byNonZoneReport[9]-旁路恢复报告。byNonZoneReport[10]-探测器连接状态报告（上线、离线）。byNonZoneReport[11]-探测器电量状态报告（电压正常、欠压）byNonZoneReport[12]-视频报警报告
    BYTE        byAlarmNetCard[MAX_REPORTCHAN_NUM/*4*/];    //中心组报警网卡中心，0-主网卡中心1，1-主网卡中心2，2-扩展网卡中心1,3-扩展网卡中心2（报警通道为N1、N2、N3、N4时有效）
    BYTE        byRes2[252];            //保留2
}NET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40, *LPNET_DVR_ALARMHOST_REPORT_CENTER_CFG_V40;



typedef struct tagNET_DVR_AUDIO_PARAM
{
    DWORD        dwSize;
    BYTE        byAudioFormat;      //音频格式，1-G711，2-G722 
    BYTE        byRes1;
    WORD        wChannels;          // number of channels (i.e. mono, stereo...)
    DWORD        dwSamplesPerSec;    //采样率
    BYTE        byRes2[20];            //保留
    DWORD        dwAudioSize;        //音频长度大小，压缩后的大小
}NET_DVR_AUDIO_PARAM,*LPNET_DVR_AUDIO_PARAM;

typedef struct tagNET_DVR_PREVIEWINFO
{
    LONG lChannel;//通道号
    DWORD dwStreamType;    // 码流类型，0-主码流，1-子码流，2-码流3，3-码流4, 4-码流5,5-码流6,7-码流7,8-码流8,9-码流9,10-码流10
    DWORD dwLinkMode;// 0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-RTP/RTSP,5-RSTP/HTTP ,6- HRUDP（可靠传输） ,7-RTSP/HTTPS
    HWND hPlayWnd;//播放窗口的句柄,为NULL表示不播放图象
    DWORD bBlocked;  //0-非阻塞取流, 1-阻塞取流, 如果阻塞SDK内部connect失败将会有5s的超时才能够返回,不适合于轮询取流操作.
    DWORD bPassbackRecord; //0-不启用录像回传,1启用录像回传
    BYTE byPreviewMode;//预览模式，0-正常预览，1-延迟预览
    BYTE byStreamID[STREAM_ID_LEN/*32*/];//流ID，lChannel为0xffffffff时启用此参数
    BYTE byProtoType; //应用层取流协议，0-私有协议，1-RTSP协议,2-SRTP码流加密（对应此结构体中dwLinkMode 字段，支持如下方式, 为1，表示udp传输方式，信令走TLS加密，码流走SRTP加密，为2，表示多播传输方式，信令走TLS加密，码流走SRTP加密）
    BYTE byRes1;
    BYTE byVideoCodingType; //码流数据编解码类型 0-通用编码数据 1-热成像探测器产生的原始数据（温度数据的加密信息，通过去加密运算，将原始数据算出真实的温度值）
    DWORD dwDisplayBufNum; //播放库播放缓冲区最大缓冲帧数，范围1-50，置0时默认为1 
    BYTE byNPQMode;	//NPQ是直连模式，还是过流媒体 0-直连 1-过流媒体
    BYTE byRecvMetaData;  //是否接收metadata数据，设备是否支持该功能通过GET /ISAPI/System/capabilities 中DeviceCap.SysCap.isSupportMetadata是否存在且为true
    BYTE byDataType;    //数据类型，0-码流数据，1-音频数据
    BYTE byRes[213];
}NET_DVR_PREVIEWINFO, *LPNET_DVR_PREVIEWINFO;


typedef struct tagNET_DVR_LINK_ADDR
{
    NET_DVR_IPADDR_UNION      uLocalIP;      //本地IP地址
    WORD                      wLocalPort[10];   //本地端口号
    BYTE                      byLocalPortNum;   //本地端口数
    BYTE                      byRes1[3];
    NET_DVR_IPADDR_UNION      uDevIP;        //设备IP地址
    WORD                      wDevPort[10];     //设备端口号
    BYTE                      byDevPortNum;     //设备端口数
    BYTE                      byRes2[3];
    BYTE                      byRes[80];
}NET_DVR_LINK_ADDR, *LPNET_DVR_LINK_ADDR;

typedef struct tagNET_DVR_PREVIEWINFO_SPECIAL
{
    char sURL[1024];  //取流URL，对应/ISAPI/SDT/Management/Region/ID返回的取流URL，部分设备返回的URL不合法，需要增加用户名密码节点，其中用户名和密码信息来自deviceUser和devicePassword节点
    //示例：rtsp://admin:abcd12345@10.7.37.2:554/Streaming/Channels/101?transportmode=unicast
    DWORD dwLinkMode;// 0：TCP方式,1：UDP方式,2：多播方式,3 - RTP方式，4-RTP/RTSP,5-RSTP/HTTP 
    HWND hPlayWnd;//播放窗口的句柄,为NULL表示不播放图象
    DWORD bBlocked;  //0-非阻塞取流, 1-阻塞取流, 如果阻塞SDK内部connect失败将会有5s的超时才能够返回,不适合于轮询取流操作.
    DWORD dwDisplayBufNum; //播放库播放缓冲区最大缓冲帧数，范围1-50，置0时默认为1 
    BYTE byRes[64];
}NET_DVR_PREVIEWINFO_SPECIAL, *LPNET_DVR_PREVIEWINFO_SPECIAL;

typedef struct tagNET_DVR_TRIGGER_EVENT
{
    DWORD    dwSize;
    DWORD    dwOverallEventTriggerAlarmoutOn;    //全局事件触发报警输出开启，按位或，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常 ,bit5-硬盘故障, bit6-3G/4G信号异常, bit7-（模块链接）第三方主机掉线 ，bit8- WIFI通信故障，bit9-RF信号干扰故障
    DWORD    dwOverallEventTriggerAlarmoutOff;    //全局事件触发报警输出开启，按位或，bit0-交流电掉电，bit1-电池电压低，bit2-电话线掉线，bit3-有线网络异常，bit4-无线网络异常 ,bit5-硬盘故障, bit6-3G/4G信号异常, bit7-（模块链接）第三方主机掉线 ，bit8- WIFI通信故障，bit9-RF信号干扰故障
    DWORD    dwSubSystemEventTriggerAlarmoutOn[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //子系统事件触发报警输出开启,dwSubSystemEvent[0]表示子系统1，dwSubSystemEvent[2]表示子系统2，具体的子系统个数从能力集获取（wSubSystem），每个子系统的事件按位表示，bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆,bit6-报警恢复,bit7-防区防拆,bit8-防区防拆恢复
    DWORD    dwSubSystemEventTriggerAlarmoutOff[MAX_ALARMHOST_SUBSYSTEM/*32*/]; //子系统事件触发报警输出关闭,wSubSystemEvent[0]表示子系统1，dwSubSystemEvent[2]表示子系统2，具体的子系统个数从能力集获取（wSubSystem），每个子系统的事件按位表示，bit0-进入延时，bit1-退出延时，bit2-布防，bit3-撤防，bit4-报警，bit5-消除报警记忆,bit6-报警恢复,bit7-防区防拆,bit8-防区防拆恢复
    BYTE    byRes[128];
}NET_DVR_TRIGGER_EVENT, *LPNET_DVR_TRIGGER_EVENT;

typedef struct  tagNET_DVR_ALARMHOST_FAULT_CFG
{
    DWORD     dwSize;
    DWORD    dwCheckFault;    //是否检测故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，bit9- FPGA故障，bit10- 模拟量故障, bit11-防区扩展板异常，bit12-WIFI通信故障，bit13-RF信号干扰故障，具体支持的故障类型从能力集获取
    DWORD    dwOverallFaultJointLED;        //故障关联全局键盘指示灯输出 bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，具体支持的故障类型从能力集获取
    DWORD    dwOverallFaultJointSound;    //故障关联全局键盘声音输出 bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常，具体支持的故障类型从能力集获取
    DWORD    dwSubSystemFaultJointLED[MAX_ALARMHOST_SUBSYSTEM]; /*故障关联子系统键盘指示灯输出，dwSubSystemFaultJointLED[0]表示子系统1的关联信息。dwSubSystemFaultJointLED[0]的每一位表示一中故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常; dwSubSystemFaultJointLED[1]表示子系统2，以此类推*/
    DWORD    dwSubSystemFaultJointSound[MAX_ALARMHOST_SUBSYSTEM];/*故障关联子系统键盘声音输出（声音在键盘上输出）dwSubSystemFaultJointLED[0]表示子系统1的关联信息。dwSubSystemFaultJointSound [0]的每一位表示一中故障，bit0-交流电断电，bit1-蓄电池欠压，bit2-主机防拆开，bit3-电话线掉线，bit4-485设备异常，bit5-网络故障，bit6-无线异常，bit7-扩展总线异常，bit8-硬盘异常; dwSubSystemFaultJointSound [1]表示子系统2，以此类推*/
    DWORD    dwFaultJointFaultLight;//故障关联故障灯输出
    BYTE    byRes[60];
}NET_DVR_ALARMHOST_FAULT_CFG, *LPNET_DVR_ALARMHOST_FAULT_CFG;

typedef struct tagNET_DVR_LIST_INFO
{
    DWORD    dwSize;
    BYTE    byIndex;            //子系统号，0xff表示所有子系统
    BYTE       byRes[63];      //保留
}NET_DVR_LIST_INFO, *LPNET_DVR_LIST_INFO;





typedef struct tagNET_DVR_CID_ALARM
{
    DWORD    dwSize;
    BYTE    sCIDCode[CID_CODE_LEN/*4*/];    //CID事件号
    BYTE    sCIDDescribe[NAME_LEN/*32*/];    //CID事件名
    NET_DVR_TIME_EX struTriggerTime;            //触发报警的时间点
    NET_DVR_TIME_EX struUploadTime;                //上传报警的时间点
    BYTE    sCenterAccount[ACCOUNTNUM_LEN/*6*/];    //中心帐号
    BYTE    byReportType;                    //见定义NET_DVR_ALARMHOST_REPORT_TYPE
    BYTE    byUserType;                        //用户类型，0-网络用户 1-键盘用户,2-手机用户,3-系统用户
    BYTE    sUserName[NAME_LEN/*32*/];        //网络用户用户名
    WORD    wKeyUserNo;                        //键盘用户号    0xFFFF表示无效
    BYTE    byKeypadNo;                        //键盘号        0xFF表示无效
    BYTE    bySubSysNo;                        //子系统号        0xFF表示无效
    WORD    wDefenceNo;                        //防区号        0xFFFF表示无效
    BYTE    byVideoChanNo;                    //视频通道号   0表示无效，表示设备自带的默认视频通道号
    BYTE    byDiskNo;                        //硬盘号        0xFF表示无效
    WORD    wModuleAddr;                    //模块地址        0xFFFF表示无效
    BYTE    byCenterType;                    //0-无效, 1-中心账号(长度6),2-扩展的中心账号(长度9)
    BYTE    byRelativeChannel;              //外接的视频通道号，0表示无效，字节表示通道号
    BYTE    sCenterAccountV40[ACCOUNTNUM_LEN_32/*32*/];    //中心账号V40,使用此字段时sCenterAccount无效
    BYTE   byDevSerialNo[DEV_SERIAL_LEN];   /*产品序列号*/
    BYTE    byRepeaterNo;    //中继器号，为0无效
    WORD    wRemoteCtrllerUserNo;    //遥控器用户号，为0无效
    DWORD dwIOTChannelNo;    //IOT通道号
    BYTE    standardCIDcode;  //标准CID码
    BYTE    byRes2[11];
}NET_DVR_CID_ALARM, *LPNET_DVR_CID_ALARM;

typedef struct tagNET_DVR_ALARMHOST_MODULE_CFG
{
    DWORD dwSize;
    BYTE    byModuleType;    //1-防区，2-触发器 3-防区触发器      
    BYTE    byZoneType;        //防区类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区，6-单防区触发器，0xff表示该参数无效
    BYTE    byTriggerType;    //触发器类型，1-本地触发器， 2-4路触发器，3-8路触发器，4-单防区触发器，0xff表示该参数无效
    BYTE    byRes1[1];
    char    sModelInfo[MODULE_INFO_LEN];                //模块信息
    char    sDeviceVersionInfo[VERSION_INFO_LEN];                /* 版本信息*/
    BYTE    byRes[188];
} NET_DVR_ALARMHOST_MODULE_CFG, *LPNET_DVR_ALARMHOST_MODULE_CFG;

typedef struct tagNET_DVR_DECCARD_ABILITY_V41 /*高清解码卡能力集*/
{
    BYTE byCardType;      //解码卡类型(0:MD,1:MD+,2:HD)
    BYTE byDecNums;      //解码通道数 
    BYTE byDispNums;      //显示通道数 
    BYTE byDecStartIdx;     //首个解码通道在所有解码通道中的索引 
    BYTE byDispStartIdx;     //首个显示通道在所有显示通道中的索引
    BYTE byRes1[3]; 
    DWORD dwVgaSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwHdmiSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwDviSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwYpbprSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    BYTE byDispFormat[MAX_DECODE_CARD_SUPPORTDISPNUMS];   //支持的输出模式(按HD_DISPLAY_FORMAT中的枚举) 
    BYTE byWindowMode[MAX_DECODE_CARD_SUPPORTDISPNUMS][12]; //支持的窗口模式(比如1,2,4,9,16))
    BYTE byRes2[36];
} NET_DVR_DECCARD_ABILITY_V41,*LPNET_DVR_DECCARD_ABILITY_V41;

typedef struct tagNET_DVR_DECODESVR_ABILITY_V41
{
    DWORD dwSize;      /* 结构体大小 */
    BYTE byCardNums;      /* 解码卡数 */
    BYTE byStartChan;     /* 起始通道号 */
    BYTE byRes1[2];
    NET_DVR_DECCARD_ABILITY_V41 struDecCardAbility[MAX_DECODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_DECODESVR_ABILITY_V41, *LPNET_DVR_DECODESVR_ABILITY_V41;

typedef struct tagNET_DVR_STREAM_RECORD_STATUS
{
    DWORD           dwSize;
    BYTE            byRecord;         //(只读)录像类型, 0：不在录像，1：在录像 2-空闲 
    //3-无连接 4-无输入视频 5-未加载 6-存档中
    //7-回传中 8-用户名或密码错 9-未验证
    //10-存档中和录像中 11-录像回传中和录像中12-token认证失败
    //13-当前条件不满足录像计划条件 14-通道接入异常（见通道状态） 15-硬盘满
    //16-硬盘错 17-无硬盘
    BYTE            byOffLineRecord;  //断网录像功能 0-关闭 1-开启
    BYTE            byRes1[2];        //保留字节
    DWORD            dwRelatedHD;      //关联磁盘
    BYTE            byRes2[8];        //保留字节
}NET_DVR_STREAM_RECORD_STATUS, *LPNET_DVR_STREAM_RECORD_STATUS;

typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO
{
    BYTE        byEnable;                    //是否启用
    BYTE        byProType;                    //协议类型，0-私有协议(default), (需要从设备获取能力)
    BYTE          byZeroChan;                    //是否是零通道,0-不是，1-是
    BYTE        byPriority;                //优先级
    BYTE        sUserName[NAME_LEN];        //用户名
    BYTE        sPassword[PASSWD_LEN];        //密码
    BYTE        byDomain[MAX_DOMAIN_NAME];    //设备域名
    NET_DVR_IPADDR  struIP;                        //IP地址
    WORD        wDVRPort;                     //端口号
    BYTE        byStreamType;               //主码流:0; 子码流：1
    BYTE        byOnline;                    //只读，0-不在线 1-在线
    DWORD        dwChannel;                  //通道号
    BYTE        byTransProtocol;            //协议类型，0-TCP，1-UDP，2-多播
    BYTE        byLocalBackUp;                //本地备份: 0-不启用CVR本地备份，1-启用CVR本地备份--即回放时的流一份在录像卷，一份在存档卷（本地备份）
    WORD        wDirectLastTime;            //导播持续时间
    BYTE        byChanNo[CHAN_NO_LEN];     //通道编号--用于VAG取流
}NET_DVR_DIRECT_CONNECT_CHAN_INFO, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO;

typedef struct tagNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40
{
    BYTE    byEnable;                    //是否启用
    BYTE    byProType;                    //协议类型，0-私有协议(default), 1-松下协议，2-索尼, 3-大华 (需要从设备获取能力)
    BYTE    byZeroChan;                    //是否是零通道,0-不是，1-是
    BYTE    byRes1;                        //保留字段，置0
    BYTE    sUserName[NAME_LEN];        //用户名
    BYTE    sPassword[PASSWD_LEN];        //密码
    BYTE    byAddress[MAX_DOMAIN_NAME];  //前端IP或者域名,需要设备 解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    WORD    wDVRPort;                     //端口号
    BYTE    byStreamType;               //主码流:0; 子码流：1
    BYTE    byOnline;                    //只读，0-不在线 1-在线
    DWORD   dwChannel;                //通道号
    BYTE    byTransProtocol;            //传输协议类型，0-TCP，1-UDP 2-多播
    BYTE    byLocalBackUp;                     //本地备份，0-不启用CVR本地备份，1-启用CVR本地备份--即录像时的流一份在录像卷，一份在存档卷（本地备份）
    BYTE    byRes2[2];                //保留字段，置0
    BYTE    byVAGChanNo[MAX_VAG_CHANNO_LEN];     //协议类型为VAG时，对应的VAG通道编号
    BYTE    byRes[340];
}NET_DVR_DIRECT_CONNECT_CHAN_INFO_V40, *LPNET_DVR_DIRECT_CONNECT_CHAN_INFO_V40;

typedef struct tagNET_DVR_PU_STREAM_URL_CFG
{ 
    BYTE    byEnable;  
    BYTE    byRes[3]; 
    BYTE    byStreamMediaIP[64];//流媒体IP 
    WORD    wStreamMediaPort; //流媒体端口
    BYTE    byTransmitType; //流媒体传输协议 0- TCP  1- UDP
    BYTE    byRes1[33];
    BYTE    byDevIP[64]; //设备IP 
    WORD    wDevPort; //设备端口
    BYTE    byChannel; //通道号
    BYTE    byTransMode; //传输模式 0-主码流 1- 子码流 
    BYTE    byProType;    
    //厂家类型 0-私有 1-大华 2-汉邦 3-郎驰 4-蓝色星际 NET_DVR_GetIPCProtoList接口获取
    //VQD流媒体下只支持 0，1方式；直连支持 0，1，2，3，4
    BYTE    byTransProtocol; //传输协议类型0-TCP,  1-UDP,  2-多播方式,  3-RTP
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];   //设备登陆用户名
    BYTE    sPassWord[PASSWD_LEN]; // 设备登陆密码
    BYTE    byRes2[28];  //预留  
}NET_DVR_PU_STREAM_URL_CFG, *LPNET_DVR_PU_STREAM_URL_CFG;

typedef struct tagNET_DVR_PU_STREAM_URL_CFG_V40
{ 
    BYTE    byEnable;  
    BYTE    byRes[3]; 
    BYTE    byStreamMediaIP[64];//流媒体IP 
    WORD   wStreamMediaPort; //流媒体端口
    BYTE    byTransmitType; //流媒体传输协议 0- TCP  1- UDP
    BYTE    byRes1;
    BYTE    byDevIP[64]; //设备IP 
    WORD   wDevPort; //设备端口
    BYTE    byChannel; //通道号
    BYTE    byTransMode; //传输模式 0-主码流 1- 子码流 
    BYTE    byProType;    
    //厂家类型 0-海康 1-大华 2-汉邦 3-郎驰 4-蓝色星际 NET_DVR_GetIPCProtoList接口获取
    //VQD流媒体下只支持 0，1方式；直连支持 0，1，2，3，4
    BYTE    byTransProtocol; //传输协议类型0-TCP,  1-UDP  2-多播方式
    BYTE    byRes3[2];
    BYTE    sUserName[NAME_LEN];   //设备登陆用户名
    BYTE    sPassWord[PASSWD_LEN]; // 设备登陆密码
    BYTE    byRes2[308];  //预留  
}NET_DVR_PU_STREAM_URL_CFG_V40, *LPNET_DVR_PU_STREAM_URL_CFG_V40;

typedef struct tagNET_DVR_STREAM_URL_V40
{
    BYTE    byEnable; 
    BYTE    byStreamType; //主子码流
    BYTE    byLocalBackUp; //是否本地备份
    BYTE     byRes;
    BYTE    strURL[URL_LEN_V40]; //流媒体URL，可以级联
    DWORD   dwProtocalType;   //IPC协议类型值，可以通过获取IPC协议列表得到
    BYTE    sUserName[NAME_LEN];   //设备登陆用户名
    BYTE    sPassWord[PASSWD_LEN]; // 设备登陆密码
    BYTE    byAddress[MAX_DOMAIN_NAME];  //流来源IP或者域名,需要解析 解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    WORD    wIPPort;  //流来源对应的端口号
    WORD    wChanNo; //流来源设备IP通道号
    BYTE    byVAGChanNo[MAX_VAG_CHANNO_LEN];     //流来源通道编号,用于VAG功能
    BYTE     byRes1[88];   
}NET_DVR_STREAM_URL_V40, *LPNET_DVR_STREAM_URL_V40;



typedef struct tagNET_DVR_STREAM_MODE_TYPE
{
    BYTE                    byGetStreamType;    //取流方式，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流, 3.通过IPServer找到设备，再通过流媒体去设备的流 4-通过流媒体由URL去取流
    BYTE                    byRes[3];            // 保留字节
    NET_DVR_STREAM_TYPE_UNION    uGetStream;            // 不同取流方式结构体
}NET_DVR_STREAM_MODE_TYPE, *LPNET_DVR_STREAM_MODE_TYPE;

typedef struct tagNET_DVR_STREAM_SRC_INFO
{
    DWORD                        dwSize;
    NET_DVR_STREAM_MODE_TYPE    struStreamSrcInfo;
}NET_DVR_STREAM_SRC_INFO,*LPNET_DVR_STREAM_SRC_INFO;

typedef struct tagNET_DVR_STREAM_SRC_INFO_V40
{
    DWORD                    dwSize;
    BYTE                    byGetStreamType;    //取流方式，0-直接从设备取流，1-从流媒体取流、2-通过IPServer获得ip地址后取流, 3.通过IPServer找到设备，再通过流媒体去设备的流 4-通过流媒体由URL去取流 6-通过流媒体到指定监控设备上取流
    BYTE                    byRes1[3];            // 保留字节
    NET_DVR_STREAM_TYPE_V40_UNION    uGetStream;            // 不同取流方式结构体
    BYTE                    byMonitorName[128];/*监控点名称（支持中文，大小写字母，数字，下划线等非特殊字符，编码格式根据登录返回的byCharEncodeType字段判断，
                                                    目前CVR中英文版本不一样，有不同选择，中文CVR要求监控点名称为gbk，英文版本CVR要求监控点名称为iso8859-1，如“A号楼_监控点1”）*/
    BYTE                    byRes[384];            // 保留字节
}NET_DVR_STREAM_SRC_INFO_V40,*LPNET_DVR_STREAM_SRC_INFO_V40;

typedef struct 
{
    DWORD            dwSize;
    NET_DVR_RECORD_V30    struRecordInfo;
}NET_DVR_STREAM_RECORD_INFO, *LPNET_DVR_STREAM_RECORD_INFO;

typedef struct tagNET_DVR_STREAM_TIME_LOCK
{
    DWORD            dwSize;                // 结构体大小
    NET_DVR_TIME    strBeginTime;        // 开始时间
    NET_DVR_TIME    strEndTime;            // 结束时间
    NET_DVR_STREAM_INFO struStreamInfo;        // 流信息
    DWORD            dwRecordType;        // 录像类型:  0xffffffff－全部，－定时录像，-移动侦测，－报警触发，-报警触发或移动侦测，-报警触发和移动侦测，-命令触发，-手动录像，-智能录像(同文件查找)
    DWORD            dwLockDuration;        // 锁定持续时间,单位秒，0xffffffff表示永久锁定
    NET_DVR_TIME_EX        strUnlockTimePoint;    // 加锁时有效，当dwLockDuration不为永久锁定时，锁定持续的时间到此时间点就自动解锁
    BYTE   		 	 byISO8601;      		//是否是8601的时间格式，即时差字段是否有效,0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char       		 cTimeDifferenceH;      //与UTC的时差（小时），-12 ... +14，+表示东区, byISO8601为1时有效
    char             cTimeDifferenceM;      //与UTC的时差（分钟），-30, 30, 45，+表示东区, byISO8601为1时有效
    BYTE                byRes[1];
}NET_DVR_STREAM_TIME_LOCK, *LPNET_DVR_STREAM_TIME_LOCK;

typedef struct tagNET_DVR_VOD_DRAWFRAME_PARA
{
    NET_DVR_TIME_EX struTime;
    /*
    dwDrawType只有设备支持选择性抽帧时，参数才有效果，抽帧方式有：
    0：只传I帧
    1：丢1/2 P帧（只有svc码流支持）
    2：丢3/4P帧 （只有svc码流支持）
    3：传1/2 I帧(只传I帧，且每2个I帧传一个。)
    4：传1/4 I振(只传I帧，且每4个I帧传一个。)
    5：传1/8 I帧(只传I帧，且每8个I帧传一个。)
    */
    DWORD  dwDrawType;
    BYTE   byRes[128];
}NET_DVR_VOD_DRAWFRAME_PARA, *LPNET_DVR_VOD_DRAWFRAME_PARA;

typedef struct tagNET_DVR_VOD_PARA
{
    DWORD                dwSize;
    NET_DVR_STREAM_INFO struIDInfo; 
    NET_DVR_TIME        struBeginTime;
    NET_DVR_TIME        struEndTime;
    HWND                hWnd;
    BYTE                byDrawFrame; //0:不抽帧，1：抽帧
    BYTE                byVolumeType;  //0-普通录像卷  1-存档卷
    BYTE                byVolumeNum;  //卷号，目前指存档卷号
    BYTE                byStreamType;   //码流类型 0-主码流， 1-子码流，2-码流三
    DWORD                   dwFileIndex;      //存档卷上的录像文件索引，搜索存档卷录像时返回的值
    BYTE                byAudioFile;    //音频文件0-否，1-是
    BYTE                byCourseFile;    //课程文件0-否，1-是
    BYTE                byDownload;    //是否下载 0-否，1-是
    BYTE                byOptimalStreamType;    //是否按最优码流类型回放 0-否，1-是（对于双码流设备，某一段时间内的录像文件与指定码流类型不同，则返回实际码流类型的录像）
    BYTE                byUseAsyn;       //0-使用同步IO，1-使用异步IO 
    BYTE                byRes2[19];
}NET_DVR_VOD_PARA, *LPNET_DVR_VOD_PARA;

typedef struct tagNET_DVR_VOD_PARA_V50
{
    DWORD                   dwSize;
    NET_DVR_STREAM_INFO     struIDInfo;
    NET_DVR_TIME_V50        struBeginTime;
    NET_DVR_TIME_V50        struEndTime;
    HWND                    hWnd;
    BYTE                    byDrawFrame; //0:不抽帧，1：抽帧
    BYTE                    byVolumeType;  //0-普通录像卷  1-存档卷
    BYTE                    byVolumeNum;  //卷号，目前指存档卷号
    BYTE                    byStreamType;   //码流类型 0-主码流， 1-子码流，2-码流三
    DWORD                   dwFileIndex;      //存档卷上的录像文件索引，搜索存档卷录像时返回的值
    BYTE                    byAudioFile;    //回放音频文件，0-不回放音频文件，1-仅回放音频文件
    BYTE                    byCourseFile;    //回放课程文件0-否，1-是
    BYTE                    byPlayMode;    //播放方式0-正放，1-倒放
    BYTE                    byLinkMode;    //连接方式0-TCP，1-AdaptiveUDP
    BYTE                    byDownload;    //是否下载 0-否，1-是
    BYTE                    byOptimalStreamType;    //是否按最优码流类型回放 0-否，1-是（对于双码流设备，某一段时间内的录像文件与指定码流类型不同，则返回实际码流类型的录像）
    BYTE                    byDisplayBufNum;  //设置播放缓冲帧数，当为0时，默认为3帧，hWnd不为空时有效
    BYTE 					byNPQMode;	   //NPQ是直连模式，还是过流媒体 0-直连 1-过流媒体
    BYTE                    sUserName[NAME_LEN/*32*/]; //二次认证用户名
    BYTE                    sPassword[PASSWD_LEN/*16*/]; //二次认证密码
    BYTE                    byRemoteFile;    //回放远程文件0-否，1-是
    BYTE                    byUseAsyn;       //0-使用同步IO，1-使用异步IO 
    BYTE                    byRes2[201];
    BYTE                    byHls;          //HLS回放，0-否，1-是
    char*					pSavedFileName;	//下载时，保存的录像文件路径，byDownload为1时有效，长度超过256将会被截断
}NET_DVR_VOD_PARA_V50, *LPNET_DVR_VOD_PARA_V50;

typedef struct tagNET_DVR_MANUAL_RECORD_PARA
{
    NET_DVR_STREAM_INFO struStreamInfo; 
    DWORD            lRecordType;
    BYTE            byRes[32];
}NET_DVR_MANUAL_RECORD_PARA, *LPNET_DVR_MANUAL_RECORD_PARA;

typedef struct tagNET_DVR_STREAM_CABAC
{
    DWORD        dwSize;                  //结构体大小
    BYTE         byCabacEnable;           //码流压缩性能选项值0 不提升 1 提升
    BYTE          byRes1[31];                  //保留
}NET_DVR_STREAM_CABAC, *LPNET_DVR_STREAM_CABAC;

typedef struct tagNET_ITC_IOOUT_PARAM
{
    DWORD    dwSize;
    BYTE     byDefaultStatus;//IO默认状态：0-低电平，1-高电平 
    BYTE     byIOOutStatus;//IO起效时状态：0-低电平，1-高电平，2-脉冲
    BYTE     byMode; //闪光灯工作方式,按位表示，0-表示工作，1-表示不工作，bit0-视频，bit1-卡口，bit2-违章
    BYTE     byIOWorkMode;//IO输出口工作模式：0-闪光灯，1-偏振镜,  2-常亮灯
    DWORD    dwTimeDelay;//IO有效持续时间，单位us
    WORD     wAheadTime;//输出IO提前时间，单位us
    BYTE     byFreqMulti;        //倍频，数值范围[1,15]
    BYTE     byDutyRate;        //占空比，[0,40%]
    BYTE     byDetectBrightness;/*自动检测亮度使能闪光灯0-不检测；1-检测*/
    BYTE     byBrightnessThreld;/*使能闪光灯亮度阈值，范围[0,100],高于阈值闪*/
    BYTE     byFlashLightEnable;    //设置闪光灯时间使能:0-关;1-开
    BYTE     byStartHour;        //开始时间-小时,取值范围0-23
    BYTE     byStartMinute;        //开始时间-分,取值范围0-59
    BYTE     byEndHour;        //结束时间-小时,取值范围0-23
    BYTE     byEndMinute;        //结束时间-分,取值范围0-59
    BYTE     byAutoPlateBrightness;// 车牌亮度自动使能闪光灯 0-不启用 1-启用
    BYTE     byIncrBrightEnable;//是否启用增亮模式（常亮灯模式下）
    BYTE     byIncrBrightPercent;//增量百分比，0~100%（启用增亮模式下生效）
    WORD     wIncrBrightTime;//增亮时间,单位为毫秒（启用增亮模式下生效）
    BYTE     byBrightness;//亮度值；0~100（常亮灯模式下）
    BYTE     byEnvironBright;//环境照度值；0~100（闪光灯模式下生效，该参数只读）环境照度值代表着闪光灯所处环境的亮度值，客户可以拿该值作为参考，去配置相应的亮度阈值。
    WORD     wDelayCaptureTime;//延时抓拍时间1~1000ms（启用增亮模式下生效）
}NET_ITC_IOOUT_PARAM, *LPNET_ITC_IOOUT_PARAM;


typedef struct tagNET_ITC_TRIGGERMODE_ABILITY
{
    DWORD dwSize;
    DWORD dwTriggerType; //触发类型，按位表示，定义ITC_TRIGGERMODE_ABILITY定义，根据输入的能力类型不同，此处返回的触发类型也不同
    BYTE byRes[16]; 
}NET_ITC_TRIGGERMODE_ABILITY, *LPNET_ITC_TRIGGERMODE_ABILITY;

typedef struct tagNET_ITC_INTERVAL_PARAM    
{
    BYTE byIntervalType;    //间隔类型（默认按时间），0-时间起效,1-距离起效
    BYTE byRes1[3];
    WORD wInterval[MAX_INTERVAL_NUM];//连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    BYTE byRes[8];
}NET_ITC_INTERVAL_PARAM, *LPNET_ITC_INTERVAL_PARAM;

typedef struct tagNET_ITC_PLATE_RECOG_PARAM
{
    BYTE byDefaultCHN[MAX_CHJC_NUM]; /*设备运行省份的汉字简写*/
    BYTE byEnable; //是否启用该区域牌识，0-否，1-是
    DWORD dwRecogMode;  
    /*识别的类型，
       bit0-背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ； 
       bit1-大车牌识别或小车牌识别：0-小车牌识别，1-大车牌识别 ；
       bit2-车身颜色识别：0-不采用车身颜色识别，在背向识别或小车牌识别时禁止启用，1-车身颜色识别；
       bit3-农用车识别：0-不采用农用车识别，1-农用车识别； 
       bit4-模糊识别：0-不采用模糊识别，1-模糊识别；
       bit5-帧定位或场定位：0-帧定位，1-场定位；
       bit6-帧识别或场识别：0-帧识别，1-场识别； 
       bit7-晚上或白天：0-白天，1-晚上 
       bit8-摩托车识别：0-不采用摩托车识别，1-摩托车识别;
       bit9-场景模式：0-电警/多帧，1-卡口；
       bit10-微小车牌：0-不启用，1-启用微小车牌识别(像素60～80)
       bit11-安全带检测：0-不启用，1-启用安全带检测
       bit12-民航车牌识别: 0-不启用，1-开启民航车牌识别
       bit13-车牌过渡倾斜处理: 0-不启用，1-开启过渡倾斜处理（PRS）
       bit14-超大车牌识别: 0-不启用，1-开启超大车牌识别（PRS）
       bit15-遮阳板检测：0-不启用，1-启用遮阳板检测
       bit16-黄标车检测：0-不启用，1-启用黄标车检测
       bit17-危险品车辆检测：0-不启用，1-启用危险品车辆检测
       bit18-使馆车牌识别：0-不启用，1-启用使馆车牌识别 
       bit19-车辆子品牌识别：0-不启用，1-启用车辆子品牌识别
       bit20-打电话识别：0-不启用，1-启用
       bit21-车窗悬挂物识别：0-不启用，1-启用
    */
    BYTE byVehicleLogoRecog;//车标识别 0-不启用，1-启用  
   /*
       0-保留，1-澳，2-京，3-渝，4-闽，5-甘，6-粤，7-桂，8-贵，9-琼，10-冀，11-豫，
       12-黑，13-鄂，14-湘，15-吉，16-苏，17-赣，18-辽，19-蒙，20-宁，21-青，22-鲁，
       23-晋，24-陕，25-沪，26-川，27-台，28-津，29-藏，30-港，31-新，32-云，33-浙，
       34-皖，0xff-全部
    */
    BYTE byProvince;//省份索引值
    BYTE byRegion;// 区域索引值 0-保留，1-欧洲，2-俄语区域, 3-欧洲&俄罗斯(EU&CIS),4-中东(Middle East)
    BYTE byCountry;//国家索引，参照枚举COUNTRY_INDEX(不支持“COUNTRY_ALL = 0xff,//ALL 全部”)
    WORD wPlatePixelWidthMin;//车牌像素识别宽度最小值（单位是像素）当前推荐范围[130,500]
    WORD wPlatePixelWidthMax;//车牌像素识别宽度最大值（单位是像素）当前推荐范围[130,500]
    BYTE byRes[24];
}NET_ITC_PLATE_RECOG_PARAM, *LPNET_ITC_PLATE_RECOG_PARAM;

typedef struct tagNET_ITC_POLYGON
{
    DWORD dwPointNum; //有效点 大于等于3，若是3点在一条线上认为是无效区域，线交叉认为是无效区域 
    NET_VCA_POINT  struPos[ITC_MAX_POLYGON_POINT_NUM]; //多边形边界点,最多20个 
}NET_ITC_POLYGON, *LPNET_ITC_POLYGON;

typedef struct tagNET_ITC_PLATE_RECOG_REGION_PARAM    
{
    BYTE byMode; //区域类型，0-矩形，1-多边形
    BYTE byRes1[3];
    union
    {
        NET_VCA_RECT struRect;  //矩形区域
        NET_ITC_POLYGON struPolygon; //多边形区域
    }uRegion;
    BYTE  byRes[16];    //保留
}NET_ITC_PLATE_RECOG_REGION_PARAM, *LPNET_ITC_PLATE_RECOG_REGION_PARAM;

typedef struct tagNET_ITC_SINGLE_IOSPEED_PARAM
{
    BYTE byEnable; //是否启用，0-不启用，1-启用
    BYTE byTrigCoil1; //第一线圈关联IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byCoil1IOStatus;//第一线圈IO输入口状态，0-下降沿（默认），1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    BYTE byTrigCoil2; //第二线圈关联IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byCoil2IOStatus;//第二线圈IO输入口状态，0-下降沿（默认），1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    BYTE byRelatedDriveWay;//关联的车道号
    BYTE byTimeOut;//超时时间（默认10），单位s
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    DWORD dwDistance;//线圈距离（默认1000）,单位：厘米
    BYTE byCapSpeed;//起拍速度（默认30），单位km/h
    BYTE bySpeedLimit;//限速值（默认60），单位km/h
    BYTE bySpeedCapEn; //是否启用超速抓拍，0-否，1-是
    BYTE bySnapTimes1; //线圈1抓拍次数（默认不抓拍），0-不抓拍，非0-连拍次数，最大5次 
    BYTE bySnapTimes2; //线圈2抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5次
    BYTE byBigCarSpeedLimit; //大车车速限制值
    BYTE byBigCarSignSpeed;//标志限速(大车)，单位km/h(3.7Ver)
    BYTE byIntervalType;    //间隔类型（默认按时间），0-时间起效,1-距离起效
    WORD wInterval1[MAX_INTERVAL_NUM];//线圈1连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    WORD wInterval2[MAX_INTERVAL_NUM];//线圈2连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口(可以同时关联多个)，数组0表示IO输出口1，数组1表示IO输出口2，以此类推，0-不关联，1-关联
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byLaneType;   //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    BYTE byCarSignSpeed;//标志限速，单位km/h(3.7Ver)
    BYTE byUseageType; //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //牌识参数(可用牌识区域1个，保留一个)
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;                        //小车限底速值，单位km/h
    BYTE byBigCarLowSpeedLimit;                //大车限底速值，单位km/h
    BYTE byLowSpeedCapEn;                 //是否启用低速抓拍，0-否，1-是
    BYTE byEmergencyCapEn;                //是否启用应急车道抓拍，0-否，1-是
    BYTE byRes[27];
}NET_ITC_SINGLE_IOSPEED_PARAM, *LPNET_ITC_SINGLE_IOSPEED_PARAM;

typedef struct tagNET_ITC_POST_IOSPEED_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_SINGLE_IOSPEED_PARAM struSingleIOSpeed[MAX_IOSPEED_GROUP_NUM]; //单个IO测速组参数
    BYTE  byRes[32];
}NET_ITC_POST_IOSPEED_PARAM, *LPNET_ITC_POST_IOSPEED_PARAM;

typedef struct tagNET_ITC_SINGLEIO_PARAM
{
    BYTE byDefaultStatus;//IO触发默认状态：0-低电平，1-高电平
    BYTE byRelatedDriveWay;//关联的车道号
    BYTE bySnapTimes; //抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    NET_ITC_INTERVAL_PARAM struInterval; //抓拍间隔参数
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口，可以同时关联多个
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byEnable;//单IO使能标志0-不启用，1-启用 (Remark:在能力返回支持 bySupport&0x20，表示是否支持单IO触发界面IO使能配置 时生效)
    BYTE byUseageType; //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    BYTE byEmergencyCapEn;  //是否启用应急车道抓拍，0-否，1-是
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //牌识参数
    BYTE byRes[24];
}NET_ITC_SINGLEIO_PARAM, *LPNET_ITC_SINGLEIO_PARAM;

typedef struct tagNET_ITC_POST_SINGLEIO_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_SINGLEIO_PARAM struSingleIO[MAX_IOIN_NUMEX]; //单个IO触发参数
}NET_ITC_POST_SINGLEIO_PARAM, *LPNET_ITC_POST_SINGLEIO_PARAM;

typedef struct tagNET_ITC_LANE_PARAM
{
    BYTE byEnable; //是否启用该车道，0-不启用，1-启用
    BYTE byRelatedDriveWay;//关联的车道号
    WORD wDistance; //线圈距离，计算速度
    WORD wTrigDelayTime; //触发延迟时间（默认200），单位：毫秒
    BYTE byTrigDelayDistance; //触发延迟距离（默认0），单位：分米
    BYTE bySpeedCapEn; //是否启用超速抓拍，0-否，1-是
    BYTE bySignSpeed;//标志限速，单位km/h
    BYTE bySpeedLimit;//限速值，单位km/h
    BYTE bySnapTimes; //抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
    BYTE byOverlayDriveWay; //OSD叠加的车道号
    NET_ITC_INTERVAL_PARAM struInterval; //抓拍间隔参数
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口，可以同时关联多个
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byCartSignSpeed;//标志限速(大车)，单位km/h
    BYTE byCartSpeedLimit;//限速值（大车），单位km/h
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //车道牌识参数
    BYTE byLaneType;   //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    BYTE byUseageType; //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byLowSpeedLimit;                    //小车限底速值，单位km/h
    BYTE byBigCarLowSpeedLimit;                //大车限底速值，单位km/h
    BYTE byLowSpeedCapEn;                   //是否启用低速抓拍，0-否，1-是
    BYTE byEmergencyCapEn;                 //是否启用应急车道抓拍，0-否，1-是
    BYTE byRes[9];
}NET_ITC_LANE_PARAM, *LPNET_ITC_LANE_PARAM;

typedef struct tagNET_ITC_POST_RS485_PARAM
{
    BYTE byRelatedLaneNum;//关联的车道个数
    BYTE byTriggerSpareMode; //触发备用模式，0-默认，1-卡口虚拟线圈模式,2-卡口混合车道模式
    BYTE byFaultToleranceTime;//容错时间(单位:分钟)，用于检测车检器是否正常的最大时间
    BYTE byRes1; 
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //关联的车道参数
    BYTE  byRes[32];
}NET_ITC_POST_RS485_PARAM, *LPNET_ITC_POST_RS485_PARAM;

typedef struct tagNET_ITC_RADAR_PARAM
{
    BYTE    byRadarType;    //雷达类型，0-无雷达,1-安道雷雷达，2-奥利维亚，3-川速微波4,雷达接IO扩展盒(此参数在卡口虚拟线圈、混行卡口界面中使用，卡口RS485雷达不使用),0xff-其它类型
    BYTE    byLevelAngle;   //与水平线所成角度,默认为25°(0到90度)
    WORD    wRadarSensitivity; //雷达灵敏度 
    WORD    wRadarSpeedValidTime;//雷达速度有效时间(0~2000] ,0表示不支持
    BYTE    byRes1[2];
    float      fLineCorrectParam;//线性矫正参数[0.0~2.0]
    int      iConstCorrectParam;//常量矫正参数[-100~100]
    BYTE    byRes2[8];
}NET_ITC_RADAR_PARAM, *LPNET_ITC_RADAR_PARAM;

typedef struct tagNET_ITC_RS485_ACCESS_INFO_COND  //条件结构
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerModeType;
    BYTE  byAssociateRS485No;//关联的RS485号 1～5 (唯一值)
    //    BYTE  byModeType; //0～预留，1～雷达，2～车检器，3～信号灯检测器
    BYTE  byRes[15];
}NET_ITC_RS485_ACCESS_INFO_COND,*LPNET_ITC_RS485_ACCESS_INFO_COND;

typedef struct tagNET_ITC_RADAR_INFO_PARAM
{
    NET_ITC_RADAR_PARAM  struRadarParam;//24
    BYTE  byAssociateLaneNo;//关联的车道号1～99 (这个值可以在不同RS485口重复)
    BYTE  byRes[103];
}NET_ITC_RADAR_INFO_PARAM, *LPNET_ITC_RADAR_INFO_PARAM;


typedef struct tagNET_ITC_RS485_ACCESS_CFG //144  配置结构
{
    DWORD dwSize;
    BYTE  byModeType;//0～预留，bit1～雷达，bit2～车检器，bit3～信号灯检测器
    BYTE  byRes[3];
    NET_ITC_ACCESS_DEVINFO_PARAM_UNION uITCAccessDevinfoParam; //64
    BYTE  byRes1[12];
}NET_ITC_RS485_ACCESS_CFG,*LPNET_ITC_RS485_ACCESS_CFG;

typedef struct tagNET_ITC_RS485_ACCESS_INFO
{
    DWORD dwSize;
    NET_ITC_RADAR_PARAM  struRadar[MAX_ITC_LANE_NUM];//多车道雷达信息
    //根据能力集开发显示，不支持的默认为0，不显示  （有几个车道支持几个）
    BYTE  byRes[20];
}NET_ITC_RS485_ACCESS_INFO, *LPNET_ITC_RS485_ACCESS_INFO;

typedef struct tagNET_ITC_POST_RS485_RADAR_PARAM
{
    BYTE byRelatedLaneNum;//关联的车道个数
    BYTE byRes1[3];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //关联的车道参数
    NET_ITC_RADAR_PARAM struRadar;  //雷达参数
    BYTE  byRes[32];
}NET_ITC_POST_RS485_RADAR_PARAM, *LPNET_ITC_POST_RS485_RADAR_PARAM;

typedef struct tagNET_ITC_VTLANE_PARAM
{
    BYTE byRelatedDriveWay;//关联的车道号
    BYTE bySpeedCapEn; //是否启用超速抓拍，0-否，1-是
    BYTE bySignSpeed;//标志限速，单位km/h
    BYTE bySpeedLimit;//限速值，单位km/h
    BYTE bySnapTimes; //抓拍次数（默认1），0-不抓拍，非0-连拍次数，最大5
    BYTE byBigCarSignSpeed;///*大车标志限速，单位km/h*/
    BYTE byBigCarSpeedLimit;/*大车限速值，单位km/h*/
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    NET_ITC_INTERVAL_PARAM struInterval; //抓拍间隔参数
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口，可以同时关联多个
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byLowSpeedLimit;/*限低速，单位km/h*/
    BYTE byBigCarLowSpeedLimit; /*大车限低速，单位km/h*/
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //车道牌识参数
    NET_VCA_LINE struLine; //车道线
}NET_ITC_VTLANE_PARAM, *LPNET_ITC_VTLANE_PARAM;

typedef struct tagNET_ITC_VTCOIL_INFO
{
    NET_VCA_RECT struLaneRect;  /*虚拟线圈区域*/
    BYTE byTrigFlag; //触发标志，0-车头触发；1-车尾触发；2-车头/车尾都触发
    BYTE byTrigSensitive;  //触发灵敏度，1-100
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口(可以同时关联多个)，数组0表示IO输出口1，数组1表示IO输出口2，以此类推，0-不关联，1-关联
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byLaneType;   //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    BYTE byEnableRadar; //是否启用雷达测速，0-否，1-是
    NET_ITC_VTLANE_PARAM struLane; //关联的车道参数
    //车道用途类型，详见ITC_LANE_USEAGE_TYPE，使用1和8两种类型(3.7Ver)
    BYTE byUseageType; 
    //车辆行驶方向，详见ITC_LANE_CAR_DRIVE_DIRECT(3.7Ver)
    BYTE byCarDriveDirect;
    BYTE byRes[30];
}NET_ITC_VTCOIL_INFO, *LPNET_ITC_VTCOIL_INFO;

typedef struct tagNET_ITC_POST_VTCOIL_PARAM
{
    BYTE    byRelatedLaneNum;//关联的车道个数
    BYTE    byIsDisplay; //视频中是否显示虚拟线圈，0-不显示，1-显示
    BYTE    byLoopPos; //晚间触发线圈的偏向（默认10）
    BYTE    byPolarLenType; /*偏振镜类型，0：不加偏振镜；1：加施耐德偏振镜。*/
    BYTE    byDayAuxLightMode; /*白天辅助照明模式，0：无辅助照明；1：LED灯照明；2：闪光灯照明*/
    BYTE    byVideoLaneNO; //视频参考亮度的参考车道号
    BYTE    byVideoLowTh; /*视频参考亮度低阈值初始化值（默认40）*/
    BYTE    byVideoHighTh; /*视频参考亮度高阈值初始化值（默认55）*/
    BYTE    byRecordMode; //录像标志：0-不录像，1-录像
    BYTE     bySnapMode;//抓拍模式：0-频闪模式；1-爆闪模式
    /*测速方式：0-不测速，0x1-雷达测速，0x2-视频测速*/
    BYTE    bySpeedDetector;
    BYTE    byRes2;
    WORD    wResolutionX;/* 设备当前分辨率宽*/
    WORD    wResolutionY;/* 设备当前分辨率高*/
    DWORD   dwDayInitExp; /*视频白天曝光时间的初始值2000*/
    DWORD   dwDayMaxExp; /*视频白天曝光时间的最大值20000*/
    DWORD   dwNightExp; /*晚间视频曝光时间的设置值3000*/
    DWORD   dwSnapExp; /*抓拍曝光时间*/
    BYTE    byDayInitGain; /*视频白天增益的初始值200*/
    BYTE    byDayMaxGain; /*视频白天增益的最大值400*/
    BYTE    byNightGain; /*晚间视频增益*/
    BYTE    bySnapGain; /*抓拍增益*/
    DWORD   dwSceneMode; //场景模式， 详见SCENE_MODE
    NET_DVR_GEOGLOCATION struGeogLocation; //地址位置(默认浙江)
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_VTCOIL_INFO struVtCoil[MAX_VL_NUM]; //虚拟线圈参数
    NET_ITC_RADAR_PARAM struRadar;  //雷达参数
    NET_VCA_LINE struLine; //右车道线
    //违规检测类型，按位表示，详见ITC_VIOLATION_DETECT_TYPE，0-不启用，1-启用(3.7Ver)
    DWORD dwVioDetectType;    
    BYTE  byDebugMode; /*调试模式，0-不启用，1-启用*/
    BYTE  byRes[11];
}NET_ITC_POST_VTCOIL_PARAM, *LPNET_ITC_POST_VTCOIL_PARAM;

typedef struct tagNET_ITC_SINGLE_IOTL_PARAM
{
    BYTE byEnable; //是否启用，0-不启用，1-启用
    BYTE byLightIO; //红绿灯IO，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byTrafficLight; //红绿灯有效状态0-高电平红灯，低电平绿灯；1-高电平绿灯，低电平红灯
    BYTE byTrigIO;//触发的IO号，0-IO1,1-IO2,2-IO3,3-IO4,4-IO5,5-IO6
    BYTE byTrigIOStatus;//触发IO口的状态（默认0），0-下降沿，1-上升沿，2-上升沿和下降沿，3-高电平，4-低电平
    BYTE byRelatedDriveWay;//关联的车道号
    BYTE byRecordEnable;//闯红灯周期录像标志，0-不录像，1-录像
    BYTE byRecordType;//闯红灯录像类型，0-预录，1-延时录像
    BYTE byPreRecordTime;//闯红灯录像片段预录时间（默认0），单位：秒
    BYTE byRecordDelayTime;//闯红灯录像片段延时时间（默认0），单位：秒
    BYTE byRecordTimeOut;//闯红灯周期录像超时时间（秒）
    BYTE byRedSnapTimes; //红灯抓拍次数，0-不抓拍，非0-连拍次数，最大5次 
    BYTE byGreenSnapTimes; //绿灯抓拍次数，0-不抓拍，非0-连拍次数，最大5次
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    BYTE byRes1;
    BYTE byIntervalType;    //间隔类型（默认按时间），0-时间起效,1-距离起效
    WORD wRedInterval[MAX_INTERVAL_NUM];//红灯连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    WORD wGreenInterval[MAX_INTERVAL_NUM];//绿灯连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口，可以同时关联多个
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE byRes2[3];
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //牌识区域参数
    BYTE  byRes[32];
}NET_ITC_SINGLE_IOTL_PARAM, *LPNET_ITC_SINGLE_IOTL_PARAM;

typedef struct tagNET_ITC_EPOLICE_IOTL_PARAM
{
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_SINGLE_IOTL_PARAM struSingleIOTL[MAX_IOSPEED_GROUP_NUM]; //单组IO红绿灯参数
    BYTE  byRes[32];
}NET_ITC_EPOLICE_IOTL_PARAM, *LPNET_ITC_EPOLICE_IOTL_PARAM;





typedef struct tagNET_ITC_SERIAL_INFO
{
    BYTE bySerialProtocol; //车检器协议类型，详见ITC_SERIAL_PROTOCOL
    BYTE byIntervalType;    //间隔类型（默认按时间），0-时间起效,1-距离起效
    WORD wInterval;//连拍间隔时间（单位ms）或连拍间隔距离（单位分米），当byIntervalType为0时，表示间隔时间，当byIntervalType为1时，表示距离
    BYTE byNormalPassProtocol; //正常过车抓拍协议类型，详见ITC_NORMAL_PASS_SERIAL_PROTOCOL
    BYTE byInverseProtocol; //逆行抓拍协议类型，详见ITC_INVERSE_SERIAL_PROTOCOL
    BYTE bySpeedProtocol; //超速抓拍协议类型，详见ITC_SPEED_SERIAL_PROTOCOL
    BYTE byRes[9];
}NET_ITC_SERIAL_INFO, *LPNET_ITC_SERIAL_INFO;

typedef struct tagNET_ITC_EPOLICE_LANE_PARAM
{
    BYTE byEnable; //是否启用该车道，0-不启用，1-启用
    BYTE byRelatedDriveWay;//关联的车道号
    WORD wDistance; //线圈距离，单位厘米
    BYTE byRecordEnable;//闯红灯周期录像标志，0-不录像，1-录像
    BYTE byRecordType;//闯红灯录像类型，0-预录，1-延时录像
    BYTE byPreRecordTime;//闯红灯录像片段预录时间（默认0），单位：秒
    BYTE byRecordDelayTime;//闯红灯录像片段延时时间（默认0），单位：秒
    BYTE byRecordTimeOut;//闯红灯周期录像超时时间（秒）
    BYTE bySignSpeed;//标志限速(卡式电警模式有效)，单位km/h
    BYTE bySpeedLimit;//限速值(卡式电警模式有效)，单位km/h
    BYTE byOverlayDriveWay; //OSD叠加的车道号
    NET_ITC_SERIAL_INFO struSerialInfo; //车检器参数
    BYTE byRelatedIOOut[MAX_IOOUT_NUM]; //关联的IO输出口，可以同时关联多个
    BYTE byFlashMode;   //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE bySerialType; //车检器类型，0-私有车检器，1-私有OEM车检器，2-其他车检器
    BYTE byRelatedIOOutEx;//第0位表示IO输出口1，以此类推，0-不关联，1-关联 支持关联到8个(兼容byRelatedIOOut字段)
    BYTE bySnapPicPreRecord; //抓拍图片预录时间点；0-默认值（第二张图片），1-第一张图片，2-第二张图片，3-第三张图片
    NET_ITC_PLATE_RECOG_REGION_PARAM struPlateRecog[MAX_LANEAREA_NUM]; //车道牌识参数
    BYTE byBigCarSignSpeed;    ///*大车标志限速，单位km/h*/
    BYTE byBigCarSpeedLimit;/*大车限速值，单位km/h*/    
    BYTE byRedTrafficLightChan;//红灯通道号：1～16（红绿灯检测器）
    BYTE byYellowTrafficLightChan;//黄灯通道号：1～16（红绿灯检测器）
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byRes3[11];
}NET_ITC_EPOLICE_LANE_PARAM, *LPNET_ITC_EPOLICE_LANE_PARAM;

typedef struct tagNET_ITC_EPOLICE_RS485_PARAM
{
    BYTE byRelatedLaneNum;//关联的车道个数
    BYTE byTrafficLightSignalSrc;//交通灯信号来源 0～车检器 1～红绿灯检测器
    BYTE byRes1[2];
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_EPOLICE_LANE_PARAM struLane[MAX_ITC_LANE_NUM]; //关联的车道参数
    BYTE  byRes[32];
}NET_ITC_EPOLICE_RS485_PARAM, *LPNET_ITC_EPOLICE_RS485_PARAM;

typedef struct tagNET_ITC_LANE_LOGIC_PARAM
{
    BYTE byUseageType;     //车道用途类型，详见ITC_LANE_USEAGE_TYPE
    BYTE byDirectionType;  //车道方向类型，详见ITC_LANE_DIRECTION_TYPE
    BYTE byCarDriveDirect; //车辆行驶方向，详见ITC_LANE_CAR_DRIVE_DIRECT 
    BYTE byRes[33];        //保留
}NET_ITC_LANE_LOGIC_PARAM, *LPNET_ITC_LANE_LOGIC_PARAM;

typedef struct tagNET_ITC_LINE
{
    NET_VCA_LINE struLine; //线参数
    BYTE byLineType; //线类型，详见ITC_LINE_TYPE
    BYTE byRes[7];
}NET_ITC_LINE, *LPNET_ITC_LINE;

typedef struct tagNET_ITC_SNAPMODE_PARAM
{
    BYTE     byVehicleCapMode;//机动车抓拍模式，0-频闪模式；1-爆闪模式
    BYTE     byNoVehicleCapMode;//非机动车抓拍模式，0-频闪模式；1-爆闪模式
    BYTE     byPasserCapMode;//行人抓拍模式，0-频闪模式；1-爆闪模式
    BYTE     byRes[29];
}NET_ITC_SNAPMODE_PARAM, *LPNET_ITC_SNAPMODE_PARAM;

typedef struct tagNET_ITC_HVT_EC_PARAM
{
    DWORD         dwCapShutter;            //抓拍快门0~65535
    WORD         wCapGain;            //抓拍增益0～100
    BYTE          byRes[2];
    DWORD         dwDayTimeVideoShutter;    //白天曝光时间最大值
    WORD         wDayTimeVideoGain;        //白天增益最大值
    WORD         wNightVideoGain;            //晚上增益最大值
    DWORD         wNightVideoShutter;        //晚上曝光时间最大值
    BYTE          byRes1[108];
}NET_ITC_HVT_EC_PARAM, *LPNET_ITC_HVT_EC_PARAM;

typedef struct tagNET_ITC_LANE_HVT_PARAM
{
    BYTE byLaneNO; //关联的车道号 1~255（用于叠加和上传）
    BYTE bySignSpeed;    //标志限速，单位km/h 0～255  70
    BYTE bySpeedLimit;    //限速值，单位km/h 0～255    80 实际起效
    BYTE byBigCarSignSpeed;///*大车标志限速，单位km/h*/
    BYTE byBigCarSpeedLimit;/*大车限速值，单位km/h*/
    BYTE bySpeedCapEn; //是否启用超速抓拍，0-否，1-是
    BYTE byCaptureCount;//抓拍张数1～5(正常)
    BYTE byRelatedIOOut;    /*关联的IO输出口(可以同时关联多个)，按位表示IO输出口，第0位表示IO输出口1，以此类推，0-不关联，1-关联*/
    BYTE byFlashMode;        /*闪光灯闪烁模式，0-同时闪，1-轮流闪*/
    BYTE byEnableRadar; //是否启用雷达测速，0-否，1-是
    BYTE byChangeLaneEnable;   //违章变道抓拍使能，0-关闭，1-开启
    BYTE byChangeLaneCapNo;    //违章变道抓拍张数2-3
    DWORD dwCapTarget;    //抓拍类型 bit0 表示机动车 bit1 表示非机动车 bit2 表示行人 0～表示不选择 1～表示选择
    NET_ITC_INTERVAL_PARAM struInterval; //抓拍间隔参数
    BYTE byRes3[24];
    NET_ITC_LANE_LOGIC_PARAM struLane; //车道属性，用byUseageType和byCarDriveDirect
    NET_ITC_LINE struLeftLaneLine;          //左车道线，线类型为虚线、实线、单黄线和双黄线
    NET_ITC_LINE struRightLaneLine;          //右车道线，线类型为虚线、实线、单黄线和双黄线
    NET_ITC_POLYGON struPlateRecog;         //牌识区域参数
    NET_ITC_POLYGON struTraceArea;          //视频触发焦点区域
    NET_VCA_LINE  struForwardTrigLine;      //正向触发线：一条线段，关心端点位置，目前只支持水平配置，接口按线段的两个端点保存。（一般配置为正向车辆的最佳触发位置）     
    NET_VCA_LINE  struBackwardTrigLine;     //背向触发线：一条线段，关心端点位置，目前只支持水平配置，接口按线段的两个端点保存（一般配置为背向车辆的最佳触发位置）
    NET_VCA_LINE  struLeftTrigLine;          //左边触发线：一条线段，关心端点位置，目前只支持垂直配置，接口按线段的两个端点保存（一般配置为从左边进入车辆的最佳触发位置）
    NET_VCA_LINE  struRightTrigLine;          //右边触发线：一条线段，关心端点位置，目前只支持垂直配置，接口按线段的两个端点保存（一般配置为从右边进入车辆的最佳触发位置）
    BYTE byRes4[60];
}NET_ITC_LANE_HVT_PARAM, *LPNET_ITC_LANE_HVT_PARAM;

typedef struct tagNET_ITC_POST_HVT_PARAM
{
    BYTE byLaneNum;//识别的车道个数，1-6 
    BYTE bySceneMode;//0-未知1-城区道路；2-小区出入口
    BYTE byRoadExpBright;//路面期望亮度（视频曝光参数调整的依据之一。在无机动车时，依据此亮度期望值，调整视频曝光参数）
    BYTE byPlateExpBright;//车牌期望亮度（视频曝光参数调整的依据之一。在有机动车通过并识别到车牌时，依据此亮度期望值，对视频曝光参数调整）
    NET_ITC_POLYGON struDetectArea;                    //视频检测区域  
    NET_ITC_SNAPMODE_PARAM  struCapMode;//抓拍模式  
    NET_ITC_HVT_EC_PARAM struEcParam;    //曝光控制参数  
    NET_ITC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //单车道属性
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;    //牌识参数
    NET_DVR_GEOGLOCATION struGeogLocation;    //地址位置（默认浙江）
    BYTE byRes[324];
}NET_ITC_POST_HVT_PARAM, *LPNET_ITC_POST_HVT_PARAM;

typedef struct tagNET_ITC_LANE_MPR_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO号[1, byIoInNum+1] 最小从1开始，最大值根据接口能力返回NET_DVR_SNAP_ABILITY的字段byIoInNum
            BYTE  byTriggerType;//0-下降沿，1-上升沿
            BYTE  byRes1[2];
        }struIO;//IO模式下生效
        struct
        {
            BYTE  byRelateChan;//关联车检器通道号[1,16]
            BYTE  byRes2[3];    
        }struRS485;
    }uTssParamInfo;
    BYTE byCarDriveDirect; //车辆行驶方向 ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[58];
    NET_ITC_LINE struLaneLine;//车道线
    NET_ITC_POLYGON struPlateRecog;//牌识区域
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPEtypedef struct tagNET_ITS_PICTURE_INFO
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byRes1[255];
}NET_ITC_LANE_MPR_PARAM,*LPNET_ITC_LANE_MPR_PARAM;

typedef struct tagNET_ITC_POST_MPR_PARAM
{
    BYTE byEnable;    
    BYTE byLaneNum;
    BYTE bySourceType;//0-MPR触发（视频触发）,1-关联IO触发（地感线圈）,2-关联RS485的触发信号
    BYTE byPicUploadType;//图片上传类型，0~全部上传，1-正向上传，2-背向上传
    BYTE byRoadType;//模式选择 0-出入口，1-城市道路，2-自定义，3-报警输入，4-卡口, 5-治安监控(该模式下可以检测车辆比较混乱且没有车道线的场景)
    BYTE byRes2;
    WORD wCustomDelayTime;//自定义抓拍延时时间（在byRoadType为 "自定义"的时候生效），范围在[0,15000]ms
    BYTE byRes[56];
    NET_ITC_LINE struLaneBoundaryLine;//车道边界线（最左边车道的左边界线）
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//牌识参数  40
    NET_ITC_LANE_MPR_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    char szSceneName[NAME_LEN/*32*/]; //场景名称
    NET_VCA_LINE struSnapLine;//抓拍线，在相机的架设方式为侧装，配置这个参数生效（即4.5中NET_DVR_CAMERA_SETUPCFG结构体中byErectMethod字段为1时 ）
    BYTE byRes1[392];
}NET_ITC_POST_MPR_PARAM,*LPNET_ITC_POST_MPR_PARAM;

typedef struct tagNET_DVR_VIA_LANE_PARAM
{
    BYTE byLaneNO;  //关联车道号
    BYTE byRes[63]; //保留 
    NET_ITC_LANE_LOGIC_PARAM  struLogicParam; //车道属性参数
    NET_ITC_LINE  struLaneLine;//车道线  
    NET_ITC_POLYGON  struPlateRecog;//牌识区域  
    BYTE byRes1[300]; //保留 
} NET_DVR_VIA_LANE_PARAM,*LPNET_DVR_VIA_LANE_PARAM;

typedef struct tagNET_DVR_VIA_VTCOIL_PARAM
{
    BYTE byEnable;    //使能 0-不开启 1-开启
    BYTE byLaneNum; //车道数
    BYTE byRes[62]; //保留     
    NET_ITC_LINE  struLaneBoundaryLine;//车道边界线（最左边车道的左边界线） 
    NET_DVR_VIA_LANE_PARAM  struLaneParam[MAX_ITC_LANE_NUM/*6*/];
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;//牌识参数      
    BYTE byRes1[624];//保留
}NET_DVR_VIA_VTCOIL_PARAM,*LPNET_DVR_VIA_VTCOIL_PARAM;

typedef struct tagNET_DVR_TRIGGER_COND
{
    DWORD  dwSize;       //结构体大小
    DWORD  dwChannel;    //通道号
    DWORD  dwTriggerMode;//触发方式，参考 ITC_TRIGGERMODE_TYPE
    BYTE   byDetSceneID;//检测场景号[1,4], IPC默认是0
    BYTE   byRes[63];    //保留留
}NET_DVR_TRIGGER_COND,*LPNET_DVR_TRIGGER_COND;

typedef struct tagNET_ITC_LANE_IMT_PARAM
{
    BYTE byLaneNO;//叠加车道号
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byRes[146];
    NET_ITC_LINE struLaneLine;//车道线
    BYTE byRes1[256];
}NET_ITC_LANE_IMT_PARAM,*LPNET_ITC_LANE_IMT_PARAM;

typedef struct tagNET_ITC_POST_IMT_PARAM
{
    BYTE byEnable;    
    BYTE byLaneNum;
    BYTE bySnapMode; //抓拍类型；0~机动车，1~机非人
    BYTE byRes[61];
    NET_ITC_PLATE_RECOG_PARAM  struPlateRecog;//牌识参数 
    NET_ITC_LINE struLaneBoundaryLine;//车道边界线（最右边车道的边界线）
    NET_ITC_LANE_IMT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    BYTE byRes1[1584];
}NET_ITC_POST_IMT_PARAM,*LPNET_ITC_POST_IMT_PARAM;

typedef struct tagNET_ITC_LANE_PRS_PARAM
{
    BYTE byLaneNO;
    union
    {
        BYTE  uLen[4];
        struct
        {
            BYTE  byIONo;//IO号[1,4]
            BYTE  byTriggerType;//0-下降沿，1-上升沿
            BYTE  byRes1[2];
        }struIO;//IO模式下生效
        struct
        {
            BYTE  byRelateChan;//关联车检器通道号[1,16]
            BYTE  byRes2[3];    
        }struRS485;
    }uTssParamInfo;
    BYTE byRes[59];
    NET_ITC_LINE struLaneLine;//车道线
    NET_ITC_POLYGON struPlateRecog;//牌识区域
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byRes2[3];
    NET_ITC_LINE struTrigLine;//触发线
    BYTE byRes1[228];
}NET_ITC_LANE_PRS_PARAM,*LPNET_ITC_LANE_PRS_PARAM;

typedef struct tagNET_ITC_POST_PRS_PARAM
{
    BYTE byEnable;    
    BYTE byLaneNum;
    BYTE bySourceType;//0-视频检测,1-关联IO触发（地感线圈）,2-关联RS485的触发信号
    BYTE bySnapMode;//0-全景图，1-全景图+特写
    BYTE byCapMode;//bySourceType为0视频检测时使用，0-频闪模式；1-爆闪模式
    BYTE byNoPlatCarCap;//是否启用无车牌抓拍 0-不启用 1-启用
    BYTE bySceneMode;//场景模式:0-普通出入口场景、1-收费站模式场景(车辆停留时间较长)、2-地下停车场出入口场景(白天黑夜均较暗)
    BYTE byRes[57];
    NET_ITC_LINE struLaneBoundaryLine;//车道边界线（最左边车道的左边界线）
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//牌识参数  40
    NET_ITC_LANE_PRS_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    BYTE byRes1[440];
}NET_ITC_POST_PRS_PARAM,*LPNET_ITC_POST_PRS_PARAM;

typedef struct tagNET_IPC_LANE_HVT_PARAM
{
    BYTE byLaneNO;
    BYTE byCarDriveDirect; //车辆行驶方向 ITC_LANE_CAR_DRIVE_DIRECT
    BYTE byRes[62];
    NET_ITC_LINE struLaneLine;//车道线
    NET_ITC_POLYGON struPlateRecog;//牌识区域
    BYTE byRes1[256];
} NET_IPC_LANE_HVT_PARAM,*LPNET_IPC_LANE_HVT_PARAM;

typedef struct _NET_ITC_PARKING_DETECTION_
{
    BYTE        byEnable; //是否启用，0-不启用，1-启用
    BYTE        byRes; //保留字节
    WORD       wDuration;//检测时间间隔，单位：s
    WORD       wAlarmIntervalTime;//上传时间间隔，单位：s
    BYTE        byRes1[58]; //保留字节
}NET_ITC_PARKING_DETECTION, *LPNET_ITC_PARKING_DETECTION;

typedef struct tagNET_IPC_POST_HVT_PARAM
{
    BYTE  byEnable;    
    BYTE  byLaneNum;
    BYTE byEnhancedMode;    //增强模式，0-不启用，1-启用    
    BYTE byPicRecognition;  //车辆报警图片二次识别，0-不启用，1-启用
    BYTE  byRes[60];
    NET_ITC_LINE struLaneBoundaryLine;//车道边界线（最左边车道的左边界线）
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;//牌识参数  40
    NET_IPC_LANE_HVT_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    
    char    szSceneName[NAME_LEN/*32*/]; //场景名称
    NET_VCA_LINE struSnapLine;//抓拍线，抓在相机的架设方式为侧装，配置这个参数生效（即4.5中NET_DVR_CAMERA_SETUPCFG结构体中byErectMethod字段为1时 ）
    NET_ITC_PARKING_DETECTION struParkingDetection;    //停车检测参数
    BYTE byRes1[328];
} NET_IPC_POST_HVT_PARAM,*LPNET_IPC_POST_HVT_PARAM;

typedef struct tagNET_ITC_LANE_HVT_PARAM_V50
{
    BYTE  byLaneNO;        //关联的车道号1～255(用于叠加和上传)
    BYTE  byFlashMode;    //闪光灯闪烁模式，0-同时闪，1-轮流闪
    BYTE  bySignSpeed;    //小车标志限高速，单位km/h
    BYTE  bySpeedLimit;    //小车限高速值，单位km/h
    BYTE  bySignLowSpeed;    //小车标志限底速，单位km/h
    BYTE  byLowSpeedLimit;    //小车限底速值，单位km/h
    BYTE  byBigCarSignSpeed;    //大车标志限高速，单位km/h（新交规）
    BYTE  byBigCarSpeedLimit;    //大车限高速值，单位km/h（新交规）
    BYTE  byBigCarSignLowSpeed;    //大车标志限底速，单位km/h
    BYTE  byBigCarLowSpeedLimit;    //大车限底速值，单位km/h
    BYTE  bySnapTimes;    //卡口抓拍张数，1~3
    BYTE  byDriveLineSnapTime;// 压线抓拍张数 1~3
    BYTE  byHighSpeedSnapTime;// 超高速抓拍张数1~3
    BYTE  byLowSpeedSnapTime;// 超低速抓拍张数1~3
    BYTE  byBanSnapTime;// 违反禁令抓拍张数  1~3
    BYTE  byReverseSnapTime;//逆行抓拍张数  1~3
    BYTE  byRelatedDriveWay;                //关联车道号，用于匹配车检器
    BYTE  byLaneType;   //车道类型，0-未配置、1-高速公路、2-城市快速路、0xff-其他道路
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号byRelatedDriveWay对应，确保车道唯一性。
    BYTE  byRelaLaneDirectionType;
    BYTE  byRes1[27];
    BYTE  byChangeLaneEnable;   //违章变道抓拍使能，0-关闭，1-开启
    BYTE  byChangeLaneCapNo;    //违章变道抓拍张数2-3
    //目前仅使用第一个车道的，以后可能会扩展为多车道分别配置
    //类型, 按位表示,0-不启用,1-启用参考 ITC_VIOLATION_DETECT_TYPE
    DWORD  dwVioDetectType;
    DWORD  dwRelatedIOOut;  //关联的IO输出口(可以同时关联多个)，按位表示IO输出口，第0位表示IO输出口1，以此类推，0-不关联，1-关联
    NET_ITC_LINE struTrigLine; //触发线，目前仅使用第一个车道的，以后可能会扩展为多车道分别配置
    NET_ITC_LINE struLineLeft;                //左车道线
    NET_ITC_POLYGON struPlateRecog;       //牌识区域
    NET_ITC_LANE_LOGIC_PARAM struLane;   //车道属性，用byUseageType和byCarDriveDirect
    NET_ITC_INTERVAL_PARAM struInterval;//抓拍间隔参数（20byte）
    BYTE byRes2[280];
}NET_ITC_LANE_HVT_PARAM_V50, *LPNET_ITC_LANE_HVT_PARAM_V50;

typedef struct tagNET_ITC_POST_HVT_PARAM_V50
{
    BYTE byLaneNum;    //识别的车道个数，1-6
    BYTE byCapType;        //抓拍类型，0-机、非、人（默认），1-机动车
    BYTE byCapMode;    //抓拍方式，0-视频抽帧，1-打断抓拍，2-混合模式， 
    BYTE bySecneMode;    //场景模式，0-城区道路（默认），1-小区出入口，2-高速公路    
    BYTE bySpeedMode;  //测速模式，0-无测速，1-雷达测速，2-视频测速
    BYTE byLineRuleEffect; //触发规则线有效性,每一位代表一条触发线,0-无效;1-有效。bit0-左触发线;bit1-右触发线;bit2-视频检测区域
    BYTE byRes1[78];
    NET_ITC_LINE struLeftTrigLine;    //左触发线(一条垂直线)
    NET_ITC_LINE struRigtTrigLine;    //右触发线(一条垂直线)
    NET_ITC_LINE struLaneBoundaryLine;        //车道边界线（最右边车道的右车道线）
    NET_ITC_POLYGON struDetectArea;    //视频检测区域
    NET_DVR_GEOGLOCATION struGeogLocation; //地理位置（默认浙江省）计算时区
    NET_ITC_LANE_HVT_PARAM_V50 struLaneParam[MAX_ITC_LANE_NUM/*6*/]; //单车道属性
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog;    //牌识参数
    BYTE byRes2[260];
} NET_ITC_POST_HVT_PARAM_V50, *LPNET_ITC_POST_HVT_PARAM_V50;

typedef struct tagNET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM
{
    BYTE byRelatedDriveWay;//关联的车道号
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    BYTE byPedestriansNum;//行人数量阈值：范围1-100，默认值1
    BYTE byVehicleSpeed;//车辆速度阈值：范围0-100，默认值0
    DWORD dwVehicleInterval; //跟车检测阈值：范围0-65536，默认值0
    BYTE byPedesDetRule; //行人检测规则；代表行人检测区域中行人行驶方向； 0~向左， 1~向右。
    BYTE byRes[3];
    NET_ITC_LINE struLaneLine;//车道线
    NET_ITC_LINE struStopLine;//停止线
    NET_ITC_POLYGON struPlateRecog;       //牌识区域 
    BYTE byRes1[280];
} NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM,

typedef struct tagNET_ITC_NOCOMITY_PEDESTRIAN_PARAM
{
    BYTE byEnable;    //使能
    BYTE byLaneNum;// 关联车道总数：范围1-3，默认值3
    BYTE byRes[74];
    NET_ITC_LINE struLaneBoundaryLine;//车道右边界线
    NET_ITC_LINE struTriggerLine;//不礼让行人触发线
    NET_ITC_POLYGON struPedesDetRecog;//行人检测区域
    NET_ITC_LANE_NOCOMITY_PEDESTRIAN_PARAM struLaneParam[MAX_ITC_LANE_NUM/*6*/];    //车道参数
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    BYTE byRes1[400];
}NET_ITC_NOCOMITY_PEDESTRIAN_PARAM,

typedef struct tagNET_ITC_SINGLE_IO_LIGHT_PARAM
{
    BYTE byLightType; //交通灯导向类型,0-左转灯,1-直行灯,2-右转灯
    BYTE byRelatedIO; //关联的IO口号
    BYTE byRedLightState; //红灯电平状态，0-高电平红灯，1-低电平红灯
    BYTE byRes[17];
}NET_ITC_SINGLE_IO_LIGHT_PARAM, *LPNET_ITC_SINGLE_IO_LIGHT_PARAM;

typedef struct tagNET_ITC_IO_LIGHT_PARAM
{
    NET_ITC_SINGLE_IO_LIGHT_PARAM struIOLight[MAX_LIGHT_NUM]; //单个IO接入信号灯参数
    BYTE byRes[8];
}NET_ITC_IO_LIGHT_PARAM, *LPNET_ITC_IO_LIGHT_PARAM;

typedef struct tagNET_ITC_SINGLE_RS485_LIGHT_PARAM
{
    BYTE byLightType; //交通灯导向类型，0-左转灯，1-直行灯，2-右转灯
    BYTE byRelatedLightChan; //关联的红绿灯检测器通道号
    BYTE byInputLight;    //接入的信号灯类型，0-接红灯，1-接绿灯
    BYTE byRelatedYLightChan; //关联的黄灯检测器通道号
    BYTE byRes[16];
}NET_ITC_SINGLE_RS485_LIGHT_PARAM, *LPNET_ITC_SINGLE_RS485_LIGHT_PARAM;

typedef struct tagNET_ITC_RS485_LIGHT_PARAM
{
    NET_ITC_SINGLE_RS485_LIGHT_PARAM struRS485Light[MAX_LIGHT_NUM]; //单个485接入信号灯参数
    BYTE byRes[8];
}NET_ITC_RS485_LIGHT_PARAM, *LPNET_ITC_RS485_LIGHT_PARAM;

typedef struct tagNET_POS_PARAM
{
    WORD wLeft;
    WORD wTop;
    WORD wRight;
    WORD wBottom;
}NET_POS_PARAM, *LPNET_POS_PARAM;

typedef struct tagNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM
{
    BYTE byLightNum; //交通灯个数
    BYTE byStraightLight; //是否有直行标志灯，0-否 ，1-是
    BYTE byLeftLight; //是否有左转标志灯，0-否，1-是
    BYTE byRightLight; //是否有右转标志灯，0-否，1-是
    BYTE byRedLight;//是否有红灯，0-否，1-是
    BYTE byGreenLight; //是否有绿灯，0-否，1-是
    BYTE byYellowLight; //是否有黄灯，0-否，1-是
    BYTE byYellowLightTime;//取值范围（0～10s）（ITC3.7Ver）
    NET_POS_PARAM struLightRect; //交通灯区域
    BYTE byRes[24];
}NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM;

typedef struct tagNET_ITC_VIDEO_DETECT_LIGHT_PARAM
{
    NET_ITC_SINGLE_VIDEO_DETECT_LIGHT_PARAM struTrafficLight[MAX_VIDEO_DETECT_LIGHT_NUM]; //单个视频检测信号灯参数
    BYTE byRes[8];
}NET_ITC_VIDEO_DETECT_LIGHT_PARAM, *LPNET_ITC_VIDEO_DETECT_LIGHT_PARAM;


typedef struct tagNET_ITC_TRAFFIC_LIGHT_PARAM
{
    BYTE bySource; //交通信号灯接入源，0-IO接入，1-RS485接入
    BYTE byRes1[3];
    NET_ITC_LIGHT_ACCESSPARAM_UNION struLightAccess;//信号灯接入参数
    BYTE byRes[32];
}NET_ITC_TRAFFIC_LIGHT_PARAM, *LPNET_ITC_TRAFFIC_LIGHT_PARAM;

typedef struct tagNET_ITC_VIOLATION_DETECT_LINE
{
    NET_ITC_LINE  struLaneLine; //车道线参数
    NET_ITC_LINE  struStopLine; //停止线参数
    NET_ITC_LINE  struRedLightLine; //闯红灯触发线参数
    NET_ITC_LINE  struCancelLine; //直行触发位置取消线
    NET_ITC_LINE struWaitLine; //待行区停止线参数
    NET_ITC_LINE struRes[8];
}NET_ITC_VIOLATION_DETECT_LINE, *LPNET_ITC_VIOLATION_DETECT_LINE;

typedef struct tagNET_ITC_REDLIGHT_PEDESTRIAN_PARAM
{
    BYTE byEnable;    //使能
    BYTE bySnapNumTimes; //抓拍张数：1-3，默认3张
    BYTE byPedesDir; //行人方向：0~正向，1~背向，2~双向
    BYTE byDelayTime; //延时时间1-5s
    BYTE byStackTargetEnble;//叠加目标框（即抓拍第一张图片上框住闯红灯的行人），0~不叠加，1~叠加
    BYTE byCalibRecogCtrl;//标定区域控制；0~移除标定区域，1~添加标定区域
    BYTE byRes1[2];
    NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight; //交通信号灯参数
    NET_ITC_LINE struStopLine;//停止线
    NET_ITC_POLYGON struCalibRecog[MAX_CALIB_RECOG_NUM/*2*/];//标定区域
    BYTE byRes[440];
}NET_ITC_REDLIGHT_PEDESTRIAN_PARAM,

typedef struct tagNET_ITC_POST_MOBILE_PARAM
{
    BYTE  byEnable;    
    BYTE  bySceneMode;//场景模式 0-高速公路 1-城市道路
    /*抓拍类型
    bit0-卡口,bit1-大车占道,bit2-压硬路肩
    */
    WORD  wExpressWayCapType;//高速公路
    /*抓拍类型
    bit0-卡口,bit1-机占非,bit2-占用专用车道
    */
    WORD  wUrbanRoadCapType;//城市道路
    BYTE  byCapNum;//抓拍张数 [2,3]
    BYTE  byRecordEnable;//违章录像使能 0-关闭，1-开启
    DWORD dwPreRecordTime;//录像预录时间(s)
    DWORD dwOverRecordTime;//录像超时时间(s)
    NET_ITC_LANE_LOGIC_PARAM struLane;   //车道属性
    NET_ITC_POLYGON struPolygon[MAX_MOBILE_POLYGON_NUM/*3*/]; //牌识区域参数
    NET_ITC_VIOLATION_DETECT_LINE struLine[MAX_MOBILE_DETECTLINE_NUM/*3*/]; //违规检测线
    NET_ITC_LINE struLaneBoundaryLine;        //车道边界线（最右边车道的右车道线）
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_INTERVAL_PARAM struInterval;//抓拍间隔参数（20byte）
    BYTE  byRes[256];
}NET_ITC_POST_MOBILE_PARAM,*LPNET_ITC_POST_MOBILE_PARAM;


typedef struct tagNET_ITC_SINGLE_TRIGGERCFG
{
    BYTE  byEnable;    //是否启用该触发模式，0-否，1-是
    BYTE  byRes1[3];
    DWORD dwTriggerType; //触发类型，详见ITC_TRIGGERMODE_TYPE
    NET_ITC_TRIGGER_PARAM_UNION uTriggerParam; //触发参数
    BYTE  byRes[64];
}NET_ITC_SINGLE_TRIGGERCFG, *LPNET_ITC_SINGLE_TRIGGERCFG;

typedef struct tagNET_ITC_TRIGGERCFG
{
    DWORD   dwSize;            //结构长度
    NET_ITC_SINGLE_TRIGGERCFG  struTriggerParam;  //单个触发参数
    BYTE    byRes[32];
}NET_ITC_TRIGGERCFG, *LPNET_ITC_TRIGGERCFG;


typedef struct tagNET_ITC_VIOLATION_DETECT_PARAM
{
    DWORD dwVioDetectType; //违规检测类型, 按位表示, 详见ITC_VIOLATION_DETECT_TYPE ,0-不启用,1-启用
    BYTE byDriveLineSnapTimes; //压车道线抓拍张数,2-3
    BYTE byReverseSnapTimes; //逆行抓拍,2-3
    WORD wStayTime; //机占非停留时间（该时间后抓拍），单位s
    BYTE byNonDriveSnapTimes;//机占非抓拍张数2-3
    BYTE byChangeLaneTimes;//违法变道抓拍张数 2-3
    BYTE bybanTimes;//违法禁令抓拍张数2-3
    BYTE byDriveLineSnapSen;// 压线灵敏度(0~100)(3.7Ver)
    WORD wSnapPosFixPixel; //第2,3张抓拍位置最小偏移(违反信号灯时起效)（单位：像素） 命名需改进
    BYTE bySpeedTimes;//违法超速抓拍张数2-3(3.8Ver)
    BYTE byTurnAroundEnable;//违章掉头使能 0~关闭 1~开启
    BYTE byThirdPlateRecogTime;//第三张牌识时间 0~180s
    BYTE byPostSnapTimes;//卡口抓拍张数,1-2张
    BYTE byRes1[18];
    WORD wStopLineDis;  //电警第2张违规图片与停止线的最短距离，[0,300]单位(像素)
    BYTE byRes[14];
}NET_ITC_VIOLATION_DETECT_PARAM, *LPNET_ITC_VIOLATION_DETECT_PARAM;






typedef struct tagNET_ITC_LANE_VIDEO_EPOLICE_PARAM
{
    BYTE byLaneNO; //关联的车道号
    BYTE bySensitivity; //线圈灵敏度，[1,100]
    BYTE byEnableRadar;//启用雷达测试0-不启用，1-启用
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE byRelaLaneDirectionType;
    NET_ITC_LANE_LOGIC_PARAM struLane; //车道参数
    NET_ITC_VIOLATION_DETECT_PARAM struVioDetect; //违规检测参数
    NET_ITC_VIOLATION_DETECT_LINE struLine; //违规检测线
    NET_ITC_POLYGON struPlateRecog; //牌识区域参数
    BYTE byRecordEnable;//闯红灯周期录像标志，0-不录像，1-录像
    BYTE byRecordType;//闯红灯录像类型，0-预录，1-延时录像
    BYTE byPreRecordTime;//闯红灯录像片段预录时间（默认0），单位：秒
    BYTE byRecordDelayTime;//闯红灯录像片段延时时间（默认0），单位：秒
    BYTE byRecordTimeOut;//闯红灯周期录像超时时间（秒）
    BYTE byCarSpeedLimit; //车速限制值，单位km/h
    BYTE byCarSignSpeed;//标志限速，单位km/h
    BYTE bySnapPicPreRecord; //抓拍图片预录时间点；0-默认值（第二张图片），1-第一张图片，2-第二张图片，3-第三张图片
    NET_ITC_INTERVAL_PARAM struInterval;//抓拍间隔参数（20byte）
    BYTE byRes[36];
}NET_ITC_LANE_VIDEO_EPOLICE_PARAM, *LPNET_ITC_LANE_VIDEO_EPOLICE_PARAM;

typedef struct tagNET_ITC_VIDEO_EPOLICE_PARAM
{
    BYTE byEnable;    //是否启用，0-不启用，1-启用
    BYTE byLaneNum; //识别的车道个数
    BYTE byLogicJudge;//闯红灯违规判断逻辑，设置值为：0-按方向，1-按车道
    BYTE byRes1;
    NET_ITC_PLATE_RECOG_PARAM struPlateRecog; //牌识参数
    NET_ITC_TRAFFIC_LIGHT_PARAM struTrafficLight; //交通信号灯参数
    NET_ITC_LANE_VIDEO_EPOLICE_PARAM struLaneParam[MAX_ITC_LANE_NUM]; //单车道参数
    NET_ITC_LINE  struLaneBoundaryLine; //车道边界线（最右边车道的边界线）
    NET_ITC_LINE  struLeftLine; //左转弯分界线
    NET_ITC_LINE  struRightLine; //右转弯分界线
    NET_ITC_LINE  struTopZebraLine; //上部斑马线
    NET_ITC_LINE  struBotZebraLine; //下部斑马线
    BYTE  byRes[32];
}NET_ITC_VIDEO_EPOLICE_PARAM, *LPNET_ITC_VIDEO_EPOLICE_PARAM;


typedef struct tagNET_ITC_VIDEO_TRIGGER_PARAM
{
    DWORD dwSize;
    DWORD dwMode; //触发模式，详见ITC_TRIGGERMODE_TYPE
    NET_ITC_VIDEO_TRIGGER_PARAM_UNION uVideoTrigger; //触发模式参数
    BYTE  byRes[32];
}NET_ITC_VIDEO_TRIGGER_PARAM, *LPNET_ITC_VIDEO_TRIGGER_PARAM;

typedef struct tagNET_DVR_STATUS_DETECTCFG
{
    DWORD  dwSize;            //结构长度
    BYTE   byEnableTrigIODetect; //开启触发IO状态检测，1-是，0-否
    BYTE   byEnableFlashOutDetect; //开启同步输出状态检测，1-是，0-否
    BYTE   byEnableRS485Detect; //开启RS485接收状态检测，1-是，0-否
    BYTE   byEnableTrafficLightDetect;//开启交通灯状态检测，1-是，0-否
    BYTE   byRes[28];
}NET_DVR_STATUS_DETECTCFG, *LPNET_DVR_STATUS_DETECTCFG;


typedef struct tagNET_ITC_TRIGGERIO_INFO
{
    BYTE byTriggerIOIndex[MAX_IOIN_NUM]; //触发IO号
    BYTE byRes[40]; 
}NET_ITC_TRIGGERIO_INFO, *LPNET_ITC_TRIGGERIO_INFO;

typedef struct tagNET_ITC_FLASHOUT_INFO
{
    BYTE byFlashOutIndex[MAX_IOOUT_K_NUM]; //同步输出号
    BYTE byRes[40]; 
}NET_ITC_FLASHOUT_INFO, *LPNET_ITC_FLASHOUT_INFO;

typedef struct tagNET_ITC_SERIAL_CHECKINFO
{
    BYTE bySerialIndex[MAX_ITC_SERIALCHECK_NUM]; //485串口校验结果，0-无效,1-有效, bySerialIndex[0]表示正确的头, bySerialIndex[1]表示正确的尾
    BYTE byRes[40]; 
}NET_ITC_SERIAL_CHECKINFO, *LPNET_ITC_SERIAL_CHECKINFO;

typedef struct tagNET_ITC_TRIGGERTYPE_INFO
{
    BYTE byTrigTypeIndex; //触发类型值
    BYTE byRes[47]; 
}NET_ITC_TRIGGERTYPE_INFO, *LPNET_ITC_TRIGGERTYPE_INFO;

typedef struct tagNET_ITC_TRAFFIC_LIGHT_COLOR
{
    BYTE  byLeftLight;//左转灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    BYTE  byRightLight; //右转灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    BYTE  byStraightLight; //直行灯，0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    BYTE  byRes[45];
}NET_ITC_TRAFFIC_LIGHT_COLOR, *LPNET_ITC_TRAFFIC_LIGHT_COLOR;

typedef struct tagNET_ITC_TRAFFIC_LIGHT_TURN
{
    BYTE byLightType[MAX_ITC_LANE_NUM];// 0 表示无效，1为红灯 2为绿灯 3 黄灯 4灯都不亮
    BYTE byRes[42];
} NET_ITC_TRAFFIC_LIGHT_TURN, *LPNET_ITC_TRAFFIC_LIGHT_TURN;


typedef struct tagNET_ITC_STATUS_DETECT_RESULT
{
    ITC_STATUS_DETECT_TYPE dwStatusType;//状态检测类型，详见ITC_STATUS_DETECT_TYPE
    NET_ITC_STATUS_UNION uStatusParam; //状态检测结果
    DWORD dwHoldTime; //灯亮持续时间（保留），单位：ms
    BYTE byRes[32];
}NET_ITC_STATUS_DETECT_RESULT, *LPNET_ITC_STATUS_DETECT_RESULT;

typedef struct tagNET_DVR_SETUPALARM_PARAM
{
    DWORD dwSize;
    BYTE  byLevel; //布防优先级，0-一等级（高），1-二等级（中），2-三等级（低）
    BYTE  byAlarmInfoType; //上传报警信息类型（抓拍机支持），0-老报警信息（NET_DVR_PLATE_RESULT），1-新报警信息(NET_ITS_PLATE_RESULT)2012-9-28
    BYTE  byRetAlarmTypeV40; //0--返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO, 1--设备支持NET_DVR_ALARMINFO_V40则返回NET_DVR_ALARMINFO_V40，不支持则返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO
    BYTE  byRetDevInfoVersion; //CVR上传报警信息回调结构体版本号 0-COMM_ALARM_DEVICE， 1-COMM_ALARM_DEVICE_V40
    BYTE  byRetVQDAlarmType; //VQD报警上传类型，0-上传报报警NET_DVR_VQD_DIAGNOSE_INFO，1-上传报警NET_DVR_VQD_ALARM
    //1-表示人脸侦测报警扩展(INTER_FACE_DETECTION),0-表示原先支持结构(INTER_FACESNAP_RESULT)
    BYTE  byFaceAlarmDetection;
    //Bit0- 表示二级布防是否上传图片: 0-上传，1-不上传
    //Bit1- 表示开启数据上传确认机制；0-不开启，1-开启
    //Bit6- 表示雷达检测报警(eventType:radarDetection)是否开启实时上传；0-不开启，1-开启（用于web插件实时显示雷达目标轨迹）
    BYTE  bySupport; 
    //断网续传类型 
    //bit0-车牌检测（IPC） （0-不续传，1-续传）
    //bit1-客流统计（IPC）  （0-不续传，1-续传）
    //bit2-热度图统计（IPC） （0-不续传，1-续传）
    //bit3-人脸抓拍（IPC） （0-不续传，1-续传）
    //bit4-人脸对比（IPC） （0-不续传，1-续传）
    BYTE  byBrokenNetHttp;
    WORD  wTaskNo;    //任务处理号 和 (上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段dwTaskNo对应 同时 下发任务结构 NET_DVR_VEHICLE_RECOG_COND中的字段dwTaskNo对应)
    BYTE  byDeployType;    //布防类型：0-客户端布防，1-实时布防
    BYTE  bySubScription;	//订阅，按位表示，未开启订阅不上报  //占位
    //Bit7-移动侦测人车分类是否传图；0-不传图(V30上报)，1-传图(V40上报)
    BYTE  byRes1[2];
    BYTE  byAlarmTypeURL;//bit0-表示人脸抓拍报警上传（INTER_FACESNAP_RESULT）；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断,同时设备需要支持URL的相关服务，当前是”云存储“）
    //bit1-表示EVENT_JSON中图片数据长传类型；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断）
    //bit2 - 人脸比对(报警类型为COMM_SNAP_MATCH_ALARM)中图片数据上传类型：0 - 二进制传输，1 - URL传输
    //bit3 - 行为分析(报警类型为COMM_ALARM_RULE)中图片数据上传类型：0 - 二进制传输，1 - URL传输，本字段设备是否支持，对应软硬件能力集中<isSupportBehaviorUploadByCloudStorageURL>节点是否返回且为true
    BYTE  byCustomCtrl;//Bit0- 表示支持副驾驶人脸子图上传: 0-不上传,1-上传
}NET_DVR_SETUPALARM_PARAM, *LPNET_DVR_SETUPALARM_PARAM;

typedef struct tagNET_DVR_SETUPALARM_PARAM_V50
{
    DWORD dwSize;
    BYTE  byLevel; //布防优先级，0-一等级（高），1-二等级（中），2-三等级（低）
    BYTE  byAlarmInfoType; //上传报警信息类型（抓拍机支持），0-老报警信息（NET_DVR_PLATE_RESULT），1-新报警信息(NET_ITS_PLATE_RESULT)2012-9-28
    BYTE  byRetAlarmTypeV40; //0--返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO, 1--设备支持NET_DVR_ALARMINFO_V40则返回NET_DVR_ALARMINFO_V40，不支持则返回NET_DVR_ALARMINFO_V30或NET_DVR_ALARMINFO
    BYTE  byRetDevInfoVersion; //CVR上传报警信息回调结构体版本号 0-COMM_ALARM_DEVICE， 1-COMM_ALARM_DEVICE_V40
    BYTE  byRetVQDAlarmType; //VQD报警上传类型，0-上传报报警NET_DVR_VQD_DIAGNOSE_INFO，1-上传报警NET_DVR_VQD_ALARM
    //1-表示人脸侦测报警扩展(INTER_FACE_DETECTION),0-表示原先支持结构(INTER_FACESNAP_RESULT)
    BYTE  byFaceAlarmDetection;
    //Bit0- 表示二级布防是否上传图片: 0-上传，1-不上传
    //Bit1- 表示开启数据上传确认机制；0-不开启，1-开启
    //Bit6- 表示雷达检测报警(eventType:radarDetection)是否开启实时上传；0-不开启，1-开启（用于web插件实时显示雷达目标轨迹）
    BYTE  bySupport;
    //断网续传类型 
    //bit0-车牌检测（IPC） （0-不续传，1-续传）
    //bit1-客流统计（IPC）  （0-不续传，1-续传）
    //bit2-热度图统计（IPC） （0-不续传，1-续传）
    //bit3-人脸抓拍（IPC） （0-不续传，1-续传）
    //bit4-人脸对比（IPC） （0-不续传，1-续传）
    //bit5-JSON报警透传（IPC） （0-不续传，1-续传）
    //bit6-热度图按人员停留时间统计数据上传事件（0-不续传，1-续传）
    //bit7-热度图按人数统计数据上传事件的确认机制（0-不续传，1-续传）
    BYTE  byBrokenNetHttp;
    WORD  wTaskNo;    //任务处理号 和 (上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段dwTaskNo对应 同时 下发任务结构 NET_DVR_VEHICLE_RECOG_COND中的字段dwTaskNo对应)
    BYTE  byDeployType;    //布防类型：0-客户端布防，1-实时布防
    BYTE  bySubScription;	//订阅，按位表示，未开启订阅不上报  //占位Bit7-移动侦测人车分类是否传图；0-不传图(V30上报)，1-传图(V40上报)
    //断网续传响应类型V60版本
    //bit0-AID事件(COMM_ALARM_AID_V41) （0-不续传，1-续传）
    //bit1-TFS事件（COMM_ALARM_TFS）  （0-不续传，1-续传）
    //bit2-TPS统计过车事件（COMM_ALARM_TPS_STATISTICS）  （0-不续传，1-续传）
    BYTE  byBrokenNetHttpV60;
    BYTE  byRes1;
    BYTE  byAlarmTypeURL;//bit0-表示人脸抓拍报警上传（INTER_FACESNAP_RESULT）；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断,同时设备需要支持URL的相关服务，当前是”云存储“）
    //bit1-表示EVENT_JSON中图片数据长传类型；0-表示二进制传输，1-表示URL传输（设备支持的情况下，设备支持能力根据具体报警能力集判断）
    //bit2 - 人脸比对(报警类型为COMM_SNAP_MATCH_ALARM)中图片数据上传类型：0 - 二进制传输，1 - URL传输
    //bit3 - 行为分析(报警类型为COMM_ALARM_RULE)中图片数据上传类型：0 - 二进制传输，1 - URL传输，本字段设备是否支持，对应软硬件能力集中<isSupportBehaviorUploadByCloudStorageURL>节点是否返回且为true
    BYTE  byCustomCtrl;//Bit0- 表示支持副驾驶人脸子图上传: 0-不上传,1-上传
    BYTE  byRes4[128];
}NET_DVR_SETUPALARM_PARAM_V50, *LPNET_DVR_SETUPALARM_PARAM_V50;

typedef struct tagNET_ITC_VIDEO_TRIGGER_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwTriggerMode; //视频触发模式类型，详见ITC_TRIGGERMODE_TYPE
    BYTE byRes[16];
}NET_ITC_VIDEO_TRIGGER_COND, *LPNET_ITC_VIDEO_TRIGGER_COND;

typedef struct tagNET_ITC_FTP_TYPE_COND
{
    DWORD dwChannel;//通道号
    BYTE    byWorkMode;  // 0-FTP1(主FTP)，1-FTP2(备FTP)
    BYTE    byRes[7];
}NET_ITC_FTP_TYPE_COND, *LPNET_ITC_FTP_TYPE_COND;

typedef struct tagNET_ITC_FTP_CFG
{
    DWORD            dwSize;
    BYTE                byEnable;            /*是否启动ftp上传功能，0-否，1-是*/
    BYTE                 byAddressType;   //0-实际ipv4 ipv6地址 1-域名
    // 控制unionServer是使用实际地址还是域名
    WORD                wFTPPort;            /*端口*/
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];//服务器地址，域名 
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;/*IP地址*/        //IPv4 IPv6地址, 144字节
        } struAddrIP;
    }unionServer;  //使用联合体结构，通过byAddressType字段表示是IP地址还是域名 64    
    BYTE                szUserName[NAME_LEN];        /*用户名*/
    BYTE                szPassWORD[PASSWD_LEN];        /*密码*/
    BYTE                byRes4;  // 0-FTP1(主FTP)，1-FTP2(备FTP)
                                 BYTE                byDirLevel;    /*0 = 不使用目录结构，直接保存在根目录,
                                                                1 = 使用1级目录,2=使用2级目录,
                                 3 = 使用3级目录,4=使用4级目录*/                    
                                 BYTE                 byIsFilterCarPic;/*车牌小图是否上传，0-上传,1-不上传*/
                                 BYTE                    byUploadDataType;//0-全部，1-卡口，2-违章 (单FTP时默认选择全部，双FTP时支持卡口，违章的选择)
                                 NET_DVR_PICTURE_NAME     struPicNameRule;/* 图片命名规则 */
                                                                        BYTE                byTopDirMode; /*一级目录, 0x1 = 使用设备名,
                                                                                                          0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                          0x4=使用监测点,0x5=使用时间(年月),  
                                                                                                          0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义*/
                                                                        BYTE                bySubDirMode; /*二级目录, 0x1 =使用设备名,
                                                                                                          0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                          0x4=使用监测点,0x5=使用时间(年月),  
                                                                                                          0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义*/
                                                                        BYTE                byThreeDirMode; /*三级目录, 0x1 = 使用设备名,
                                                                                                            0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                            0x4=使用监测点,0x5=使用时间(年月),  
                                                                                                            0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义*/
                                                                        BYTE                byFourDirMode; /*四级目录, 0x1 =使用设备名,
                                                                                                           0x2 = 使用设备号,0x3 =使用设备ip地址，
                                                                                                           0x4=使用监测点,0x5=使用时间(年月),  
                                                                                                           0x6=使用时间(年月日),0x7=违规类型,0x8=方向,0x9=地点,
                                                                        0xa=通道名,0xb=通道号,0xc=车道号0xff=自定义*/
                                                                        /*图片命名自定义 当PICNAME_ITEM_CUSTOM 时 生效*/
                                                                        BYTE                szPicNameCustom[MAX_CUSTOMDIR_LEN];// (3.7Ver 生效)
                                                                        BYTE                szTopCustomDir[MAX_CUSTOMDIR_LEN]; /*自定义一级目录*/  
                                                                        BYTE                szSubCustomDir[MAX_CUSTOMDIR_LEN];/*自定义二级目录*/
                                                                        BYTE                szThreeCustomDir[MAX_CUSTOMDIR_LEN];    /*自定义三级目录*/
                                                                        BYTE                szFourCustomDir[MAX_CUSTOMDIR_LEN];    /*自定义四级目录*/
                                                                        BYTE                 byRes3[900]; //满足12级扩展预留 支持透传
}NET_ITC_FTP_CFG, *LPNET_ITC_FTP_CFG;

typedef struct tagNET_DVR_LATITUDE_PARAM
{
    BYTE byDegree;//度[0,179]
    BYTE byMinute;//分[0,59]
    BYTE bySec;//秒[0,59]
    BYTE byRes;
}NET_DVR_LATITUDE_PARAM, *LPNET_DVR_LATITUDE_PARAM;

typedef struct tagNET_DVR_LONGITUDE_PARAM
{
    BYTE byDegree;//度[0,179]
    BYTE byMinute;//分[0,59]
    BYTE bySec;//秒[0,59]
    BYTE byRes;
}NET_DVR_LONGITUDE_PARAM, *LPNET_DVR_LONGITUDE_PARAM;

typedef struct tagNET_DVR_GPS_DATACFG
{
    DWORD     dwSize;
    BYTE byGpsDataMode;//GPS数据获取 0-自动，1-手动
    BYTE byLongitudeType;//经度 0-东经，1-西经
    BYTE byLatitudeType;//纬度 0-南纬，1-北纬
    BYTE byRes;
    NET_DVR_LATITUDE_PARAM    struLatitude;     /*纬度*/
    NET_DVR_LONGITUDE_PARAM    struLongitude; /*经度*/
    BYTE byRes1[128];
}NET_DVR_GPS_DATACFG,*LPNET_DVR_GPS_DATACFG;


typedef struct tagNET_VCA_DATABASE_PARAM
{
    DWORD dwSize;
    DWORD dwDataBaseID; //数据库ID（设备生成，添加时无效，修改和删除时有效）
    DWORD dwDataBaseType; //数据库类型，见VCA_DATABASE_TYPE
    BYTE byDataBaseName[NAME_LEN]; //数据库名称
    BYTE byAttribute[64]; //数据库属性
    BYTE byRes[20];
}NET_VCA_DATABASE_PARAM, *LPNET_VCA_DATABASE_PARAM;

typedef struct tagNET_VCA_FIND_DATABASE_COND
{
    DWORD dwDataBaseType; //数据库类型，详见VCA_DATABASE_TYPE
    BYTE byRes[12]; //保留
}NET_VCA_FIND_DATABASE_COND, *LPNET_VCA_FIND_DATABASE_COND;

typedef struct tagNET_VCA_DELETE_DATABASE_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //数据库类型，见VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //数据库ID
    BYTE byRes[64]; //保留
}NET_VCA_DELETE_DATABASE_COND, *LPNET_VCA_DELETE_DATABASE_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPDB_COND
{
    DWORD dwChannel;//通道号
    NET_DVR_TIME struStartTime;//开始时间
    NET_DVR_TIME struStopTime;//结束时间
    BYTE bySex; //性别：0-不启用，1-男，2-女
    BYTE byRes1[3]; //保留
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //起始出生年月，如：201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //截止出生年月，如201106
    BYTE byAttribute1[NAME_LEN]; //属性1
    BYTE byAttribute2[NAME_LEN]; //属性2
    BYTE byRes[12]; //保留
}NET_VCA_INQUIRE_SNAPDB_COND, *LPNET_VCA_INQUIRE_SNAPDB_COND;

typedef struct tagNET_VCA_INQUIRE_SNAPRECORD_RESULT
{ 
    DWORD dwSize; //结构体大小
    DWORD dwDataBaseID;  //数据库ID
    DWORD dwRecordID; //记录ID
    NET_DVR_TIME struSnapTime;  //抓拍时间
    BYTE bySex; //性别：0-不启用，1-男，2-女
    BYTE byRes1[3]; //保留
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //起始出生年月，如：201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //截止出生年月，如201106
    BYTE byAttribute1[NAME_LEN]; //属性1
    BYTE byAttribute2[NAME_LEN]; //属性2
    DWORD dwFacePicID; //人脸图ID
    DWORD dwFacePicLen;  //人脸图数据长度
    BYTE byRes[80];  //保留
    BYTE *pFacePic;    //人脸图数据
}NET_VCA_INQUIRE_SNAPRECORD_RESULT, *LPNET_VCA_INQUIRE_SNAPRECORD_RESULT;



typedef struct tagNET_VCA_DELETE_SNAPRECORD_COND
{ 
    VCA_DELETE_RECORD_TYPE dwDeleteType; //删除记录类型
    NET_VCA_DELETE_SNAPRECORD_COND_UNION uDeleteCond;  //删除参数
    BYTE  byRes[40]; //保留
}NET_VCA_DELETE_SNAPRECORD_COND, *LPNET_VCA_DELETE_SNAPRECORD_COND;


typedef struct tagNET_VCA_ADVANCE_SEARCH_DATABASE_COND
{
    DWORD dwDataBaseType; //数据库类型，详见VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //数据库ID
    DWORD dwFacePicID; //人脸图片ID
    BYTE byRes[36];
}NET_VCA_ADVANCE_SEARCH_DATABASE_COND, *LPNET_VCA_ADVANCE_SEARCH_DATABASE_COND;


typedef struct tagNET_VCA_SEARCH_DATABASE_PARAM
{
    DWORD dwSearchType; //检索类型，详见VCA_SEARCH_DATABASE_TYPE
    NET_VCA_SEARCH_DATABASE_COND_UNION uSearchCond; //检索参数
    BYTE byRes[16];
}NET_VCA_SEARCH_DATABASE_PARAM, *LPNET_VCA_SEARCH_DATABASE_PARAM;

typedef struct tagNET_VCA_SEARCH_SNAPDB_COND
{ 
    DWORD dwChannel; //通道
    DWORD dwDataBaseID; //数据库ID
    NET_DVR_TIME struStartTime;//开始时间
    NET_DVR_TIME struStopTime;//结束时间
    BYTE bySex; //性别：0-不启用，1-男，2-女
    BYTE byRes1[3]; //保留
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //起始出生年月，如：201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //截止出生年月，如201106
    BYTE byAttribute1[NAME_LEN]; //属性1
    BYTE byAttribute2[NAME_LEN]; //属性2
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //检索参数
    DWORD dwMaxSearchNum; //最大检索条数
    WORD wThreshold;  //阈值，0-100
    BYTE  byRes[78]; //保留
}NET_VCA_SEARCH_SNAPDB_COND, *LPNET_VCA_SEARCH_SNAPDB_COND;

typedef struct tagNET_VCA_SEARCH_SNAPRECORD_RESULT
{ 
    DWORD dwSize; //结构体大小
    DWORD dwDataBaseID;  //数据库ID
    DWORD dwRecordID; //记录ID
    NET_DVR_TIME struSnapTime;//抓拍时间
    BYTE bySex; //性别：0-不启用，1-男，2-女
    BYTE byRes1[3]; //保留
    BYTE byStartBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //起始出生年月，如：201106
    BYTE byEndBirthDate[MAX_HUMAN_BIRTHDATE_LEN]; //截止出生年月，如201106
    BYTE byAttribute1[NAME_LEN]; //属性1
    BYTE byAttribute2[NAME_LEN]; //属性2
    float fSimilarity; //相似度，[0.001,1]
    DWORD dwFacePicID; //人脸图ID
    DWORD dwFacePicLen;  //人脸图数据长度
    BYTE byRes[80];  //保留
    BYTE *pFacePic;    //人脸图数据
}NET_VCA_SEARCH_SNAPRECORD_RESULT, *LPNET_VCA_SEARCH_SNAPRECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_INFO
{ 
    DWORD dwSize; //结构体大小
    DWORD dwRecordID; //记录ID，添加时无效，修改时有效
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //人员信息
    NET_VCA_REGISTER_PIC struRegisterPic;  //人员图片信息
    BYTE  byRemark1[NAME_LEN]; //备注信息1
    BYTE  byRemark2[64]; //备注信息2
    BYTE  byRes[32]; //保留
}NET_VCA_DATARECORD_INFO, *LPNET_VCA_DATARECORD_INFO;

typedef struct tagNET_VCA_FAST_DATARECORD_INFO
{ 
    DWORD dwSize; //结构体大小
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //人员信息
    BYTE  byRemark1[NAME_LEN]; //备注信息1
    BYTE  byRemark2[64]; //备注信息2
    DWORD dwImageLen;  //图像数据长度
    BYTE  byRes[80];  //保留
    BYTE *pImage;    //图像数据
}NET_VCA_FAST_DATARECORD_INFO, *LPNET_VCA_FAST_DATARECORD_INFO;

typedef struct tagNET_VCA_INQUIRE_DATARECORD_RESULT
{ 
    DWORD dwSize; //结构体大小
    DWORD dwDataBaseID;  //数据库ID
    DWORD dwRecordID; //记录ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //人员信息
    BYTE  byRemark1[NAME_LEN]; //备注信息1
    BYTE  byRemark2[64]; //备注信息2
    DWORD dwFacePicID; //人脸图ID
    DWORD dwFacePicLen;  //人脸图数据长度
    BYTE byRes[80];  //保留
    BYTE *pFacePic;    //人脸图数据
}NET_VCA_INQUIRE_DATARECORD_RESULT, *LPNET_VCA_INQUIRE_DATARECORD_RESULT;

typedef struct tagNET_VCA_SEARCH_DATARECORD_RESULT
{ 
    DWORD dwSize; //结构体大小
    DWORD dwDataBaseID;  //数据库ID
    DWORD dwRecordID; //记录ID
    NET_VCA_HUMAN_ATTRIBUTE struAttribute;  //人员信息
    BYTE  byRemark1[NAME_LEN]; //备注信息1
    BYTE  byRemark2[64]; //备注信息2
    float fSimilarity; //相似度，[0.001,1]
    DWORD dwFacePicID; //人脸图ID
    DWORD dwFacePicLen;  //人脸图数据长度
    BYTE byRes[80];  //保留
    BYTE *pFacePic;    //人脸图数据
}NET_VCA_SEARCH_DATARECORD_RESULT, *LPNET_VCA_SEARCH_DATARECORD_RESULT;

typedef struct tagNET_VCA_DATARECORD_COND
{ 
    DWORD dwDataBaseID; //数据库ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //人员信息
    BYTE byRes[80];  //保留
}NET_VCA_DATARECORD_COND, *LPNET_VCA_DATARECORD_COND;


typedef struct tagNET_VCA_DELETE_RECORD_COND
{ 
    VCA_DELETE_RECORD_TYPE dwDeleteType; //删除记录类型
    NET_VCA_DELETE_RECORD_COND_UNION uDeleteCond;  //删除参数
    BYTE  byRes[40]; //保留
}NET_VCA_DELETE_RECORD_COND, *LPNET_VCA_DELETE_RECORD_COND;

typedef struct tagNET_VCA_SEARCH_FACEDB_COND
{ 
    DWORD dwDataBaseID; //数据库ID
    NET_VCA_HUMANATTRIBUTE_COND struAttribute;  //人员信息
    NET_VCA_SEARCH_DATABASE_PARAM struSearchParam;  //检索参数
    DWORD dwMaxSearchNum; //最大检索条数
    WORD wThreshold;  //阈值，0-100
    BYTE  byRes[78]; //保留
}NET_VCA_SEARCH_FACEDB_COND, *LPNET_VCA_SEARCH_FACEDB_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_COND
{
    DWORD dwSize;
    DWORD dwDataBaseType; //数据库类型，见VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //数据库ID
    DWORD dwRecordID; //记录ID
    BYTE byRes[64]; //保留
}NET_VCA_FIND_MATCHPIC_COND, *LPNET_VCA_FIND_MATCHPIC_COND;

typedef struct tagNET_VCA_FIND_MATCHPIC_RESULT
{
    DWORD dwSize;
    DWORD dwDataBaseType; //数据库类型，见VCA_DATABASE_TYPE
    DWORD dwDataBaseID; //数据库ID
    DWORD dwRecordID; //记录ID
    DWORD dwPicLen; //图片长度
    BYTE byRes[64]; //保留
    BYTE *pPicBuffer; //图片数据指针
}NET_VCA_FIND_MATCHPIC_RESULT, *LPNET_VCA_FIND_MATCHPIC_RESULT;

typedef struct tagNET_DVR_REMOTECONTROL_ALARM_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    WORD wDealyTime; //延迟时间，单位s
    BYTE  byRes[30]; 
}NET_DVR_REMOTECONTROL_ALARM_PARAM, *LPNET_DVR_REMOTECONTROL_ALARM_PARAM;

typedef struct tagNET_DVR_REMOTECONTROL_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  byRes[16]; 
}NET_DVR_REMOTECONTROL_STUDY_PARAM, *LPNET_DVR_REMOTECONTROL_STUDY_PARAM;

typedef struct tagNET_DVR_WIRELESS_ALARM_STUDY_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  byIndex;  //无线报警序号，1-8
    BYTE  byRes[15]; 
}NET_DVR_WIRELESS_ALARM_STUDY_PARAM, *LPNET_DVR_WIRELESS_ALARM_STUDY_PARAM;


typedef struct tagNET_DVR_AUDIO_LIMIT_ALARM_CFG
{    
    DWORD    dwSize;
    BYTE    byEnable;//使能
    BYTE    byRes1[3];
    DWORD    dwDecibelLimit; //分贝告警阀值
    NET_DVR_HANDLEEXCEPTION_V30    struHandleException;  //异常处理方式
    BYTE    byRes2[24];
}NET_IPC_AUDIO_LIMIT_ALARM_CFG,*LPNET_IPC_AUDIO_LIMIT_ALARM_CFG;

typedef struct tagNET_DVR_BUTTON_DOWN_ALARM_CFG
{    
    DWORD    dwSize;
    BYTE    byEnable;//使能
    BYTE    byRes1[3]; 
    NET_DVR_HANDLEEXCEPTION_V30    struHandleException;  //异常处理方式
    BYTE    byRes2[24];
}NET_IPC_BUTTON_DOWN_ALARM_CFG,*LPNET_IPC_BUTTON_DOWN_ALARM_CFG;

typedef struct tagNET_IPC_PIR_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];    /* 报警名称 */
    BYTE byAlarmHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byRes1[3];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* 处理方式 */    
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道
    BYTE byRes[64];
}NET_IPC_PIR_ALARMCFG, *LPNET_IPC_PIR_ALARMCFG;

typedef struct tagNET_IPC_PIR_ALARMCFG_EX
{
    BYTE byAlarmName[NAME_LEN];    /* 报警名称 */
    BYTE byAlarmHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byRes1[3];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* 处理方式 */    
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    BYTE byRes[1464];
}NET_IPC_PIR_ALARMCFG_EX, *LPNET_IPC_PIR_ALARMCFG_EX;

typedef struct tagNET_IPC_CALLHELP_ALARMCFG
{
    BYTE byAlarmHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byRes1[3];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* 处理方式 */    
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道
    BYTE byRes[64];
}NET_IPC_CALLHELP_ALARMCFG, *LPNET_IPC_CALLHELP_ALARMCFG;

typedef struct tagNET_IPC_SINGLE_WIRELESS_ALARMCFG
{
    BYTE byAlarmName[NAME_LEN];    /* 报警名称 */
    BYTE byAlarmHandle;            /* 是否处理 0-不处理 1-处理*/
    BYTE byID; //无线报警ID，1-8
    BYTE byRes1[2];            
    NET_DVR_HANDLEEXCEPTION_V30 struAlarmHandleType;    /* 处理方式 */
    BYTE byRelRecordChan[MAX_CHANNUM_V30]; //报警触发的录象通道,为1表示触发该通道    
    BYTE byRes[32];
}NET_IPC_SINGLE_WIRELESS_ALARMCFG, *LPNET_IPC_SINGLE_WIRELESS_ALARMCFG;

typedef struct tagNET_IPC_WIRELESS_ALARMCFG
{
    NET_IPC_SINGLE_WIRELESS_ALARMCFG struWirelessAlarm[MAX_WIRELESS_ALARM_NUM]; //单个无线报警参数
    BYTE byRes[32];
}NET_IPC_WIRELESS_ALARMCFG, *LPNET_IPC_WIRELESS_ALARMCFG;


typedef struct tagNET_IPC_SINGLE_AUX_ALARMCFG
{
    BYTE byAlarmType;       //报警器类型，详见IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];            
    NET_IPC_AUX_ALARMCFG_UNION uAlarm; //报警参数
    BYTE byRes[16];
}NET_IPC_SINGLE_AUX_ALARMCFG, *LPNET_IPC_SINGLE_AUX_ALARMCFG;

typedef struct tagNET_IPC_AUX_ALARMCFG
{
    DWORD dwSize;
    NET_IPC_SINGLE_AUX_ALARMCFG struAlarm[MAX_AUX_ALARM_NUM]; //报警参数
    BYTE byRes[64];
}NET_IPC_AUX_ALARMCFG, *LPNET_IPC_AUX_ALARMCFG;


typedef struct tagNET_IPC_AUXALARM_RESULT
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE byAlarmType;       //报警器类型，详见IPC_AUX_ALARM_TYPE
    BYTE byRes1[3];
    NET_IPC_AUXALARM_UPLOAD_UNION struAuxAlarm; //报警结果参数
    BYTE byDeviceID[NAME_LEN];/*设备的ID串*/
    BYTE byRes[32];
}NET_IPC_AUXALARM_RESULT, *LPNET_IPC_AUXALARM_RESULT;

typedef struct tagNET_DVR_PREVIEW_DISPLAYCFG
{
    DWORD  dwSize;         // 结构体大小 
    BYTE   byCorrectMode;   //校正模式，0-软件校正，1-芯片校正
    BYTE   byMountType;     //安装类型，0-吸顶，1-桌面，2-墙面
    /*
    0-模式1：鱼眼+全景+3PTZ (与原有非实时模式一致)；
    1-模式2：鱼眼+4PTZ(与原有实时模式一致)；
    2-模式3：鱼眼(主)+鱼眼(子)+3PTZ；
    3-模式4：全景展开(主码流+子码流)；
    4-模式5：4PTZ；
    5-模式6：鱼眼；
    6-模式7: 经纬度全景展开模式；
    7-模式8: 4PTZ融合模式；
    */
    BYTE   byRealTimeOutput;  //实时输出，0 -不启用，1- 启用
    BYTE   byRes[61];
}NET_DVR_PREVIEW_DISPLAYCFG, *LPNET_DVR_PREVIEW_DISPLAYCFG;

typedef struct tagNET_DVR_REMOTECONTROL_PTZ_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    DWORD dwPTZCommand; //PTZ控制命令 
    NET_VCA_POINT struVcaPoint; //预览界面点坐标
    DWORD dwSpeed; //控制的速度，取值范围[0,7]
    DWORD dwStop; //停止动作或开始动作：0-开始；1-停止
    BYTE  byRes[32]; 
}NET_DVR_REMOTECONTROL_PTZ_PARAM, *LPNET_DVR_REMOTECONTROL_PTZ_PARAM;

typedef struct tagNET_DVR_PRESET_POINT_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    DWORD dwPTZPresetCmd; //预置点控制命令 
    NET_VCA_POINT struVcaPoint; //预览界面点坐标
    DWORD dwPresetIndex; //预置点的序号（从1开始），最多支持255个预置点
    WORD  wZoomCoordinate;///<预置点窗口Zoom值
    BYTE  byRes[30];
}NET_DVR_PRESET_POINT_PARAM, *LPNET_DVR_PRESET_POINT_PARAM;

typedef struct tagNET_DVR_PTZ_CRUISE_PARAM
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    DWORD dwPTZCruiseCmd; //巡航控制命令 
    NET_VCA_POINT struVcaPoint; //预览界面点坐标
    WORD wCruiseRoute; //巡航路径，最多支持32条路径（序号从1开始）
    WORD wCruisePoint; //巡航点，最多支持32个点（序号从1开始）
    WORD wInput; //不同巡航命令时的值不同，预置点(最大255)、时间(最大255)、速度(最大40)
    WORD wZoomCoordinate;///<预置点窗口Zoom值
    BYTE  byRes[32];
}NET_DVR_PTZ_CRUISE_PARAM, *LPNET_DVR_PTZ_CRUISE_PARAM;

typedef struct tagNET_DVR_WPS_PARAM
{
    DWORD dwSize;
    BYTE byEnableWps; //启用WPS，0-否，1-是
    BYTE byRes[31]; 
}NET_DVR_WPS_PARAM, *LPNET_DVR_WPS_PARAM;

typedef struct tagNET_DVR_PIN_PARAM
{
    DWORD dwSize;
    BYTE byPIN[8]; //PIN码
    BYTE byRes[32]; 
}NET_DVR_PIN_PARAM, *LPNET_DVR_PIN_PARAM;

typedef struct tagNET_DVR_WPS_CONNECT_PARAM_
{
    DWORD dwSize;
    BYTE byConnectType; //WPS连接方式，0-PBC,1-AP PIN
    BYTE byRes1[3];
    BYTE byPIN[8]; //PIN码(WPS连接方式为AP PIN时有效)
    BYTE byEssid[IW_ESSID_MAX_SIZE]; //essid(WPS连接方式为AP PIN时有效)
    BYTE byRes[32]; 
}NET_DVR_WPS_CONNECT_PARAM, *LPNET_DVR_WPS_CONNECT_PARAM;

typedef struct tagNET_DVR_DECODER_JOINT_PARAM
{
    DWORD    dwSize;        // 结构体大小
    BYTE    byJointed;        //  0 没有关联 1 已经关联
    BYTE    byRes1[3];        // 保留字节
    NET_DVR_IPADDR    struIP;    // 被关联解码器的IP地址
    WORD    wPort;            // 被关联解码器的端口号
    WORD    wChannel;        // 被关联解码器的解码通道号
    BYTE    sDeviceName[NAME_LEN];    //被关联解码器的设备名称
    BYTE    sChanName[NAME_LEN];    //被关联解码器的解码通道名称
    BYTE    byRes2[32];        // 保留字节
}NET_DVR_DECODER_JOINT_PARAM, *LPNET_DVR_DECODER_JOINT_PARAM;

typedef struct tagNET_DVR_PIC_VIEW_PARAM
{
    DWORD    dwSize;
    NET_DVR_IPADDR    struCuIp; //CU端IP地址
    WORD    wPort;/*CU端口*/
    BYTE    bySourceIndex;    //信号源通道号
    BYTE    byRes[29];
}NET_DVR_PIC_VIEW_PARAM, *LPNET_DVR_PIC_VIEW_PARAM;

typedef struct tagNET_DVR_PICVIEW_CALLBACKPARAM
{
    DWORD    dwUserID;
    BYTE    sDeviceID[DVCS_DEVICEID_LEN];
    LONG    nPicViewHandle; //回显句柄
    WORD    wSignalIndex;    //信号源索引
    WORD    wHeadLen;        //文件头长度 私有的码流文件头都是40
    BYTE    byHeadBuf[100]; //文件头
    BYTE    byRes2[32];
}NET_DVR_PICVIEW_CALLBACKPARAM, *LPNET_DVR_PICVIEW_CALLBACKPARAM;

typedef struct tagNET_DVR_DEVICEID_INFO
{
    DWORD        dwSize;
    DWORD        dwDeviceIndex;    //设备序号
    BYTE        byWallNo;     //墙号，从1开始
    BYTE        byRes1[27];
    DWORD        dwChan;        //通道号
    DWORD        dwInputSignalIndex; //信号源索引，集中式大屏控制器使用
    BYTE        byRes2[60];
}NET_DVR_DEVICEID_INFO, *LPNET_DVR_DEVICEID_INFO;

typedef struct tagNET_DVR_SINGLE_NETPARAM
{
    DWORD  dwSize;
    BYTE   byUseDhcp;                 //是否启用DHCP 0xff-无效 0-不启用 1-启用
    BYTE   byRes1[3];
    NET_DVR_IPADDR  struDevIP;       // 设备IP地址
    NET_DVR_IPADDR  struSubnetMask;  // 设备子网掩码
    NET_DVR_IPADDR  struGateway;     // 设备网关
    WORD    wDevPort;                 // 设备端口号
    BYTE    byMACAddr[MACADDR_LEN];   // MAC 地址(只能获取)
    BYTE    byRes2[16];
} NET_DVR_SINGLE_NETPARAM, *LPNET_DVR_SINGLE_NETPARAM;

typedef struct tagNET_DVR_CHAN_INFO
{
    DWORD    dwSize;
    BYTE    byValid;                //0-无效 1-有效
    BYTE    byRes1[3];
    BYTE    sChanName[NAME_LEN];    //通道名称
    NET_DVR_COLOR struVideoColor;   //信号源颜色
    WORD    wResolutionX;        //当前分辨率---宽 
    WORD    wResolutionY;        //当前分辨率---高
    BYTE   byRes2[40];
} NET_DVR_CHAN_INFO, *LPNET_DVR_CHAN_INFO;

typedef struct tagNET_DVR_CODEDEV_INFO 
{
    NET_DVR_CHAN_INFO struChanInfo[MAX_CHANNUM/*16*/];/*设备通道信息*/ 
} NET_DVR_CODEDEV_INFO, *LPNET_DVR_CODEDEV_INFO;

typedef struct tagNET_DVR_DECODEDEV_INFO 
{
    BYTE    byRes[1408];
} NET_DVR_DECODEDEV_INFO, *LPNET_DVR_DECODEDEV_INFO;

typedef struct tagNET_DVR_NETSIGNAL_INFO
{
    DWORD    dwSize;
    BYTE    byDevName[NAME_LEN/*32*/];//网络信号源名称
    NET_DVR_PU_STREAM_CFG struPuStream;  
    BYTE    byValid;            //是否有效，0-无效，删除时设为0  1-有效，添加和修改时设为1/
    BYTE     byRes1[3];    //保留
    BYTE    sGroupName[NAME_LEN/*32*/];//网络信号源所在组的组名，网络信号源根据这个组名来分类
    WORD    wResolutionX;        //当前分辨率---宽 
    WORD    wResolutionY;        //当前分辨率---高
    BYTE    byRes2[24];        
}NET_DVR_NETSIGNAL_INFO, *LPNET_DVR_NETSIGNAL_INFO;

typedef struct tagNET_DVR_NETSIGNALDEV_INFO
{
    NET_DVR_NETSIGNAL_INFO struDevInfo;
    BYTE    byRes1[816];
}NET_DVR_NETSIGNALDEV_INFO, *LPNET_DVR_NETSIGNALDEV_INFO;



typedef struct  tagNET_DVR_SINGLE_DEV_INFO 
{
    DWORD    dwSize;
    DWORD    dwSoftVersion;            /*设备软件版本号(只能获取) 最高8位为主版本号，次高8位为次版本号，低16位为修复版本号*/
    DWORD    dwSoftwareBuildDate;         //版本编译日期Build, 0xYYYYMMDD
    BYTE    byUseInSys;                /*是否在系统中使用*/
    BYTE    byDevStatus;            /*设备当前状态，0-下线，1-上线(只能获取)*/ 
    BYTE    byDeviceType;            /*设备类型(只能获取)  见DEVICE_TYPE*/ 
    BYTE    byRes1[17];
    BYTE    sDevName[NAME_LEN];     /*设备名称*/
    NET_DVR_SINGLE_NETPARAM struEtherNet[MAX_ETHERNET]; /*设备网络参数*/
    BYTE    sSerialNumber[SERIALNO_LEN];    /*设备序列号*/
    NET_DVR_DIFFDEV_INFO  struSubDevInfo;        /*设备信息*/ 
    DWORD   dwDeviceIndex; //设备序号，相对于C20N或Y10等设备的全局编号
    DWORD   dwSubBoardNo; //分布式设备所属的子板编号，相对于C20N或Y10等设备的全局编号，从1开始，为0时该字段无效，子板编号默认为1
    BYTE    bySubSysNo; //分布式设备所属的子板上的子系统编号，相对于子板全局，从1开始，为0时该字段无效，子系统号默认为1
    BYTE    byRes3[3];
    WORD    wStartAudioTalkChanNo; //分布式设备上语音对讲的起始通道号
    WORD    wAudioTalkChanNum; //分布式设备上语音对讲通道号的数量
    BYTE    byRes2[36];
} NET_DVR_SINGLE_DEV_INFO, *LPNET_DVR_SINGLE_DEV_INFO;

typedef struct tagNET_DVR_DEVLIST
{
    DWORD        dwSize;
    DWORD        dwDevNums;//设备返回的分布式子设备数量
    BYTE          *pBuffer;
    BYTE        byRes1[3];
    DWORD         dwBufLen;//所分配指针长度，输入参数
    BYTE        byRes2[64];
} NET_DVR_DEVLIST,*LPNET_DVR_DEVLIST;

typedef struct tagNET_DVR_DEV_BASE_INFO
{
    DWORD  dwSize;
    BYTE   byEnable;          /*是否在系统中使用*/
    BYTE   byDeviceType;      /*设备类型(只能获取)*/ 
    BYTE   byRes1[2];
    BYTE   sDevName[NAME_LEN]; /*设备名称*/ 
    BYTE   byRes2[24];
} NET_DVR_DEV_BASE_INFO,*LPNET_DVR_DEV_BASE_INFO;


typedef struct tagNET_DVR_DISP_SCREEN
{
    DWORD    dwSize;
    WORD    wScreenID;        // 屏幕ID号, ID号从1开始
    BYTE    byWallNo;        // 电视墙号
    BYTE    byRes1;            // 保留1
    DWORD    dwDeviceIndex;    // 输出设备序号
    BYTE    byRes2[16];        // 保留2
}NET_DVR_DISP_SCREEN, *LPNET_DVR_DISP_SCREEN;

typedef struct tagNET_DVR_TEXTSHOW
{
    DWORD dwSize;
    BYTE  byShowText;//是否显示文字，1-显示文字，0-不显示文字
    BYTE  byRes[35];
}NET_DVR_TEXTSHOW, *LPNET_DVR_TEXTSHOW;

typedef struct tagNET_DVR_SCREENLIST
{
    DWORD        dwSize;
    BYTE        byWallNo;    //电视墙号，从1开始
    BYTE        byRes[11];
    DWORD        dwScreenNums;//设备返回的映射显示屏数量
    BYTE          *pBuffer;
    DWORD         dwBufLen;//所分配指针长度，输入参数
} NET_DVR_SCREENLIST,*LPNET_DVR_SCREENLIST;

typedef struct tagNET_DVR_OPERATE_DEVICE
{
    DWORD    dwSize;
    DWORD    dwSubCommand;    //设置设备的命令，1-设备开始升级，2-停止升级
    DWORD    dwDeviceIndex;//设备序号
    BYTE    byRes[44];
}NET_DVR_OPERATE_DEVICE, *LPNET_DVR_OPERATE_DEVICE;

typedef struct tagNET_DVR_UPGRADE_STATE
{
    DWORD    dwProgress; // 0-100
    BYTE     byState;  //升级进度：1-升级完成 2-正在升级 3-升级失败
    BYTE    byRes2[31];
}NET_DVR_UPGRADE_STATE, *LPNET_DVR_UPGRADE_STATE;


typedef struct tagNET_DVR_START_PIC_VIEW_INFO
{
    DWORD    dwSize;
    DWORD    dwSignalIndex;    //信号源序号，该参数用于大屏控制器，其他设备该值设为0
    DWORD    dwDeviceIndex;//设备序号
    BYTE    byRes1[12];
    BYTE    byChanIndex;    //通道号
    BYTE    byRes2[3];
    //视频综合平台回显参数
    DWORD   dwScreenNum; //大屏序号：从零开始
    DWORD   dwLayer;     //图层号：从零开始
    DWORD   dwResolution;//回显分辨率,1-QCIF,2-CIF,3-D1
    BYTE    byFrame;//帧率，单位：帧/秒
    BYTE    bySupportStreamView; //客户端是否支持码流回显，0-不支持，1-支持
    BYTE    byRes3[14];
}NET_DVR_START_PIC_VIEW_INFO, *LPNET_DVR_START_PIC_VIEW_INFO;

typedef struct tagNET_DVR_DVCS_STATE_ALARM
{
    DWORD    dwSize;
    BYTE    byAlarmType;        // 报警类型,1-设备上线，2-设备离线 3-服务器上线 4-服务器离线 5-管理员登陆 6-预案开始,7-预案结束，8-分辨率变化，9-图像切割失败，10-设备资源不足，11-温度异常  12-窗口大小与信号源分辨率不符合*/
    BYTE    byDeviceType;        // 设备类型 见定义NET_DVCS_DEVICE_TYPE */ 
    BYTE    byWallNo;            // 墙号，从1开始， 0表示无效
    BYTE    byDeviceChanIndex;     // 设备通道号，0表示无效，其他值表示通道号
    DWORD    dwDeviceIndex;        // 设备序号， 0表示无效
    WORD    wResolutionX;        // 分辨率-宽  0表示无效
    WORD    wResolutionY;        // 分辨率-高  0表示无效
    WORD    wTemperature;       // 设备温度 单位：摄氏度, 0表示无效 
    BYTE    byRes[86];
}NET_DVR_DVCS_STATE_ALARM, *LPNET_DVR_DVCS_STATE_ALARM;

typedef struct tagNET_DVR_PIC_ADJUST
{
    DWORD        dwSize;
    BYTE        bySubCommand;        //见宏定义DECODEPIC_LEFTADJUST等
    BYTE        byScale;            //调整的量值
    BYTE        byPictureProportion;    //图像缩放比例 0-无效 1-4:3, 2-16:9
    BYTE        byRes[29];            
}NET_DVR_PIC_ADJUST, *LPNET_DVR_PIC_ADJUST;

typedef struct tagNET_DVR_PICTURE_PARAM
{
    DWORD    dwSize;        
    BYTE    byControlCommand;    //切换命令，1-显示，2-隐藏，3-全部删除（针对GIF图片    ）
    BYTE    byUseType;            //图片类型，1-OSD 2-底图，3-GIF
    BYTE    byWallNo;            //电视墙墙号，从1开始
    BYTE    byPictureNo;        //图片序号
    BYTE    byRes[64];
}NET_DVR_PICTURE_PARAM, *LPNET_DVR_PICTURE_PARAM;

typedef struct tagNET_DVR_POE_CHANNEL_ADD_MODE
{
    DWORD        dwSize;                  //结构体大小
    BYTE         byAddMode;                 //添加方式 0: 即插即用 1: 手动添加    
    BYTE          byRes1[127];              //保留
}NET_DVR_POE_CHANNEL_ADD_MODE, *LPNET_DVR_POE_CHANNEL_ADD_MODE;

typedef struct tagNET_DVR_ESATA_MINISAS_USAGE
{
    DWORD        dwSize;
    BYTE        byESATAUsage[MAX_ESATA_NUM];        // 数组索引表示第几个eSATA，0：默认备份 1：默认录像
    BYTE        byMiniSASUsage[MAX_MINISAS_NUM];    // 数组索引表示第几个miniSAS，0：默认备份 1：默认录像
    BYTE         byRes[32];
}NET_DVR_ESATA_MINISAS_USAGE, *LPNET_DVR_ESATA_MINISAS_USAGE;

typedef struct tagNET_DVR_BACKUP_LOG_PARAM
{
    DWORD        dwSize;
    BYTE        byDiskDesc[DESC_LEN_32];        //备份磁盘描述
    BYTE        byHardDisk[MAX_DISK_NUM];        //需备份的硬盘号，备份几个取前几个 
    BYTE        byBackupHardDiskNum;              //需备份的硬盘个数
    BYTE        byContinue;                        //是否继续备份，0-不继续，1-继续
    BYTE        byAllLogBackUp ;        /*是否全部备份，0-按磁盘号备份，1-备份所有日志，当为1时，需备份的磁盘号和硬盘个数无效*/
    BYTE         byRes[29];
}NET_DVR_BACKUP_LOG_PARAM, *LPNET_DVR_BACKUP_LOG_PARAM;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_STATE
{
    DWORD    dwSize;
    BYTE    byDigitalAudioChanTalkState[MAX_CHANNUM_V30];  //表示数字语音通道的对讲状态 0-未使用，1-使用中, 0xff无效
    BYTE    byDigitalChanState[MAX_CHANNUM_V30];  /*数字通道的连接状态 byDigitalChanErrState[0] 
                                               表示第一个数字通道，具体值表示状态码，祥见NET_SDK_DIGITAL_CHANNEL_STATUS，以此类推，0表示无效*/
    BYTE    byDigitalAudioChanTalkStateEx[MAX_CHANNUM_V30*3];  //表示数字语音通道的对讲状态，从第MAX_CHANNUM_V30+1 到第MAX_CHANNUM_V30*4个， 0-未使用，1-使用中, 0xff无效
    BYTE    byDigitalChanStateEx[MAX_CHANNUM_V30*3];  /*数字通道的连接状态 byDigitalChanErrStateEx[0]表示第从第MAX_CHANNUM_V30+1个个数字通道，具体值表示状态码，祥见NET_SDK_DIGITAL_CHANNEL_STATUS，以此类推，0表示无效*/
    BYTE    byAnalogChanState[MAX_ANALOG_CHANNUM];//表示模拟通道是否启用,0-禁用,1-启用
    BYTE    byRes[32];
}NET_DVR_DIGITAL_CHANNEL_STATE, *LPNET_DVR_DIGITAL_CHANNEL_STATE;


typedef struct tagNET_ITS_BASEINFO
{
    DWORD   dwSize;    
    BYTE    byMainVer[VERSION_LEN];    // 算法主流程版本
    BYTE    byMprVer[VERSION_LEN];    // 多帧识别库版本
    BYTE    byBvtVer[VERSION_LEN];    // 背向视频库版本
    BYTE    byLptVer[VERSION_LEN];    // 视频跟踪库版本
    BYTE    byTvdVer[VERSION_LEN];    // 违章检测库版本
    BYTE    byTldVer[VERSION_LEN];    // 信号灯检测库版本
    BYTE    byRes[252];        // 预留字段
}NET_ITS_BASEINFO,*LPNET_ITS_BASEINFO;

typedef struct tagNET_ITS_IMGMERGE_CFG
{
    DWORD  dwSize;
    BYTE   byIsMerge;        //是否需要合成（0：不合成；1：合成）
    BYTE   byCloseupProportion;//特写图比例 1-原始分辨率大小，2-宽高为原始分辨率两倍，以此类推(1～8)
    BYTE   byRes1[2];
    DWORD  dwOneMergeType;    //抓拍单张图合成方式（可能会截取特写图）
    /************************************************************************/
    /* 201 两张图片上下排列合成,合成后图片宽为单张图的1倍,高为2倍         */
    /* 202 两张图片左右排列合成,合成后图片宽为单张图的2倍,高为1倍         */
    /* 203 上下合成，特写在最上边.                                          */
    /* 204 上下合成，特写在最下边.                                        */
    /* 205 左右合成，特写在最右边。                                       */
    /* 206 左右合成，特写在最左边                                         */
    /* 207 品字合成，特写图在上边                                         */
    /* 208 倒品字合成，特写图在下边                                       */
    /* 209 唱字形，左边1张为特写                                          */
    /* 210 反唱字形，右边1张为特写                                        */
    /* 301 三张图片上下排列合成,合成后图片宽为单张图的1倍,高为3倍         */
    /* 302 三张图片左右排列合成,合成后图片宽为单张图的3倍,高为1倍          */
    /* 303 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右下;合成后图片宽为单张图的2倍,高为2倍                      */
    /* 304 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右下;合成后图片宽为单张图的1倍,高为1倍                      */
    /* 305 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左上;合成后图片宽为单张图的2倍,高为2倍                      */
    /* 306 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左上;压缩图片分辨率,合成后图片宽为单张图的1倍,高为1倍      */
    /* 307 三张图片"品"字型排列合成                                          */
    /* 308 三张图片倒"品"字型排列合成                                      */
    /* 309 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左下;合成后图片宽为单张图的2倍,高为2倍                          */
    /* 310 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在左下;合成后图片宽为单张图的1倍,高为1倍                          */
    /* 311 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右上;合成后图片宽为单张图的2倍,高为2倍                          */
    /* 312 从三张图片中取一幅车牌特写区域,组成四张图片;四张图片"田"字型合成,
    特写在右上;压缩图片分辨率,合成后图片宽为单张图的1倍,高为1倍      */
    
    /* 313 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：特写图、场景图、场景图、场景图                         */
    /* 314 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：场景图、特写图、场景图、场景图                         */
    /* 315 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：场景图、场景图、特写图、场景图                         */                   
    /* 316 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片横"一"字型合成，
    顺序为：场景图、场景图、场景图、特写图                         */  
    /* 317 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：特写图、场景图、场景图、场景图                         */
    /* 318 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：场景图、特写图、场景图、场景图                         */  
    /* 319 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：场景图、场景图、特写图、场景图                         */ 
    /* 320 从三张图片中取一幅车牌特写区域，组成四张图片；
    四张图片竖"1"字型合成，
    顺序为：场景图、场景图、场景图、特写图                         */     
    /************************************************************************/
    DWORD  dwTwoMergeType;    //抓拍两张图合成方式
    DWORD  dwThreeMergeType;    //抓拍三张图合成方式
    DWORD  dwJpegQuality;      //压缩质量（0~100）
    DWORD  dwCloseupIndex;     //特写图抓拍第几张
    DWORD  dwMerageMaxSize;   //合成图片大小的上限,300-10240(单位KB)
    WORD   wCloseupDeviation; // 特写图偏移量(50~图片高度)，单位:像素
    BYTE   byRes[30];
}NET_ITS_IMGMERGE_CFG,*LPNET_ITS_IMGMERGE_CFG;



typedef struct tagNET_DVR_SYSTEM_TIME
{
    WORD  wYear;           //年
    WORD  wMonth;          //月
    WORD  wDay;            //日
    WORD  wHour;           //时
    WORD  wMinute;      //分
    WORD  wSecond;      //秒
    WORD  wMilliSec;    //毫秒
    BYTE  byRes[2];
}NET_DVR_SYSTEM_TIME, *LPNET_DVR_SYSTEM_TIME;




typedef struct tagNET_ITS_ECTWORKSTATE
{ 
    DWORD     dwSize ;
    BYTE     byDevName[NAME_LEN];    // 设备名称
    DWORD    dwRunTime;        // 系统运行时间，单位s
    NET_ITS_TRAFFIC_DATA_INFO    struTrafficDataInfo[2]; //支持两台主机（数据上传配置的主机）
    DWORD    dwMemoryUsage;    // 内存占用率（如果内存占用率为30%，此处填30）
    DWORD    dwCpuUsage;        // cpu占用率（如果cpu占用率为30%，此处填30）
    DWORD    dwDevTemperature;    // 本机温度
    DWORD    dwDeviceStatic;     // 设备的状态,0-正常,1-CPU占用率太高,超过85%,2-硬件错误,例如串口死掉
    NET_DVR_DISKSTATE  struHardDiskStatic[MAX_DISKNUM_V30];   //硬盘状态
    BYTE     byAlarmInStatic[MAX_ALARMIN_V30];  //报警输入口的状态,0-没有报警,1-有报警
    BYTE     byAlarmOutStatic[MAX_ALARMOUT_V30]; //报警输出端口的状态,0-没有输出,1-有报警输出
    DWORD    dwLocalDisplay;            //本地显示状态,0-正常,1-不正常
    BYTE     byRes[256];             //保留
}NET_ITS_ECTWORKSTATE, *LPNET_ITS_ECTWORKSTATE;

typedef struct tagNET_ITS_PICTURE_INFO
{
    DWORD   dwDataLen;            //媒体数据长度
    // 0:车牌图;1:车辆图;2:合成图; 3:特写图;4:二直图;5:码流;6:人脸子图(主驾驶);7:人脸子图(副驾驶)成图;8-非机动车;9-行人;10-称重原始裸数据;11-目标图;12-主驾驶室图 ;13-副驾驶室图;14-人脸图抠小图
    //15 - 自定义图片(用户自己上传进行违法检测的图片)
    BYTE    byType;            
    // 0-数据直接上传; 1-云存储服务器URL(3.7Ver)原先的图片数据变成URL数据，图片长度变成URL长度
    BYTE    byDataType;
    BYTE    byCloseUpType;//特写图类型，0-保留,1-非机动车,2-行人
    BYTE    byPicRecogMode;  //图片背向识别：0-正向车牌识别，1-背向识别(尾牌识别) ；
    DWORD   dwRedLightTime;        //经过的红灯时间  （s）
    BYTE    byAbsTime[32];        //绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999  最后三位为毫秒数
    NET_VCA_RECT   struPlateRect;    //车牌位置,当byType为8-非机动车;9-行人时，表示人体坐标
    NET_VCA_RECT  struPlateRecgRect;   //牌识区域坐标，当图片类型为12-主驾驶室图13-副驾驶室图是，该坐标为驾驶员坐标
    BYTE    *pBuffer;    //数据指针
    DWORD   dwUTCTime;//UTC时间定义
    BYTE    byCompatibleAblity; //兼容能力字段 0表示无效，1表示有效; bit0-表示dwUTCTime字段有效
    BYTE    byTimeDiffFlag;      /*时差字段是否有效  0-时差无效， 1-时差有效 */
    char    cTimeDifferenceH;         /*与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效*/
    char    cTimeDifferenceM;      	/*与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效*/
    BYTE    byRes2[4];           //保留
}NET_ITS_PICTURE_INFO, *LPNET_ITS_PICTURE_INFO;

typedef struct tagNET_ITS_ILLEGAL_INFO
{
    BYTE  byIllegalInfo[MAX_ILLEGAL_LEN/*64*/];// 违章类型信息（字符格式）
    BYTE  byRes[256];
}NET_ITS_ILLEGAL_INFO,*LPNET_ITS_ILLEGAL_INFO;

typedef struct tagNET_ITS_PLATE_RESULT
{
    DWORD   dwSize;        //结构长度
    DWORD   dwMatchNo;        //匹配序号,由(车辆序号,数据类型,车道号)组成匹配码
    BYTE    byGroupNum;    //图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
    BYTE    byPicNo;        //连拍的图片序号（接收到图片组数量后，表示接收完成;接收超时不足图片组数量时，根据需要保留或删除）
    BYTE    bySecondCam;    //是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）
    BYTE    byFeaturePicNo; //闯红灯电警，取第几张图作为特写图,0xff-表示不取
    BYTE    byDriveChan;        //触发车道号
    BYTE    byVehicleType;     //车辆类型，参考VTR_RESULT
    BYTE    byDetSceneID;//检测场景号[1,4], IPC默认是0
    //车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
    //该节点已不再使用,使用下面的byYellowLabelCar和byDangerousVehicles判断是否黄标车和危险品车
    BYTE    byVehicleAttribute;
    WORD    wIllegalType;       //违章类型采用国标定义
    BYTE    byIllegalSubType[8];   //违章子类型
    BYTE    byPostPicNo;    //违章时取第几张图片作为卡口图,0xff-表示不取
    //通道号(有效，报警通道号和所在设备上传报警通道号一致，在后端和所接入的 通道号一致)
    BYTE    byChanIndex;        
    WORD    wSpeedLimit;        //限速上限（超速时有效）
    BYTE    byChanIndexEx;      //byChanIndexEx*256+byChanIndex表示真实通道号。
    /*车辆方位布控标志,0~为普通车牌识别报警,
    1~为车辆位置布控触发报警(即通过PUT /ISAPI/Traffic/channels/<ID>/vehiclePositionControl?format=json触发)。
    2~为车辆智能布控触发报警(包含多预置点及GPS车辆布控)(即通过PUT /ISAPI/Traffic/channels/<ID>/vehicleMonitor/<taskID>/startTask触发,
    但在unarmedVehicleDetectionEnable（非目标车辆检测使能）为true时，只上报车辆检测报警，无车辆智能布控报警，因此该字段取值为0，而不是2)。
    3~为手动车辆布控触发报警(/ISAPI/Traffic/channels/<ID>/manualVehicleMonitor?format=json)
    4~为日常布控(复用车辆检测配置)可通过车辆检测能力中区分是否支持日常车辆布控,
        (即通过/ISAPI/Traffic/channels/<ID>/vehicleDetect/capabilities中isSupportDailyVehicleMonitor判断,日常车辆布控时,设备不仅会上报ANPR报警还会实时上报vehicleMonitor车辆布控报警)
        若不返回该字段则代表为普通车辆检测
    */
    BYTE    byVehiclePositionControl;  
    NET_DVR_PLATE_INFO  struPlateInfo;     //车牌信息结构
    NET_DVR_VEHICLE_INFO struVehicleInfo;    //车辆信息
    BYTE    byMonitoringSiteID[48];        //监测点编号
    BYTE    byDeviceID[48];                //设备编号
    BYTE    byDir;            //监测方向，1-上行（反向），2-下行(正向)，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南，8-其它
    BYTE    byDetectType;    //检测方式,1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）,2表示未知
    //当wIllegalType参数为空时，使用该参数。若wIllegalType参数为有值时，以wIllegalType参数为准，该参数无效。
    DWORD   dwCustomIllegalType; //违章类型定义(用户自定义)
    /*为0~数字格式时，为老的违章类型，wIllegalType、dwCustomIllegalType参数生效，赋值国标违法代码。
      为1~字符格式时，pIllegalInfoBuf参数生效。老的违章类型，wIllegalType、dwCustomIllegalType参数依然赋值国标违法代码*/
    BYTE*   pIllegalInfoBuf;    //违法代码字符信息结构体指针；指向NET_ITS_ILLEGAL_INFO 
    BYTE    byIllegalFromatType; //违章信息格式类型； 0~数字格式， 1~字符格式
    BYTE    byPendant;// 0-表示未知,1-车窗有悬挂物，2-车窗无悬挂物
    BYTE    byDataAnalysis;            //0-数据未分析, 1-数据已分析
    BYTE    byYellowLabelCar;        //0-表示未知, 1-非黄标车,2-黄标车
    BYTE    byDangerousVehicles;    //0-表示未知, 1-非危险品车,2-危险品车
    //以下字段包含Pilot字符均为主驾驶，含Copilot字符均为副驾驶
    BYTE    byPilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE    byCopilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE    byPilotSunVisor;//0-表示未知,1-不打开遮阳板,2-打开遮阳板
    BYTE    byCopilotSunVisor;//0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    BYTE    byPilotCall;// 0-表示未知, 1-不打电话,2-打电话
    //0-开闸，1-未开闸 (专用于历史数据中相机根据名单匹配后，是否开闸成功的标志)；当byAlarmDataType为0-实时数据时 0-未开闸 1-开闸
    BYTE    byBarrierGateCtrlType; 
    BYTE    byAlarmDataType;//0-实时数据，1-历史数据
    NET_DVR_TIME_V30  struSnapFirstPicTime;//端点时间(ms)（抓拍第一张图片的时间）
    DWORD   dwIllegalTime;//违法持续时间（ms） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
    DWORD   dwPicNum;        //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义    
    NET_ITS_PICTURE_INFO struPicInfo[6];         //图片信息,单张回调，最多6张图，由序号区分
}NET_ITS_PLATE_RESULT, *LPNET_ITS_PLATE_RESULT;

typedef struct tagNET_ITS_GATE_VEHICLE
{
    DWORD   dwSize;        //结构长度
    DWORD   dwMatchNo;        //匹配序号,由(车辆序号,数据类型,车道号)组成匹配码 默认0
    BYTE    byGroupNum;    //图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）默认 1 抓拍类型下图片数据 控制后续接收延时操作
    BYTE    byPicNo;        //连拍的图片组上传图片序号（接收到图片组数量后，表示接收完成。
    //接收超时不足图片组数量时，根据需要保留或删除）
    BYTE    bySecondCam;    //是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）标示前后相机抓拍图片
    BYTE    byRes; //标记为预留
    WORD    wLaneid;            //车道号1～32（索引车道号，可以跳跃）
    BYTE    byCamLaneId;    //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    BYTE    byRes1;            //保留
    BYTE    byAlarmReason[MAX_ALARMREASON_LEN]; //自定义报警类型 默认为中文
    WORD    wBackList;    //标记为是否报警数据 0 表示为正常过车数据 1 表示禁止名单
    WORD    wSpeedLimit;        //限速上限（超速时有效）km/h
    DWORD   dwChanIndex;        //通道号
    NET_DVR_PLATE_INFO    struPlateInfo;     //车牌信息结构
    NET_DVR_VEHICLE_INFO  struVehicleInfo;    //车辆信息  含速度
    BYTE    byMonitoringSiteID[MAX_ID_LEN];        //监测点编号
    BYTE    byDeviceID[MAX_ID_LEN];                //设备编号 
    BYTE    byDir;            //监测方向，0-其它 1 入场，2 出场
    BYTE    byDetectType;    //检测方式, 0-其他 1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
    BYTE    byRes2[2];
    BYTE    byCardNo[MAX_ID_LEN]; // 卡号
    DWORD   dwPicNum;        //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义    
    NET_ITS_PICTURE_INFO struPicInfo[4];         //图片信息,单张回调，最多4张图，由序号区分
    //2013-11-19 出入口车辆抓拍数据上传（监听方式）新增参数
    BYTE    bySwipeTime[MAX_TIME_LEN];//增加刷卡时间  时间格式为yyyymmddhh24missfff
    BYTE    byRes3[224];
}NET_ITS_GATE_VEHICLE, *LPNET_ITS_GATE_VEHICLE;


typedef struct _tagNET_ITS_PARK_VEHICLE_
{
    DWORD   dwSize; //结构长度
    BYTE    byGroupNum; //图片组数量（单次轮询抓拍的图片数量）
    BYTE    byPicNo; //连拍的图片组上传图片序号（接收到图片组数量后，表示接收完成
    //接收超时不足图片组数量时，根据需要保留或删除）
    BYTE    byLocationNum; //单张图片所管理的车位数
    BYTE    byParkError; //停车异常，0-正常 1 异常
    BYTE    byParkingNo[MAX_PARKNO_LEN];//车位编号
    BYTE    byLocationStatus; //车位车辆状态，0-无车，1有车
    BYTE    bylogicalLaneNum;//逻辑车位号，0-3，一个相机最大能管4个车位 （0代表最左边，3代表最右边）
    WORD    wUpLoadType;//第零位表示：0~轮巡上传、1~变化上传
    BYTE    byRes1[4]; //保留字节
    DWORD   dwChanIndex; //通道号数字通道
    NET_DVR_PLATE_INFO   struPlateInfo;  //车牌信息结构
    NET_DVR_VEHICLE_INFO struVehicleInfo; //车辆信息
    BYTE    byMonitoringSiteID[MAX_ID_LEN]; //监测点编号
    BYTE    byDeviceID[MAX_ID_LEN]; //设备编号 
    DWORD   dwPicNum; //图片数量（与picGroupNum不同，代表本条信息附带的图片数量
    //，图片信息由struVehicleInfoEx定义 
    NET_ITS_PICTURE_INFO struPicInfo[2];  //图片信息,单张回调，最多2张图，由序号区分
    BYTE   byRes2[256];
}NET_ITS_PARK_VEHICLE, *LPNET_ITS_PARK_VEHICLE;

typedef struct tagNET_DVR_TFS_ALARM
{
    DWORD                   dwSize;                //结构体大小
    DWORD                   dwRelativeTime;        //相对时标
    DWORD                   dwAbsTime;               //绝对时标
    DWORD                   dwIllegalType;         //违章类型，采用国标定义，当dwIllegalType值为0xffffffff时使用byIllegalCode
    DWORD                   dwIllegalDuration;     //违法持续时间（单位：秒） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
    BYTE                    byMonitoringSiteID[MONITORSITE_ID_LEN];//监测点编号（路口编号、内部编号）
    BYTE                    byDeviceID[DEVICE_ID_LEN];             //设备编号
    NET_VCA_DEV_INFO        struDevInfo;           //前端设备信息
    NET_DVR_SCENE_INFO      struSceneInfo;         //场景信息
    NET_DVR_TIME_EX         struBeginRecTime;      //录像开始时间 
    NET_DVR_TIME_EX         struEndRecTime;        //录像结束时间 
    NET_DVR_AID_INFO        struAIDInfo;           //交通事件信息
    NET_DVR_PLATE_INFO      struPlateInfo;         //车牌信息
    NET_DVR_VEHICLE_INFO    struVehicleInfo;       //车辆信息
    DWORD                   dwPicNum;              //图片数量
    NET_ITS_PICTURE_INFO    struPicInfo[8];        //图片信息，最多8张 
    BYTE                    bySpecificVehicleType;     //具体车辆种类  参考识别结果类型VTR_RESULT
    BYTE                    byLaneNo;  //关联车道号
	WORD                    wDevInfoIvmsChannelEx; //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    NET_DVR_TIME_V30        struTime;//手动跟踪定位，当前时间。
    DWORD                   dwSerialNo;//序号；
    BYTE                    byVehicleAttribute;//车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
    BYTE                    byPilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE                    byCopilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE                    byPilotSunVisor;//0-表示未知,1-不打开遮阳板,2-打开遮阳板
    BYTE                    byCopilotSunVisor;//0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    BYTE                    byPilotCall;// 0-表示未知, 1-不打电话,2-打电话
    BYTE                    byRes2[2]; //保留
    BYTE                    byIllegalCode[ILLEGAL_LEN/*32*/];//违法代码扩展，当dwIllegalType值为0xffffffff；使用这个值
    WORD                    wCountry; // 国家索引值,参照枚举COUNTRY_INDEX
    BYTE                    byRegion; //区域索引值,0-保留，1-欧洲(Europe Region)，2-俄语区域(Russian Region)，3-欧洲&俄罗斯(EU&CIS) , 4-中东（Middle East），0xff-所有
    BYTE                    byCrossLine;//是否压线停车（侧方停车），0-表示未知，1-不压线，2-压线
    BYTE                    byParkingSerialNO[SERIAL_NO_LEN/*16*/];//泊车位编号
    BYTE                    byCrossSpaces;//是否跨泊车位停车（侧方停车），0-表示未知，1-未跨泊车位停车，2-跨泊车位停车
    BYTE                    byAngledParking;//是否倾斜停车（侧方停车）, 0-表示未知，1-未倾斜停车，2-倾斜停车
    BYTE                    byAlarmValidity;//报警置信度，可以输出驶入驶出的置信度，范围0-100；置信度越高，事件真实性越高
    BYTE                    byDoorsStatus;//车门状态 0-车门关闭 1-车门开启
    DWORD               dwXmlLen;//XML报警信息长度
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    char*                   pXmlBuf; // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
#else
    char*                   pXmlBuf; // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
    BYTE                   byRes3[4];
#endif  
    BYTE                   byVehicleHeadTailStatus;//车头车尾状态 0-保留 1-车头 2-车尾
	BYTE                   byBrokenNetHttp;        //断网续传标志位，0-不重传数据，1-重传数据
    BYTE                   byRes[30];              //保留
}NET_DVR_TFS_ALARM,*LPNET_DVR_TFS_ALARM;

typedef struct tagNET_DVR_SOFTWARE_SERVICE_CFG
{
    DWORD       dwSize;//结构体大小
    BYTE        byThirdStreamEnabled;  //是否开启三码流配置：0-否，1-是
    BYTE        bySubStreamEnabled;  //是否开启子码流配置：0-否，1-是
    BYTE        byRes[254];
}NET_DVR_SOFTWARE_SERVICE_CFG, *LPNET_DVR_SOFTWARE_SERVICE_CFG;

typedef struct tagNET_ITS_ECT_BLOCKLIST
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  bylogicalLaneNo;//逻辑车道号
    BYTE  byRes1[3];
    BYTE  byLaneName[NAME_LEN];//车道名称 32
    NET_DVR_PLATE_INFO  struPlateInfo;  //车牌信息结构  
    BYTE  byRes2[256];       // 保留字节    
}NET_ITS_ECT_BLOCKLIST, *LPNET_ITS_ECT_BLOCKLIST;


typedef struct tagNET_ITS_SINGLE_DEVICE_INFO
{
    DWORD  dwDeviceType;  //设备类型：0-终端，1-相机，2-补光灯，3-车检器，4-线圈1，5-线圈2，6-线圈3，7-红绿灯检测器，8-机柜，
    //9-雷达，10-道闸，11-出入口控制机(票箱)，12-LED显示屏，13-远距离读卡器，14-近距离读卡器，15-红外扫描枪，
    //16-票据打印机，17-节点管理器(诱导服务器相关) , 18-机柜检测仪
    DWORD  dwDirID;               //方向编号
    DWORD  dwLaneID;             //车道编号
    DWORD  dwDeviceState;         //设备状态  0正常 非0 异常（参考设备异常代码表）
    BYTE   byDeviceName[32];     //设备名称
    BYTE   byDeviceID[48];           //设备编号，一般用序列号，车检器用地址
    NET_DVR_TIME_V30  struTriggerTime;//触发时间
    BYTE   byRelateChan; //关联通道号（传感器是1~8  AC端子1~4  AC插座1~2）
    BYTE   byRes[3];
}NET_ITS_SINGLE_DEVICE_INFO,*LPNET_ITS_SINGLE_DEVICE_INFO;

typedef struct tagNET_ITS_ROADINFO
{    
    DWORD     dwSize;
    DWORD     dwChannel;          //通道号,0xffffffff表示终端，其它表示对应的相机
    BYTE     byTriggerMode;    //  0:线圈触发;  1:视频触发
    BYTE     byRes1[3];
    DWORD    dwDeviceNum;       //实际设备个数 
    BYTE     byMonitoringSiteID[48];    //监测点编号
    BYTE       byRoadInfo[48];       //监测点信息
    NET_ITS_SINGLE_DEVICE_INFO        struSingleDevice[ITS_MAX_DEVICE_NUM];
    BYTE     byRes[16];
}NET_ITS_ROADINFO,*LPNET_ITS_ROADINFO;

typedef struct tagNET_ITS_TRAFFIC_DRIVE_CHAN
{
    BYTE   byDriveChan;        //车道号
    BYTE   byRes1[3];            // 预留
    WORD   wCarFlux;            //汽车流量数
    WORD   wPasserbyFlux;        //行人流量数
    WORD   wShayFlux;        //二轮车流量数
    float  fAverOccpancy;       //平均车道占有率百分比
    WORD   wAverSpeed;         //平均车速(km/h)
    WORD   wAverCarDis;        //平均车距(单位待定)
    BYTE   byRes2[16];            // 预留
}NET_ITS_TRAFFIC_DRIVE_CHAN,*LPNET_ITS_TRAFFIC_DRIVE_CHAN;

typedef struct tagNET_ITS_TRAFFIC_COLLECT
{
    DWORD  dwSize;        //结构大小
    BYTE   byMonitoringSiteID[48];        //监测点编号
    BYTE   byDeviceID[48];                //设备编号
    BYTE   byLaneNum;    //车道总数
    BYTE   byDir;        //监测方向
    BYTE   byDetectType;    //检测方式1-地感线圈、2-视频触发、3、多帧识别、4雷达触发
    BYTE   byRes1;           //预留     
    DWORD  dwChannel; //通道号
    NET_DVR_SYSTEM_TIME     struStartTime;        //统计开始时间
    DWORD  dwSamplePeriod;    //统计时间,单位秒
    NET_ITS_TRAFFIC_DRIVE_CHAN    struDriveChan[6];         //交通流量数据,每个相机支持6个车道
    BYTE   byRes2[24];     //预留
}NET_ITS_TRAFFIC_COLLECT,*LPNET_ITS_TRAFFIC_COLLECT;

typedef struct tagNET_ITS_OVERLAPCFG_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwConfigMode; //配置模式，0-终端，1-前端(直连前端或终端接前端)
    BYTE  byPicModeType;//0-表示小图(独立图)，1-表示大图(合成图)
                        /*
                        0表示关联 抓拍MPR模式（多帧触发抓拍 IPC使用）
                        1 表示关联 抓拍 HVT 模式（混卡IPC使用）
    */
    BYTE  byRelateType; 
    BYTE  byRes[14];
}NET_ITS_OVERLAPCFG_COND, *LPNET_ITS_OVERLAPCFG_COND;


typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM
{
    BYTE byRes1[2];                   // 保留
    BYTE byItemType;   //类型，详见OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;           //叠加项后的换行数[0-10](默认0)
    BYTE bySpaceNum;                   //叠加项后的空格数[0-255](默认0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //是否启用坐标显示
    WORD wStartPosTop;    //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD wStartPosLeft;    //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM struSingleItem[MAX_OVERLAP_ITEM_NUM]; //单条字符参数
    DWORD dwLinePercent;  //叠加行百分比(0-100),(默认100)
    DWORD dwItemsStlye;   //叠加方式：0-横排,1-竖排(默认横排)
    WORD  wStartPosTop;    //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD  wStartPosLeft;    //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD  wCharStyle;    //字体类型,0-宋体1-魏体(默认)
    WORD  wCharSize;    //字符大小,0--16x16,1--32x32,2-48x48,3--64x64 (默认),8x128(Ver3.7)
    WORD  wCharInterval;    //字符间距，[0～16]，可设单位：像素(默认)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB;      //前景色的RGB值bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00FFFFFF-白)
    DWORD dwBackClorRGB; //背景色的RGB值,只对图片外叠加有效bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00000000-黑)
    BYTE  byColorAdapt;    //颜色是否自适应0-否1-是
    //(Ver3.7 新增)
    // 参数补零使能 0-补零, 1-不补零（详细注释）速度,限速值 不足3位补0
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// 车牌小图叠加左上角使能 0-不叠加, 1-叠加
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //起始上坐标,只对图片内部叠加有效[0~2448](默认0) 
    WORD  wStartSPicPosLeft; //起始左坐标,只对图片内部叠加有效[0~2448](默认0) 
    //OSD叠加位置  0-图片内,1-图片上边缘,2-图片下边缘（合成图专用的是上边缘外）（V3.7）
    BYTE       byOsdLocate;
    BYTE         byRes[23];
}NET_ITS_OVERLAP_ITEM_PARAM, *LPNET_ITS_OVERLAP_ITEM_PARAM;

typedef struct tagNET_ITS_OVERLAP_INFO_PARAM
{
    BYTE bySite[128];           //地点描述
    BYTE byRoadNum[32];  //路口编号
    BYTE byInstrumentNum[32];                //设备编号
    BYTE byDirection[32];        //方向编号
    BYTE byDirectionDesc[32];    //方向描述
    BYTE byLaneDes[32];        //车道描述
    BYTE byRes1[32];     //保留
    BYTE byMonitoringSite1[44];        //监测点1信息
    BYTE byMonitoringSite2[32];        //监测点2信息
    BYTE byRes[64];        //保留
}NET_ITS_OVERLAP_INFO_PARAM, *LPNET_ITS_OVERLAP_INFO_PARAM;

typedef struct tagNET_ITS_OVERLAP_CFG
{
    DWORD dwSize;    
    BYTE  byEnable; //是否启用，0-不启用，1-启用
    BYTE  byRes1[3]; 
    NET_ITS_OVERLAP_ITEM_PARAM        struOverLapItem; //字符串参数
    NET_ITS_OVERLAP_INFO_PARAM     struOverLapInfo;  //字符串内容信息
    BYTE  byRes[32];
}NET_ITS_OVERLAP_CFG, *LPNET_ITS_OVERLAP_CFG;

typedef struct tagNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50
{
    BYTE byRes1[2];                   // 保留
    BYTE byItemType;   //类型，详见OVERLAP_ITEM_TYPE
    BYTE byChangeLineNum;           //叠加项后的换行数[0-10](默认0)
    BYTE bySpaceNum;                   //叠加项后的空格数[0-255](默认0)
    BYTE byRes2[2];
    BYTE byEnablePos;  //是否启用坐标显示
    WORD wStartPosTop;    //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD wStartPosLeft;    //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    //自定义类型；与byItemType参数对应。可将byItemType参数类型自定义名称。若自定义内容为空，便默认以byItemType参数中的类型命名。
    BYTE byItemTypeCustom[32]; 
    BYTE byRes[8];
}NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_ITEM_PARAM_V50
{
    NET_ITS_OVERLAP_SINGLE_ITEM_PARAM_V50 struSingleItem[MAX_OVERLAP_ITEM_NUM]; //单条字符参数
    DWORD dwLinePercent;  //叠加行百分比(0-100),(默认100)
    DWORD dwItemsStlye;   //叠加方式：0-横排,1-竖排(默认横排)
    WORD  wStartPosTop;    //起始上坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD  wStartPosLeft;    //起始左坐标,只对图片内部叠加有效[0~2448](默认0)
    WORD  wCharStyle;    //字体类型,0-宋体1-魏体(默认)
    WORD  wCharSize;    //字符大小,0--16x16,1--32x32,2-48x48,3--64x64 (默认),8x128(Ver3.7)
    WORD  wCharInterval;    //字符间距，[0～16]，可设单位：像素(默认)
    BYTE  byRes1[2];
    DWORD dwForeClorRGB;      //前景色的RGB值bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00FFFFFF-白)
    DWORD dwBackClorRGB; //背景色的RGB值,只对图片外叠加有效bit0-1:(B) bit2-3:(G) bit4-5:(G) (默认x00000000-黑)
    BYTE  byColorAdapt;    //颜色是否自适应0-否1-是
    //(Ver3.7 新增)
    // 参数补零使能 0-补零, 1-不补零（详细注释）速度,限速值 不足3位补0
    BYTE  byParamFillZeroEnble;
    BYTE  byPlateLeftCornerEnable;// 车牌小图叠加左上角使能 0-不叠加, 1-叠加
    BYTE  byRes2;
    WORD  wStartSPicPosTop; //起始上坐标,只对图片内部叠加有效[0~2448](默认0) 
    WORD  wStartSPicPosLeft; //起始左坐标,只对图片内部叠加有效[0~2448](默认0) 
    //OSD叠加位置  0-图片内,1-图片上边缘,2-图片下边缘（合成图专用的是上边缘外）（V3.7）
    BYTE  byOsdLocate;
    BYTE  byRes[63];
}NET_ITS_OVERLAP_ITEM_PARAM_V50, *LPNET_ITS_OVERLAP_ITEM_PARAM_V50;

typedef struct tagNET_ITS_OVERLAP_CFG_V50
{
    DWORD dwSize;    
    BYTE  byEnable; //是否启用，0-不启用，1-启用
    BYTE  byRes1[3]; 
    NET_ITS_OVERLAP_ITEM_PARAM_V50        struOverLapItemV50; //字符串参数
    NET_ITS_OVERLAP_INFO_PARAM             struOverLapInfo;  //字符串内容信息
    BYTE  byRes[120];
}NET_ITS_OVERLAP_CFG_V50, *LPNET_ITS_OVERLAP_CFG_V50;

typedef struct tagNET_DVR_PRESET_INFO
{
    DWORD dwSize;
    DWORD dwPresetNum; //预置点个数
    DWORD dwGroupNum;  //组数
    BYTE  byRes[8];
}NET_DVR_PRESET_INFO, *LPNET_DVR_PRESET_INFO;

typedef struct tagNET_DVR_PRESET_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO; //组号
    BYTE byRes[8];
}NET_DVR_PRESET_COND, *LPNET_DVR_PRESET_COND;

typedef struct tagNET_DVR_PRESETCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex; //预置点序号
    NET_VCA_POINT struVcaPoint; //预置点坐标
    WORD wZoomCoordinate; ///<预置点窗口Zoom值
    BYTE  byRes[30]; 
}NET_DVR_PRESETCFG, *LPNET_DVR_PRESETCFG;

typedef struct tagNET_DVR_PTZCRUISE_INFO
{
    DWORD dwSize;
    DWORD dwPtzCruiseNum; //路径个数
    DWORD dwGroupNum; //组数
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_INFO, *LPNET_DVR_PTZCRUISE_INFO;

typedef struct tagNET_DVR_PTZCRUISE_COND
{
    DWORD dwSize;
    DWORD dwChannel;
    DWORD dwGroupNO; //组号
    BYTE byRes[8];
}NET_DVR_PTZCRUISE_COND, *LPNET_DVR_PTZCRUISE_COND;

typedef struct tagNET_DVR_PTZCRUISE_POINTCFG
{
    DWORD dwSize;
    DWORD dwPresetIndex; //预置点序号
    NET_VCA_POINT struVcaPoint; //预置点坐标
    BYTE    byDwell;        //停留时间
    BYTE    bySpeed;        //速度
    WORD  wZoomCoordinate;///<预置点窗口Zoom值
    BYTE   byRes[28]; 
}NET_DVR_PTZCRUISE_POINTCFG, *LPNET_DVR_PTZCRUISE_POINTCFG;

typedef struct tagNET_DVR_PTZCRUISECFG
{
    DWORD dwSize;
    DWORD dwCruiseRoute; //巡航路径序号
    NET_DVR_PTZCRUISE_POINTCFG struCruisePoint[MAX_PTZCRUISE_POINT_NUM]; //最大支持32个巡航点
    BYTE  byRes[32]; 
}NET_DVR_PTZCRUISECFG, *LPNET_DVR_PTZCRUISECFG;

typedef struct tagNET_DVR_MOTION_TRACK_CFG
{
    DWORD dwSize; 
    BYTE byEnableTrack;   //启用跟踪，0-否，1-是
    BYTE byRes[63];
}NET_DVR_MOTION_TRACK_CFG, *LPNET_DVR_MOTION_TRACK_CFG;

typedef struct tagNET_DVR_DAY_SCHEDULE
{   
    BYTE byWorkMode ;            //0-全天开，1-全天关，2-定时
    BYTE byRes1[3] ;
    NET_DVR_SCHEDTIME struTime[MAX_TIMESEGMENT_V30/*8*/];  //时间段
    BYTE byRes2[8];                  //保留
}NET_DVR_DAY_SCHEDULE ,*LPNET_DVR_DAY_SCHEDULE;

typedef struct tagNET_DVR_SCHEDULE_AUTO_TRACK_CFG
{
    DWORD    dwSize;    //结构长度
    BYTE     byEnableTrack;            //启用跟踪：0- 否，1- 是
    BYTE    byRes1[3] ;
    NET_DVR_DAY_SCHEDULE struSchedule[MAX_DAYS/*7*/];    //定时智能跟踪时间段，不在这8个时间段内的时间，默认定时智能跟踪关闭
    BYTE    byRes2[128];
}NET_DVR_SCHEDULE_AUTO_TRACK_CFG,*LPNET_DVR_SCHEDULE_AUTO_TRACK_CFG;

typedef struct tagNET_DVR_I_FRAME
{
    DWORD    dwSize;                    //结构长度
    BYTE    sStreamID[STREAM_ID_LEN/*32*/] ; //流ID
    DWORD    dwChan;                     //被控通道号
    BYTE    byStreamType;             //0-主码流，1-子码流，2-码流3，3-码流4，4-码流5     
    BYTE    byRes[63];
} NET_DVR_I_FRAME, *LPNET_DVR_I_FRAME;

typedef struct tagNET_DVR_REBOOT_TIME
{
    BYTE byDate;   //星期几，1-7代表星期一到星期日
    BYTE byHour;   //时
    BYTE byMinute; //分    
    BYTE byRes1;
    BYTE byRebootMode; //0-按周重启，1-按月重启（此参数只能获取，不能设置）
    BYTE byDisabled; // 0-启用 1-禁用
    BYTE byRes[10]; //保留
}NET_DVR_REBOOT_TIME,*LPNET_DVR_REBOOT_TIME;

typedef struct tagNET_DVR_AUTO_REBOOT_CFG
{
    DWORD dwSize;
    NET_DVR_REBOOT_TIME struRebootTime;
}NET_DVR_AUTO_REBOOT_CFG,*LPNET_DVR_AUTO_REBOOT_CFG;

typedef struct tagNET_DVR_MENU_OUTPUT_MODE
{
    DWORD        dwSize;
    BYTE        byMenuOutputMode; //非同源设备：0-Auto 1-主CVBS 2-HDMI 3-VGA 同源设备：0-Auto 1-主CVBS 2-HDMI/VGA
    BYTE        byRes[63];
}NET_DVR_MENU_OUTPUT_MODE, *LPNET_DVR_MENU_OUTPUT_MODE;

typedef struct tagNET_DVR_MB_IPADDR
{
    NET_DVR_IPADDR   struIP;  //IP地址
    WORD        wPort;   //端口号
    BYTE        byRes[2];
}NET_DVR_MB_IPADDR,*LPNET_DVR_MB_IPADDR;

typedef struct tagNET_DVR_MB_WVSPARA
{
    NET_DVR_MB_IPADDR struWVSAddr;
    BYTE byPuid[NAME_LEN];    //设备id
    BYTE byPassword[PASSWD_LEN];  //密码
    BYTE byRes[8];
}NET_DVR_MB_WVSPARA, *LPNET_DVR_MB_WVSPARA;

typedef struct tagNET_DVR_MB_EHOMEPARA
{
    NET_DVR_MB_IPADDR struEHomeAddr;
    BYTE byPuid[NAME_LEN];   //设备id
}NET_DVR_MB_EHOMEPARA, *LPNET_DVR_MB_EHOMEPARA;

typedef struct tagNET_DVR_MB_PLATFORMPARA
{   
    DWORD dwSize;
    BYTE byNetEnvironment;/*网络环境,0-wireless,1-3G,2-wLan,3-lan*/
    BYTE byCurPlatForm;   /*< 当前平台0 - WVS, 1 - E家, 2 - 推模式 */
    BYTE byRes1[2];    
    NET_DVR_MB_WVSPARA  struWVSPara; /*车载平台(平台登入)*/
    NET_DVR_MB_EHOMEPARA struMbEHpara;/*E家平台车载平台不设置设备登入密码 */
    BYTE byRes2[64];
}NET_DVR_MB_PLATFORMPARA, *LPNET_DVR_MB_PLATFORMPARA;

typedef struct tagNET_DVR_MB_GPS_STATUS
{
    BYTE        byGPSModule;      /*gps模块, 0: 不存在, 1: 正常*/
    BYTE        byPositionStatus;      /*gps定位状态, 0: 定位失败, 1: 定位成功*/
    BYTE        bySignalStrength;    /*信号强度, 0: 弱, 1: 正常, 2: 强*/
    BYTE        byres[5];
}NET_DVR_MB_GPS_STATUS, *LPNET_DVR_MB_GPS_STATUS;

typedef struct tagNET_DVR_MB_GSENSOR_STATUS
{
    BYTE        byGsensorModule;    /*g-sensor模块, 0: not exist, 1: 内置, 2: 外置*/
    BYTE        byCurAccX[10];     /*当前X轴加速度*/
    BYTE        byCurAccY[10];    /*当前Y轴加速度*/
    BYTE        byCurAccZ[10];    /*当前Z轴加速度*/
    BYTE        byRefAccX[10];    /* X轴加速度标定值*/
    BYTE        byRefAccY[10];    /* Y轴加速度标定值*/
    BYTE        byRefAccZ[10];    /* Z轴加速度标定值*/
    BYTE        byres[3];
}NET_DVR_MB_GSENSOR_STATUS, *LPNET_DVR_MB_GSENSOR_STATUS;

typedef struct tagNET_DVR_MB_WIFI_STATUS
{
    BYTE        byEnableWiFi; /* 无线, 0 关, 1 开 */
    BYTE         byWiFiConnectStatus;  /* WIFI状态, 0: 连接失败, 1: 连接成功 2: 无模块*/
    BYTE        bySignalStrength;             /* 信号强度, 0 弱, 1 正常, 2 强 */
    BYTE        byIPaddress[IP_ADDR_LEN];   /*WIFI 设备 ip*/
    BYTE        byEssid[IW_ESSID_MAX_SIZE];  /*无线接入点essid*/
    BYTE        byres[5];
}NET_DVR_MB_WIFI_STATUS,*LPNET_DVR_MB_WIFI_STATUS;

typedef struct tagNET_DVR_MB_PLATFORM_STATUS
{
    BYTE        byCurPlat;      /*当前平台, 0: wvs, 1: ivms, 2: 推模式(net_3g_sdk)*/
    BYTE        byLoginStatus;     /*login 状态, 0: login failed, 1: login success*/
    BYTE        byExceptionInfo;      /*异常信息*/
    /*
    WVS :exception info:
    0: 连接服务器失败
    1: 注册中
    2: 用户名密码错误
    3: 注册超时
    4: 心跳超时
    5: 注册成功
    iVMS :exception info:
    0未注册    
    1注册中    
    2注册连接出错
    3注册超时
    4长时间没有心跳，连接中断
    5重新注册
    6 CMS中注册设备数量已经超过限定的台数
    7 CMS中注册通道数量已经超过限定通道数
    8设备在WEB管理中心中没有配置
    9CMS和WEB管理中心通信失败
    10登录未知错误
    11注册成功
    推模式 :exception info:    
    0未注册
    1: 注册中
    2: 重复注册
    3: 注册连接失败
    4: 服务器IP变化
    5: 注册成功
    6: 用户注销
    7: 心跳超时
    */                        
    BYTE        byres[5];
}NET_DVR_MB_PLATFORM_STATUS, *LPNET_DVR_MB_PLATFORM_STATUS;

typedef struct tagNET_DVR_MB_MOBILEDEV_STATUS
{
    DWORD        dwSize;      /*结构大小*/
    union
    {
        NET_DVR_MB_GPS_STATUS struGPSStatus;
        NET_DVR_MB_GSENSOR_STATUS struGSensorStatus;
        NET_DVR_MB_WIFI_STATUS struWiFiStatus;
        NET_DVR_MB_PLATFORM_STATUS struPlatformStatus;
    }mobileStatus;
}NET_DVR_MB_MOBILEDEV_STATUS, *LPNET_DVR_MB_MOBILEDEV_STATUS;

typedef struct tagNET_DVR_GPS_INFO
{
    /* 经纬度为S*100 */
    BYTE    byDirection[2];        /*direction[0]0or1(东经/西经), direction[1]:0or1(北纬/南纬)  */
    BYTE    bySvs;         /* satellite vehicles(初值0)：有效定位星数 */
    BYTE    byLocateMode;  /* 定位模式(初值0)：仅NMEA0183 3.00版本输出，0=自主定位，1=差分，2=估算，3=数据无效 */
    WORD    wHDOP;  /* 水平精度因子，度量GPS精确度，0.5-99.9，6以内定位精度高，20以上需丢弃，这里存储的是乘以10以后的整数 */     
    WORD    wHeight;             /* 高度 */
    DWORD   dwLatitude;     /*纬度latitude = 实际度*3600*100+实际分*60*100+实际秒*100 */
    DWORD   dwLongitude; /*经度longitude =实际度*3600*100+实际分*60*100+实际秒*100 */
    DWORD   dwVehicleSpeed;        /* mobile speed =实际速度*100000 实际单位kph*/
    DWORD    dwVehicleDirection;    /* mobile direction= 实际方向*100，实际数值是方向角，正北为0度，顺时针 */
    BYTE    byRes[8];            // 保留
}NET_DVR_GPS_INFO,*LPNET_DVR_GPS_INFO; //32字节


typedef struct tagNTE_DVR_GPS_DATA
{
    NET_DVR_GPS_INFO  struGPSInfo;      //GPS坐标点
    NET_DVR_TIME      struTime;            //GPS坐标对应的时间点，UTC时间
    BYTE        byRes[12];             // 保留
}NET_DVR_GPS_DATA,*LPNET_DVR_GPS_DATA;

typedef struct tagNET_DVR_GET_GPS_DATA_PAPAM
{    
    DWORD dwCmdType;              //0-按时间段查找GPS数据,1-按时间点查找GPS数据    
    union
    {
        struct
        {
            NET_DVR_TIME struBeginTime;               //GPS数据查找起始时间       
            NET_DVR_TIME struEndTime;                 //GPS数据查找结束时间
            DWORD dwInterval;                  //GPS点时间间隔，单位秒
            BYTE  byRes[76];                    // 保留
        }TimeSeg;
        struct
        {
            NET_DVR_TIME struTimePoint;              //GPS数据查找起始时间单位秒
            BYTE  byRes[104];              // 保留
        }TimePoint;    
    }GpsDataParam;
}NET_DVR_GET_GPS_DATA_PARAM,*LPNET_DVR_GET_GPS_DATA_PARAM;


typedef struct tagNET_DVR_SDKLOCAL_CFG
{
    BYTE    byEnableAbilityParse;    //使用能力集解析库,0-不使用,1-使用,默认不使用
    BYTE    byVoiceComMode;          //对讲模式，0-使用对讲库（默认），1-使用windows api模式    
    BYTE    byLoginWithSimXml;  //登录时使用模拟能力,0-不使用,1-使用,默认不使用
    BYTE    byCompatibleType;
    BYTE    byRes[380];
    BYTE    byProtectKey[128];    //默认设置为0
}NET_DVR_SDKLOCAL_CFG, *LPNET_DVR_SDKLOCAL_CFG;

typedef struct tagNET_DVR_LOCAL_ABILITY_PARSE_CFG
{
    BYTE    byEnableAbilityParse;    //使用能力集解析库,0-不使用,1-使用,默认不使用
    BYTE    byRes[127];                
}NET_DVR_LOCAL_ABILITY_PARSE_CFG, *LPNET_DVR_LOCAL_ABILITY_PARSE_CFG;

typedef struct tagNET_DVR_LOCAL_TALK_MODE_CFG
{
    BYTE    byTalkMode;                //对讲模式，0-使用对讲库（默认），1-使用windows api模式
    BYTE    byRes[127];                
}NET_DVR_LOCAL_TALK_MODE_CFG, *LPNET_DVR_LOCAL_TALK_MODE_CFG;

typedef struct tagNET_DVR_LOCAL_PROTECT_KEY_CFG
{
    BYTE    byProtectKey[128];        //默认设置为0
    BYTE    byRes[128];            
}NET_DVR_LOCAL_PROTECT_KEY_CFG, *LPNET_DVR_LOCAL_PROTECT_KEY_CFG;

typedef struct tagNET_DVR_SIMXML_LOGIN
{
    BYTE   byLoginWithSimXml;   //登录时使用模拟能力校正结构体能力字段,0-不使用,1-使用
    BYTE   byRes[127];
}NET_DVR_SIMXML_LOGIN, *LPNET_DVR_SIMXML_LOGIN;




typedef struct tagNET_DVR_LOCAL_GENERAL_CFG
{
    BYTE     byExceptionCbDirectly;    //0-通过线程池异常回调，1-直接异常回调给上层
    BYTE     byNotSplitRecordFile;     //回放和预览中保存到本地录像文件不切片 0-默认切片，1-不切片
    BYTE     byResumeUpgradeEnable;    //断网续传升级使能，0-关闭（默认），1-开启
    BYTE     byAlarmJsonPictureSeparate;   //控制JSON透传报警数据和图片是否分离，0-不分离，1-分离（分离后走COMM_ISAPI_ALARM回调返回）
    BYTE     byRes[4];                 //保留
    UINT64   i64FileSize;              //单位：Byte
    DWORD    dwResumeUpgradeTimeout;   //断网续传重连超时时间，单位毫秒
	BYTE     byAlarmReconnectMode;     //0-独立线程重连（默认） 1-线程池重连
    BYTE     byStdXmlBufferSize;       //设置ISAPI透传接收缓冲区大小，1-1M 其他-默认
    BYTE     byMultiplexing;           //0-普通链接（非TLS链接）关闭多路复用，1-普通链接（非TLS链接）开启多路复用
    BYTE     byFastUpgrade;           //0-正常升级，1-快速升级
    BYTE     byRes1[232];              //预留
}NET_DVR_LOCAL_GENERAL_CFG, *LPNET_DVR_LOCAL_GENERAL_CFG;

typedef struct tagNET_SDK_P2P_SERVER_2C
{
    BYTE   byPlatformType;   //0-国内 1-国外 2-test2
    BYTE   byRes1[3];
    char   *pAppID;          //APP ID
    char   *pAuthAddr;       //认证服务器IP地址
    char   *pPlatformAddr;   //平台服务IP地址
    char   *pUserName;       //账号
    char   *pPassword;       //密码
    BYTE byRes[40];
} NET_SDK_P2P_SERVER_2C, *LPNET_DVR_P2P_SERVER_2C;

typedef struct tagNET_SDK_P2P_SERVER_2B
{
    BYTE   byPlatformType; //0-国内 1-国外 2-test2
    BYTE   byRes1[3];
    char   *pAppID;          //APP ID
    char   *pAuthAddr;       //认证服务器IP地址
    char   *pPlatformAddr;   //平台服务IP地址
    char   *pToken;          //Token
    BYTE byRes[44];
} NET_SDK_P2P_SERVER_2B, *LPNET_DVR_P2P_SERVER_2B;

typedef struct tagNET_DVR_LOCAL_ASYNC_CFG
{
    BOOL    bEnable;                //异步配置使能，true-开启
    BYTE    byRes[60];
}NET_DVR_LOCAL_ASYNC_CFG, *LPNET_DVR_LOCAL_ASYNC_CFG;

typedef struct tagNET_DVR_LOCAL_STREAM_CALLBACK_CFG
{
    BYTE     byPlayBackEndFlag;      //0-不回调回放结束标记，1-回调回放结束标记
    BYTE     byRes[255];      //保留
}NET_DVR_LOCAL_STREAM_CALLBACK_CFG, *LPNET_DVR_LOCAL_STREAM_CALLBACK_CFG;

typedef struct tagNET_DVR_LOCAL_LOG_CFG
{
    WORD    wSDKLogNum;
    LOGCALLBACK fnCB;		//日志回调
    void *pUserData;		//用户指针
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    BYTE    byRes[238];      //保留
#else
    BYTE    byRes[246];      //保留
#endif  
}NET_DVR_LOCAL_LOG_CFG, *LPNET_DVR_LOCAL_LOG_CFG;

typedef struct tagNET_DVR_LOCAL_BYTE_ENCODE_CONVERT
{
    CHAR_ENCODE_CONVERT  fnCharConvertCallBack;
    BYTE     byRes[256];
}NET_DVR_LOCAL_BYTE_ENCODE_CONVERT, *LPNET_DVR_LOCAL_BYTE_ENCODE_CONVERT;

typedef struct tagNET_DVR_LOCAL_SECURITY
{
    BYTE bySecurityLevel;//私有协议通信模式， //0-兼容模式（默认），允许所有的SDK登录协议通过，1-安全模式（MD5）, 允许RSA和MD5登录，开启校验2-安全模式（RSA）RSA登录，开启校验
    BYTE byRes[255];
}NET_DVR_LOCAL_SECURITY, *LPNET_DVR_LOCAL_SECURITY;

typedef struct tagNET_DVR_LOCAL_CHECK_DEV
{
    DWORD   dwCheckOnlineTimeout;     //巡检时间间隔，单位ms  最小值为30s，最大值120s。为0时，表示用默认值(120s)
    DWORD   dwCheckOnlineNetFailMax;  //由于网络原因失败的最大累加次数；超过该值SDK才回调用户异常，为0时，表示使用默认值1
    BYTE    byRes[256];
}NET_DVR_LOCAL_CHECK_DEV,*LPNET_DVR_LOCAL_CHECK_DEV;

typedef struct tagNET_DVR_LOCAL_PTZ_CFG
{
    BYTE   byWithoutRecv;     //0-接收设备返回，1-不接收设备返回
    BYTE   byRes[63];
}NET_DVR_LOCAL_PTZ_CFG, *LPNET_DVR_LOCAL_PTZ_CFG;

typedef struct tagNET_DVR_LOCAL_CFG_VERSION
{
    BYTE    byVersion;                        //版本信息
    BYTE    byRes[63];                        //保留
}NET_DVR_LOCAL_CFG_VERSION, *LPNET_DVR_LOCAL_CFG_VERSION;

typedef struct tagNET_DVR_LOCAL_TCP_PORT_BIND_CFG
{
    WORD    wLocalBindTcpMinPort;            //本地绑定Tcp最小端口
    WORD    wLocalBindTcpMaxPort;            //本地绑定Tcp最大端口
    BYTE    byRes[60];                        //保留
}NET_DVR_LOCAL_TCP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_TCP_PORT_BIND_CFG;

typedef struct tagNET_DVR_LOCAL_UDP_PORT_BIND_CFG
{
    WORD    wLocalBindUdpMinPort;            //本地绑定Udp最小端口
    WORD    wLocalBindUdpMaxPort;            //本地绑定Udp最大端口
    BYTE    byRes[60];                        //保留
}NET_DVR_LOCAL_UDP_PORT_BIND_CFG, *LPNET_DVR_LOCAL_UDP_PORT_BIND_CFG;

typedef struct tagNET_DVR_LOCAL_MEM_POOL_CFG
{
    DWORD    dwAlarmMaxBlockNum;        //报警模块内存池最多向系统申请的内存块（block）个数，每个block为64MB, 超过这个上限则不向系统申请，0表示无上限
    DWORD    dwAlarmReleaseInterval;                //报警模块空闲内存释放的间隔，单位秒，为0表示不释放
    DWORD   dwObjectReleaseInterval;   //对象申请模块空闲内存释放的间隔，单位秒，为0表示不释放
    BYTE    byRes[508];                //保留
}NET_DVR_LOCAL_MEM_POOL_CFG, *LPNET_DVR_LOCAL_MEM_POOL_CFG;

typedef struct tagNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG
{
    DWORD        dwPreviewTime;        //预览模块超时时间
    DWORD        dwAlarmTime;        //报警模块超时时间
    DWORD        dwVodTime;            //回放模块超时时间
    DWORD        dwElse;                //其他模块
    BYTE        byRes[512];                            //保留
}NET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG, *LPNET_DVR_LOCAL_MODULE_RECV_TIMEOUT_CFG;

typedef struct  tagNET_DVR_CETTIFICATE_INFO
{
    DWORD dwSize;
    char szIssuer[MAX_CERTIFICATE_ISSUER_LEN];               //证书颁发者
    char szSubject[MAX_CERTIFICATE_SUBJECT_LEN];             //证书持有者
    NET_DVR_TIME struStartTime;
    NET_DVR_TIME struEndTime;
    BYTE byRes1[1024];
}NET_DVR_CETTIFICATE_INFO, *LPNET_DVR_CETTIFICATE_INFO;

typedef struct tagNET_DVR_LOCAL_CERTIFICATION
{
    char szLoadPath[MAX_FILE_PATH_LEN];
    fnCertVerifyResultCallBack fnCB;
    void* pUserData;
    BYTE byRes[64];
}NET_DVR_LOCAL_CERTIFICATION, *LPNET_DVR_LOCAL_CERTIFICATION;

typedef struct tagNET_DVR_LOCAL_PORT_MULTI_CFG
{
    BOOL    bEnable;                //端口复用使能，true-开启
    BYTE    byRes[60];
}NET_DVR_LOCAL_PORT_MULTI_CFG, *LPNET_DVR_LOCAL_PORT_MULTI_CFG;

typedef struct tagNET_DVR_RTSP_PARAMS_CFG
{
    DWORD    dwMaxBuffRoomNum;    //rtp over udp排序开辟的最大缓冲区个数，0为无效，使用默认值20
    //一个缓冲区开辟内存为10K多一点，缓冲区个数越多，处理乱序的能力则越强，流畅性越好，延时也越大
    BYTE    byUseSort;    //是否开启rtp over udp排序， 0-不开启  1-开启
    BYTE    byRes[123];
}NET_DVR_RTSP_PARAMS_CFG, *LPNET_DVR_RTSP_PARAMS_CFG;


typedef struct tagNET_DVR_OPTICAL_CHANNEL_CFG
{
    DWORD dwSize;
    NET_DVR_OPTICAL_CHANNEL_BIND struBindVideo;//视频绑定
    NET_DVR_OPTICAL_CHANNEL_BIND struBindAudio;//音频绑定
    BYTE  byRes[16];           //保留   
}NET_DVR_OPTICAL_CHANNEL_CFG,*LPNET_DVR_OPTICAL_CHANNEL_CFG;

typedef struct tagNET_DVR_OPTICAL_INFO
{
    DWORD dwSize;
    BYTE  bySlotNum;//编码子系统槽位号
    BYTE  byChannel; //编码通道号
    BYTE  byRes[18];
}NET_DVR_OPTICAL_INFO,*LPNET_DVR_OPTICAL_INFO;

typedef struct tagNET_DVR_AUDIO_SURCHAN_CFG
{
    DWORD dwSize;
    BYTE  byStatus;       //音频是否开启，1-开，0-关
    BYTE  byRes1[3];
    //以下参数当byStatus == 1时有效
    DWORD dwSubWinNum; //关联的子窗口号
    DWORD dwSurChanNum;             /*监控通道号  */   
    NET_DVR_IPADDR struIpaddr;            /*监控通道地址 */
    WORD   wPort;                          /*监控通道端口 */     
    BYTE   byRes2[14];
}NET_DVR_AUDIO_SURCHAN_CFG, *LPNET_DVR_AUDIO_SURCHAN_CFG;

typedef struct tagNET_DVR_ETHERNET_CHANNEL_INFO
{
    DWORD dwSize;
    BYTE byConverge[MAX_ETHERNET_PORT_NUM];
    //byConverge[i] = j表示将第i个端口加入到第j条链路，j的取值为1-8,j=0表示移除
    BYTE byRes[32];
}NET_DVR_ETHERNET_CHANNEL_INFO,*LPNET_DVR_ETHERNET_CHANNEL_INFO;

typedef struct tagNET_DVR_SPARTAN_INFO
{
    DWORD  dwSize;
    BYTE   bySpartanStatus; //0-畅显关，1-畅显开
    BYTE   byRes[31];
}NET_DVR_SPARTAN_INFO,*LPNET_DVR_SPARTAN_INFO;

typedef struct tagNET_DVR_IPADDR_FILTERCFG
{
    DWORD dwSize;
    BYTE byEnable; //启用IP地址过滤，0-否，1-是
    BYTE byFilterType; //过滤类型，0-禁用，1-允许
    BYTE byRes[18];
    BYTE byIPAddr[1024];    //IP地址信息，格式192.168.1.2;192.168.1.3
}NET_DVR_IPADDR_FILTERCFG, *LPNET_DVR_IPADDR_FILTERCFG;

typedef struct tagNET_DVR_LOGO_OVERLAYCFG
{
    DWORD dwSize;
    BYTE  byEnable; //是否启用，0-否，1-是
    BYTE  byRes1[3];
    DWORD dwCoordinateX;    //图片显示区域X坐标
    DWORD dwCoordinateY;    //图片显示区域Y坐标
    WORD  wPicWidth; //图片宽
    WORD  wPicHeight; //图片高
    BYTE  byLogoName[16];//Logo名称
}NET_DVR_LOGO_OVERLAYCFG,*LPNET_DVR_LOGO_OVERLAYCFG;

typedef struct tagNET_DVR_INVALID_DISK_PARAM
{
    NET_DVR_STRUCTHEAD    struStructHead;
    DWORD                dwDiskNo;            // 磁盘号
    BYTE                byDelAll;            // 0-删除dwDiskNo  1-删除全部无效磁盘
    BYTE                 byres[31];
}NET_DVR_INVALID_DISK_PARAM, *LPNET_DVR_INVALID_DISK_PARAM;

typedef struct tagNET_DVR_INVALID_MOUNT_DISK_PARAM
{
    NET_DVR_STRUCTHEAD    struStructHead;
    DWORD                dwDiskNo;            // 磁盘号
    BYTE                 byres[32];
}NET_DVR_MOUNT_DISK_PARAM, *LPNET_DVR_MOUNT_DISK_PARAM;









typedef struct tagNET_DVR_CODECARD_ABILITY /*高清编码卡能力集*/
{
    BYTE byCardType;      //编码卡类型(按BOARD_TYPE中的枚举)
    BYTE byCodeNums;      //编码通道数 
    BYTE byDispNums;      //显示通道数 
    BYTE byCodeStartIdx;     //首个编码通道在所有编码通道中的索引 
    BYTE byDispStartIdx;     //首个显示通道在所有显示通道中的索引
    BYTE byRes1[3]; 
    DWORD dwVgaSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwHdmiSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwDviSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    DWORD dwYpbprSupportResolution[MAX_SUPPORT_RES/*32*/];//支持的分辨率
    BYTE byDispFormat[MAX_CODE_CARD_SUPPORTDISPNUMS];   //支持的输出模式(按HD_DISPLAY_FORMAT中的枚举) 
    BYTE byWindowMode[MAX_CODE_CARD_SUPPORTDISPNUMS][12]; //支持的窗口模式(比如1,2,4,9,16))
    BYTE byRes2[36];
}NET_DVR_CODECARD_ABILITY,*LPNET_DVR_CODECARD_ABILITY;

typedef struct tagNET_DVR_CODESVR_ABILITY
{
    DWORD dwSize;      /* 结构体大小 */
    BYTE byCardNums;      /* 编码卡数 */
    BYTE byStartChan;     /* 起始通道号 */
    BYTE byRes1[2];
    NET_DVR_CODECARD_ABILITY struCodeCardAbility[MAX_CODE_CARD_NUM];
    BYTE byRes2[64];
}NET_DVR_CODESVR_ABILITY, *LPNET_DVR_CODESVR_ABILITY;

typedef struct tagNET_DVR_CODER_SERVER_OUTPUT_CFG
{
    DWORD  dwSize;
    BYTE   byDispChanType;        /*显示通道类型：0-BNC，1-VGA，2-HDMI，3-DVI*/ //此参数只能获取
    BYTE   byVedioFormat;      /*1:NTSC,2:PAL，0-NULL*/
    BYTE   byRes1[2];
    DWORD  dwResolution;       //分辨率
    DWORD  dwWindowMode;        /*画面模式，支持模式从能力集获取*/
    BYTE   byRes2[64];
}NET_DVR_CODER_SERVER_OUTPUT_CFG,*LPNET_DVR_CODER_SERVER_OUTPUT_CFG;

typedef struct tagNET_DVR_DISPLAY_START_INFO 
{
    DWORD  dwSize;
    DWORD  dwDisplayChan; //显示通道号
    DWORD  dwCodeChan; //编码通道号
    DWORD  dwWinNum;   //窗口号，从1起
    BYTE   byEnableAudio; //开启音频，0-关，1-开
    BYTE   byRes[31];
}NET_DVR_DISPLAY_START_INFO,*LPNET_DVR_DISPLAY_START_INFO;

typedef struct tagNET_DVR_CODER_WINDOW_INFO
{
    DWORD dwSize;
    DWORD dwDisplayChan;//显示通道号
    DWORD dwWinNum;     //窗口号，从1开始
    BYTE  byRes[16];
}NET_DVR_CODER_WINDOW_INFO,*LPNET_DVR_CODER_WINDOW_INFO;

typedef struct tagNET_DVR_WINDOW_STATUS
{
    DWORD  dwSize;         //结构大小
    DWORD  dwCodeChan;      /*编码通道号*/
    BYTE   byDisplay;              /*是否输出，0-否，1-是*/
    BYTE   byAudio;            /*音频是否开启,0-否，1-是*/   
    BYTE   byRes[30];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
}NET_DVR_WINDOW_STATUS,*LPNET_DVR_WINDOW_STATUS;

typedef struct tagNET_DVR_RECORD_LOCK_PERCENTAGE
{
    DWORD     dwSize;              //结构体大小
    BYTE     byPercentage;        //百分比，取值范围[0,100]
    BYTE      byRes[31];          //保留
}NET_DVR_RECORD_LOCK_PERCENTAGE, *LPNET_DVR_RECORD_LOCK_PERCENTAGE;

typedef struct tagNET_DVR_UPDATE_RECORD_INFO
{
    DWORD             dwSize;             //结构体大小
    NET_DVR_STREAM_INFO struStreasmInfo;     //流ID
    DWORD              dwBeginTime;    //录像总的开始时间
    DWORD             dwEndTime;        //录像总的结束时间
    BYTE              byRes[32];       //保留
}NET_DVR_UPDATE_RECORD_INFO, *LPNET_DVR_UPDATE_RECORD_INFO;

typedef struct tagNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA
{
    NET_DVR_STREAM_INFO        struStreamInfo; 
    DWORD                    dwCmdType;                         //外部触发类型 
    DWORD                    dwRecordTimeLen;                //录像持续时间，单位：秒
    BYTE                    byEventID[MAX_EVENTID_LEN];        //事件ID，作为附加信息
    DWORD                    dwLockDuration;                //锁定持续时间，单位：秒，0xffffffff- 永久锁定，0- 不锁
    BYTE                    byBackUp;                       //是否存档，0-不存档，1-存档
    BYTE                    byPreRecord;                    //是否预录，0-不预录，1-预录
    BYTE                    byRes[122];
}NET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA, *LPNET_DVR_CMD_TRIGGER_PERIOD_RECORD_PARA;

typedef struct tagNET_DVR_LOCK_FILE_BY_NAME_PARA
{
    BYTE                byFileName[NAME_LEN];     // 录像文件名，老协议只传32个文件名
    DWORD                dwLockDuration;            // 锁定持续时间,单位秒，0xffffffff表示永久锁定
    BYTE                byRes[512];
}NET_DVR_LOCK_FILE_BY_NAME_PARA, *LPNET_DVR_LOCK_FILE_BY_NAME_PARA;

typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND
{
    DWORD                    dwSize;
    NET_DVR_STREAM_INFO        struStreamInfo;
    DWORD                    dwStreamType; //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……（自定义码流类型需通过GET /ISAPI/Streaming/channels/<ID>/customStream获取当前通道已经添加的所有自定义码流ID。自定义码流为6~10，其索引值就是6~10）
    BYTE                    byRes[32];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND;

typedef struct tagNET_DVR_MULTI_STREAM_COMPRESSIONCFG
{
    DWORD                            dwSize;
    DWORD                            dwStreamType;        //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
    NET_DVR_COMPRESSION_INFO_V30    struStreamPara;        //码流压缩参数
    DWORD    dwResolution;        //当分辨率索引小于255时和byResolution保持一致，大于255时以该字段返回索引值判断。
    BYTE byRes[76];
}NET_DVR_MULTI_STREAM_COMPRESSIONCFG, *LPNET_DVR_MULTI_STREAM_COMPRESSIONCFG;

typedef struct tagNET_DVR_PUSHALARMINFO_V40
{
    DWORD dwAlarmType; /*0-信号量报警,1-硬盘满,2-信号丢失,3－移动侦测,4－硬盘未格式化,5-读写硬盘出错,6-遮挡报警,7-制式不匹配, 8-非法访问, 9-视频信号异常，10-录像异常 11- 智能场景变化  12-阵列异常 */
    union
    {
        BYTE byRes[300];
        struct
        {
            DWORD dwAlarmInputNumber;    /*按位,第0位对应第0个输入端口,dwAlarmType为0时需要设置*/
            BYTE  byAlarmOutputNumber[MAX_ALARMOUT_V30];   /*按位,第0位对应第0个输出端口, */
            BYTE  byAlarmRelateChannel[MAX_CHANNUM_V30];  /*按位,第0位对应第0个通道*/
            BYTE  byRes1[97];
            BYTE  byDeviceID[NAME_LEN]; /*设备的ID串*/
            BYTE  byRes2[7];
        }struIOAlarm;
        struct
        {
            BYTE byStreamID[STREAM_ID_LEN]; // ID信息
            BYTE byRes1[132];
            BYTE byChannel[MAX_CHANNUM_V30];             /*按位,0x2表示第1通道，第1位对应第1个通道(从通道1开始)，dwAlarmType为2或3, 6，9，10时需要设置, */
            BYTE byRes2[33];
            BYTE byDeviceID[NAME_LEN]; /*设备的ID串*/
            BYTE byRes3[7];
        }struStreamIDorChannel;
        struct
        {
            BYTE byRes1[228];
            BYTE byDiskNumber[MAX_DISKNUM_V30];  /*按位,第0位对应第0个硬盘,dwAlarmType为1,4,5时需要设置*/
            BYTE byDeviceID[NAME_LEN]; /*设备的ID串*/
            BYTE byRes2[7];
        }struDiskAlarm;
    }uAlarmInfo;
}NET_DVR_PUSHALARMINFO_V40, *LPNET_DVR_PUSHALARMINFO_V40;

typedef struct tagNET_DVR_RECORD_PACK
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    DWORD             dwPackageInterval;    // 打包时间间隔 ，时间单位：分钟
    BYTE              byRes[32];               // 保留
}NET_DVR_RECORD_PACK,*LPNET_DVR_RECORD_PACK;

typedef struct tagNET_DVR_NET_DISK_SERACH_PARAM
{
    NET_DVR_IPADDR              struIP;         // IP地址
    WORD              wPort;      // IP端口
    BYTE                byRes[10];  // 保留字节
}NET_DVR_NET_DISK_SERACH_PARAM, *LPNET_DVR_NET_DISK_SERACH_PARAM;

typedef struct tagNET_DVR_NET_DISK_SERACH_RET
{
    BYTE byDirectory[128];  // 返回的文件目录
    BYTE byRes[20];
}NET_DVR_NET_DISK_SERACH_RET, *LPNET_DVR_NET_DISK_SERACH_RET;

typedef struct tagNET_DVR_WD1_CFG
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    BYTE              byWD1Enable;         //WD1使能开关 0 关闭 1 开启    
    BYTE                 byRes[31];      //保留
}NET_DVR_WD1_CFG, *LPNET_DVR_WD1_CFG;

typedef struct tagNET_DVR_FTPCFG_V40
{
    NET_DVR_STRUCTHEAD     struStruceHead;
    BYTE                byEnableFTP;            /*是否启动ftp上传功能，0-否，1-是*/
    BYTE                byProtocolType;             /*协议类型 0-FTP，1-SFTP*/
    WORD                wFTPPort;                /*端口*/
    union 
    {
        struct
        {
            BYTE            szDomain[64];        //服务器地址，可以使IPv4 IPv6或是域名
            BYTE            byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;             /*IP地址:IPv4 IPv6地址, 144字节*/
        }struAddrIP;
    }unionServer;  //使用联合体结构，防止既是IP地址又是域名的情况
    BYTE                szUserName[32];            /*用户名*/
    BYTE                szPassWORD[16];            /*密码*/
    BYTE                szTopCustomDir[64];        /*自定义一级目录*/
    BYTE                szSubCustomDir[64];        /*自定义二级目录*/
    BYTE                byDirLevel;                /*0 = 不使用目录结构，直接保存在根目录,    1 = 使用1级目录,2=使用2级目录*/
    BYTE                 byTopDirMode;            /* 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址，
                                                0x4=使用监测点,0x5=使用时间(年月),0x6-使用自定义 ,0x7=违规类型,0x8=方向,0x9=地点*/
    BYTE                 bySubDirMode;           /*二级目录，0x1=使用通道名,0x2=使用通道号 0x3=使用时间(年月日),
                                                0x4=使用车道号,0x5-使用自定义, 0x6=违规类型,0x7=方向,0x8=地点,0x9 = 车位编号*/
    BYTE                byType;                    /* 0-主服务器，1-备服务器*/
    BYTE                byEnableAnony;          /*启用匿名 0-否 1是*/
    BYTE                byAddresType;           /*0 使用IPV4、IPV6  1- 使用域名*/
    BYTE                byFTPPicType;           //0-保留，1-停车场抓拍图片命名规则
    BYTE                 byPicArchivingInterval; //图片归档间隔[1~30],0表示关闭
    NET_DVR_PICTURE_NAME_EX     struPicNameRule;   /* 图片命名规则:     
    byFTPPicType ==1的时候,自数组内的命名规则是停车场抓拍图片命名规则*/
    BYTE                byPicNameRuleType;      //图片命令规则类型；0~默认类型，1~图片前缀名定义(启用struPicNameRule中的byPicNamePrefix字段)
    BYTE                 byRes[203];             /*保留*/
}NET_DVR_FTPCFG_V40, *LPNET_DVR_FTPCFG_V40;

typedef struct tagNET_DVR_FTP_TYPE
{
    BYTE    byType;  // 0-主服务器，1-备服务器
    BYTE    byRes[3];
}NET_DVR_FTP_TYPE, *LPNET_DVR_FTP_TYPE;

typedef struct 
{
    DWORD     dwSize;
    BYTE    byEnableFTP;            /*是否启动ftp上传功能，0-否，1-是*/
    BYTE    byProtocolType;             /*协议类型 0-FTP，1-SFTP*/
    WORD    wFTPPort;                /*端口*/
    union 
    {
        BYTE    byRes[144];
        struct
        {
            BYTE    szDomain[MAX_DOMAIN_NAME];        //服务器地址，可以使IPv4 IPv6或是域名
            BYTE    byRes1[80];
        }struDomain;
        struct
        {
            NET_DVR_IPADDR     struIp;             /*IP地址:IPv4 IPv6地址, 144字节*/
        }struAddrIP;
    }unionServer;  //使用联合体结构，防止既是IP地址又是域名的情况
    
    BYTE    szUserName[NAME_LEN];            /*用户名*/
    BYTE    szPassWORD[PASSWD_LEN];            /*密码*/
    BYTE    szTopCustomDir[MAX_CUSTOM_DIR];        /*自定义一级目录*/
    BYTE    szSubCustomDir[MAX_CUSTOM_DIR];        /*自定义二级目录*/
    BYTE    byDirLevel;                /*0 = 不使用目录结构，直接保存在根目录,    1 = 使用1级目录,2=使用2级目录*/
                                    BYTE    byTopDirMode;            /* 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址，
                                                                    0x4=使用监测点,0x5=使用时间(年月),0x6-使用自定义 ,0x7=违规类型,
                                    0x8=方向,0x9=地点*/
                                    BYTE    bySubDirMode;           /*二级目录，0x1=使用通道名,0x2=使用通道号 0x3=使用时间(年月日),
                                                                    0x4=使用车道号,0x5-使用自定义, 0x6=违规类型,0x7=方向,0x8=地点,
                                    0x9 = 车位编号*/
                                    BYTE    byType;                    /* 0-主服务器，1-备服务器*/
                                    BYTE    byEnableAnony;          /*启用匿名 0-否 1是*/
                                    BYTE    byAddresType;           /*0 使用IPV4、IPV6  1- 使用域名*/
                                    
                                    BYTE    byRes2[198];
}NET_DVR_FTP_SERVER_TEST_PARA, *LPNET_DVR_FTP_SERVER_TEST_PARA;

typedef struct tagNET_DVR_SERVER_TEST_PARA
{
    DWORD    dwSize;
    union 
    {
        BYTE byRes[740];
        struct
        {
            NET_DVR_NTPPARA    struNtpPara;                    /*NTP服务器测试参数80字节*/           
            BYTE    byRes1[660];
        }struNtpPara;
        struct
        {
            NET_DVR_SINGLE_NET_DISK_INFO_V40    struNasPara;   /*NAS服务器测试参数480字节*/         
            BYTE    byRes1[260];
        }struNasPara;
        struct
        {
            NET_DVR_FTP_SERVER_TEST_PARA    struFtpPara;   /*FTP服务器测试参数528字节*/          
            BYTE    byRes1[212];
        }struFtpPara;
        struct
        {
            NET_DVR_EMAILCFG_V30    struEmailPara;            /*Email服务器测试参数660字节*/        
            BYTE    byRes1[80];
        }struEmailPara;
        struct
        {
            NET_DVR_IPADDR    struIp;                            /*IP冲突测试参数24字节*/
            BYTE    byRes1[716];
        }struIpPara;
        struct  
        {
            NET_DVR_IPADDR  struIPAdder;
            WORD  wPort; //端口号
            BYTE  byRes2[2];
            char  szUser[CLOUD_NAME_LEN/*48*/]; //用户名
            char  szPassword[CLOUD_PASSWD_LEN/*48*/];     // 密码
            NET_DVR_POOLPARAM  struPoolInfo[16];// 数组0表示卡口图片数据池，数组1表示违章图片数据池，数组2表示车辆侦测数据池（IPC/D）
            BYTE   byProtocolType;//云存储协议版本，0- 1.0版本，1- 2.0版本
            BYTE   byRes3[3];
            char  szAccessKey[NET_SDK_ACCESS_KEY_LEN/*64*/]; //访问密码
            char  szSecretKey[NET_SDK_SECRET_KEY_LEN/*64*/]; //加密密码
            BYTE byRes1[354];
        }struCloudStoragePara;
        struct 
        {
            BYTE byPhoneNum[MAX_PHONE_NUM/*32*/];
            BYTE byRes1[708];
        }struPhoneNumPara;//短信测试
    }unionServerPara; 
    BYTE byRes2[800]; 
}NET_DVR_SERVER_TEST_PARA, *LPNET_DVR_SERVER_TEST_PARA;

typedef struct  tagNET_DVR_GOP_INFO  //获取GOP索引信息结构体,建立连接时使用
{
    DWORD      dwSize;          //结构体大小
    LONG      lChannel;       //通道号
    NET_DVR_TIME_EX   struStartTime;    //开始时间
    NET_DVR_TIME_EX   struEndTime;     //结束时间
    BYTE                 byRes[256];      // 保留字节  
}NET_DVR_GOP_INFO, *LPNET_DVR_GOP_INFO;

typedef struct  tagNET_DVR_GOP_INFO_RET
{
    NET_DVR_TIME_V30   struGopTime;    //Gop信息时间点
    DWORD         dwDuration;    //信息持续时间
    DWORD         dwDataSize;     //指针pBuf大小
    BYTE          byRes[128];
    char* pBuf;//Gop信息块
}NET_DVR_GOP_INFO_RET, *LPNET_DVR_GOP_INFO_RET;

typedef struct tagNET_DVR_GOP_INFO_PASSBACK   //智能数据信息回填
{
    DWORD       dwSize;                 //结构体大小
    NET_DVR_TIME_V30  struTime;         //开始时间,当数据类型为智能元数据时，表示的开始时间，当为缩略图时，表示的是图片时间
    DWORD       dwDuration;             //信息持续时间，仅当数据类型为智能元数据时有效
    DWORD       dwMetaDataSize;         //数据源的大小
    DWORD       dwPicDataSize;          //图片数据大小
    char*        pMetaDataBuffer;        //智能元数据缓冲区
    char*       pPicDataBuf;            //图片缓冲区
    BYTE        byRes[32];
}NET_DVR_GOP_INFO_PASSBACK, *LPNET_DVR_GOP_INFO_PASSBACK;

typedef struct tagNET_DVR_SINGLEWALLPARAM
{
    DWORD  dwSize;
    BYTE   byEnable;    
    BYTE   byRes1[3];
    DWORD  dwWallNum;//电视墙输出号
    //坐标须为基准坐标的整数倍（128×128），宽度和高度值不用设置，即为基准值
    NET_DVR_RECTCFG struRectCfg;
    BYTE    byRes2[36];
}NET_DVR_SINGLEWALLPARAM, *LPNET_DVR_SINGLEWALLPARAM;

typedef struct tagNET_DVR_WALLWINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byRes1[7];
    DWORD dwWinNum;//窗口号
    DWORD dwLayerIndex;//窗口相对应的图层号
    NET_DVR_RECTCFG struWinPosition;//目的窗口(相对显示墙)
    DWORD dwDeviceIndex;//分布式大屏控制器设备序号
    WORD wInputIndex;//输入信号源
    BYTE  byRes2[14];
}NET_DVR_WALLWINCFG, *LPNET_DVR_WALLWINCFG;

typedef struct tagNET_DVR_WALL_INDEX
{
    DWORD    dwSize;
    BYTE    byWallNo;    //电视墙序号，从1开始
    BYTE    bySceneNo;    //场景序号
    BYTE    byRes1[2];
    DWORD    dwDeviceID;    //分布式子设备ID
    DWORD    dwWindowNo;    //窗口序号/信号源序号
    BYTE    byRes2[32];
}NET_DVR_WALL_INDEX, *LPNET_DVR_WALL_INDEX;

typedef struct tagNET_DVR_WALLWINPARAM
{
    DWORD dwSize;
    BYTE  byTransparency; //使能透明度，0-关，非0-开    
    BYTE  byWinMode;//窗口分屏模式，能力集获取
    BYTE  byEnableSpartan;//畅显使能，0-关，1-开
    BYTE  byDecResource;  //为窗口分配的解码资源，1-D1,2-720P,3-1080P
    BYTE  byWndShowMode; //窗口显示模式，0-此字段不用，1-子窗口模式，2-子窗口全屏模式
    BYTE    byEnabledFeature; //是否启用场景特写，0-不启用，!0-启用
    BYTE    byFeatureMode; //特写模式，启用场景特写时有效，0-无效，1-“1+5”模式
    BYTE  byRes1;
    DWORD dwAmplifyingSubWndNo; //全屏子窗口号（1字节墙号+1字节子窗口号+2字节窗口号）
                                                                  //当byWndShowMode为2时有效，表示当前全屏显示的子窗口
    BYTE  byWndTopKeep; //窗口置顶保持，0-不保持，1-保持
    BYTE  byWndOpenKeep; //窗口打开保持，0-不保持，1-保持
    BYTE  byRes[22];
}NET_DVR_WALLWINPARAM, *LPNET_DVR_WALLWINPARAM;

typedef struct tagNET_DVR_WALLSCENECFG
{
    DWORD    dwSize;
    BYTE    sSceneName[NAME_LEN];    //场景名称
    BYTE    byEnable;                //场景是否有效，0-无效，1-有效
    BYTE    bySceneIndex;            //场景号，只能获取。获取所有场景时使用该参数
    BYTE    byRes [78];
}NET_DVR_WALLSCENECFG, *LPNET_DVR_WALLSCENECFG;

typedef struct tagNET_DVR_WALLWIN_INFO
{
    DWORD dwSize;
    DWORD dwWinNum;   //窗口号
    DWORD dwSubWinNum;//子窗口号
    DWORD dwWallNo; //墙号
    BYTE  byRes[12];
}NET_DVR_WALLWIN_INFO,*LPNET_DVR_WALLWIN_INFO;

typedef struct tagNET_DVR_WALL_WIN_STATUS
{
    DWORD dwSize ;
    BYTE  byDecodeStatus; /*当前解码状态:0:未启动,1 :已启动*/
    BYTE  byStreamType;    /*码流类型*/
    BYTE  byPacketType;    /*打包方式*/
    BYTE  byFpsDecV; /*视频解码帧率*/
    BYTE  byFpsDecA; /*音频解码帧率*/
    BYTE  byRes1[7];    
    DWORD dwDecodedV; /*解码的视频帧*/
    DWORD dwDecodedA; /*解码的音频帧*/
    WORD  wImgW; /*当前码流源的图像大小*/
    WORD  wImgH; 
    BYTE  byStreamMode ; //码流源(此参数对视频综合平台有效)：1-网络，2-综合平台内部编码子系统，3-屏幕服务器，0xff-无效
    BYTE  byRes2[31];
}NET_DVR_WALL_WIN_STATUS, *LPNET_DVR_WALL_WIN_STATUS;

typedef struct tagNET_DVR_WININDEX_INFO
{
    DWORD dwWinIndex; //窗口号
    DWORD dwSubWinIndex;//子窗口号
    BYTE  byType ;//资源类型，1-解码，2-回显
    BYTE  byWallNo ; //墙号
    BYTE  byRes[6];
}NET_DVR_WININDEX_INFO, *LPNET_DVR_WININDEX_INFO;

typedef struct tagNET_DVR_ASSOCIATEDDEV_CHAN_INFO
{
    DWORD  dwSize ;
    BYTE   sAddress[MAX_DOMAIN_NAME];//ip地址，或是域名
    WORD   wDVRPort;                 /* 端口号 */
    WORD   wChannel;                /* 通道号 */
    BYTE   sUserName[NAME_LEN];    /* 监控主机登陆帐号 */
    BYTE   sPassword[PASSWD_LEN];    /* 监控主机密码 */
    BYTE   byRes[24];
}NET_DVR_ASSOCIATEDDEV_CHAN_INFO,*LPNET_DVR_ASSOCIATEDDEV_CHAN_INFO;

typedef struct tagNET_DVR_WALLOUTPUTPARAM
{
    DWORD dwSize;
    DWORD dwResolution; //分辨率    
    NET_DVR_VIDEOEFFECT struRes;
    BYTE  byVideoFormat; //视频制式，见VIDEO_STANDARD
    BYTE  byDisplayMode;/*输出连接模式,1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, 7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，0xff-无效*/
    BYTE  byBackgroundColor; //背景色，0-无效，不支持背景色，1-红，2-绿，3-蓝，4-黄，5-紫，6-青，7-黑，8-白，0xff-自定义
    BYTE  byUseEDIDResolution; //是否使用EDID分辨率，0-不使用，1-使用
    WORD  wLEDWidth;     //LED屏输出分辨率宽
    WORD  wLEDHeight;    //LED屏输出分辨率高
    NET_DVR_RGB_COLOR struBackColor;//背景色，byBackgroundColor为0xff时有效
    BYTE    byLinkStatus;//输出口连接状态，0-无效,1-接入显示器,2-未接入显示器
    BYTE    byRes2[51];
}NET_DVR_WALLOUTPUTPARAM, *LPNET_DVR_WALLOUTPUTPARAM;

typedef struct NET_DVR_SUBMATRIXSYSTEMINFO
{
    //平台号，0表示无此平台
    DWORD        dwSequence;
    BYTE        sAddress[MAX_DOMAIN_NAME];//ip地址，或是域名
    WORD        wSubMatrixPort;        /*子系统端口号*/
    BYTE        byRes1[6];   
    BYTE        sUserName[NAME_LEN];    /*用户名*/
    BYTE        sPassword[PASSWD_LEN];    /*密码 */   
    BYTE        byRes2[36];
}NET_DVR_SUBMATRIXSYSTEMINFO,*LPNET_DVR_SUBMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_UNITEDMATRIXSYSTEMINFO
{
    DWORD dwSize;
    //视频综合平台信息
    NET_DVR_SUBMATRIXSYSTEMINFO struMatrixInfo[MAX_UNITEDMATRIX_NUM]; 
    BYTE  byRes[32];
}NET_DVR_UNITEDMATRIXSYSTEMINFO,*LPNET_DVR_UNITEDMATRIXSYSTEMINFO;

typedef struct tagNET_DVR_SUBSTREAM_SWITCH_CFG
{
    BYTE  byAutoSwitchEnable; //子码流自动切换，0 - 不启用，1 - 启用
    BYTE     byRes1[3];
    WORD  wSubWndWidth; //子窗口宽度设定值，byAutoSwitchEnable为1时有效
    WORD  wSubWndHeight; //子窗口高度设定值，byAutoSwitchEnable为1时有效
}NET_DVR_SUBSTREAM_SWITCH_CFG, *LPNET_DVR_SUBSTREAM_SWITCH_CFG;

typedef struct tagNET_DVR_WALL_CFG
{
    DWORD  dwSize;
    BYTE  byTransparency;//透明度,0-100,0为不透明
    BYTE  byWinStaticMode; //窗口解码停止显示模式，1-清屏(之前的清屏后是黑色)，2-显示最后一帧图像
    BYTE  byStreamFailedMode; //取流失败显示模式，1-“无网络视频信号”，2-显示最后一帧图像，3-连接异常，4-清屏
    BYTE    byEnabledOverlayLogo; //解码能力不足时是否叠加LOGO以提示用户，0-不叠加，!0-叠加
    NET_DVR_SUBSTREAM_SWITCH_CFG  struSubStreamSwitch; //子码流切换
    BYTE  byLEDShowMode; //LED窗口显示模式，0-普通模式，1-平铺模式
    BYTE  byLowLatencyMode; //低延时模式，0-普通模式，1-低延时模式
    BYTE  byRes[50];
}NET_DVR_WALL_CFG, *LPNET_DVR_WALL_CFG;


typedef struct tagNET_DVR_LOW_LIGHT_CFG
{
    DWORD dwSize;
    BYTE  byLowLightLimt; /* 低照度电子快门: 0-关，1-开 */
    BYTE  byLowLightLimtLevel; 
    /*球机0-关，1-慢快门*2，2-慢快门*3，3-慢快门*4，4-慢快门*6，5-慢快门*8，6-慢快门*12，7-慢快门*16，
    8-慢快门*24，9-慢快门*32，10-慢快门*48，11-慢快门*64，12-慢快门*96，13-慢快门*128，14-慢快门*256，
    15-慢快门*512, 16-慢快门*1.25, 17-慢快门*1.5 */
    BYTE  byRes[66];
}NET_DVR_LOW_LIGHT_CFG, *LPNET_DVR_LOW_LIGHT_CFG;

typedef struct tagNET_DVR_FOCUSMODE_CFG
{
    DWORD dwSize;
    BYTE  byFocusMode;  /* 聚焦模式，0-自动，1-手动，2-半自动 */
    BYTE  byAutoFocusMode; /* 自动聚焦模式，0-关，1-模式A，2-模式B，3-模式AB，4-模式C 自动聚焦模式，需要在聚焦模式为自动时才显示*/
    WORD  wMinFocusDistance; /* 最小聚焦距离，单位CM,  0-自动，0xffff-无穷远 */
    BYTE  byZoomSpeedLevel;  /* 变倍速度，为实际取值，1-3 */
    BYTE  byFocusSpeedLevel; /* 聚焦速度，为实际取值，1-3 */
    BYTE  byOpticalZoom;        /* 光学变倍，0-255 */
    BYTE  byDigtitalZoom;        /* 数字变倍，0-255 */
    float fOpticalZoomLevel; /* 光学变倍(倍率值) [1,32], 最小间隔0.5 ，内部设备交互的时候*1000 */
    DWORD dwFocusPos;/* dwFocusPos 是focus值（聚焦值），范围为[0x1000,0xC000]，这个值是sony坐标值，使用这个值是为了对外统一，保证不同的镜头对外focus值都转换在这个范围内 (手动聚焦模式下下应用)*/
    BYTE   byFocusDefinitionDisplay;// 聚焦清晰度显示，0~不显示，1~显示, 开启会在码流上显示当前镜头目标的清晰度值，用于帮助客户调焦使相机抓拍能够达到最清晰的效果，该清晰度越大代表着越清晰，清晰度范围为：0~100.0000
    BYTE   byFocusSensitivity; //聚焦灵敏度，范围[0,2]，聚焦模式为自动、半自动时生效
    BYTE   byRes1[2];
    DWORD  dwRelativeFocusPos;//相对focus值，其低16位表示聚焦值，0~4000；高16位代表当前聚焦值获取时的温度值
    BYTE   byRes[48];
}NET_DVR_FOCUSMODE_CFG, *LPNET_DVR_FOCUSMODE_CFG;

typedef struct tagNET_DVR_INFRARE_CFG
{
    DWORD  dwSize;
    BYTE  byIrControlMode;  /* 红外球机配置-控制模式：0-自动，1-手动 */
    BYTE  byIrBrightness;    /* 红外球机配置-红外亮度：0-100 */
    BYTE  byIrSensitivity;    /* 红外球机配置-红外灯灵敏度：0-100 */
    BYTE  byIrTrigMode; /* 触发模式 0-机芯触发，1-光敏触发 自动模式下生效*/
    BYTE  byIrBrightnessLimit;/* 亮度限制 如果此值为80，表示的意义是当前红外灯的亮度为原先根据自动策略计算出的亮度值×80% 自动模式下生效*/   
    BYTE  byRes[63];
}NET_DVR_INFRARE_CFG, *LPNET_DVR_INFRARE_CFG;

typedef struct tagNET_DVR_AEMODECFG
{
    DWORD  dwSize;
    int   iIrisSet;    /* 光圈，为实际取值*100的值，0-关 */
    int   iGainSet;    /* 快球增益，曝光补偿，为实际取值*100的值，有可能是负值 */
    int   iGainLimit;/* 增益限制，曝光补偿，为实际取值*100的值，有可能是负值 */
    int   iExposureCompensate; /* 曝光补偿，为实际取值*100的值，比如1050代表10.5dB, -750代表-7.5dB */
    BYTE  byExposureModeSet;    /* 球机的曝光模式,0-手动模式，1-自动曝光，2-光圈优先，3-快门优先，4-增益优先 */
    BYTE  byShutterSet;         /* 快门，0-关，1-自动x1，2-自动x2，3-自动x4，4-自动x8，5-自动x16，6-自动x32，7-自动x64，8-自动x128，9-1/1，10-1/2，
    11-1/3，12-1/4，13-1/6，14-1/8，15-1/12，16-1/15，17-1/25，18-1/30，19-1/50，20-1/60，21-1/75，
    22-1/90，23-1/100，24-1/120，25-1/125，26-1/150，27-1/180，28-1/200，29-1/215，30-1/250，31-1/300，
    32-1/350，33-1/425，34-1/500，35-1/600，36-1/725，37-1/1000，38-1/1250，39-1500,40-1/1750，41-1/2000，
    42-1/2500，43-3000,44-1/3500，45-1/4000，46-1/6000，47-1/10000，48-1/30000，49-1/100000,50-1/175，
    51-1/195，52-1/225，53-1/230 */
    BYTE  byImageStabilizeLevel;  /* 防抖动等级: 0-3 */
    BYTE  byCameraIrCorrect; /* 红外校正: 0-自动，1-开，2,关 */
    BYTE  byHighSensitivity; /* 高灵敏度设置: 0-关，1-开 */
    BYTE  byInitializeLens;  /* 初始化镜头: 0-关，1-开 */
    BYTE  byChromaSuppress; /* 色彩抑制 :0-255*/
    BYTE  byMaxShutterSet;     //最大快门值;索引值与byShutterSet相同(在自动曝光、光圈优先模式下生效)
    BYTE  byMinShutterSet;     //最小快门值;索引值与byShutterSet相同(在自动曝光、光圈优先模式下生效)
    BYTE  byMaxIrisSet; //最大光圈限制值(自动曝光、快门优先模式) [0,100] ;
    BYTE  byMinIrisSet;    //最小光圈限制值(自动曝光、快门优先模式) [0,100] ;
    BYTE  byExposureLevel;//曝光等级（曝光模式为自动、光圈优先、快门优先情况有效），等级1-5 默认4，兼容老版本SDK配置新设备时，保留字节为0的情况，所以这个字节为0时，也默认为曝光等级为1
    BYTE  byRes[60];
}NET_DVR_AEMODECFG, *LPNET_DVR_AEMODECFG;

typedef struct tagNET_DVR_FLASH_CFG
{
    DWORD      dwSize;
    DWORD    dwChan;//通道号
    DWORD    dwInNumbers;//进入人数
    DWORD    dwOutNumbers;//离开人数
    DWORD    dwStartTime;//开始时间秒数
    DWORD    dwEndTime;//结束时间秒数
    DWORD    dwEhomeFlag;//
    DWORD    dwAlarmFlag;//
    BYTE       byRes[1024];
}NET_DVR_FLASH_CFG, *LPNET_DVR_FLASH_CFG;

typedef struct tagNET_DVR_EXTERNAL_MATRIX_CFG
{
    DWORD        dwSize;
    BYTE        byValid;            // 有效时为设置，无效时为删除
    BYTE        byRes1[3];
    BYTE        sMatrixName[NAME_LEN/*32*/];       // 矩阵的名称
    DWORD          dwMatrixID;        // 矩阵的ID号，只能获取
    WORD        wMatrixInputChanNum;                // 矩阵的输入通道数目
    WORD        wMatrixOutputChanNum;            // 矩阵的输出通道数目
    WORD           wMatrixOutputChanRef[MAX_CAM_COUNT];   //// 设备输入和矩阵输出的绑定关系，数组下标表示控制器设备输入通道号，元素的值表示矩阵的输出通道号，
    //元素值大于0 表示绑定矩阵输出通道，元素值为0时表示不绑定，屏幕服务器为屏幕索引号和矩阵输出的绑定关系
    BYTE        byMatrixChanType;// 矩阵的通道类型1-BNC、2-VGA、3-RGB、4-DVI
    BYTE        byMatrixProtocol;    // 矩阵所用协议1、ZT1.0、2.ZT2.0、3.Extron、4.Creator
    BYTE        byMatrixType;        //1-模拟矩阵，2-数字矩阵
    BYTE        byRes2;
    NET_MATRIX_UNION struMatrixUnion;    
    BYTE        byRes3[128];        
}NET_DVR_EXTERNAL_MATRIX_CFG, *LPNET_DVR_EXTERNAL_MATRIX_CFG;

typedef struct tagNET_DVR_EXTERNAL_MATRIX_CFG_V50
{
    DWORD       dwSize;
    BYTE        byValid;            // 有效时为设置，无效时为删除
    BYTE        byRes1[3];
    BYTE        sMatrixName[NAME_LEN/*32*/];       // 矩阵的名称
    DWORD       dwMatrixID;        // 矩阵的ID号，只能获取
    WORD        wMatrixInputChanNum;                // 矩阵的输入通道数目
    WORD        wMatrixOutputChanNum;            // 矩阵的输出通道数目
    WORD        wMatrixOutputChanRef[MAX_CAM_COUNT_V50];   //// 设备输入和矩阵输出的绑定关系，数组下标表示控制器设备输入通道号，元素的值表示矩阵的输出通道号，
    //元素值大于0 表示绑定矩阵输出通道，元素值为0时表示不绑定，屏幕服务器为屏幕索引号和矩阵输出的绑定关系
    BYTE        byMatrixChanType;// 矩阵的通道类型1-BNC、2-VGA、3-RGB、4-DVI
    BYTE        byMatrixProtocol;    // 矩阵所用协议1、ZT1.0、2.ZT2.0、3.Extron、4.Creator
    BYTE        byMatrixType;        //1-模拟矩阵，2-数字矩阵
    BYTE        byRes2;
    NET_MATRIX_UNION struMatrixUnion;
    BYTE        byRes3[128];
}NET_DVR_EXTERNAL_MATRIX_CFG_V50, *LPNET_DVR_EXTERNAL_MATRIX_CFG_V50;

typedef struct tagNET_DVR_ASSOCIATE_INPUT_PARAM
{
    BYTE byEnable;
    BYTE byRes1[3];
    DWORD dwDeviceIndex;//分布式大屏控制器设备序号
    WORD wInputIndex;//输入信号源
    BYTE  byRes2[18];
}NET_DVR_ASSOCIATE_INPUT_PARAM, *LPNET_DVR_ASSOCIATE_INPUT_PARAM;

typedef struct tagNET_DVR_ASSOCIATE_OUTPUT_PARAM
{
    BYTE    byEnable;
    BYTE    byWallNo;        //墙号，从1开始
    BYTE    byRes1[2];
    DWORD    dwOutputIndex;    //输出显示屏的序号    
    BYTE    byRes2[20];
}NET_DVR_ASSOCIATE_OUTPUT_PARAM,*LPNET_DVR_ASSOCIATE_OUTPUT_PARAM;

typedef struct tagNET_DVR_VCS_USER_INFO
{
    DWORD   dwSize;
    BYTE    sUserName[NAME_LEN];            // 用户名，最大16字节
    BYTE    sPassWord[PASSWD_LEN];        // 密码
    NET_DVR_IPADDR    struUserIP;    // 用户IP地址(为0时表示允许任何地址)
    BYTE    byMacAddr[MACADDR_LEN];            // 物理地址
    BYTE    byPriority;        // 优先级，1-管理员，2-操作员 ，管理员具有任何权限，操作员没有"管理用户"的权限
    BYTE    byRes1;
    DWORD    dwRight;/*远程操作权限，按位表示，0-不支持，1-支持，各32位代表的权限类型*/    
    //bit0-获取设置基本参数
    //bit1-显示屏管理
    //bit2-窗口管理
    //bit3-信号源管理
    //bit4-布局管理
    //bit5-预案管理
    //bit6-底图管理
    //bit7-OSD管理
    //bit8-回显权限
    //bit9-报警布防
    //bit10-远程升级
    //bit11-恢复默认设置
    //bit12-导入导出配置配置文件
    //bit13-日志查询
    //bit14-远程重启
    //bit15-屏幕区域管理
    NET_DVR_ASSOCIATE_INPUT_PARAM struInputParam[MAX_INPUTNUMS/*1024*/];
    NET_DVR_ASSOCIATE_OUTPUT_PARAM struOutputParam[MAX_OUTPUTNUMS/*256*/];
    NET_DVR_RECTCFG_EX struManageRegion;   //屏幕管理区域
    BYTE   byWallNo;    //开启屏幕管理区域的墙号，对只支持单墙的设备，此字段无效
	BYTE   byRes2[3];
	BYTE   sLoginPassword[PASSWD_LEN/*16*/];		/* 登陆密码*/
	BYTE   byRes[88];} NET_DVR_VCS_USER_INFO, *LPNET_DVR_VCS_USER_INFO;

typedef struct tagNET_DVR_STREAM_MEDIA_SERVER_CFG_V41
{    
    BYTE    byValid; //是否启用，0-否，1-是
    BYTE    byRes1[3];
    BYTE    byAddress[MAX_DOMAIN_NAME];   //IP或者域名   
    WORD    wDevPort;            /*流媒体服务器端口*/    
    BYTE    byTransmitType;        /*传输协议类型 0-TCP，1-UDP*/
    BYTE    byRes2[69];
}NET_DVR_STREAM_MEDIA_SERVER_CFG_V41,*LPNET_DVR_STREAM_MEDIA_SERVER_CFG_V41;

typedef struct tagNET_DVR_DEV_CHAN_INFO_V41
{
    BYTE    byAddress[MAX_DOMAIN_NAME];    //设备域名
    WORD     wDVRPort;                 //端口号
    BYTE     byChannel;                //通道号
    BYTE    byTransProtocol;        //传输协议类型0-TCP，1-UDP
    BYTE    byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE    byFactoryType;            /*前端设备厂家类型,通过接口获取*/
    BYTE    byDeviceType; //设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
    BYTE    byDispChan;//显示通道号,智能配置使用
    BYTE    bySubDispChan;//显示通道子通道号，智能配置时使用
    BYTE    byResolution;    //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
    BYTE    byUseZeroChan; //是否使用零通道，0-否，1-是
    BYTE    byRes;   
    BYTE    sUserName[NAME_LEN];    //监控主机登陆帐号
    BYTE    sPassword[PASSWD_LEN];    //监控主机密码
}NET_DVR_DEV_CHAN_INFO_V41,*LPNET_DVR_DEV_CHAN_INFO_V41;

typedef struct tagNET_DVR_DEV_CHAN_INFO_EX
{
    BYTE   byChanType;              //通道类型，0-普通通道,1-零通道,2-流ID，3-本地输入源，4-虚拟屏服务器通道，5-拼接通道，6-屏幕服务器，7-分布式网络源，8-多相机融合通道，9-网络输入源
	BYTE    byStreamId[STREAM_ID_LEN]; //流ID，当byChanType=2、9时，该字段用于指定流或者网络ipc的ID号
    BYTE    byRes1[3];
    DWORD   dwChannel;  //通道号，通道类型为普通通道，零通道，本地输入源，虚拟屏服务器通道，拼接通道，屏幕服务器，分布式网络源时填此字段
    BYTE    byRes2[24];
    BYTE    byAddress[MAX_DOMAIN_NAME];    //设备域名
    WORD     wDVRPort;                 //端口号
    BYTE     byChannel;                //通道号,dwChannel不为0时此字段无效
    BYTE    byTransProtocol;        //传输协议类型0-TCP，1-UDP
    BYTE    byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE    byFactoryType;            /*前端设备厂家类型,通过接口获取*/
    BYTE    byDeviceType; //设备类型(视频综合平台智能板使用)，1-解码器（此时根据视频综合平台能力集中byVcaSupportChanMode字段来决定是使用解码通道还是显示通道），2-编码器
    BYTE    byDispChan;//显示通道号,智能配置使用
    BYTE    bySubDispChan;//显示通道子通道号，智能配置时使用
    BYTE    byResolution;    //; 1-CIF 2-4CIF 3-720P 4-1080P 5-500w大屏控制器使用，大屏控制器会根据该参数分配解码资源
    BYTE    byRes[2];   
    BYTE    sUserName[NAME_LEN];    //监控主机登陆帐号
    BYTE    sPassword[PASSWD_LEN];    //监控主机密码
}NET_DVR_DEV_CHAN_INFO_EX,*LPNET_DVR_DEV_CHAN_INFO_EX;

typedef struct tagNET_DVR_STREAM_MEDIA_SERVER
{    
    BYTE   byValid; //是否启用，0-否，1-是
    BYTE   byRes1[3];
    BYTE   byAddress[MAX_DOMAIN_NAME];   //IP或者域名 
    WORD   wDevPort;            /*流媒体服务器端口*/    
    BYTE   byTransmitType;        /*传输协议类型 0-TCP，1-UDP*/
    BYTE   byRes2[5];
}NET_DVR_STREAM_MEDIA_SERVER,*LPNET_DVR_STREAM_MEDIA_SERVER;

typedef struct tagNET_DVR_DEV_DDNS_INFO
{
    BYTE   byDevAddress[MAX_DOMAIN_NAME];    //域名(IPServer或hiDDNS时可填序列号或者别名)
    BYTE   byTransProtocol;        //传输协议类型0-TCP，1-UDP, 2-MCAST
    BYTE   byTransMode;            //传输码流模式 0－主码流 1－子码流
    BYTE   byDdnsType;         //域名服务器类型，0-IPServer 1－Dyndns 2－PeanutHull(花生壳)，3- NO-IP, 4- hiDDNS
    BYTE   byRes1;
    BYTE   byDdnsAddress[MAX_DOMAIN_NAME];  //DDNS服务器地址
    WORD   wDdnsPort;                 //DDNS服务器端口号
    BYTE   byChanType;              //0-普通通道,1-零通道,2-流ID
    BYTE   byFactoryType;            //前端设备厂家类型,通过接口获取
    DWORD  dwChannel; //通道号
    BYTE   byStreamId[STREAM_ID_LEN]; //流ID
    BYTE   sUserName[NAME_LEN];    //监控主机登陆帐号
    BYTE   sPassword[PASSWD_LEN];    //监控主机密码
    WORD   wDevPort;                //前端设备通信端口
    BYTE   byRes2[2];
}NET_DVR_DEV_DDNS_INFO,*LPNET_DVR_DEV_DDNS_INFO;

typedef struct tagNET_DVR_DEC_STREAM_DEV_EX
{
    NET_DVR_STREAM_MEDIA_SERVER    struStreamMediaSvrCfg;
    NET_DVR_DEV_CHAN_INFO_EX                struDevChanInfo;
}NET_DVR_DEC_STREAM_DEV_EX,*LPNET_DVR_DEC_STREAM_DEV_EX;

typedef struct tagNET_DVR_DEC_DDNS_DEV
{
    NET_DVR_DEV_DDNS_INFO struDdnsInfo;
    NET_DVR_STREAM_MEDIA_SERVER struMediaServer;
}NET_DVR_DEC_DDNS_DEV,*LPNET_DVR_DEC_DDNS_DEV;


typedef struct tagNET_DVR_PU_STREAM_CFG_V41
{
    DWORD dwSize;
    BYTE byStreamMode;/*取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流*/
    BYTE byStreamEncrypt;  //是否进行码流加密处理,0-不支持,1-支持
	BYTE byRes1[2];
	NET_DVR_DEC_STREAM_MODE uDecStreamMode;//取流信息
    DWORD  dwDecDelayTime;//解码延时时间，单位：毫秒
    BYTE   sStreamPassword[STREAM_PASSWD_LEN];  //码流加密密码,需敏感信息加密
	BYTE  byRes2[48];
}NET_DVR_PU_STREAM_CFG_V41,*LPNET_DVR_PU_STREAM_CFG_V41;

typedef struct  tagNET_DVR_MATRIX_CHAN_INFO_V41
{
    BYTE byEnable; //是否启用，0-否，1-是
    BYTE byStreamMode;/*取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流*/
    BYTE byRes[2];
    NET_DVR_DEC_STREAM_MODE uDecStreamMode;//取流信息
}NET_DVR_MATRIX_CHAN_INFO_V41,*LPNET_DVR_MATRIX_CHAN_INFO_V41;

typedef struct  tagNET_DVR_MATRIX_LOOP_DECINFO_V41
{
    DWORD                            dwSize;
    DWORD                            dwPoolTime;        /*轮巡间隔*/
    NET_DVR_MATRIX_CHAN_INFO_V41    struchanConInfo[MAX_CYCLE_CHAN_V30];
    BYTE                            byStreamEncrypt;  //是否进行码流加密处理,0-不支持,1-支持
    BYTE                            byRes[3];
    BYTE                            sStreamPassword[STREAM_PASSWD_LEN];  //码流加密密码,需敏感信息加密
}NET_DVR_MATRIX_LOOP_DECINFO_V41, *LPNET_DVR_MATRIX_LOOP_DECINFO_V41;

typedef struct tagNET_DVR_MATRIX_DEC_CHAN_INFO_V41
{
    DWORD    dwSize;
    BYTE byStreamMode;/*取流模式，0-无效，1-通过IP或域名取流，2-通过URL取流,3-通过动态域名解析向设备取流*/
    BYTE byRes1[3];
    NET_DVR_DEC_STREAM_MODE uDecStreamMode;//取流信息
    DWORD    dwPlayMode;        /* 0-动态解码 1－循环解码 2－按时间回放 3－按文件回放 */
    NET_DVR_TIME StartTime;        /* 按时间回放开始时间 */
    NET_DVR_TIME StopTime;        /* 按时间回放停止时间 */
    BYTE    sFileName[128];        /* 按文件回放文件名 */
    DWORD   dwGetStreamMode;    /*取流模式:1-主动，2-被动*/
    NET_DVR_MATRIX_PASSIVEMODE    struPassiveMode;
    BYTE    byRes2[32];
}NET_DVR_MATRIX_DEC_CHAN_INFO_V41,*LPNET_DVR_MATRIX_DEC_CHAN_INFO_V41;

typedef struct tagNet_DVR_IP_ADDRESS
{
    BYTE    byDevAddress[MAX_DOMAIN_NAME];    /*设备IP地址*/
    WORD    wDevPort;       //设备端口
    BYTE     byres[134];
}NET_DVR_IP_ADDRESS, *LPNET_DVR_IP_ADDRESS;

typedef struct tagNet_DVR_DDNS_ADDRESS
{
    BYTE byDevAddress[MAX_DOMAIN_NAME];    /*DDNS域名*/
    BYTE byDevDdns[MAX_DOMAIN_NAME];    /*设备地址*/
    BYTE byDdnsType; //域名服务器类型，0-IPServer 1－Dyndns 2－PeanutHull(花生壳)，//3- NO-IP, 4- hiDDNS
    BYTE byRes1[3];
    WORD wDevPort;       //设备端口
    WORD wDdnsPort; //域名服务器端口
    BYTE byres[64];
}NET_DVR_DDNS_ADDRESS, *LPNET_DVR_DDNS_ADDRESS;

typedef struct tagNet_DVR_PLAY_BACK_BY_TIME
{
    NET_DVR_TIME StartTime;
    NET_DVR_TIME StopTime;
}NET_DVR_PLAY_BACK_BY_TIME, *LPNET_DVR_PLAY_BACK_BY_TIME;

typedef struct tagNet_DVR_MATRIX_DEC_REMOTE_PLAY_EX
{
    DWORD    dwSize;
    DWORD    dwDecChannel;  //解码通道号
    BYTE    byAddressType;  //设备地址类型，0-IP，1-DDNS
    BYTE    byChannelType;  //通道类型，0-普通通道，1-零通道，2-流ID
    BYTE    byres[2];
    BYTE    sUserName[NAME_LEN];        /* 用户名 */
    BYTE    sPassword[PASSWD_LEN];        /* 密码 */
    DWORD    dwChannel;            /* 设备通道号 */
    BYTE    byStreamId[STREAM_ID_LEN];  //流ID,此参数在通道类型为流ID时有效
    DWORD    dwPlayMode;       /* 0－按文件 1－按时间*/
    union
    {
        BYTE byRes[200];
        NET_DVR_IP_ADDRESS struIpAddr;
        NET_DVR_DDNS_ADDRESS struDdnsAddr;
    }unionAddr;
    
    union
    {
        BYTE byRes[128];
        NET_DVR_PLAY_BACK_BY_TIME struPlayBackByTime; //按时间回放时文件信息
        char sFileName[128];    //按文件名回放时文件信息
    }unionPlayBackInfo;
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_EX, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_EX;

typedef struct tagNET_DVR_MATRIX_DEC_REMOTE_PLAY_V50
{
    DWORD   dwSize;
    DWORD   dwDecChannel;   //解码通道号
    BYTE    byAddressType;  //设备地址类型，0-IP，1-DDNS，2-URL
    BYTE    byChannelType;  //通道类型，0-普通通道，1-零通道，2-流ID
    BYTE    byStreamEncrypt;  //是否进行码流加密处理,0-不支持,1-支持
	BYTE	byRes1[1];
    BYTE    sUserName[NAME_LEN];    /* 用户名 */
    BYTE    sPassword[PASSWD_LEN];  /* 密码 */
    DWORD   dwChannel;              /* 设备通道号 */
    BYTE    byStreamId[STREAM_ID_LEN];  //流ID,此参数在通道类型为流ID时有效
    DWORD   dwPlayMode;             /* 0－按文件 1－按时间*/
    union
    {
        BYTE byRes[200];
        NET_DVR_IP_ADDRESS struIpAddr;	 //IP地址，byAddressType为0时有效
        NET_DVR_DDNS_ADDRESS struDdnsAddr;	//DDNS地址，byAddressType为1时有效
    }unionAddr;
    union
    {
        BYTE byRes[128];
        NET_DVR_PLAY_BACK_BY_TIME struPlayBackByTime; //按时间回放时文件信息
        BYTE sFileName[128];    //按文件名回放时文件信息
    }unionPlayBackInfo;
    NET_DVR_PU_STREAM_URL struURL;	//取流URL，byAddressType为2时有效
    BYTE    sStreamPassword[STREAM_PASSWD_LEN];  //码流加密密码,需敏感信息加密
    BYTE    byRes2[116];
}NET_DVR_MATRIX_DEC_REMOTE_PLAY_V50, *LPNET_DVR_MATRIX_DEC_REMOTE_PLAY_V50;

typedef struct tagNET_DVR_DISPLAY_EFFECT_CFG
{
    DWORD dwSize;
    NET_DVR_COLOR  struColor;      //显示相关参数/
    BYTE byRes[32];
}NET_DVR_DISPLAY_EFFECT_CFG,*LPNET_DVR_DISPLAY_EFFECT_CFG;

typedef struct tagNET_DVR_TRUNK_USE_STATE
{
    DWORD        dwSize;
    DWORD        dwTrunkID;    //干线ID
    WORD        wReserveUserID;    //预留的用户ID： 1~256 ，0表示释放预留
    BYTE        byStatus;  //1-空闲，2-占用，3-复用 */
    BYTE        byRes1;
    BYTE          byUserId[256];  //数组下标表示用户ID号，数组元素的值表示是否使用干线。如：byUserID[0] 的值为1，表示用户ID为0的用户正在使用，byUserID[0] 的值为0表示用户ID为0的用户没有使用这条干线
    BYTE           byRes2[64];  
}NET_DVR_TRUNK_USE_STATE,  *LPNET_DVR_TRUNK_USE_STATE;

typedef struct tagNET_DVR_PTZ_CTRL_INFO
{
    DWORD    dwSize;
    DWORD    dwCtrlDelayTime;        //PTZ控制持续时间，指PTZ控制后在dwCtrlDelayTime时间内，其他同级别或低级别用户对其操作无效。单位：秒
    BYTE    byRes[64];
}NET_DVR_PTZ_CTRL_INFO, *LPNET_DVR_PTZ_CTRL_INFO;

typedef struct tagNET_DVR_MATRIX_ROUTE_INFO
{
    DWORD        dwSize;
    DWORD           dwCamNo;
    DWORD       dwMonNo;
    DWORD        dwSubWin;
    DWORD        dwUserId;
    DWORD       dwTrunkId[MAX_MATRIX_CASCADE/*32*/];//trunkId成员对应级联级数从1到32，从CAM端开始，trunkId[0]表示第一级级联，trunkId[1]表示第二级级联, trunkId[i] = 0 表示无干线
    BYTE        byRes[64];      /* 预留 */
}NET_DVR_MATRIX_ROUTE_INFO, *LPNET_DVR_MATRIX_ROUTE_INFO;

typedef struct tagNET_DVR_PTZ_STATUS
{
    DWORD        dwSize;
    DWORD        dwUserID;    //1~256，0 表示无用户
    DWORD       dwStatus;      // PTZ控制状态0-停止、1-运行
    DWORD        dwRestTime;  //剩余时间
    BYTE        byRes[64];  
}NET_DVR_PTZ_STATUS, *LPNET_DVR_PTZ_STATUS;

typedef struct tagNET_DVR_SAFETYCABIN_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //工作模式，0-无人门常开，1-无人门常锁
    BYTE  byFaintToUnlock; //晕倒报警一定时间后外部可以开锁：0-否，1-是
    BYTE  byOvertimeToUnlock;  //使用超时后外部按钮是否可以开锁：0-否，1-是
    BYTE  byRes[13];
}NET_DVR_SAFETYCABIN_WORK_MODE,*LPNET_DVR_SAFETYCABIN_WORK_MODE;

typedef struct tagNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE  bySensorType; //传感器类型，0-红外对射型，1-幕帘传感器
    BYTE  bySensitivity; //传感器敏感度，范围：0-100%
    BYTE  byDevUseTimeout; //防护舱使用超时时间，单位：分,范围：5-30，默认超时15min,超时后通过布防通道上传报警
    BYTE  byRes1;
    WORD  wCurtainDelayTime; //幕帘传感器探测延时时间，单位：秒，范围：0-10
    WORD  wCurtainResponseTime; //幕帘人状态变化控制器响应时间，单位：秒，范围：0-300
    WORD  wFaintToEmergencyTime; //晕倒告警生效时间，单位：秒，范围：10-300
    BYTE  byFollowDetectorSensitivity;  //尾随检测灵敏度，范围：0-100%
    BYTE  byManyPersonSensitivity;    //多人检测灵敏度，范围：0-100%
    BYTE  byRes2[28];  //保留
}NET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG,*LPNET_DVR_SAFETYCABIN_PERSON_SIGNAL_CFG;    

typedef struct tagNET_DVR_ETHERNET_IPV6_COND
{
    DWORD        dwSize;
    BYTE  byMACAddr[MACADDR_LEN]; //网卡的物理地址
    BYTE  byRes[64];      //保留
}NET_DVR_ETHERNET_IPV6_COND,*LPNET_DVR_ETHERNET_IPV6_COND;

typedef struct tagNET_DVR_ETHERNET_IPV6_CFG
{
    DWORD        dwSize;
    BYTE  byState; //IPv6状态，0-路由分配，1-自动设置
    BYTE  byRes1[3]; 
    BYTE  byIPv6[MAX_IPV6_LEN]; //IPv6地址
    BYTE  byRes[64];      //保留
}NET_DVR_ETHERNET_IPV6_CFG,*LPNET_DVR_ETHERNET_IPV6_CFG;

typedef struct  
{
    BYTE byHour;//0~24
    BYTE byMinute;//0~60
    BYTE bySecond;//0~60
    BYTE byRes;
    WORD wMilliSecond; //0~1000
    BYTE byRes1[2];
}NET_DVR_DAYTIME,*LPNET_DVR_DAYTIME;



typedef struct 
{
    BYTE byAreaNo;//区域编号(IPC- 1~8)
    BYTE byRes[3];
    NET_VCA_RECT struRect;//单个区域的坐标信息(矩形) size = 16;
    NET_DVR_DNMODE  struDayNightDisable;//关闭模式
    NET_DVR_DNMODE  struDayModeParam;//白天模式
    NET_DVR_DNMODE  struNightModeParam;//夜晚模式
    BYTE byRes1[8];
}NET_DVR_MOTION_MULTI_AREAPARAM, *LPNET_DVR_MOTION_MULTI_AREAPARAM;



typedef struct 
{
    NET_DVR_MOTION_SINGLE_AREA  struMotionSingleArea; //普通模式下的单区域设
    NET_DVR_MOTION_MULTI_AREA struMotionMultiArea; //专家模式下的多区域设置    
}NET_DVR_MOTION_MODE_PARAM, *LPNET_DVR_MOTION_MODE_PARAM;

typedef struct 
{    
    NET_DVR_MOTION_MODE_PARAM  struMotionMode; //(5.1.0新增)
    BYTE byEnableHandleMotion;        /* 是否处理移动侦测 0－否 1－是*/ 
    BYTE byEnableDisplay;    /*启用移动侦测高亮显示，0-否，1-是*/
    BYTE byConfigurationMode; //0~普通,1~专家(5.1.0新增)
    BYTE byKeyingEnable; //启用键控移动侦测 0-不启用，1-启用
    /* 异常处理方式 */
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/ 
    /*0x1000: 抓图上传到云*/
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数量
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40]; //实际触发的报警输出号，按值表示,采用紧凑型排列，从下标0 - dwRelAlarmOut -1有效，如果中间遇到0xffffffff,则后续无效
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间*/
    /*触发的录像通道*/
    DWORD     dwMaxRecordChanNum;   //设备支持的最大关联录像通道数-只读
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40];     /* 实际触发录像通道，按值表示,采用紧凑型排列，从下标0 - dwRelRecordChan -1有效，如果中间遇到0xffffffff,则后续无效*/  
    BYTE  byDiscardFalseAlarm; //启用去误报 0-无效，1-不启用，2-启用
    BYTE  byRes[127]; //保留字节
}NET_DVR_MOTION_V40,*LPNET_DVR_MOTION_V40;





typedef struct  //
{
    DWORD                   dwSize; 
    BYTE   byWorkType;// 0-自适应, 1-定时模式
    BYTE   byRes[3];
    //定时模式参数
    NET_DVR_SCHEDULE_DAYTIME  struDayNightScheduleTime;//日夜定时切换模式(白天时间)
    NET_DVR_CAMERAPARAMCFG_EX   struSelfAdaptiveParam; //自适应参数
    NET_DVR_CAMERAPARAMCFG_EX   struDayIspAdvanceParam;//白天参数
    NET_DVR_CAMERAPARAMCFG_EX   struNightIspAdvanceParam;//夜晚参数
    BYTE   byRes1[512];
}NET_DVR_ISP_CAMERAPARAMCFG,*LPNET_DVR_ISP_CAMERAPARAMCFG;


typedef struct tagNET_DVR_GBT28181_ACCESS_CFG
{
    DWORD       dwSize;
    BYTE       byEnable;//28181协议使能 0-关闭 1-开启
    BYTE       byTransProtocol;//传输协议:0-UDP、1-TCP、默认0-UDP
    WORD       wLocalSipPort;//1024-65535(IPC设备端)
    char       szServerID[MAX_SERVERID_LEN];//服务器ID：64字节字符串，仅限数字
    char       szServerDomain[MAX_SIPSERVER_ADDRESS_LEN] ;// 服务器域
    char       szSipServerAddress[MAX_SIPSERVER_ADDRESS_LEN] ;// SIP服务器地址支持域名和IP地址
    WORD       wServerSipPort;//服务器SIP端口：1024-65535
    BYTE       byProtocolVersion;//协议版本 0-GB/T28181-2011(仅支持UDP),1-GB/T28181-2015(支持TCP,UDP),2-GB/T28181-2016
    BYTE        byTCPConnectMod; //TCP连接模式，使用TCP传输协议时有效，0-无效，1-主动模式，2-被动模式
    char       szSipUserName[MAX_SERVERNAME_LEN];//SIP用户名称：64字节字符串(第三方SIP终端请求IPC服务时使用)
    char       szSipAuthenticateID[MAX_AUTHENTICATEID_LEN];//SIP用户认证ID：64字节字符串
    char       szSipAuthenticatePasswd[MAX_AUTHENTICATEPASSWD_LEN];//SIP用户认证密码：32字节字符串(IPC设备注册到SIP服务器时使用)
    DWORD      dwRegisterValid;//注册有效期：单位秒，默认3600；
    BYTE       byHeartbeatInterval;//心跳间隔：单位秒，默认10秒；
    BYTE       byMaxHeartbeatTimeOut;//最大心跳超时次数：默认3次；
    BYTE       byStreamType;// 取流类型0～主码流，1～子码流，2～3码流
    BYTE          byDeviceStatus; //设备是否在线状态，0-保留，1-在线，2-离线
    DWORD      dwRegisterInterval;//注册间隔:注册失败后再次注册的时间间隔,范围60-600s，默认60s
    DWORD      dwAutoAllocChannelID ; //是否自动分配通道ID,按位表示，0为手动配置，1为自动分配，bit1-自动分配编码通道ID,bit2-自动分配报警输入通道,bit3-自动分配解码通道ID 
    char       szDeviceDomain[MAX_SIPSERVER_ADDRESS_LEN] ;// 设备域
    BYTE       byRes4[116];
}NET_DVR_GBT28181_ACCESS_CFG,*LPNET_DVR_GBT28181_ACCESS_CFG;

typedef struct tagNET_DVR_GBT28181_CHANINFO_CFG
{
    DWORD                   dwSize;
    char    szVideoChannelNumID[MAX_COMPRESSIONID_LEN];//设备视频通道编码ID：64字节字符串，仅限数字
    BYTE             byRes[256];
}NET_DVR_GBT28181_CHANINFO_CFG,*LPNET_DVR_GBT28181_CHANINFO_CFG;

typedef struct tagNET_DVR_ALARMIN_INFO
{
    NET_DVR_STREAM_INFO struStreamInfo;
    DWORD  dwAlarmInChannel;//报警输入通道号
    BYTE  byRes[32]; //保留
}NET_DVR_ALARMIN_INFO, *LPNET_DVR_ALARMIN_INFO;

typedef struct tagNET_DVR_GBT28181_ALARMINCFG
{
    DWORD                   dwSize;
    char    szAlarmInNumID[MAX_COMPRESSIONID_LEN];//设备报警输入编码ID（每一路报警输入不同）：20字节字符串，仅限数字
    BYTE             byRes[256];
}NET_DVR_GBT28181_ALARMINCFG,*LPNET_DVR_GBT28181_ALARMINCFG;

typedef struct tagNET_DVR_CAMERA_SETUPCFG
{
    DWORD dwSize;
    WORD  wSetupHeight; //架设高度[0,20]，单位：米
    BYTE  byLensType; //镜头焦距类型，0-未知,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm
    BYTE  bySetupHeightUnit;// 架设高度单位0～M,1~CM
    DWORD dwSceneDis; //图像下边缘位置与相机之间的水平距离，单位：厘米
    float fPitchAngle;//相机俯仰角度[-180°, 180°],
    float fInclineAngle;//相机倾斜角度[-180°,180°]
    float fRotateAngle;//相机旋转角度[-180°,180°]
    WORD  wVideoDetCoefficient; //视频测试系数[0,300](3.6新增)
    BYTE  byErectMethod; //架设方式0-正装，1-侧装(3.6新增)
    BYTE  byCameraViewAngle;//摄像机安装视野角度(0-垂直，1-倾斜，默认0-垂直)
    DWORD dwHorizontalDistance;//摄像机与出入口水平距离：范围1-1000，默认30，单位cm，注意摄像机角度为倾斜时该项有效
    BYTE  byDetailLensType;//范围1-100，默认28，单位0.1mm
    BYTE  byRes[3]; 
    float fHorFieldAngle; //相机水平视场角角度[0°, 360°]（抓拍机）
    float fVerFieldAngle; //相机垂直视场角角度[0°, 360°]（抓拍机）,鹰眼范围-90°-90°
    float fLableSetupHeight; //标签到架设相机的高度[0,100]，单位：米
    float fMaxViewRadius;//最大可视半径,0~10000.00米，默认5000米.
    BYTE  byRes1[16];
}NET_DVR_CAMERA_SETUPCFG, *LPNET_DVR_CAMERA_SETUPCFG;

typedef struct tagNET_DVR_SCHEDDATE
{   
    BYTE   byStartMonth;   //起始（月）
    BYTE   byStartDay;     //起始（日）
    BYTE   byStopMonth;    //结束（月）
    BYTE   byStopDay;      //结束（日）
}NET_DVR_SCHEDDATE,*LPNET_DVR_SCHEDDATE;

typedef struct tagNET_DVR_OUTPUT_SCHEDULE
{   
    NET_DVR_SCHEDTIME struTime;  //时间段
    BYTE byState;                //0–关闭, 1–开启
    BYTE byRes[11];              //保留
} NET_DVR_OUTPUT_SCHEDULE ,*LPNET_DVR_OUTPUT_SCHEDULE;

typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE
{   
    BYTE                     byEnable;    //是否启用规则,0-否,1-是
    BYTE                     byRes1[3];   //保留
    NET_DVR_SCHEDDATE        struDate;    //日期区段
    NET_DVR_OUTPUT_SCHEDULE  struOutputSchedule[MAX_TIMESEGMENT_V30];  //最多支持8个时间段的时控输出
    BYTE                     byRes2[16];  //保留
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE,*LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE;

typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG
{   
    DWORD  dwSize; //结构体大小
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE struOutputRule[MAX_RULE_NUM]; //最多支持8个日期区段的规则配置
    BYTE   byRes[64];  //保留
}NET_DVR_OUTPUT_SCHEDULE_RULECFG,*LPNET_DVR_OUTPUT_SCHEDULE_RULECFG;

typedef struct tagNET_DVR_TPS_ALARMCFG
{
    DWORD dwSize;
    BYTE byEnable; //是否启用交通统计报警上传
    BYTE byRes1[3];    //
    DWORD dwInterval;//统计间隔时间（单位：分钟）
    BYTE  byRes[248];
}NET_DVR_TPS_ALARMCFG, *LPNET_DVR_TPS_ALARMCFG;

typedef struct tagNET_DVR_DOWNLOAD_ALARM_RECORD_COND
{
    DWORD dwSize;
    WORD  wAlarmRecordID;    //报警录像ID(用于查询录像，仅当byResultType为2时有效)
    BYTE  byRes[130];
}NET_DVR_DOWNLOAD_ALARM_RECORD_COND, *LPNET_DVR_DOWNLOAD_ALARM_RECORD_COND;

typedef struct tagNET_DVR_CABINET_AlARM_PARAMCFG
{
    char  sCabinetName[NAME_LEN];
    BYTE  byAssociateIO;//1-4，0xff， 其中1-4表示具体的IO通道号，0xff表示不启用
    BYTE  byCabinetState;//0~低电平,1~高电平
    BYTE  byAlarmIntervalTime;//取值范围1-60，单位：秒
    BYTE  byRes1[25]; 
}NET_DVR_CABINET_AlARM_PARAMCFG, *LPNET_DVR_CABINET_AlARM_PARAMCFG;

typedef struct tagNET_DVR_CABINET_CFG
{
    DWORD dwSize;
    BYTE  byEnable;//0~不启用，1～启用
    BYTE  byRes[3];
    NET_DVR_CABINET_AlARM_PARAMCFG struCabinetCfg[MAX_CABINET_COUNT];
    BYTE  byRes1[84];
} NET_DVR_CABINET_CFG, *LPNET_DVR_CABINET_CFG;





typedef struct tagNET_ITS_ECT_CHANNELSTATE
{
    DWORD dwSize;
    BYTE  byRecordStatic; //通道是否在录像,0-不录像,1-录像
    BYTE  bySignalStatic; //连接的信号状态,0-正常,1-信号丢失
    BYTE  byHardwareStatic;//通道硬件状态,0-正常,1-异常,例如DSP死掉
    BYTE  byChannelArmState; //接入IPC的布防状态
    DWORD dwChannel; //通道号
    DWORD dwBitRate;//实际码率
    DWORD dwLinkNum;//客户端连接的个数
    NET_DVR_IPADDR struClientIP[MAX_LINK];//客户端的IP地址
    DWORD dwIPLinkNum;//如果该通道为IP接入，那么表示IP接入当前的连接数
    BYTE  byExceedMaxLink;    // 是否超出了128路连接数 0 - 未超出, 1-超出     
    BYTE  byRes[139];       // 保留字节    
}NET_ITS_ECT_CHANNELSTATE, *LPNET_ITS_ECT_CHANNELSTATE;

typedef struct tagNET_DVR_PARK_EXTERNAL_SUBINFO
{
    BYTE   byEnable; //0 ～ 不开启 1 ～ 开启
    BYTE   byFlicker;//0 ～ 不闪烁 1 ～ 闪烁
    BYTE   byIOState;//0 ～ 低电平 1 ～ 高电平 (外置灯起效)
    BYTE   byLampColor;// 0- 灭 1-红   2-绿  3-黄  4-蓝 5-品红  6-青  7-白色 (内置灯起效)
    BYTE   byRes[4];
}NET_DVR_PARK_EXTERNAL_SUBINFO, *LPNET_DVR_PARK_EXTERNAL_SUBINFO;

typedef struct tagNET_DVR_PARK_INLAY_SUBINFO
{
    BYTE   byEnable; //0～不开启 1 ～开启
    BYTE   byFlicker;//0～不闪烁 1 ～闪烁
    BYTE   byLampColor;//0-灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (内置灯起效) 
    BYTE   byRes[21];
}NET_DVR_PARK_INLAY_SUBINFO, *LPNET_DVR_PARK_INLAY_SUBINFO;

typedef struct tagNET_DVR_PARKINFO
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalParkIOState;//有车io电平状态
    NET_DVR_PARK_EXTERNAL_SUBINFO   struNormalNoParkIOState;//无车io电平状态
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialParkIOState;//特殊车位有车io电平状态
    NET_DVR_PARK_EXTERNAL_SUBINFO   struSpecialNoParkIOState;//特殊车位无车io电平状态
    BYTE   byRes[32];
}NET_DVR_PARKINFO, *LPNET_DVR_PARKINFO;

typedef struct tagNET_DVR_EXTERNAL_LAMP_CTRL_MODE
{
    NET_DVR_PARKINFO  struParkInfo[MAX_PARKING_NUM];/*外接灯的情况下车位信息，一个通道最大4个车位 (从左到右车位 数组0～3)*/
    BYTE   byRes[32];
}NET_DVR_EXTERNAL_LAMP_CTRL_MODE, *LPNET_DVR_EXTERNAL_LAMP_CTRL_MODE; 

typedef struct tagNET_DVR_INLAY_LAMP_CTRL_MODE
{
    NET_DVR_PARK_INLAY_SUBINFO  struLampStateCtrl[MAX_PARKING_STATUS];
    BYTE   byRes[96];
}NET_DVR_INLAY_LAMP_CTRL_MODE, *LPNET_DVR_INLAY_LAMP_CTRL_MODE; 

typedef struct tagNET_DVR_LAMP_INFO //8
{
    BYTE   byEnable; //0～不开启 1 ～开启
    BYTE   byFlicker;//0~不闪烁 1 ～闪烁(车位指示灯闪烁)
    BYTE   byLampColor;//0- 灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (车位指示灯颜色)
    BYTE   byRes[5];
}NET_DVR_LAMP_INFO, *LPNET_DVR_LAMP_INFO;

typedef struct tagNET_DVR_PARKLAMP_CTRL_MODE//size == 72
{
    //车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
    NET_DVR_LAMP_INFO  struLampInfo[MAX_PARKING_STATUS/*8*/];
    //关联车位灯（0-内置灯, 1-外置灯1, 2-外置灯2, 3-外置灯3）
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_PARKLAMP_CTRL_MODE, *LPNET_DVR_PARKLAMP_CTRL_MODE; 

typedef struct tagNET_DVR_LAMP_PARAM //4
{
    BYTE   byEnable; //0～不开启 1 ～开启
    BYTE   byFlicker;//0~不闪烁 1 ～闪烁
    BYTE   byLampColor;//0- 灭 1-红   2-绿  3-黄  4-蓝 5-品红  6-青  7-白色 
    BYTE   byRes[3];
}NET_DVR_LAMP_PARAM, *LPNET_DVR_LAMP_PARAM;

typedef struct tagNET_DVR_EXTERNAL_PARKLAMP //size == 56
{
    //车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
    NET_DVR_LAMP_PARAM  struLampParam[MAX_PARKING_STATUS/*8*/];
    //关联车位灯（0-内置灯, 1-外置灯1, 2-外置灯2, 3-外置灯3）
    BYTE   byLampType;
    BYTE   byRes[7];
}NET_DVR_EXTERNAL_PARKLAMP, *LPNET_DVR_EXTERNAL_PARKLAMP; 

typedef struct tagNET_DVR_BUILTIN_PARKLAMP
{
    BYTE   byEnable;     //0～不开启 1 ～开启
    BYTE   byFlicker;    //0~不闪烁 1 ～闪烁
    BYTE   byLampColor;  //0- 灭 1-红 2-绿 3-黄 4-蓝 5-品红 6-青 7-白色 (内置灯起效)  
    BYTE   byRes[5];
}NET_DVR_BUILTIN_PARKLAMP, *LPNET_DVR_BUILTIN_PARKLAMP;

typedef struct tagNET_DVR_MIXLAMP_CTRL_MODE
{
    NET_DVR_EXTERNAL_PARKLAMP  struExternalParkLamp[MAX_PARKING_NUM/*4*/];//外置灯 按照车位号进行区分，一个通道最大4个车位 (从左到右车位 数组0～3) 
    NET_DVR_BUILTIN_PARKLAMP  struBuiltInParkLamp[MAX_PARKING_STATUS/*8*/];//内置灯 按照车位状态区分，车位状态 0代表无车，1代表有车，2代表压线(优先级最高), 3特殊车位
}NET_DVR_MIXLAMP_CTRL_MODE, *LPNET_DVR_MIXLAMP_CTRL_MODE;

typedef struct tagNET_DVR_SINGLELAMP_CTRL_MODE //单外置灯模式是不区分车位信息，显示当前车位状态中，等级最好的状态（压线>特殊车位>有无车状态）
{
    NET_DVR_PARK_EXTERNAL_SUBINFO   struExternLampStateCtrl[MAX_PARKING_STATUS/*4*/];//外置灯 按照车位号进行区分，一个通道最大4个车位 (从左到右车位 数组0～3)
    BYTE byLampType; /* 1-外置灯1，2-外置灯2，3-外置灯3*/
    BYTE byRes[23];
}NET_DVR_SINGLELAMP_CTRL_MODE, *LPNET_DVR_SINGLELAMP_CTRL_MODE;


typedef struct tagNET_DVR_LAMP_CTRL_INFO
{
    DWORD     dwSize;
    BYTE      byLampCtrlMode;/*控灯模式：1代表内置灯,2代表外接灯,3代表内外置灯,4代表混合灯模式（内置灯只做高优先级指示灯),5-代表单外置灯模式*/
    BYTE      byCtrlChannelIndex;/*交替控制通道号(33~48)*/
    BYTE      byRes[2];
    NET_DVR_LAMP_CTRL_MODE_UNION  uLampCtrlMode;/*灯控制模式联合体*/
    BYTE      byRes2[32];
}NET_DVR_LAMP_CTRL_INFO, *LPNET_DVR_LAMP_CTRL_INFO;

typedef struct tagNET_DVR_PARKSPACE_INFO
{
    BYTE      byParkSpaceAttribute; //0~普通车位 1～特殊车位
    BYTE      byRes[23];
}NET_DVR_PARKSPACE_INFO, *LPNET_DVR_PARKSPACE_INFO;

typedef struct tagNET_DVR_PARKSPACE_ATTRIBUTE
{
    DWORD     dwSize;
    NET_DVR_PARKSPACE_INFO  struParkSpaceInfo[MAX_PARKING_NUM];//一个通道最大4个车位 (从左到右车位 数组0～3)
    BYTE      byRes[64];
}NET_DVR_PARKSPACE_ATTRIBUTE, *LPNET_DVR_PARKSPACE_ATTRIBUTE;

typedef struct tagNET_DVR_LAMP_STATE
{
    BYTE      byFlicker;//0~不闪烁 1 ～闪烁
    BYTE      byParkingIndex;//车位号1～3
    BYTE      byRes1[2];
    DWORD     dwIONo;//1~IO1;2~IO2;4~IO3;
    BYTE      byRes2[8];
}NET_DVR_LAMP_STATE, *LPNET_DVR_LAMP_STATE;

typedef struct tagNET_DVR_LAMP_EXTERNAL_CFG
{
    DWORD     dwSize;
    BYTE      byEnable; //外控使能 0～不启用 1～启用
    BYTE      byRes1[3];
    NET_DVR_LAMP_STATE     struLampStateCtrl;//指示灯外控
    BYTE      byRes2[32];
}NET_DVR_LAMP_EXTERNAL_CFG, *LPNET_DVR_LAMP_EXTERNAL_CFG;

typedef struct tagNET_DVR_COMPEL_CAPTURE
{
    DWORD      dwSize;
    BYTE       byParkIndex;/*车位序号从左到右 （0-表示当前有几个车位，就上传几张图片）1,2,3,4*/
    BYTE       byRes[63];
}NET_DVR_COMPEL_CAPTURE, *LPNET_DVR_COMPEL_CAPTURE;

typedef struct tagNET_DVR_EXTERNAL_CONTROL_ALARM
{
    DWORD     dwSize;
    DWORD      dwChannelNo;
    NET_DVR_LAMP_STATE      struLampStateCtrl;//指示灯外控状态
    NET_DVR_TIME      struExternalBeginTime;/*外控开始时间*/ 
    BYTE      byRes1[64];
}NET_DVR_EXTERNAL_CONTROL_ALARM, *LPNET_DVR_EXTERNAL_CONTROL_ALARM;




typedef struct  tagNET_DVR_GATE_ALARMINFO
{
    DWORD  dwSize;
    //0x1车辆非法侵入报警
    //0x2道闸超时未关报警
    //0x3车辆压线圈超时报警
    //0x4发卡报警（无卡）
    //0x5发卡报警（少卡）
    //0x6发卡报警（发卡异常）
    BYTE  byAlarmType;
    BYTE  byExternalDevType;//外接设备类型(EXTERNAL_DEVICES_TYPE)
    BYTE  byExternalDevStatus;//外接设备类型(EXTERNAL_DEVICES_STATUS)
    BYTE  byExternalDevCtrlType;//外接设备控制类型(EXTERNAL_DEVICESCTRL_TYPE)
    NET_DVR_TIME_V30  struAlarmTime;//报警时间        
    union
    {
        BYTE  uLen[128];
        struct
        {
            char  sLicense[MAX_LICENSE_LEN/*16*/];//车牌号码
            /*车辆类型0-保留 1-固定车，2-临时车，3-预订车，4-联检车，5-授权车*/
            BYTE  byVehicleType;
            BYTE  byRes1[111];
        }struVehicleInfo;//当struAlarmType为(0x1车辆非法侵入报警)
    }uAlarmInfo;
    BYTE  byRes2[64]; //预留
}NET_DVR_GATE_ALARMINFO, *LPNET_DVR_GATE_ALARMINFO;

typedef struct tagNET_DVR_ALARMWIRELESSINFO
{
    BYTE     byDeviceID[NAME_LEN];   //设备ID
    float       fDataTraffic;    /* 已用流量,单位：MB,小数点后两位*/
    BYTE      bySignalIntensity;  /* 信号强度，0~100*/
    BYTE      byRes[127];
}NET_DVR_ALARMWIRELESSINFO, *LPNET_DVR_ALARMWIRELESSINFO;

typedef struct tagNET_DVR_VOLTAGE
{
    int iPhaseAVol;            //A相电压
    int iPhaseBVol;            //B相电压
    int iPhaseCVol;            //C相电压
    int iAveragePhaseVol;    //相电压平均值
}NET_DVR_VOLTAGE, *LPNET_DVR_VOLTAGE;

typedef struct _tagNET_DVR_LINE_VOLTAGE
{
    int iLineVolAB;            //AB线电压
    int iLineVolBC;            //BC线电压
    int iLineVolCA;            //CA线电压
    int iAverageLineVol;    //线电压平均值
} NET_DVR_LINE_VOLTAGE,*LPNET_DVR_LINE_VOLTAGE;

typedef struct tagNET_DVR_CURRENT
{
    int iPhaseACurrent;            //A相电流
    int iPhaseBCurrent;            //B相电流
    int iPhaseCCurrent;            //C相电流
    BYTE byRes[4];
}NET_DVR_CURRENT, *LPNET_DVR_CURRENT;

typedef struct tagNET_DVR_POWER
{
    int iPhaseAPower;            //A相功率
    int iPhaseBPower;            //B相功率
    int iPhaseCPower;            //C相功率
    int iSysTotalPower;            //系统总功率
}NET_DVR_POWER, *LPNET_DVR_POWER;

typedef struct tagNET_DVR_POWER_FACTOR
{
    int iPhaseAPowerFactor;     //A相功率因数
    int iPhaseBPowerFactor;     //B相功率因数
    int iPhaseCPowerFactor;     //C相功率因数
    int iTotalPowerFactor;      //总功率因数
}NET_DVR_POWER_FACTOR, *LPNET_DVR_POWER_FACTOR;

typedef struct tagNET_DVR_FREQUENCY
{
    int iPhaseAFrequency;        //A相频率
    int iPhaseBFrequency;        //B相频率
    int iPhaseCFrequency;        //C相频率
    BYTE byRes[4];
}NET_DVR_FREQUENCY, *LPNET_DVR_FREQUENCY;

typedef struct tagNET_DVR_LOAD_FACTOR
{
    int iPhaseALoadFactor;        //A相负载率
    int iPhaseBLoadFactor;        //B相负载率
    int iPhaseCLoadFactor;        //C相负载率
    BYTE    byRes[4];
} NET_DVR_LOAD_FACTOR, *LPNET_DVR_LOAD_FACTOR;

typedef struct tagNET_DVR_ALARMHOST_UPS_STATE
{
    NET_DVR_VOLTAGE        struInputVoltage;    //输入电压
    NET_DVR_VOLTAGE        struBypassVoltage;    //旁路电压
    NET_DVR_VOLTAGE        struOutputVoltage;    //输出电压
    int iRectifierVol;            //整流器电压
    int iInverterVol;            //逆变器电压
    
    NET_DVR_CURRENT    struInputCurrent;    //输入电流
    NET_DVR_CURRENT    struBypassCurrent;    //旁路电流
    NET_DVR_CURRENT    struOutputCurrent;    //输出电流
    int iInverterCurrent;        //逆变器电流
    
    NET_DVR_FREQUENCY    struInputFrequency;    //输入频率
    NET_DVR_FREQUENCY    struBypassFrequency;    //旁路频率
    NET_DVR_FREQUENCY    struOutputFrequency;    //输出频率
    int iInverterFre;            //逆变器频率
    
    NET_DVR_POWER         struInputPower;    //输入功率
    NET_DVR_POWER        struBypassPower;    //旁路功率
    NET_DVR_POWER        struOutputPower;    //输出功率
    NET_DVR_POWER        struComplexPower;    //复功率
    
    int iNormalPower;            //标称功率
    int iPowerFacter;            //功率因数
    
    NET_DVR_LOAD_FACTOR    struBatteryLoadFactor;    //电池负载率
    int iBatteryEstimated;        //电池备份时间(min)
    int iBatteryTemperature;        //电池温度
    int iBatteryVoltage;            //电池电压
    
    
    BYTE    byRectifierState;        //整流器运行状态/*1正常 2异常*/
    BYTE    byInverterState;        //逆变器运行状态/*1正常 2异常*/
    BYTE    byChargeState;        //充电器运行状态/*1正常 2异常*/
    BYTE    byBatteryState;        //电池运行状态/*1正常 2异常*/
    BYTE    byAutoBypassState;    //自动旁路状态/*1正常 2异常*/
    BYTE    byRes2[247];
} NET_DVR_ALARMHOST_UPS_STATE, *LPNET_DVR_ALARMHOST_UPS_STATE; 

typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_STATE
{
    NET_DVR_VOLTAGE        struACVoltage;    //交流电压
    int     iDCConvertVoltage;    //DC转换器电压
    NET_DVR_CURRENT        struACCurrent;    //交流电流
    int     iTotalCurrent;            //负载总电流
    int     iBattery1Temperature;    //电池1温度
    int     iBattery2Temperature;    //电池2温度
    int     iBattery1Current;        //电池1电流
    int     iBattery2Current;        //电池2电流
    int     iBattery3Current;        //电池3电流
    int     iBattery4Current;        //电池4电流
    int     iBatteryTestVoltage;    //电池测试电压
    int     iRectifierOutputVoltage;    //整流模块输出电压
    int     iRectifierOutputCurrent;    //整流模块输出电流
    int     iDCOutputVoltage;        //直流输出电压
    BYTE    byRes[432];
} NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_STATE, 

typedef struct tagNET_DVR_ALARMHOST_GAS_DETECTOR_STATE
{
    int        iSF6;            //SF6，单位ppm
    int      iFlow;           //流量，ml/min       
    int        iTemperature;        //温度，单位摄氏度
    int        iO2;            //氧气，单位%
    int        iHumidity;        //湿度，单位%
    BYTE    byRes[492];
} NET_DVR_ALARMHOST_GAS_DETECTOR_STATE,

typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE
{
    int        iTemperature;    //温度，单位摄氏度
    int        iHumidity;        //湿度，单位%
    BYTE    byRes[504];
} NET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE, *LPNET_DVR_ALARMHOST_TEMP_HUMI_SENSOR_STATE;

typedef struct tagNET_DVR_ALARMHOST_AIRCONDITION_STATE
{
    int        iTemperature;    //温度，单位摄氏度
    int        iHumidity;        //湿度，单位%
    BYTE   byRunState;        //运行状态 1-正常，2-停机
    BYTE    byRes[503];
} NET_DVR_ALARMHOST_AIRCONDITION_STATE, *LPNET_DVR_ALARMHOST_AIRCONDITION_STATE;

typedef struct tagNET_DVR_ALARMHOST_ELECTRICITY_STATE
{
    int        iDCVoltage;        //直流电压
    int        iDCCurrent;        //直流电流
    NET_DVR_VOLTAGE        struPhaseVoltage;    //相电压
    NET_DVR_LINE_VOLTAGE struLineVoltage;    //线电压
    NET_DVR_CURRENT    struCurrent[4];        //电流，struCurrent[0]表示第1路, 以此类推 
    int iAverageCurrent;    //平均电流
    int iNeutralCurrent;        //中线电流
    NET_DVR_POWER    struActivePower[4];    //有功功率 struActivePower[0]表示第一路有功功率，以此类推
    NET_DVR_POWER    struReactivePower[4];    //无功功率 struReactivePower[0]表示第一路无功功率，以此类推
    NET_DVR_POWER    struApparentPower[4];    //视在功率 struApprentPower[0]表示第一路视在功率，以此类推
    NET_DVR_POWER_FACTOR    struPowerFactor[4];    //功率因数，struPowerFactor[0]表示第一路功率因数，以此类推
    NET_DVR_FREQUENCY        struFrequency;            //频率
    BYTE byRes[128];
}NET_DVR_ALARMHOST_ELECTRICITY_STATE, *LPNET_DVR_ALARMHOST_ELECTRICITY_STATE;

typedef struct  tagNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE
{
    int        iPhaseATemperature;        //A相温度
    int        iPhaseBTemperature;        //B相温度
    int        iPhaseCTemperature;        //C相温度
    int        iPhaseDTemperature;        //D相温度
    BYTE     byRes[496];
}NET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE, *LPNET_DVR_ALARMHOST_TRANSFORMER_TEMP_STATE;

typedef struct tagNET_DVR_ALARMHOST_WATERLEVEL_SENSOR
{
    LONG        iWaterLevel;        //水位
    BYTE        byRes[508];
}NET_DVR_ALARMHOST_WATERLEVEL_SENSOR, *LPNET_DVR_ALARMHOST_WATERLEVEL_SENSOR;

typedef struct tagNET_DVR_ALARMHOST_DUSTNOISE_SENSOR
{
    LONG        iDust;        //扬尘
    LONG        iNoise;       //噪声
    LONG        iPM25;        //PM2.5
    BYTE        byRes[500];
}NET_DVR_ALARMHOST_DUSTNOISE_SENSOR, *LPNET_DVR_ALARMHOST_DUSTNOISE_SENSOR;

typedef struct tagNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER
{
    LONG        iAmmoniaNitrogen;    //氨氮
    LONG        iCOD;                //COD
    LONG        iPH;                //PH
    LONG        iOxygen;            //氧气
    LONG        iSulfurDioxide;    //二氧化硫
    LONG        iSoot;            //烟尘
    LONG        iFluoride;        //氟化物
    LONG        iPollutedWater;    //污水
    LONG        iTotalPhosphorus;    //总磷
    LONG        iExhaust;            //废气
    LONG        iNitrogenOxides;    //氮氧化物
    LONG        iFlueGasTemperature;//烟气温度
    LONG        iFlueGasPressure;    //烟气压力
    LONG 		iDustThickness; /*粉尘浓度*/
    LONG 		iAirCleanLevel; /*空气洁净度等级*/
    LONG 		iPm10Thickness; /*PM10浓度*/
    BYTE	    byRes[448];
}NET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER, *LPNET_DVR_ALARMHOST_ENVIRONMENTAL_LOGGER;










typedef struct tagNET_DVR_FIRE_ALARM_STATUS
{
    BYTE  byFireAlarm[MAX_FIRE_ALARM_ZONE][MAX_FIRE_ALARM_POINT_ZONE];           //火点状态参数位，1-正常，2-告警
    BYTE  byRes[128];   //保留位
}NET_DVR_FIRE_ALARM_STATUS, *LPNET_DVR_FIRE_ALARM_STATUS;


typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE
{
    DWORD dwSize;
    BYTE    byDevType;    //1-UPS，2-开关电源，3-气体检测系统，4-温湿度传感器，5-空调，6-电量表，7-变电器状态, 8-水位传感器、9-扬尘噪声传感器、10-环境采集仪、11-风速传感器状态、12-通用扩展输出模块状态、13-浸水传感器状态、14-太阳能控制器状态、15-SF6报警主机状态、16-称重仪状态、17-气象采集系统状态、18-水质检测仪状态、19-燃气监测系统状态、20-消防主机状态
    BYTE    byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_STATE_UNION struDevState;
    BYTE    byRes2[32];
} NET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_STATE;


typedef struct tagNET_DVR_ALARMHOST_UPS_LIMIT_VALUE
{
    int iInputVolHigh;        //越限输入电压值(高值)
    int iInputVolLow;        //越限输入电压值(低值)
    int iInputFreHigh;        //越限输入频率值(高值)
    int iInputFreLow;        //越限输入频率值(低值)
    int iOutputVolHigh;    //越界输出电压值(高值)
    int iOutputVolLow;        //越界输出电压值(低值)
    int iBatteryVoltageLow;    //电池低电压限值
    int iBatterySurplus;        //电池后备时间低 限值
    int iBatteryTemperatureHigh;//电池温度高限值
    BYTE    byRes[64];            //保留
}NET_DVR_ALARMHOST_UPS_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_UPS_LIMIT_VALUE;

typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE
{
    int iTemperatureHighLimit;    //温度高限值，单位摄氏度
    int iTemperatureLowLimit;    //温度低限值，单位摄氏度
    int iHumidityHighLimit;        //湿度高限值，单位%
    int iHumidityLowLimit;        //湿度低限值，单位%
    BYTE    byRes[84];        
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_LIMIT_VALUE;


typedef struct tagNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE
{
    DWORD dwSize;
    BYTE    byDevType;    //1-UPS，2-温湿度传感器
    BYTE    byRes1[3];
    NET_DVR_EXTERNAL_DEVICE_LIMIT_VALUE_UNION struAlarmValue;
    BYTE    byRes2[32];
}NET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE, *LPNET_DVR_ALARMHOST_EXTERNAL_DEVICE_LIMIT_VALUE;

typedef struct  tagNET_DVR_ALARMHOST_SENSOR_JOINT_CFG
{
    DWORD         dwSize;
    BYTE        bySensorJointAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM/*512*/];//模拟量联动触发器，0-不联动，1-联动
    BYTE        bySensorJointSiren[ALARMHOST_MAX_SIREN_NUM/*8*/];//模拟量联动警号
    BYTE        bySensorAlarmTypeJointAlarmOut[ALARMHOST_ALARMOUT_NUM/*64*/];//模拟量按类型联动触发器，该字段是bySensorJointAlarmOut的扩展。数组下标表示触发器号，数组元素的值按位表示报警类型，各个类型间是"或"的关系。类型值定义：1bit0-限1；bit1-限2；bit2-限3；bit3-限4；bit4-故障
    BYTE        bySesorAlarmTypeJointSiren[ALARMHOST_MAX_SIREN_NUM]; //模拟量按类型联动警号，该字段是bySensorJointSiren的扩展。数组下标表示警号序号，数组元素的值按位表示报警类型，各个类型间是"或"的关系。类型值定义：bit0-限1；bit1-限2；bit2-限3；bit3-限4；bit4-故障
    BYTE        byChan;        //通道号
    BYTE        byRes[55];
}NET_DVR_ALARMHOST_SENSOR_JOINT_CFG, *LPNET_DVR_ALARMHOST_SENSOR_JOINT_CFG;

typedef struct tagNET_DVR_ALARMHOST_UPS_ALARMINFO
{
    BYTE    byAlarmType;/*报警类型：1.A相输入电压越限 2.B相输入电压越限 3.C相输入电压越限 4.A相输出电压越限5.B相输出电压越限 6.C相输出电压越限7.A相输入频率越限 8.B相输入频率越限9.C相输入频率越限10.整流器电压越限报警 11.过载报警 12.电池电压低报警 13.电池后备时间超低报警 14.电池温度超高报警 15.逆变器关闭报警 16.自动旁路开报警 17.整流器故障报警 18.逆变器故障报警 19.充电器故障报警    20.电池故障报警     21.自动旁路故障报警 */    
    BYTE    byChanNo;    //485通道号，从1开始
    BYTE    bySlotNo;    //485虚拟槽位号
    BYTE    byRes1;        //保留
    int        iAlarmValue;//报警值
    BYTE    byRes2[64];        //保留
}NET_DVR_ALARMHOST_UPS_ALARMINFO, *LPNET_DVR_ALARMHOST_UPS_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO
{
    BYTE    byAlarmType;    /*报警类型：1-电池测试失败 2-AC-DC转换器故障，3-输入线/相电压AB/A越限，4-输入线/相电压BC/B越限，5-输入线/相电压CA/C越限，6-输出电流A越限，7-输出电流B越限，8-输出电流C越限，9整流模块故障，10-风扇故障，11-直流电压越限*/
    BYTE    byChanNo;        //485通道号，从1开始
    BYTE    bySlotNo;        //485虚拟槽位号
    BYTE    byRes1;
    int     iAlarmValue;        //报警值
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_SWITCH_POWER_SUPPLY_ALARMINFO, 

typedef struct tagNET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO
{
    BYTE    byAlarmType;    /*报警类型：1- SF6气体含量异常，2-氧气含量异常，3-温度值异常，4-湿度值异常，5-流量*/
    BYTE    byChanNo;    //485通道号，从1开始
    BYTE    bySlotNo;    //485虚拟槽位号
    BYTE    byRes1;
    int     iAlarmValue;        //报警值
    BYTE    byRes2[64];
}NET_DVR_ALARMHOST_GAS_DETECT_SYS_ALARMINFO, 

typedef struct tagNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO
{
    BYTE    byAlarmType;    //1-温度异常，2-湿度异常
    BYTE    byChanNo;        //485通道号
    BYTE    bySlotNo;        //485槽位号
    BYTE    byRes1;
    int         iAlarmValue;    //报警值
    BYTE    byRes2[64];
} NET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO, *LPNET_DVR_ALARMHOST_TEMP_HUMIDITY_SENSOR_ALARMINFO;


typedef struct  tagNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO
{
    DWORD dwSize;
    BYTE    byAlarmType;    //1-UPS报警，2-开关电源报警，3-气体检测系统报警，4-温湿度传感器报警
    BYTE    byRes1[3];
    NET_DVR_485_DEVICE_ALARM_UNION struAlarmInfo;
    BYTE    byRes2[16];
} NET_DVR_485_EXTERNAL_DEVICE_ALARMINFO, *LPNET_DVR_485_EXTERNAL_DEVICE_ALARMINFO;

typedef struct tagNET_DVR_ALARMHOST_RS485_SLOT_CFG
{
    DWORD       dwSize;              // 结构体大小
    BYTE        sDeviceName[NAME_LEN];      // 前端设备名称 
    WORD        wDeviceType;            // 前端设备类型ALARM_FRONT_DEVICE _TYPE
    WORD        wDeviceProtocol;     // 前端设备协议 通过获取协议列表获取
    WORD        wAddress;            //设备地址    
    BYTE        byChannel;          //485通道号
    BYTE        bySlotChan;         //槽位号
    BYTE        byRes[60];          // 保留字节
}NET_DVR_ALARMHOST_RS485_SLOT_CFG, *LPNET_DVR_ALARMHOST_RS485_SLOT_CFG;

typedef struct tagNET_DVR_CORRIDOR_MODE
{
    DWORD        dwSize;
    BYTE        byEnableCorridorMode; //是否启用走廊模式 0～不启用， 1～启用
    BYTE        byMirrorMode;            //镜像方式，0 关闭;1 左右;2 上下;3 中间 
    BYTE        byRes[126];
}NET_DVR_CORRIDOR_MODE, *LPNET_DVR_CORRIDOR_MODE;

typedef struct tagNET_DVR_DETECT_FACE
{
    DWORD     dwSize;
    BYTE     byEnableDetectFace; //是否启用 0～不启用， 1～启用
    BYTE     byDetectSensitive; //灵敏度 10个等级 1～10
    BYTE     byEnableDisplay;    /*启用移动侦测高亮显示，0-否，1-是*/
    BYTE     byRes;
    NET_DVR_HANDLEEXCEPTION_V40  struAlarmHandleType; /*处理方式*/
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30]; /*布防时间 */
    DWORD    dwMaxRelRecordChanNum;     //报警触发的录象通道 数（只读）最大支持数量
    DWORD    dwRelRecordChanNum;     //报警触发的录象通道数 实际支持数
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30];    /* 报警触发的录象通道*/
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //假日布防时间
    WORD     wDuration;  //报警持续时间 5s 能力集
    BYTE     byRes1[30];
}NET_DVR_DETECT_FACE, *LPNET_DVR_DETECT_FACE;

typedef struct tagNET_DVR_MUL_STREAM_CHANNEL_GROUP
{
    DWORD        dwSize;                 // 结构体大小
    DWORD       dwGroup ;             //组号
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg; //多码流配置
    BYTE         byRes[64] ;        
}NET_DVR_MUL_STREAM_CHANNEL_GROUP,*LPNET_DVR_MUL_STREAM_CHANNEL_GROUP;

typedef struct tagNET_DVR_CHANNEL_GROUP
{
    DWORD        dwSize;       // 结构体大小
    DWORD       dwChannel; //通道号
    DWORD       dwGroup;   //组号 
    BYTE        byID;      //设备区域设置ID
    BYTE        byRes1[3];
    DWORD       dwPositionNo; //场景位置索引号,IPC是0，IPD是从1开始
    BYTE        byRes[56];              
}NET_DVR_CHANNEL_GROUP, *LPNET_DVR_CHANNEL_GROUP;

typedef struct tagNET_DVR_TIME_DETECTION
{
    NET_DVR_SCHEDTIME  struSchedTime; //时间
    BYTE   byDetSceneID;//检测场景号[1,4],IPC默认是0
    BYTE   byRes[15];
}NET_DVR_TIME_DETECTION,*LPNET_DVR_TIME_DETECTION;

typedef struct tagNET_DVR_GUARD_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    /*
    0表示无效， 
    1表示关联 抓拍VIA模式（视频触发抓拍 IPC使用）;
    2 表示关联 抓拍 HVT 模式 （混卡IPC使用）
    */
    BYTE   byRelateType; 
    BYTE   byGroupNo;  //组号
    BYTE   byRes[62];
}NET_DVR_GUARD_COND,*LPNET_DVR_GUARD_COND;

typedef struct tagNET_DVR_GUARD_CFG
{
    DWORD  dwSize;
    //布防时间
    NET_DVR_TIME_DETECTION    struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; 
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    DWORD  dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD  dwRelRecordChanNum ;     //本组内实际触发的录象通道数
    DWORD  dwRelRecordChan[MAX_CHANNUM_V30];    //报警触发的录象通道(0xffff ffff表示后续无效）
    NET_DVR_TIME_DETECTION  struHolidayTime[MAX_TIMESEGMENT_V30]; //假日布防时间 
    BYTE   byDirection;//触发方向：0-保留；1-全部；2-正向；3-反向
    BYTE   byRes[87];
}NET_DVR_GUARD_CFG,*LPNET_DVR_GUARD_CFG;


typedef struct tagNET_DVR_SNAPINFOCFG
{
    DWORD dwSize;
    BYTE  byCurPicType;//0-表示的图片质量，1-表示图片大小
    BYTE  byPicQuality;//图片质量[1,100]
    BYTE  byRes1[2];
    DWORD dwPicSize;//图片大小[64k,2048k]
    BYTE  byRes2[128];
}NET_DVR_SNAPINFOCFG,*LPNET_DVR_SNAPINFOCFG;


typedef struct _NET_DVR_PTZ_TRACK_PARAM_
{
    DWORD dwSize;     //结构体大小
    BYTE  byTrackMode; //跟踪方式,参考PTZ_TRACK_MODE
    BYTE  byLinkageTarget; //联动目标0-默认,1-球机1,2-球机2…..依次类推
    BYTE  byAutoTrackEnable;//跟踪使能 0-自动跟踪开启，1-自动跟踪关闭（枪球设备才支持自动跟踪关闭功能，故在此特殊扩展）
    BYTE  byRes1; //保留
    DWORD dwTrackTime; //跟踪时间，
    //当跟踪模式为PTZ_TRACK_MODE_ALWAYS，此字段无效
    //当跟踪模式为PTZ_TRACK MODE_BYTIME时，范围[1,60]，默认10秒
    //当跟踪模式为PTZ_TRACK MODE_NEXT时，范围[1,10]，默认2秒
    BYTE  byRes2[256]; //保留
}NET_DVR_PTZ_TRACK_PARAM,*LPNET_DVR_PTZ_TRACK_PARAM;

typedef struct tagNET_VCA_TRAVERSE_PLANEPARAM
{
    DWORD dwSize;
    BYTE    byEnable;//使能
    BYTE    byEnableDualVca;// 启用支持智能后检索 0-不启用，1-启用
    BYTE    byEnableHumanMisinfoFilter;// 启用人体去误报 0-不启用，1-启用
    BYTE    byEnableVehicleMisinfoFilter;// 启用车辆去误报 0-不启用，1-启用
    NET_VCA_TRAVERSE_PLANE struAlertParam[MAX_ALERTLINE_NUM];  //警戒线参数
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    DWORD  dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD  dwRelRecordChanNum ;     //报警触发的录象通道 数 实际支持的数量
    DWORD  byRelRecordChan[MAX_CHANNUM_V30];//触发录像的通道号
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //假日布防时间
    BYTE byRes2[100];
}NET_VCA_TRAVERSE_PLANE_DETECTION, *LPNET_VCA_TRAVERSE_PLANE_DETECTION;

typedef struct tagNET_VCA_FIELDDETECION
{
    DWORD dwSize;
    BYTE byEnable; //使能，是否开启
    BYTE byEnableDualVca;// 启用支持智能后检索 0-不启用，1-启用
    BYTE byEnableHumanMisinfoFilter;// 启用人体去误报 0-不启用，1-启用
    BYTE byEnableVehicleMisinfoFilter;// 启用车辆去误报 0-不启用，1-启用
    NET_VCA_INTRUSION struIntrusion[MAX_INTRUSIONREGION_NUM];//每个区域的参数设置
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30]; //布防时间
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    DWORD  dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD  dwRelRecordChanNum ;     //报警触发的录象通道 数 实际支持的数量
    DWORD  byRelRecordChan[MAX_CHANNUM_V30];//触发录像通道
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30/*8*/]; //假日布防时间
    BYTE byRes2[100];
}NET_VCA_FIELDDETECION, *LPNET_VCA_FIELDDETECION;

typedef struct tagNET_DVR_ROI_DETECT_NUM
{
    DWORD   dwSize;
    DWORD   dwGroup;
    DWORD   dwStreamType;    //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
    DWORD   dwRoiFixNum; //固定区域总数，确定后续再次获取的组号
    DWORD   dwRoiFixID[MAX_ROIDETECT_NUM];//IPC现在支持4个，球机现在支持24个
    BYTE    szFixRoiName[MAX_ROIDETECT_NUM][NAME_LEN];//固定ROI区域名称
    DWORD   dwRoiTrackNum; //自动跟踪区域总数，确定后续再次获取的组号
    DWORD   dwRoiTrackID[MAX_ROIDETECT_NUM];//IPC现在支持4个，球机现在支持24个
    BYTE    byRes[320];
}NET_DVR_ROI_DETECT_NUM, *LPNET_DVR_ROI_DETECT_NUM;


typedef struct tagNET_DVR_ROI_DETECT_COND
{
    DWORD   dwSize;
    DWORD   dwRoiID; //区域检测号 一个PTZ支持4个 
    NET_DVR_MULTI_STREAM_COMPRESSIONCFG_COND  struMultiStreamCfg; //多码流配置
    BYTE    byRoiDetectType; // DECTECT_ROI_TYPE 的值
    BYTE    byRoiDetectTrackType;//固定区域时，该字段无效；跟踪区域时，1～人脸侦测（IPC）,2～移动物体跟踪,3-车牌跟踪
    BYTE    byRes[30];
}NET_DVR_ROI_DETECT_COND,*LPNET_DVR_ROI_DETECT_COND;

typedef struct tagNET_DVR_ROI_FIX_RECT_CFG
{
    BYTE  byEnableFixRoi; // ROI固定区域模式 是否启用 0～不启用， 1～启用
    BYTE  byImageQualityLevel; //图像质量提升等级 1～6
    BYTE  byRes[2];
    BYTE  szFixRoiName[NAME_LEN];
    NET_VCA_RECT  struRoiRect;  //ROI区域
    BYTE  byRes1[468];
}NET_DVR_ROI_FIX_RECT_CFG, *LPNET_DVR_ROI_FIX_RECT_CFG;

typedef struct tagNET_DVR_ROI_TRACK_RECT_CFG
{
    BYTE  byEnableTrackRoi; // ROI自动跟踪模式 是否启用 0～不启用， 1～启用
    BYTE  byImageQualityLevel; //图像质量提升等级 1～6
    BYTE  byModeType;// 0 ~ 无, 1～人脸模式(移动和静止的物体), 2~移动物体跟踪(移动的物体), 3-车牌跟踪
    BYTE  byRes[509];
}NET_DVR_ROI_TRACK_RECT_CFG, *LPNET_DVR_ROI_TRACK_RECT_CFG;


typedef struct tagNET_DVR_ROI_DETECT_CFG
{
    DWORD      dwSize;  //560
    DWORD       dwStreamType;    //码流类型，0-主码流，1-子码流，2-事件类型，3-码流3，……
    BYTE       byRoiDetectType; // DECTECT_ROI_TYPE 的值 
    BYTE       byRes[3];
    NET_DVR_ROI_DETECT_UNION  uRoiDetectInfo; //ROI检测区域
    BYTE       byRes1[36];
}NET_DVR_ROI_DETECT_CFG, *LPNET_DVR_ROI_DETECT_CFG;

typedef struct tagNET_VCA_DEFOCUSPARAM
{    
    DWORD dwSize;
    BYTE byEnable;//使能
    BYTE  bySensitiveLevel;// 1-100，默认50，灵敏度越高，越容易报警
    BYTE  byRes1[2];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    BYTE byRes2[24];
}NET_VCA_DEFOCUSPARAM,*LPNET_VCA_DEFOCUSPARAM;

typedef struct tagNET_PTZ_INFO_EX
{
    float fPan;//P值 精确到小数点后3位 范围[0,360.000]
    float fTilt; //Z值 精确到小数点后3位 范围[-90.000,90.000]
    float fVisibleZoom;//可见光zoom 精确到小数点后1位 不会超过[0，10000.0]
    DWORD dwVisibleFocus;//可见光focus[0,65535]
    float fThermalZoom;//热成像zoom 精确到小数点后1位 不会超过[0，10000.0]
    DWORD dwThermalFocus;//热成像focus[0,65535]
}NET_PTZ_INFO_EX, *LPNET_PTZ_INFO_EX;

typedef struct tagNET_DVR_PRESET_NAME
{
    DWORD dwSize;
    WORD wPresetNum; //预置点编号
    BYTE byRes1[2]; //字节对齐 
    char byName[NAME_LEN];
    WORD wPanPos;//水平参数 如果获取到的数据大于360默认减去360
    WORD wTiltPos;//垂直参数 如果获取到的数据大于360默认减去360
    WORD wZoomPos;//变倍参数如果获取到的数据大于360默认减去360
    BYTE byRes2;
    BYTE byPTZPosExEnable; /*是否启用PTZ坐标扩展，0~不启用，PTZ坐标值以wPanPos、wTiltPos、wZoomPos为准。1~启用，PTZ坐标值以struPtzPosEx为准*/
    NET_PTZ_INFO_EX struPtzPosEx;// ptz坐标扩展(支持高精度PTZ值)
    BYTE byRes[32];
}NET_DVR_PRESET_NAME, *LPNET_DVR_PRESET_NAME;


typedef struct tagNET_DVR_TIME_TASK
{
    DWORD dwSize;
    BYTE byTaskEnable;   ///< 使能 1-开，0-关
    BYTE byRes[3];    ///< 字节对齐
    NET_DVR_SCHEDTASK struTask[MAX_DAYS][MAX_SCH_TASKS_NUM];    ///< 7天，每天10时间段
    DWORD dwParkTime;   ///< 守望时间 5s-720s
    BYTE byRes1[64];
}NET_DVR_TIME_TASK,*LPNET_DVR_TIME_TASK;

typedef struct tagNET_DVR_CHANNEL_INDEX
{
    DWORD dwSize;                 // 结构体大小
    DWORD dwChannel ;           //通道号
    DWORD dwIndex ;             //索引号
    BYTE  byRes[64] ;        
}NET_DVR_CHANNEL_INDEX, *LPNET_DVR_CHANNEL_INDEX;

typedef struct tagNET_DVR_AUDIO_NAME
{
    DWORD dwSize;                 // 结构体大小
    char  cName[NAME_LEN] ;          //名称
    BYTE  byRes[64];          
}NET_DVR_AUDIO_NAME, *LPNET_DVR_AUDIO_NAME;

typedef struct tagNET_DVR_LOGIN_DEVICE_PARAM_
{    
    DWORD  dwSize;       //结构体大小
    BYTE   byMobileDev;  //设备种类, 0- 非移动设备, 1 - 移动设备
    BYTE   byRes[63];    //保留                    
}NET_DVR_LOGIN_DEVICE_PARAM, *LPNET_DVR_LOGIN_DEVICE_PARAM;




typedef struct tagNET_DVR_FISHEYE_STREAM_STATUS_
{   
    DWORD  dwSize;        //结构体大小 
    BYTE   byStreamMode;  //码流输出模式，参见FISHEYE_STREAM_OUTPUT_MODE
    BYTE   byRes[63];     //保留
}NET_DVR_FISHEYE_STREAM_STATUS,*LPNET_DVR_FISHEYE_STREAM_STATUS;

typedef struct tagNET_DVR_CALLBACK_TYPE_DATA
{   
    DWORD  dwChannel;      //通道号
    DWORD  dwDataType;     //参见CALLBACK_TYPE_DATA_ENUM
    DWORD  dwDataLen;      //数据长度
    BYTE*  pData;          //数据，当dwTypeData为 ENUM_FISHEYE_STREAM_STATUS，其对应为NET_DVR_FISHEYE_STREAM_STATUS
    BYTE   byRes[64];      //保留    
}NET_DVR_CALLBACK_TYPE_DATA,*LPNET_DVR_CALLBACK_TYPE_DATA;

typedef struct tagNET_DVR_DRAG_POS_PARAM
{
    DWORD          dwChannel;      //通道号
    DWORD          dwPtzChannel;   //当dwChannel所指通道模式为FISHEYE_STREAM_MODE_FISHEYE（鱼眼模式时），此值为其拖动所联动的ptz通道。当dwChannel通道模式为非鱼眼时，置为0即可
    NET_VCA_POINT  struToPoint;    //拖动画面要跳转到的目标点，目标点位置相对于预览画面的左上角
    NET_VCA_POINT  struOriPoint;   //拖动操作起始点,此点为当次拖动操作开始时，鼠标指针相对于预览画面左上角的位置
    BYTE           byRes[56];      //保留
}NET_DVR_DRAG_POS_PARAM,*LPNET_DVR_DRAG_POS_PARAM;

typedef struct tagNET_DVR_QUERY_STATUS
{
    DWORD      dwSize;
    BYTE       byCpuLoad;       //CPU资源占用情况, 取值范围：0-100
    BYTE       byMemLoad;      //Memory资源占用情况，取值范围：0-100
    WORD       wAbility;      //诊断服务器能力集，大于0
    WORD       wRemainAbility;//诊断服务器剩余能力，取值范围：大于 0  剩余监控点的个数
    WORD       wTotalPlanNum; //最多64个计划>
    WORD       wCurPlanNum;   //当前计划数  最多64个计划>
    BYTE       byRes[62];     //保留
}NET_DVR_QUERY_STATUS, *LPNET_DVR_QUERY_STATUS;

typedef struct tagNET_DVR_MONITOR_VQDCFG
{
    DWORD   dwSize;
    BYTE   byEnable;            //是否启用     
    BYTE   byDevType;             //设备类型：0-非云台设备，1-带云台设备
    BYTE   bySignalPoint;       //信号丢失阀值，0-100
    BYTE   byBlurPoint;         //图像模糊阀值，0-100
    BYTE   byLumaPoint;         //图像过亮阀值，0-100
    BYTE   byChromaPoint;       //图像偏色阀值，0-100
    BYTE   bySnowPoint;         //噪声干扰阀值，0-100
    BYTE   byStreakPoint;       //条纹干扰阀值，0-100
    BYTE   byFreezePoint;       //画面冻结阀值，0-100
    BYTE   byPTZPoint;          //云台失控阀值，0-100
    BYTE   byMonitorDel;        //监控点删除 0-不删除， 1-删除
    BYTE   byContrastThreshold; //对比度异常阈值，0-100
    BYTE   byMonoThreshold;     //黑白图像阈值，0-100
    BYTE   byShakeThreshold;    //视频抖动阈值，0-100
    BYTE   byFlashThreshold;    //视频剧变阈值，0-100
    BYTE   byCoverThreshold;    //视频遮挡阈值，0-100
    BYTE   bySceneThreshold;    //场景变更阈值，0-100
    BYTE   byDarkThreshold;     //图像过暗阈值，0-100
    BYTE   byRes[46];
}NET_DVR_MONITOR_VQDCFG, *LPNET_DVR_MONITOR_VQDCFG;

typedef struct tagNET_DVR_DIAGNOSIS_UPLOAD
{
    DWORD  dwSize;
    char   sStreamID[STREAM_ID_LEN];    ///< 流ID，长度小于32个字节
       char  sMonitorIP[64];  ///< 监控点ip
       DWORD  dwChanIndex;  ///< 监控点通道号  
    DWORD  dwWidth;  ///< 图像宽度
    DWORD  dwHeight;  ///< 图像高度
    NET_DVR_TIME  struCheckTime;  ///< 检测时间(合并日期和时间字段)，格式：2012-08-06 13:00:00
    BYTE  byResult;  ///0-未检测 1-正常 2-异常 3-登录失败 4-取流异常
    BYTE  bySignalResult; ///< 视频丢失检测结果 0-未检测 1-正常 2-异常
       BYTE  byBlurResult;  ///< 图像模糊检测结果，0-未检测 1-正常 2-异常
       BYTE  byLumaResult;  ///< 图像过亮检测结果，0-未检测 1-正常 2-异常
       BYTE  byChromaResult;  ///< 偏色检测结果，0-未检测 1-正常 2-异常
       BYTE  bySnowResult;  ///< 噪声干扰检测结果，0-未检测 1-正常 2-异常
    BYTE  byStreakResult;  ///< 条纹干扰检测结果，0-未检测 1-正常 2-异常
       BYTE  byFreezeResult;  ///< 画面冻结检测结果，0-未检测 1-正常 2-异常
       BYTE  byPTZResult;  ///< 云台检测结果，0-未检测 1-正常 2-异常
    BYTE  byContrastResult;     //对比度异常检测结果，0-未检测，1-正常，2-异常
    BYTE  byMonoResult;         //黑白图像检测结果，0-未检测，1-正常，2-异常
    BYTE  byShakeResult;        //视频抖动检测结果，0-未检测，1-正常，2-异常
    char  sSNapShotURL[256];    ///<图片URL地址
    BYTE  byFlashResult;        //视频剧变检测结果，0-未检测，1-正常，2-异常
    BYTE  byCoverResult;        //视频遮挡检测结果，0-未检测，1-正常，2-异常
    BYTE  bySceneResult;        //场景变更检测结果，0-未检测，1-正常，2-异常
    BYTE  byDarkResult;         //图像过暗检测结果，0-未检测，1-正常，2-异常
    BYTE  byStreamType;        //码流类型，0-无效，1-未知，2-国标类型，3-非国标类型
    BYTE  byRes2[59];
}NET_DVR_DIAGNOSIS_UPLOAD, *LPNET_DVR_DIAGNOSIS_UPLOAD;

typedef struct tagNET_DVR_DOWN_LOAD_REQUEST   ///< 这个数据结构是平台发送到诊断服务器的
{
    NET_DVR_STREAM_INFO  struStreamInfo;
       char   sSnapShotURL[256];  ///< 诊断抓图URL，长度小于256个字节    
    BYTE   byRes[32];
}NET_DVR_DOWN_LOAD_REQUEST, *LPNET_DVR_DOWN_LOAD_REQUEST;

typedef struct tagNET_DVR_VQD_RESULT_INFO  ///< 这个数据结构是诊断服务器返回给平台的
{
    DWORD  dwSize;
    char   sStreamID[32];     ///<流ID(监控点ID)，长度小于32个字节
    DWORD  dwPicLength;  ///图片长度
    BYTE   byStatus;     ///< 设置结果:0-成功,1-数据有误，2-图片不存在，3-获取图片失败
    BYTE   byRes[31];
       char   *pSnapShot;      ///< 诊断抓图，是一块图片缓存数据(700k)
}NET_DVR_VQD_RESULT_INFO, *LPNET_DVR_VQD_RESULT_INFO;

typedef struct tagNET_DVR_PLAN_VQD_CFG
{
    DWORD   dwSize;
    BYTE    sPlanID[PLAN_ID_LEN];    ///< 计划id，长度小于32个字节
       NET_DVR_SCHEDTIME  struDetectTime[MAX_DAYS][MAX_TIMESEGMENT_V30];    ///< 检测时间 
    BYTE    byPlanMode;  ///0:即时计划，1:周期计划
    BYTE    byRes1;//     
    BYTE    byCheckFlag;  ///< 是否检测，0-不检测，1-检测
    BYTE    bySignal;  ///<视频丢失 是否检测，0-不检测，1-检测
       BYTE    byBlur;  ///< 图像模糊 是否检测，0-不检测，1-检测
       BYTE    byLuma;  ///< 图像过亮是否检测，0-不检测，1-检测
       BYTE    byChroma;  ///< 偏色检测 是否检测，0-不检测，1-检测
       BYTE    bySnow;  ///<噪声干扰 是否检测，0-不检测，1-检测
    BYTE    byStreak;  ///<条纹干扰 是否检测，0-不检测，1-检测
       BYTE    byFreeze;  ///<画面冻结是否检测，0-不检测，1-检测
       BYTE    byPTZ;  ///<云台是否检测，0-不检测，1-检测
    BYTE    byEnablePlanRound;  ///计划循环是否开启
    BYTE    byContrast;  //对比度异常是否检测，0-不检测，1-检测
    BYTE    byMono;      //黑白图像是否检测，0-不检测，1-检测
    BYTE    byShake;     //视频抖动是否检测，0-不检测，1-检测
    BYTE    byFlash;     //视频剧变是否检测，0-不检测，1-检测
    BYTE    byCover;     //视频遮挡是否检测，0-不检测，1-检测
    BYTE    byScene;     //场景变更是否检测，0-不检测，1-检测
    BYTE    byDark;      //图像过暗是否检测，0-不检测，1-检测
    BYTE    byRes[13];     
}NET_DVR_PLAN_VQD_CFG, *LPNET_DVR_PLAN_VQD_CFG;

typedef struct tagNET_DVR_TEST_SPOTCFG
{
    DWORD dwSize;
    BYTE  byStepCount;                //总步数
    BYTE  byStepIndex;                //当前第几步
    BYTE  byRes[14];
}NET_DVR_TEST_SPOTCFG, *LPNET_DVR_TEST_SPOTCFG;



typedef struct tagNET_DVR_MRD_SEARCH_PARAM
{
    DWORD                dwSize;            // 结构体大小
    NET_DVR_STREAM_INFO    struStreamInfo;    // 监控点
    WORD                 wYear;              // 年 
    BYTE                 byMonth;            // 月
    BYTE                byDrawFrame;    // 0-不抽帧 1-抽帧
    BYTE                byStreamType;   //0-主码流 1-子码流
    BYTE				byLocalOrUTC;  	//0-设备本地时区  1-UTC
    BYTE                byRes[30];  
}NET_DVR_MRD_SEARCH_PARAM, *LPNET_DVR_MRD_SEARCH_PARAM;

typedef struct tagNET_DVR_MRD_SEARCH_RESULT
{    
    DWORD            dwSize;            // 结构体大小
    BYTE            byRecordDistribution[LEN_32];   // 录像分布，byRecordDistribution[0]=1表示1日存在录像，byRecordDistribution[0]=0表示没有录像，
    //byRecordDistribution[1]表示2日，以此类推
    BYTE            byHasEventRecode[LEN_31];            //事件录像 0-无事件录像，1-有事件录像
    BYTE            byRes;                        //保留
}NET_DVR_MRD_SEARCH_RESULT, *LPNET_DVR_MRD_SEARCH_RESULT;

typedef struct tagNET_DVR_ACCESS_DEVICE_INFO
{
    DWORD    dwSize;                        // 结构体大小
    BYTE     byGroup;                    // 组号，每组可获取 64个通道，从0开始, 0表示第1组，以此类推
    BYTE    byProType;                    //协议类型，0-私有协议，1-松下协议，2-索尼
    BYTE    byAccessMode;                //接入模式，0-IP地址，1-域名
    BYTE    byRes1;                        //保留字段，置0
    char    szUserName[NAME_LEN];        //用户名
    char    szPassword[PASSWD_LEN];        //密码
    char    szDomain[MAX_DOMAIN_NAME];    //设备域名
    NET_DVR_IPADDR struIP;                //IP地址
    WORD    wPort;                         // 端口号
    BYTE    szGB28181DevID[DEV_ID_LEN]; //GB28181协议接入时的设备服务器ID
    BYTE    byRes2[2];                    //保留字段，置0
}NET_DVR_ACCESS_DEVICE_INFO, *LPNET_DVR_ACCESS_DEVICE_INFO;

typedef struct tagNET_DVR_ACCESS_DEVICE_CHANNEL_INFO
{
    DWORD    dwSize;    // 结构体大小
    DWORD    dwTotalChannelNum;      //设备总通道个数，设备不在线时返回0，byChannel无效
    BYTE     byChannel[MAX_CHANNUM_V30];    /*byChannel[i]为0表示第（byGroup+1）*（i-1）通道未接入到NVR，
                                    为1表示该通道已接入到NVR byGroup在NET_DVR_ACCESS_DEVICE_INFO中*/
    BYTE  byRes[32];           //保留
}NET_DVR_ACCESS_DEVICE_CHANNEL_INFO, *LPNET_DVR_ACCESS_DEVICE_CHANNEL_INFO;

typedef struct tagNET_DVR_PREVIEW_SWITCH_COND
{
    DWORD    dwSize; //组号
    BYTE    byGroup; //组号，每组可配置64个画面
    BYTE    byVideoOutType; /*视频输出接口类型,0-主CVBS,1-HDMI 2-VGA 3-辅助输出一
                     4-辅助输出二 5-辅助输出三 6-辅助输出四, 7-辅助HDMI, 8-扩展HDMI1,
                     9-扩展HDMI2, 10-扩展HDMI3, 11-扩展HDMI4, 12-非同源VGA1，
                     13-非同源VGA2，14-非同源VGA3，15-非同源VGA4，16-同源VGA, 17-主LCD,18-辅助VGA,19-辅助LCD*/
    BYTE    byGetDefaultPreviewSet;//是否获取预设，0-否，1-是；若为是时，byPreviewNumber字段有效
    BYTE    byPreviewNumber;//预览数目,0-1画面,1-4画面,2-9画面,3-16画面, 4-6画面, 5-8画面6-25画面,7-32画面, 8-36画面 0xfb-自定义分屏4, 0xfc-自定义分屏3, 0xfd-自定义分屏2, 0xfe-自定义分屏1,0xff:最大画面
}NET_DVR_PREVIEW_SWITCH_COND, *LPNET_DVR_PREVIEW_SWITCH_COND;

typedef struct tagNET_DVR_PREVIEW_SWITCH_CFG
{
    DWORD    dwSize;    // 版本管理及结构体大小
                    WORD    wSwitchSeq[MAX_WINDOW_V40];/*bySwitchSeq [i]=6，表示第（组号*64+i+1）个窗口
                    显示第六通道，为0xff表示该窗口不显示*/
                    BYTE    byPreviewNumber;/*预览数目,0-1画面,1-4画面,2-9画面,3-16画面, 4-6画面, 5-8画面，6-25画面,7-32画面, 8-36画面, 9-64画面
                    0xff:最大画面*/
                    BYTE    byEnableAudio;//是否声音预览,0-不预览,1-预览
                    BYTE    bySwitchTime;//切换时间,0-不切换,1-5s,2-10s,3-20s,4-30s, 5-60s 6-120s,7-300s
                    BYTE    bySameSource ; //是否同源，当视频输出口类型为非同源VGA1-非同源VGA4时有效 
                    BYTE    byRes[32];        //保留
}NET_DVR_PREVIEW_SWITCH_CFG,* LPNET_DVR_PREVIEW_SWITCH_CFG;

typedef struct tagNET_DVR_USER_COND
{    
    char        szUserName[NAME_LEN];
    BYTE        byRes[48];
}NET_DVR_USER_COND, *LPNET_DVR_USER_COND;

typedef struct tagNET_DVR_USER_RIGHT_CFG
{    
    DWORD            dwSize;
    BYTE            byAddMonitoringPointRight; // 添加监控点（前端设备）权限0-无 1-有
    BYTE            byModMonitoringPointRight; // 修改监控点（前端设备）权限0-无 1-有
    BYTE            byDelMonitoringPointRight; // 添加监控点（前端设备）权限0-无 1-有
    BYTE            bySetRecordPlanRight; // 制定录像策略权限0-无 1-有
    BYTE            byDelRecordPlanRight; // 删除录像策略权限0-无 1-有
    BYTE            byEnableOrDisableRecordPlanRight; // 启用和禁用录像计划权限0-无 1-有
    BYTE            byManualRecordRight; // 启动和停止手动录像权限0-无 1-有
    BYTE            bySetAlarmRecordRight; // 报警录像设定权限0-无 1-有
    BYTE            byRecordBackupRight; // 录像存档权限0-无 1-有
    BYTE            byRecordDownloadRight; // 录像下载权限0-无 1-有
    BYTE            byRecordDeleteRight; // 录像删除权限0-无 1-有（保留）
    BYTE            byDelBackupRecordRight; // 删除存档录像权限0-无 1-有（保留）
    BYTE            bySetBackupVolumeRight; // 设置存档卷权限0-无 1-有
    BYTE            byRecordPlayBackRight; // 录像回放权限0-无 1-有 DWORD dwZoneIndex
    BYTE            byLogDeleteRight; // 日志清空权限0-无 1-有（保留）
    BYTE            byLogDownloadRight; // 日志下载权限0-无 1-有（保留）
    BYTE            byAddUserRight; // 添加用户权限0-无 1-有
    BYTE            byDelUserRight; // 删除用户权限0-无 1-有
    BYTE            byModUserRight; // 修改用户权限0-无 1-有
    BYTE            byAllocUserRight; // 用户权限分配权限0-无 1-有
    BYTE            byRes[128];
}NET_DVR_USER_RIGHT_CFG, *LPNET_DVR_USER_RIGHT_CFG;

typedef struct tagNET_DVR_MACHINE_MAX_NUM_CFG
{
    DWORD                dwSize;
    DWORD               dwMaxNum;         // 最大备机数目
    BYTE                   byRes[32];
}NET_DVR_MACHINE_MAX_NUM_CFG, *LPNETDVR_MACHINE_MAX_NUM_CFG;

typedef struct tagNET_DVR_N_PLUS_ONE_WORK_MODE_CFG
{
    DWORD    dwSize ;
    BYTE    byWorkMode;        //0-工作机 1-备机
    BYTE    byRes[127];       //保留
}NET_DVR_N_PLUS_ONE_WORK_MODE_CFG, *LPNET_DVR_N_PLUS_ONE_WORK_MODE_CFG;

typedef struct tagNET_DVR_ADD_PARAM
{
    NET_DVR_IPADDR    struIP;        // 设备IP
    char            szPassword[PASSWD_LEN];    //备机密码，需简易加密
    BYTE             byAddType;         // 0-（工作机上）添加备机，1-（备机上）添加工作机
    BYTE             byDisableBackup; //备份功能使能开关 0-开启1-关闭 CVR默认开启
}NET_DVR_ADD_PARAM, *LPNET_DVR_ADD_PARAM;

typedef struct tagNET_DVR_DEL_PARAM
{
    NET_DVR_IPADDR    struIP;        // 设备IP
    BYTE             byDelType;     // 0-删除指定的机器（备机或工作机）1-全删
}NET_DVR_DEL_PARAM, *LPNET_DVR_DEL_PARAM;


typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_PARAM
{
    DWORD                    dwSize;
    NET_DVR_NPO_PARAM_UNION unionParam;
    BYTE                     byType;     /* 0-添加，对应unionParam中的struAddParam 1-删除，对应unionParam中的struDelParam  2-添加且用户名生效，对应unionParam中的struAddParam 和szUserName*/
    BYTE                      byRes[3];
    char                        szUserName[NAME_LEN];    //用户名
    BYTE                      byRes2[220];          // 保留
}NET_DVR_N_PLUS_ONE_DEVICE_PARAM, *LPNET_DVR_N_PLUS_ONE_DEVICE_PARAM;

typedef struct tagNET_DVR_DATA_CALLBACK_CFG
{
    DWORD                dwSize;
    BYTE                   byEnable;     // 0-不启用数据回迁 1-启用数据回迁
    BYTE                   byDelData;     // 当byEnable为1是有效 0-不删除备机录像数据 1-删除备机录像数据
    BYTE                   byRes[30];
}NET_DVR_DATA_CALLBACK_CFG, *LPNET_DVR_DATA_CALLBACK_CFG;

typedef struct tagNET_DVR_HD_STATUS
{
    DWORD     dwSize;
    BYTE     bySleepStatus;/*休眠状态0-不休眠 1-休眠*/
    BYTE      byRes[127];
}NET_DVR_HD_STATUS, *LPNET_DVR_HD_STATUS;

typedef struct tagNET_DVR_RAID_BTS_CFG
{
    DWORD     dwSize;
    BYTE     bySpeed;    /*0-高速 1-中速 2-低速*/
    BYTE      byRes[127];
}NET_DVR_RAID_BTS_CFG, *LPNET_DVR_RAID_BTS_CFG;

typedef struct tagNET_DVR_LUN_CLONE
{
    DWORD                dwSize;
    DWORD                dwSrcLunID;        // 源LUN ID
    DWORD               dwDstLunID;     // 目的LUN ID
    BYTE                   byRes[32];
}NET_DVR_LUN_CLONE, *LPNET_DVR_LUN_CLONE;

typedef struct tagNET_DVR_LUN_EXPAND
{
    DWORD                dwSize;
    DWORD                dwLunID;                    // LUN ID
    DWORD                dwHSize;                    // 扩展的大小高32位
    DWORD                dwLSize;                    // 扩展的大小低32位
    char                szArrayIDGroup[NAME_LEN];    // 使用的阵列ID组，以逗号隔开，为空则为默认
    char                   szNewLunName[MAX_NAMELEN];     // 新LUN名
    BYTE                   byRes[32];
}NET_DVR_LUN_EXPAND, *LPNET_DVR_LUN_EXPAND;

typedef struct tagNET_DVR_DVR_NET_DISK_MODIFY
{
    DWORD                dwSize;
    char                szOldDvrNetDiskName[MAX_NAMELEN];        // 原DVR网盘共享名
    char                   szNewDvrNetDiskName[MAX_NAMELEN];     // 新DVR网盘共享名
    NET_DVR_IPADDR        struWarrantIP;                        // 新授权的DVR网盘IP
    BYTE                   byRes[32];
}NET_DVR_DVR_NET_DISK_MODIFY, *LPNET_DVR_DVR_NET_DISK_MODIFY;

typedef struct tagNET_DVR_NAS_PARAM
{
    DWORD                dwSize;
    DWORD                dwLunID;        // LUN ID
    BYTE                   byRes[32];
}NET_DVR_NAS_PARAM, *LPNET_DVR_NAS_PARAM;

typedef struct tagNET_DVR_ISCSI_PARAM
{
    DWORD                dwSize;
    DWORD                dwTargetID;        // iSCSI服务的Target ID
    DWORD                dwLunID;        // LUN ID
    DWORD                dwAccessMode;    //读写方式 0-读写 1-同步读写 2-只读 3-智能只读;
    NET_DVR_IPADDR        struClientIP;        // 客户端IP，0.0.0.0为所以IP
    BYTE                   byRes[32];
}NET_DVR_ISCSI_PARAM, *LPNET_DVR_ISCSI_PARAM;

typedef struct tagNET_DVR_FC_PARAM
{
    DWORD                dwSize;
    DWORD                dwStoreLunID;                    // 存储LUN ID
    DWORD                dwLogicLunID;                    // 逻辑LUN ID，-1表示自动生成
    DWORD                dwHbaID;                        // 光纤通道号
    DWORD                dwAccessMode;                    //读写方式 0-读写 1-同步读写 2-只读 3-智能只读;
    char                szClientWWWPN[NAME_LEN];         // 客户光纤卡
    BYTE                   byRes[32];
}NET_DVR_FC_PARAM, *LPNET_DVR_FC_PARAM;

typedef struct tagNET_DVR_LUN_PARAM
{
    DWORD        dwHCapacity;    // 逻辑卷大小高32位
    DWORD        dwLCapacity;    // 逻辑卷大小低32位
    char        szName[MAX_NAMELEN];     // 逻辑卷名称
    DWORD        dwBlockSize;        // 逻辑卷的最小存储单元块大小
    char        szArrayIDGroup[NAME_LEN];     //使用的阵列ID组，以逗号隔开，为空则使用默认阵列
}NET_DVR_LUN_PARAM, *LPNET_DVR_LUN_PARAM;

typedef struct tagNET_DVR_DVR_PARAM_
{
    DWORD            dwHCapacity;    // DVR网盘大小高32位
    DWORD            dwLCapacity;    // DVR网盘大小低32位
    char                szName[MAX_NAMELEN];     // DVR网盘名称
    DWORD            dwBlockSize;        // 逻辑卷的最小存储单元块大小
    NET_DVR_IPADDR    struWarrantIP;        // 授权的DVR网盘IP
    char            szArrayIDGroup[NAME_LEN];     //使用的阵列ID组，以逗号隔开，为空则使用默认阵列
}NET_DVR_DVR_PARAM, *LPNET_DVR_DVR_PARAM;


typedef struct tagNET_DVR_OPERATE_VD_PARAM_EX
{
    BYTE                byVDType;    //虚拟磁盘类型：0-私有虚拟磁盘 1-逻辑卷 2-DVR网盘
    BYTE                byRes1[3];
    NET_DVR_VD_UNION     uVDParam;
    BYTE                byRes2[32];
}NET_DVR_OPERATE_VD_PARAM_EX, *LPNET_DVR_OPERATE_VD_PARAM_EX;

typedef struct tagNET_DVR_CVR_ALARM
{
    char            szFirstType[NAME_LEN];  //主类型，不能为空
    char            szFirstIndex[NAME_LEN];    //主类型编号
    char            szSecondType[NAME_LEN];    //次类型，可以为空
    NET_DVR_TIME    struTime;        //报警时间
    BYTE             byStatus;       //状态 0-正常 非0-不正常，不同类型值表示意义不同，见下表
    BYTE            byAlarmLevel;         //报警级别
    BYTE            byRes1[2];
    char               szSecondIndex[NAME_LEN];  //次类型编号，可以为空
    char            szThirdType[NAME_LEN];  //第三类型，可以为空
    char            szThirdIndex[NAME_LEN];    //第三类型编号
    char            szFourthType[NAME_LEN];  //第四类型，可以为空
    char            szFourthIndex[NAME_LEN];    //第四类型编号
    BYTE              byRes2[92];  //保留
}NET_DVR_CVR_ALARM, *LPNET_DVR_CVR_ALARM; 

typedef struct tagNET_DVR_WORKING_DEVICE_INFO
{
    NET_DVR_IPADDR    struIP;            //设备IP
    BYTE             byLinkStatus; //连接状态 0-连接失败1-连接成功
    BYTE             byWorkStatus; //工作状态 0-正常1-异常
    BYTE             byBacupStatus; //备份状态0-不在备份1-正在备份
    BYTE             bySyncProgress; //录像同步进度，0表示未开始，100表示同步完成
    NET_DVR_TIME_EX    struSyncBeginTime;    //同步开始时间
    NET_DVR_TIME_EX    struSyncEndTime;        //同步结束时
    char            szSerialNumber[SERIALNO_LEN] ; //设备序列号
    DWORD            dwSoftwareVersion ;        //设备软件版本
    BYTE              byWorkingDeviceGUID[GUID_LEN]; //工作机GUID，非字符串，用于备机上搜索工作机录像
    char            szDevTypeName[DEV_TYPE_NAME_LEN];        //设备类型名称
    WORD            wDevType;        //设备类型值
}NET_DVR_WORKING_DEVICE_INFO, *LPNET_DVR_WORKING_DEVICE_INFO;

typedef struct tagNET_DVR_REDUNDANT_DEVICE_INFO
{
    NET_DVR_IPADDR    struIP;            //设备IP
    BYTE             byWorkStatus;     //工作状态 0-正常1-异常
    BYTE             byBackupStatus; //备份状态0-不在监控 1-正在监控2-正在备份中2-正在同步
    WORD            wBackupPort;    //备份端口
}NET_DVR_REDUNDANT_DEVICE_INFO, *LPNET_DVR_REDUNDANT_DEVICE_INFO;

typedef struct tagNET_DVR_WORKING_DEVICE_INFO_V50
{
    NET_DVR_WORKING_DEVICE_INFO        struWorkingDeviceInfo;        //工作机信息
    char            szUserName[NAME_LEN];    //用户名
    BYTE           byRes[32];
}NET_DVR_WORKING_DEVICE_INFO_V50, *LPNET_DVR_WORKING_DEVICE_INFO_V50;

typedef struct tagNET_DVR_REDUNDANT_DEVICE_INFO_V50
{
    NET_DVR_REDUNDANT_DEVICE_INFO    struRedundantDeviceInfo;     //备机信息
    char            szUserName[NAME_LEN];    //用户名
    BYTE           byRes[32];
}NET_DVR_REDUNDANT_DEVICE_INFO_V50, *LPNET_DVR_REDUNDANT_DEVICE_INFO_V50;


typedef struct tagNET_DVR_N_PLUS_ONE_DEVICE_INFO
{
    DWORD                        dwSize;
    NET_DVR_NPO_DEV_INFO_UNION    unionDevInfo;
    BYTE                        byType;    /*类型 0-工作机，对应unionDevInfo中的struWorkingDeviceInfo     1-备机，对应unionDevInfo中的struRedundantDeviceInfo
                                           2-工作机V50，对应unionDevInfo中的struWorkingDeviceInfoV50     3-备机V50，对应unionDevInfo中的struRedundantDeviceInfoV50*/
    BYTE                           byRes[127];    
}NET_DVR_N_PLUS_ONE_DEVICE_INFO, *LPNET_DVR_N_PLUS_ONE_DEVICE_INFO;

typedef struct tagNET_DVR_UPGRADE_IPC_PARAM
{
    NET_DVR_STREAM_INFO    struStreamInfo[MAX_CHANNUM_V30];    // 64个监控点
    char                  szFileName[260];                    // 升级文件名
}NET_DVR_UPGRADE_IPC_PARAM, *LPNET_DVR_UPGRADE_IPC_PARAM;

typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE
{
    NET_DVR_STREAM_INFO    struStreamInfo;     //监控点
    WORD                wErrCode;            //对应错误码
    BYTE                byRes[30];          //保留
}NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE, *LPNET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_UPGRADE_IPC_ERR_INFO
{
    NET_DVR_UPGRADE_IPC_ERR_INFO_SINGLE struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_UPGRADE_IPC_ERR_INFO, *LPNET_DVR_UPGRADE_IPC_ERR_INFO;

typedef struct tagNET_DVR_IPC_CFG_FILE_PARAM
{
    char          szFileName[260];                    // 配置文件名
    BYTE        byRes[32];                        
}NET_DVR_IPC_CFG_FILE_PARAM, *LPNET_DVR_IPC_CFG_FILE_PARAM;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE
{
    WORD     wRow;       //出错的行，0表示没出错，1表示第1行出错，以此类推
    WORD    wErrCode;    //错误码
    BYTE    byRes[32];
}NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE;

typedef struct tagNET_DVR_IPC_CFG_FILE_ERR_INFO
{
    NET_DVR_IPC_CFG_FILE_ERR_INFO_SINGLE     struErrInfoSingle[MAX_CHANNUM_V30];
}NET_DVR_IPC_CFG_FILE_ERR_INFO, *LPNET_DVR_IPC_CFG_FILE_ERR_INFO;

typedef struct tagNET_DVR_TRANSFER_SWITCH
{
    DWORD dwEnable;
    BYTE  byRes[64];
}NET_DVR_TRANSFER_SWITCH, *LPNET_DVR_TRANSFER_SWITCH;

typedef struct tagNET_DVR_PTZ_PATTERN
{
    DWORD dwSize; 
    DWORD dwChannel; //通道号
    DWORD dwPatternCmd; //云台轨迹操作命令码,详见下面定义
    DWORD dwPatternID; //云台轨迹ID（删除所有轨迹时无效）
    BYTE  byRes[64]; 
}NET_DVR_PTZ_PATTERN, *LPNET_DVR_PTZ_PATTERN;

typedef struct tagNET_DVR_PTZ_PARKACTION_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //是否启用，0-不启用，1-启用
    BYTE  byOneTouchSwitch;//一键开关, 0-不启用，1-启用 (和wActionType组合使用)
    BYTE  byRes1[2];
    DWORD dwParkTime; //守望等待时间，单位s 
    WORD  wActionType; //守望动作类型，0-自动扫描，1-帧扫描，2-随机扫描，3-巡航扫描，4-花样扫描，5-预置点，6-全景扫描，7-垂直扫描, 8-区域扫描
    WORD  wID; //ID号（巡航扫描、预置点、花样扫描的ID）
    BYTE  byRes[128]; 
}NET_DVR_PTZ_PARKACTION_CFG, *LPNET_DVR_PTZ_PARKACTION_CFG;

typedef struct tagNET_DVR_PTZ_MANUALTRACE
{
    DWORD  dwSize; 
    DWORD  dwChannel; //通道号
    NET_VCA_POINT struPoint; //定位坐标
    BYTE byTrackType; //跟踪类型0、非自动取证(普通取证) 1、高速道路跟踪 2、城市道路跟踪（手动跟踪取证）3、静态取证
    BYTE byLinkageType;//联动动作: 0-手动跟踪 1-联动不跟踪
    BYTE byRes[2];
    NET_VCA_POINT struPointEnd;/*定位坐标终点*/
    NET_DVR_TIME_V30 struTime;//手动跟踪定位，当前时间。
    DWORD  dwSerialNo;//序号；
    BYTE   byRes1[36];  
}NET_DVR_PTZ_MANUALTRACE, *LPNET_DVR_PTZ_MANUALTRACE;


typedef struct tagNET_DVR_VQD_LOOP_DIAGNOSE_CFG
{
    DWORD  dwSize ;        //结构体大小
    BYTE    byEnable;        // 诊断使能 0 :关闭，开启 1:开启
    BYTE     byRes1[3] ;     //保留
    BYTE    byVQDTypeEnable[32];     //VQD诊断模式，0 --不启用 1--启用  每种诊断类型对应有灵敏度，灵敏度的下标与诊断类型的下标一致
    /*数组0 图像模糊     数组1 亮度异常 数组2 图像偏色*/
    /*数组3 雪花干扰     数组4 条纹干扰 数组5 画面冻结*/
    /*数组6 信号丢失     数组7 云台失控*/    
    BYTE byThresholdValue[32] ;       //阈值0~100，不同诊断模式有各自对应的阈值
    NET_DVR_HANDLEEXCEPTION_V40      struAlarmHandleType;   //报警处理方式
    NET_DVR_SCHEDTIME   struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_SCHEDTIME   struHolidayAlarmTime[MAX_TIMESEGMENT_V30];  //假日布防时间段 
    BYTE    byRes[324];      //保留
}NET_DVR_VQD_LOOP_DIAGNOSE_CFG, *LPNET_DVR_VQD_LOOP_DIAGNOSE_CFG;

typedef struct tagNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO
{
    DWORD  dwChannelNO;   //通道号
    DWORD  dwVQDType;     // VQD诊断类型    
    NET_DVR_TIME struDiagnoseTime;    //诊断时间
    BYTE     byScoreValue;       //分数值 ，百分制
    BYTE     byRes[27];
}NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO,*LPNET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO;

typedef struct tagNET_DVR_VQD_DIAGNOSE_INFO
{
    DWORD  dwSize ;        //结构体大小
    NET_DVR_VQD_DIAGNOSE_EXCEPTION_INFO  struVQDDiagnoseExceptionInfo ; //诊断异常信息结构体
}NET_DVR_VQD_DIAGNOSE_INFO, *LPNET_DVR_VQD_DIAGNOSE_INFO;

typedef struct tagNET_DVR_DEC_RESOURCE_LIST
{
    DWORD dwSize;
    BYTE  byDecStatus[MAX_SUBSYSTEM_NUM_V40/*120*/]; 
    //解码资源状态列表，byDecStatus[i]表示槽位号i的子系统状态，0-无效，1-空闲，2-普通解码(包括普通解码上墙和大屏主从屏)，3-智能解码
    BYTE  byRes[32];
}NET_DVR_DEC_RESOURCE_LIST,*LPNET_DVR_DEC_RESOURCE_LIST;

typedef struct tagNET_DVR_DEC_APPLICANT_INFO
{
    DWORD dwSize;
    DWORD dwDecResource; /*申请的解码资源，以分辨率衡量，0-DCIF 1-CIF, 2-QCIF, 3-4CIF, 4-2CIF 5（保留）,
                         6-QVGA(320*240), 7-QQVGA(160*120), 16-VGA（640*480）, 17-UXGA（1600*1200）, 18-SVGA （800*600）,
                         19-HD720p（1280*720）,20-XVGA,  21-HD900p, 27-HD1080i, 28-2560*1920, 29-1600*304, 30-2048*1536, 
                         31-2448*2048,32-2448*1200,33-2448*800,34-XGA（1024*768），35-SXGA（1280*1024）,36-WD1(960*576/960*480),
    37-1080i,38-WXGA(1440*900),39-HD_F(1920*1080/1280*720),40-HD_H(1920*540/1280*360),41-HD_Q(960*540/630*360)*/
    DWORD  dwChannel; //智能通道号
    NET_DVR_IPADDR  struIP;   //申请者IP
    WORD  wPort;         //申请者端口号(智能分析仪通讯端口)
    BYTE  byRes[18];
}NET_DVR_DEC_APPLICANT_INFO,*LPNET_DVR_DEC_APPLICANT_INFO;

typedef struct tagNET_DVR_DEC_RESOURCE_INFO
{
    DWORD dwSize;
    DWORD dwSlotNum;  //槽位号，此参数做释放解码资源和登陆解码子系统校验用
    NET_DVR_IPADDR struIP; //解码子系统IP地址
    WORD  wPort;      //端口号
    BYTE  byRes1[2];
    DWORD dwDecChan;  //解码通道号
    BYTE  sUserName[NAME_LEN];    /* 解码子系统登陆帐号 */
    BYTE  sPassword[PASSWD_LEN];    /* 解码子系统登陆密码 */
    BYTE  byRes2[32];
}NET_DVR_DEC_RESOURCE_INFO,*LPNET_DVR_DEC_RESOURCE_INFO;

typedef struct tagNET_DVR_DEC_CHAN_COND
{
    DWORD dwSize;
    DWORD dwSlotNum; //槽位号,填申请解码资源时返回的槽位号
    DWORD dwDecChan; //解码通道号
    BYTE  byRes[16];
}NET_DVR_DEC_CHAN_COND,*LPNET_DVR_DEC_CHAN_COND;

typedef struct tagNET_DVR_DEC_YUV_CFG
{
    DWORD dwSize;
    BYTE  byEnable;     //关联使能，0-无关联，1-关联
    BYTE  byRes1[3];
    //byEnable = 1时以下参数有效
    DWORD dwYUVAddress[3]; //YUV输出地址
    WORD  wWidth;       //YUV输出宽
    WORD  wHeight;      //YUV输出高
    BYTE  byEnableAudio;  //使能音频，0-不启用，1-启用
    BYTE  byRes2[3];
    DWORD dwAudioAddr;  //音频输出地址
    BYTE  byRes3[16];
}NET_DVR_DEC_YUV_CFG,*LPNET_DVR_DEC_YUV_CFG;

typedef struct tagNET_DVR_INPUT_INFO
{
    DWORD        dwSize;
    BYTE        byChanType;        //接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
    BYTE        byRes1[3];
    DWORD        dwChanNo;        //通道号，设备通道号，支持byChanType所有类型
    DWORD        dwSubChanNo;    //槽位号，485槽位号，在byChanType为3-485通道时有效，表示通道号下的子通道号
    DWORD        dwVariableNo;    //变量编号，当byChanType为2-本地开关量通道时(1-输入，2-输出)
    BYTE        byRemoteType;    //获取变量类型，0-全部类型，1-遥信，2-遥测
    BYTE        byLinkageIPCType;   //联动IPC配置类型：0-默认，1-按变量号配置，2-按通道号配置
    BYTE        byLinkageTriggerType;   //联动触发器配置类型：0-默认，1-按变量号配置，2-按通道号配置
    BYTE        byRes2[57];
}NET_DVR_INPUT_INFO, *LPNET_DVR_INPUT_INFO;

typedef struct tagNET_DVR_ALARM_VARIABLE_CFG
{
    DWORD        dwSize; 
    WORD        wVariableIndex;        //变量编号，只能获取
    WORD        wVariableType;        //变量类型 1-模拟量 2-开关量，只能获取
    BYTE        sDescribe[NAME_LEN];//变量描述
    BYTE        byLimitLineType;    //报警限值配置类型，0-不支持报警限值配置，1-两限值配置（即上限、下限），2-四限值配置
    BYTE        byRemoteType;       //变量远动系统类型：0-全部类型，1-遥信，2遥测
    BYTE        byOsdEnabled;       //变量是否支持OSD叠加:0-默认，1-支持，2-不支持
    BYTE        byRes[29];            //保留
}NET_DVR_ALARM_VARIABLE_CFG, *LPNET_DVR_ALARM_VARIABLE_CFG;

typedef struct tagNET_DVR_ALARM_SENSOR_POINT_CFG
{
    int           nMeasureHigh;            // 量程上限 外部值*1000传入 可以为负数
    int           nMeasureLow;            // 量程下限 外部值*1000传入
    BYTE        byAlarmMode;            // 报警模式，五种，-HHHH、-HHHL、-HHLL、HLLL、-LLLL，
    // 即：1111（上上上上），1110（上上上下），1100（上上下下），1000(上下下下)，0000(下下下下)
    BYTE         byRes1[3];
    int            nAlarmValue[4];            // 报警限
    DWORD          dwOsdCfg;                // 模拟量字符叠加，按位表示0-15对应视频通道1-16
    DWORD        dwSensitive;            // 灵敏度范围10~1000。外部 float*1000。 灵敏度表示当实时值的变化超过灵敏度的范围时，则表示实时值发生了变化，否则认为没有发生变化。如：灵敏度为0.1，则表示前后检测的两个值之差大于0.1时，则认为数据发生变化，需要上传。如果为1，则表示变化超过1时上报。
    DWORD        dwIPChanOsd;            // 数字通道叠加模拟量字符，按位表示，0~31对应数字通道1-32
    char         szOSDUnit[MAX_OSD_UNIT_LEN];   //OSD叠加单位
    BYTE        byRes[16];
}NET_DVR_ALARM_SENSOR_POINT_CFG,*LPNET_DVR_ALARM_SENSOR_POINT_CFG;

typedef struct tagNET_DVR_ALARM_SWITCH_POINT_CFG
{
	DWORD     dwIPCChanOsd;//支持osd开关量叠加的IPC通道信息，按位表示，0~31对应数字通道1-32
    BYTE        byRes[60];
}NET_DVR_ALARM_SWITCH_POINT_CFG,*LPNET_DVR_ALARM_SWITCH_POINT_CFG;


typedef struct tagNET_DVR_ALARM_POINT_CFG
{
    DWORD        dwSize;
    DWORD        dwPointNo;            //点号
    BYTE        sPointDescribe[NAME_LEN];        //点号描述
    NET_DVR_ALARM_POINT_PARAM_UNION struPointParam; //当变量类型为模拟量或485遥信信号时，使用结构体struSensor，当变量类型为开关量或485遥信信号时，使用结构体struSwitch
    BYTE        byPointType;        //点号类型，1-模拟量，2-开关量
    BYTE        byChanType;        //接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
    BYTE        byRes1[2];
    DWORD        dwChanNo;        //通道号
    DWORD        dwSubChanNo;    //槽位号
    DWORD        dwVariableNo;    //变量编号，当byChanType为开关量时(1-输入信号，2-输出信号)
    BYTE        byRes[16];            //保留
}NET_DVR_ALARM_POINT_CFG, *LPNET_DVR_ALARM_POINT_CFG;

typedef struct _NET_DVR_SEARCH_CONDITION
{
    DWORD        dwSize;
    BYTE        byMajorType;    //查询方式，1-全部，2-按时间， 3-按类型，4-时间+类型
    BYTE        byMinorType;    //1-点号，2-通道+槽位+变量号
    BYTE        byRes1[2];
    NET_DVR_TIME struStartTime;    //起始时间
    NET_DVR_TIME struStopTime;    //结束时间
    BYTE        byChanType;        //通道类型，1-模拟量，2-485通道，3-网络通道，0xff表示无效
    BYTE        byRes2[3];
    DWORD        dwChanNo;        //通道号，从1开始，0xffffffff表示无效
    DWORD        dwSubChanNo;    //槽位号，从1开始，0xffffffff表示无效
    DWORD        dwVariableNo;    //变量号，从1开始，0xffffffff表示无效
    DWORD        dwPointNo;    //点号，0xffffffff表示无效
    BYTE          byRes3[32];        //保留
}NET_DVR_SEARCH_CONDITION, *LPNET_DVR_SEARCH_CONDITION;

typedef struct _NET_DVR_HISTORY_DATA
{
    DWORD        dwSize;
    NET_DVR_TIME struTime;    //时间点
    BYTE        byChanType;        //通道类型，1-模拟量，2-485通道，3-网络通道，0xff表示无效
    BYTE        byRes1[3];
    DWORD        dwChanNo;        //通道号，从1开始，0xffffffff表示无效
    DWORD        dwSubChanNo;    //槽位号，从1开始，0xffffffff表示无效
    DWORD        dwVariableNo;    //变量号，从1开始，0xffffffff表示无效
    DWORD        dwPointNo;        //点号，0xffffffff表示无效
    int            iData;            //历史数据
    BYTE        byDataType;        //0-正常数据，1-越上限数据，2-越下限数据
    BYTE        byRes2[31];
}NET_DVR_HISTORY_DATA, *LPNET_DVR_HISTORY_DATA;

typedef struct tagNET_DVR_ALARMHOST_ALARM_MODE_CFG
{
    DWORD    dwSize;
    BYTE    byDataUploadMode;    //1-按通道上传，2-按监测点上传
    BYTE    byRes[31];
}NET_DVR_ALARMHOST_ALARM_MODE_CFG,*LPNET_DVR_ALARMHOST_ALARM_MODE_CFG;

typedef struct tagNET_DVR_ALARMHOST_POINT_VALUE
{
    BYTE    byChanType;        //接入类型，1-本地模拟量通道，2-本地开关量通道，3-485通道，4-网络通道
    BYTE    byPointType;    //点类型，1-遥测（模拟量），2-遥信（开关量）
    BYTE    byRes1[2];        //保留
    DWORD     dwChanNo;        //485通道号，0xffffffff表示无效，通道类型为1时：表示本地模拟量通道号，通道类型为2时表示本地开关量通道号，通道类型为3时表示485通道号。
    DWORD    dwSubChanNo;    //槽位号， 0xffffffff表示无效，通道类型为3时使用
    DWORD    dwVariableNo;    //变量编号，0xffffffff表示无效
    DWORD     dwPointNo;        //104点号，0xffffffff表示无效
	int        iValue;            //监测点的值，表示低32位
	int        iValueEx;          //监测点的值，表示高32位
	BYTE    byRes[12];
}NET_DVR_ALARMHOST_POINT_VALUE,*LPNET_DVR_ALARMHOST_POINT_VALUE;


typedef struct tagNET_DVR_ALARMHOST_DATA_UPLOAD
{
    DWORD        dwSize;
    BYTE        byDataType;        //数据类型，1-监测点实时数据上传
    BYTE        byRes1[3];
    NET_DVR_ALARMHOST_DATA_UNION struAlarmData;
    BYTE        byRes2[32];
}NET_DVR_ALARMHOST_DATA_UPLOAD, *LPNET_DVR_ALARMHOST_DATA_UPLOAD;

typedef struct  tagNET_DVR_INPUTVOLUME
{
    DWORD  dwSize;     /*结构长度*/
    BYTE   byAudioInputChan;//音频输入通道号 
    BYTE   byRes[63];        // 保留字节
}NET_DVR_INPUTVOLUME, *LPNET_DVR_INPUTVOLUME;

typedef struct tagNET_DVR_AUDIOOUT_VOLUME
{
    DWORD  dwSize;
    BYTE byAudioOutVolume;// 输出音量等级：归一化为0-100；
    BYTE byRes[63];
}NET_DVR_AUDIOOUT_VOLUME,*LPNET_DVR_AUDIOOUT_VOLUME;

typedef struct tagNET_DVR_FUZZY_UPGRADE
{
    DWORD  dwSize;
    char  sUpgradeInfo[MAX_UPGRADE_INFO_LEN];
    BYTE  byRes[64];
}NET_DVR_FUZZY_UPGRADE,*LPNET_DVR_FUZZY_UPGRADE;

typedef struct tagNET_DVR_RS485_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //工作模式，0-控制台，1-私有透明通道，2-透明通道
    BYTE  byRes[31];
}NET_DVR_RS485_WORK_MODE, *LPNET_DVR_RS485_WORK_MODE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_SINGLE
{
    BYTE byEnable; //使能透明通道，0-不使能，1-使能
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //远程设备IP地址
    WORD wPort; //远程设备端口
    BYTE byRes2[18];    
}NET_DVR_TRANSPARENT_CLIENT_SINGLE, *LPNET_DVR_TRANSPARENT_CLIENT_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_SINGLE
{
    BYTE byEnable; //使能透明通道，0-不使能，1-使能
    BYTE byRes1[3];
    NET_DVR_IPADDR struIP; //允许接入的远程设备IP    
    BYTE byRes2[16];    
}NET_DVR_TRANSPARENT_SERVER_SINGLE, *LPNET_DVR_TRANSPARENT_SERVER_SINGLE;

typedef struct tagNET_DVR_TRANSPARENT_CLIENT_MODE
{
    NET_DVR_TRANSPARENT_CLIENT_SINGLE struClientSingle[MAX_TRANSPARENT_CHAN_NUM];
    BYTE byRes[320];
}NET_DVR_TRANSPARENT_CLIENT_MODE, *LPNET_DVR_TRANSPARENT_CLIENT_MODE;

typedef struct tagNET_DVR_TRANSPARENT_SERVER_MODE
{
    WORD wPort; //本地监听的端口号，和RS485口一一对应
    BYTE byRes1[2];
    NET_DVR_TRANSPARENT_SERVER_SINGLE struServerSingle[MAX_TRANSPARENT_ACCESS_NUM];
    BYTE byRes2[332];    
}NET_DVR_TRANSPARENT_SERVER_MODE, *LPNET_DVR_TRANSPARENT_SERVER_MODE;


typedef struct tagNET_DVR_TRANSPARENT_CHAN_CFG
{
    DWORD dwSize;    
    BYTE  byWorkMode; //工作模式，1-客户端模式，2-服务器模式
    BYTE  byRes[3];
    NET_DVR_TRANSPARENT_CHAN_WORK_MODE_UNION struTransparentPara;
}NET_DVR_TRANSPARENT_CHAN_CFG, *LPNET_DVR_TRANSPARENT_CHAN_CFG;

typedef struct tagNET_DVR_NAKED_DATA_INFO
{
    char   sSocketIP[128];
    WORD   wSocktPort;
    BYTE   byRes[258];
}NET_DVR_NAKED_DATA_INFO, *LPNET_DVR_NAKED_DATA_INFO;


typedef struct tagNET_DVR_NAKED_DATA_PARAM
{
    WORD  wPort;           //IP端口号，对于Pos信息接收，该值为0，则使用默认端口7050
    BYTE  byRes[130];      //保留字节
}NET_DVR_NAKED_DATA_PARAM, *LPNET_DVR_NAKED_DATA_PARAM;

typedef struct tagNET_DVR_POS_INFO
{
    NET_DVR_STRUCTHEAD     struVerHead;  //版本头
    DWORD dwChannelNum;          //通道号
    BYTE  byRes[60]; 
}NET_DVR_POS_INFO, *LPNET_DVR_POS_INFO;

typedef struct tagNET_DVR_POS_OSD_REGION
{
    NET_VCA_POINT   struStart;   //起点坐标
    NET_VCA_POINT   struEnd;    //终点坐标
}NET_DVR_POS_OSD_REGION, *LPNET_DVR_POS_OSD_REGION;

typedef struct 
{
    DWORD dwDelayTime;                /*delay time(5-3600s)*/
    BYTE  byPrevOsd;                   /*overlay osd on preview*/
    BYTE  byRes1[3];                    /*preserve*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    BYTE  byRes[64];                   /*preserve*/
}NET_DVR_POS_ACTION, *LPNET_DVR_POS_ACTION;







typedef struct tagNET_DVR_POS_NUCLEUS/*size 952byte*/
{
    char   szEmployeeNo[SERIAL_NUM_LEN];//员工编号，如1（备注：标题e<employee#>）
    char   szTerminalNo[SERIAL_NUM_LEN];// Pos机编号，如1（备注：标题t<terminal#>）
    char   szShiftNo[SERIAL_NUM_LEN]; //轮班（备注：标题s<shift#>）
    BYTE      byRes[928];
}NET_DVR_POS_NUCLEUS, *LPNET_DVR_POS_NUCLEUS;




typedef struct  tagNET_DVR_NET_SNIFF /*网络侦听结构体 312byte*/
{
    BYTE       byEnableSourcePort;       //是否启用对数据源端口过滤  0-不启用，1-启用
    BYTE       byEnableDestAddr;        //是否启用对目标IP地址进行过滤 0-不启用，1-启用
    BYTE       byEnableDestPort;         //是否启用对目标地址的端口号进行过滤
    BYTE       byRes1;                 //保留
    BYTE       bySourceIpAddr[MAX_DOMAIN_NAME];                //数据源地址 
    BYTE       byDestinationIpAddr[MAX_DOMAIN_NAME];        //数据发送目标地址 
    WORD          wSourcePort;               //数据源端口号
    WORD          wDestinationPort;           //数据发送目标端口号
    BYTE       byRes[16];                 //保留
}NET_DVR_NET_SNIFF, *LPNET_DVR_NET_SNIFF;


typedef struct tagNET_DVR_MONITOR_INFO  /*监听*/
{
    WORD  wPort;       //监听端口号
    BYTE   byRes1[2];
    NET_DVR_IPADDR  struRestrictRemoteIP;//保留限制远程访问IP
    BYTE   byRes[164];     
}NET_DVR_MONITOR_INFO, *LPNET_DVR_MONITOR_INFO;


typedef struct tagNET_DVR_CONNECT_POS_CFG
{
    DWORD   dwSize;               //结构体大小
    BYTE     byConnectMode;    //连接模式:0->网络监听(TCP),1->网络接受,2->串口接收3-网络监听（UDP）,4-网络侦听,5-多播
    BYTE     byRes1[3];         //保留
    NET_DVR_POS_CONNECTMODE_UNION uPosConnMode;    //连接模式配置
    BYTE  byRes[64];
}NET_DVR_CONNECT_POS_CFG, *LPNET_DVR_CONNECT_POS_CFG;

typedef struct  tagNET_DVR_CHAN_FILTER_CFG
{
    DWORD                  dwSize;              //结构体大小
    BYTE                  byFilterID;           //POS过滤规则ID
    BYTE                 byFontSize;         //字号大小，0-- 8*16  1--16*32  2--32*64 
    BYTE                  byShowPosInfo;        //码流中是否叠加pos信息
    BYTE                byOverlayMode;      //叠加方式，0-滚屏，1-翻页
    DWORD                 dwDelayTime;        /*delay time(5-3600s)*/
    NET_DVR_POS_OSD_REGION  struOsdPosInfo;          /*overlay osd rect info*/
    NET_DVR_RGB_COLOR        struOsdColor;           //OSD颜色
    NET_DVR_SCHEDTIME        struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    //异常处理方式中报警输出号与组号绑定，即组号为0时，表示关联的报警输出号范围为1-64，当组号为1时，表示关联的报警输出号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组 当前的及组内后续的报警出号无效
    DWORD                  dwMaxRelRecordChanNum ;  //报警触发的录象通道数（只读）最大支持数量
    DWORD                  dwRelRecordChanNum ;     //本组内关联的录象通道数 
    DWORD                  dwRelRecordChan[MAX_CHANNUM_V30];//触发录像通道
    //关联的录像通道号与组号绑定，即组号为0时，表示关联的通道号范围为1-64，当组号为1时，表示关联的通道号范围为65-128， 且是组内紧凑排列，如果遇到0xffffffff表示本组内后续的关联通道号无效
    DWORD                 dwTimeOut;        /*time Out(5-3600s)*/ //数据超时指在多长时间接收不到POS数据即判定一次数据包的结束。
    BYTE              byRes[60];    //保留
}NET_DVR_CHAN_FILTER_CFG, *LPNET_DVR_CHAN_FILTER_CFG; 

typedef struct    tagNET_DVR_DEVICE_LAN_ENCODE
{    
    DWORD        dwSize;        
    BYTE        byLanEncode[MAX_LAN_ENCODE_LEN];    //设备语言编码格式
    BYTE        byRes[28];
}NET_DVR_DEVICE_LAN_ENCODE, *LPNET_DVR_DEVICE_LAN_ENCODE;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION
{
    DWORD    dwSize;
    BYTE    byEnable; //使能，是否开启 0~不开启,1~开启
    BYTE    bySensitiveLevel;// 1-100，默认50，灵敏度越高，越容易报警
    BYTE    byRes1[2];
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    DWORD    dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD    dwRelRecordChanNum ;     //报警触发的录象通道 数 实际支持的数量
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30];//触发录像通道
    //报警触发的录象通道（四字节的通道号，初始值是 0xffffffff）
    BYTE    byRes2[128];
}NET_DVR_SCENECHANGE_DETECTION,*LPNET_DVR_SCENECHANGE_DETECTION;

typedef struct tagNET_DVR_SCENECHANGE_DETECTION_RESULT
{
    DWORD            dwSize;          // 结构大小
    NET_VCA_DEV_INFO struDevInfo;    //前端设备信息
    WORD      wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    BYTE             byRes[126];      // 保留字节
}NET_DVR_SCENECHANGE_DETECTION_RESULT,*LPNET_DVR_SCENECHANGE_DETECTION_RESULT;


typedef struct tagNET_DVR_PARK_INFO
{ 
    char          sPlateNo[MAX_PlATE_NO_LEN];             //车牌号码 
    char          sParkIndex[MAX_PlATE_NO_LEN];        //车位编号
    BYTE          byRes[64];
}NET_DVR_PARK_INFO, *LPNET_DVR_PARK_INFO;

typedef struct tagNET_DVR_CROSSLINE_ALARM
{
    DWORD                 dwSize;
    NET_VCA_DEV_INFO     struDevInfo;
    NET_DVR_TIME_EX      struTriggerTime;/*触发时间*/
    NET_DVR_PARK_INFO    struParkInfo; //车位信息
    BYTE                 byRes1[128];
}NET_DVR_CROSSLINE_ALARM, *LPNET_DVR_CROSSLINE_ALARM;

typedef struct tagNET_DVR_STREAM_SRC_CFG
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamID; //流信息
    NET_DVR_STREAM_SRC_INFO struStreamSrcInfo; //流源信息
}NET_DVR_STREAM_SRC_CFG,*LPNET_DVR_STREAM_SRC_CFG;

typedef struct tagNET_DVR_ENCODEINFO
{
    BYTE  byFormatType; //封装类型，1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP, 9-RTP+PS（国标：GB28181），0xff-无效
    BYTE  byVideoEncType;//视频编码类型，0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，0xff-无效
    WORD  wWidth; //图像宽度
    WORD  wHeight; //图像高度
    BYTE  byRes1[2];
    DWORD dwVideoBitrate;     //视频码率,单位Kbps
    DWORD dwVideoFrameRate;    //帧率，200起表示小于1帧/秒的状态，其余值表示实际帧率值,200-1/2,201-1/4,202-1/8,203-1/16
    BYTE  byAudioEncType;//音频编码类型，0-G722，1-G711_U，2-G711_A，5-MPEG2,6-G726，7-AAC,0xff-无效    
    BYTE  byRes2[15];
}NET_DVR_ENCODEINFO, *LPNET_DVR_ENCODEINFO;

typedef struct tagNET_DVR_TRANSSTATUS
{
    DWORD dwSize;
    NET_DVR_STREAM_INFO struStreamInfo;//流ID、转码通道信息    
    BYTE  byMode;//转码模式，1-主动转码，2-被动转码
    BYTE  byLinkNums;//连接数
    BYTE  byPassiveTransMode; //被动转码模式，0-无效，1-实时流，2-文件流
    BYTE  byRes;
    NET_DVR_ADDRESS struDstIPInfo[MAX_LINK];//目标转码ip地址
    BYTE  byTransResource;//所使用的转码资源数，按D1计算
    BYTE  byRes1[15];
    NET_DVR_ENCODEINFO struSrcEncodeInfo;//源编码信息
    NET_DVR_ENCODEINFO struDstEncodeInfo[MAX_LINK /*6*/];//目标编码信息
    BYTE  byRes2[36];
}NET_DVR_TRANSSTATUS, *LPNET_DVR_TRANSSTATUS;

typedef struct tagNET_DVR_TRANSDEVICE_STATUS
{
    DWORD dwSize;
    DWORD dwTotalResource;//全部转码资源，以D1为单位计算
    DWORD dwIdleResource;//剩余转码资源，以D1为单位计算
    BYTE  byCpuLoad;//CPU利用率
    BYTE  byRes[67];
}NET_DVR_TRANSDEVICE_STATUS, *LPNET_DVR_TRANSDEVICE_STATUS;

typedef struct tagNET_DVR_DEV_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode; //1-通道模式，2-流ID模式
    BYTE  byDisplayMode; //0-普通，1-畅显
    BYTE  byEnableVcaDec; //是否启用智能解码，0-不启用，非0-启用
    BYTE  byRes[61];
}NET_DVR_DEV_WORK_MODE,*LPNET_DVR_DEV_WORK_MODE;

typedef struct tagNET_DVR_PASSIVETRANSINFO 
{
    DWORD dwSize;
    BYTE byStreamType;// 码流类型，0-主码流，1-子码流
    BYTE byLinkMode;// 0：TCP方式,1：UDP方式（保留）
    BYTE byPassiveTransMode; //被动转码模式，1-实时流，2-文件流
    BYTE byRes1[5];    
    BYTE byDataType;//缓冲区类型，1-SDP，2-码流头
    BYTE byRes2;
    WORD wDataLength;//数据长度
    char *pBuffer;//缓冲区
    BYTE byRes3[32]; // 保留
}NET_DVR_PASSIVETRANSINFO, *LPNET_DVR_PASSIVETRANSINFO;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG
{
    DWORD dwSize;
    BYTE  byEnable;          //是否显示，1-显示，0-隐藏    
    BYTE  byBaseMapType;     //底图类型，1-图片底图，2-超高清输入底图，3-底图轮训
    BYTE  byBaseMapCircleNo; //底图轮训参数编号，byBaseMapType为3时有效
    BYTE  byRes1;
    DWORD dwBaseMapNo;     //底图号；底图类型为1时，此参数为图片序号，底图类型为2时此参数为超高清输入子系统输入口号（1字节矩阵号+1字节子板号+1字节输入口号+1字节保留）
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG,*LPNET_DVR_BASEMAP_CONTROL_CFG;

typedef struct tagNET_DVR_VIRTUAL_SCREEN_CFG
{
    DWORD dwSize;
    DWORD dwResolution; //分辨率，MAKE_RESOLUTION宏定义的值，从电视墙能力获取支持的分辨率值
    BYTE byRes[64];
}NET_DVR_VIRTUAL_SCREEN_CFG, *LPNET_DVR_VIRTUAL_SCREEN_CFG;

typedef struct tagNET_DVR_BASEMAP_WINCFG
{
    DWORD dwSize;
    BYTE  byEnable;
    BYTE  byWndOperateMode;  //窗口操作模式，0-统一坐标，1-分辨率坐标
    BYTE  byRes1[6];
    NET_DVR_RECTCFG_EX struWinPosition;//目的窗口(相对显示墙),底图窗口的起始坐标和大小必须是基准坐标的整数倍
    NET_DVR_RECTCFG_EX struResolution; //目的窗口分辨率坐标，获取或按分辨率坐标设置有效
    DWORD dwXCoordinate; //LED区域左上角X坐标（统一坐标），获取或按分辨率坐标设置有效
    DWORD dwYCoordinate; //LED区域左上角Y坐标（统一坐标），获取或按分辨率坐标设置有效
    BYTE  byRes2[36];
}NET_DVR_BASEMAP_WINCFG, *LPNET_DVR_BASEMAP_WINCFG;

typedef struct tagNET_DVR_BASEMAP_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//图片名称
    BYTE   byUsed; //是否已存在，0-不存在，1-存在
    BYTE   byRes[31];
}NET_DVR_BASEMAP_PIC_INFO,*LPNET_DVR_BASEMAP_PIC_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_INFO
{
    DWORD  dwSize;
    DWORD  dwLogoSize;//LOGO大小，包括BMP的文件头，图片大小超限，限100K，高和宽须是32的倍数
    BYTE   byRes[32];
}NET_DVR_MATRIX_LOGO_INFO,*LPNET_DVR_MATRIX_LOGO_INFO;

typedef struct tagNET_DVR_MATRIX_LOGO_CFG
{
    DWORD  dwSize;
    BYTE   byExist;  //logo是否存在，0-不存在，1-存在（此参数只能获取）
    BYTE   byRes1[3];
    DWORD  dwLogoSize;//LOGO大小，包括BMP的文件头(此参数只能获取)
    BYTE   byLogoName[NAME_LEN];  //logo名称
    DWORD  dwLogoNo;    //logo编号（获取所有logo信息时有效）
    BYTE   byRes2[28];
}NET_DVR_MATRIX_LOGO_CFG,*LPNET_DVR_MATRIX_LOGO_CFG;

typedef struct tagNET_DVR_WIN_LOGO_CFG
{
    DWORD  dwSize;
    DWORD  dwLogoNo; //logo号
    BYTE   byEnable; //logo是否显示，1-显示，0-隐藏
    BYTE   byRes1[3];    
    DWORD  dwCoordinateX;    //图片显示区域X坐标
    DWORD  dwCoordinateY;    //图片显示区域Y坐标    
    BYTE   byFlash;  //是否闪烁1-闪烁，0-不闪烁
    BYTE   byTranslucent; //是否半透明1-半透明，0-不半透明
    BYTE   byRes2[34];                //保留    
}NET_DVR_WIN_LOGO_CFG,*LPNET_DVR_WIN_LOGO_CFG;    

typedef struct tagNET_DVR_BIG_SCREEN_AUDIO_CFG
{
    DWORD dwSize;
    DWORD dwWinIndex; //窗口号，从1开始，0表示底图
    BYTE  byEnable; //是否打开音频，1-打开音频，0-关闭音频
    BYTE  byRes[31];
}NET_DVR_BIG_SCREEN_AUDIO_CFG, *LPNET_DVR_BIG_SCREEN_AUDIO_CFG;

typedef struct tagNET_DVR_WIN_ZOOM_STATUS
{
    DWORD dwSize;
    BYTE  byZoomStatus;  //0-正常状态，1-放大状态
    BYTE  byRes1[3];
    NET_DVR_POINT_FRAME struPointFrame; //放大区域，当byZoomStatus为1时有效
    BYTE  byRes2[32];
}NET_DVR_WIN_ZOOM_STATUS,NET_DVR_WIN_ZOOM_STATUS;

typedef struct tagNET_DVR_RESUME_INITRACKPOS_CFG
{
    DWORD           dwSize;          // 结构大小
    DWORD           dwChannel;;     // 通道号
    BYTE            byRes[16];      // 保留字节
}NET_DVR_RESUME_INITRACKPOS_CFG,*LPNET_DVR_RESUME_INITRACKPOS_CFG;


typedef struct  tagNET_DVR_TEST_COMMAND
{
    DWORD   dwSize;     
    DWORD   dwChannel;       //通道号
    BYTE    byTestCommand[MAX_TEST_COMMAND_NUM]; 
    //0-表示不开启测试， 1-表示开启测试
    //数组下标0 开启老化测试程序                               
    //数组下标1 红外灯进入测试模式
    //数组下标2 ICR老化测试，0表示关闭，1表示开启，可以与bit0 组合，如0000_0001(只开启巡航老化)、0000_0101（同时开启巡航和ICR老化）、0000_0100（只开启ICR老化） 
    //数组下标3 -球机pt自矫正功能状态，0表示球机自矫正功能未清除，1表示球机自矫正功能已清除
    //数组下标4 花样扫描测试程序，0表示关闭，1表示开启
    //数组下标5 电子罗盘校正程序，0表示关闭，1表示开启
    WORD    wICRIntervalTime;//icr间隔时间（byTestCommand 数组下表2内的值为1时，ICR开关间隔时间，单位秒）
    BYTE    byElectronicCompassState;//罗盘状态返回， 0-正常， 1-不正常
    BYTE    byRes1[1];
    float   fDeviceTem; //设备机芯温度，精确度0.001
    BYTE    byTemp[9];  //用于多个温敏设备， 下标0-全景的温敏， 标1-4：全景1的4个sensor的温敏， 标5-8：全景2的4个sensor的温敏,目前用于鹰眼全景
    BYTE    byRes[3];      //保留字节 
}NET_DVR_TEST_COMMAND, *LPNET_DVR_TEST_COMMAND;

typedef struct  tagNET_DVR_AGING_TRICK_SCAN
{
    DWORD   dwSize;
    DWORD   dwChannel;       //通道号
    BYTE     byAging; // 表示设置的参数 为老化前工具还是老化后工具， 0-老化前、1-老化后 
    BYTE     byWriteReadEnalbe; //读写指令使能，0-设置读指令， 1-设置写指令
    BYTE     byRes[126];      //保留字节
}NET_DVR_AGING_TRICK_SCAN, *LPNET_DVR_AGING_TRICK_SCAN;

typedef struct tagNET_DVR_IPC_PARAM_TYPE
{
    DWORD dwSize;
    DWORD dwParamType; //参数类型，按位表示    
    // #define IPC_PARAM_AGING_TRICK_SCAN       0x00000001 //清除花样扫描参数设置
    BYTE byRes[32];
}NET_DVR_IPC_PARAM_TYPE, *LPNET_DVR_IPC_PARAM_TYPE;

typedef struct  tagNET_DVR_ECCENTRIC_CORRECT_STATE
{
    DWORD   dwSize;
    DWORD   dwChannel;       //通道号
    BYTE     byEccentricCorrectState; // 偏心矫正状态，0-校正失败、1-校正成功、2-校正中
    BYTE     byRes[127];      //保留字节
}NET_DVR_ECCENTRIC_CORRECT_STATE, *LPNET_DVR_ECCENTRIC_CORRECT_STATE;

typedef struct tagNET_DVR_TEST_DEVMODULE_CFG
{
    DWORD   dwSize;
    DWORD   dwChannel;      //通道号
    BYTE    byDevFanModuleType[MAX_DEVMODULE_NUM]; //测试的设备类型
    // 0-不开启测试,1-开启测试
    // bit0-测试风扇1
    // bit1-测试风扇2
    BYTE    byDevHeaterModuleType[MAX_DEVMODULE_NUM]; //测试的设备类型
    // 0-不开启测试,1-开启测试
    // bit0-测试加热器1
    // bit1-测试加热器2
    BYTE    byRes[22];      //保留字节
}NET_DVR_TEST_DEVMODULE_CFG, *LPNET_DVR_TEST_DEVMODULE_CFG;

typedef struct tagNET_DVR_BARRIERGATE_COND
{
    BYTE  byLaneNo;//车道号（0-表示无效值(设备需要做有效值判断),1-车道1）
    BYTE  byRes[3];
}NET_DVR_BARRIERGATE_COND,*LPNET_DVR_BARRIERGATE_COND;

typedef struct tagNET_DVR_VEHICLE_CONTROL
{
    BYTE   byGateOperateType;//0-无操作,1-开道闸
    BYTE   byRes1 ;
    WORD   wAlarmOperateType;//0-无操作,bit0-继电器输出报警 bit1-布防上传报警 bit3-告警主机上传（可复选）(0-表示关，1-表示开)
    BYTE   byRes2[8];
}NET_DVR_VEHICLE_CONTROL,*LPNET_DVR_VEHICLE_CONTROL;

typedef struct tagNET_DVR_RELAY_PARAM
{
    BYTE   byAccessDevInfo;//0-不接入设备，1-开道闸、2-关道闸、3-停道闸、4-报警信号、5-常亮灯
    BYTE   byRes[3];
}NET_DVR_RELAY_PARAM,*LPNET_DVR_RELAY_PARAM;

typedef struct tagNET_DVR_ENTRANCE_CFG
{
    DWORD   dwSize;
    BYTE    byEnable ;// 使能0-表示关闭，1-表示打开
    BYTE    byBarrierGateCtrlMode;//0-相机自动控制，1-平台外部控制
    BYTE    byRes1[2];
    DWORD   dwRelateTriggerMode;//关联触发模式 参考ITC_TRIGGERMODE_TYPE
    /*0x00: 不做匹配*/
    /*0x01: 车牌匹配（带车牌颜色）*/
    /*0x02: 车牌匹配（不带车牌颜色）*/
    /*0x04: 卡号匹配*/
    DWORD  dwMatchContent;  //异常处理,异常处理方式的"或"结果
    NET_DVR_RELAY_PARAM  struRelayRelateInfo[MAX_RELAY_NUM/*12*/];//继电器关联配置信息(一个继电器只能控制一个接入设备) 数组0表示继电器1 数组1表示继电器2 依次类推 12
    BYTE byGateSingleIO[MAX_IOIN_NUM/*8*/]; //单个IO触发参数，单个IO触发参数，数组0表示IO1，数组1表示IO2，依次类推 ; 具体数组值的含义（0-无，1-道闸开到位，2-道闸关到位，3-消防报警）
    //车辆信息管控  
    //数组0表示临时车辆配置的模式
    //数组1-禁止名单车辆的模式, 
    //数组2-允许名单车辆的模式
    NET_DVR_VEHICLE_CONTROL struVehicleCtrl[MAX_VEHICLE_TYPE_NUM/*8*/];//车辆信息管控  
    BYTE    byNotCloseCarFollow;//启用跟车不落闸使能，0~为不启用，1~启用
    BYTE  byParkingDetectEnabled;//启用驻车检测使能，0~为不启用，1~启用
    BYTE  byParkingDetectJudgeTime;//驻车检测判断时间，单位秒
    BYTE    byRes2[61];
}NET_DVR_ENTRANCE_CFG,*LPNET_DVR_ENTRANCE_CFG;

typedef struct tagNET_DVR_BARRIERGATE_CFG
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  byLaneNo;  //道闸号（0-表示无效值(设备需要做有效值判断),1-道闸1）
    /*
    若老的平台不支持byUnlock字段，该字段将赋值为0，通过“0-关闭道闸,1-开启道闸,2-停止道闸”中的任何一种操作皆可进行解锁。
    若新平台支持byUnlock字段，需byUnlock字段赋值为1，并结合4~解锁道闸来进行解锁。byUnlock字段赋值为1后，“0-关闭道闸,1-开启道闸,2-停止道闸”操作将不可用于解锁。
    */
    BYTE  byBarrierGateCtrl;//0-关闭道闸,1-开启道闸,2-停止道闸 3-锁定道闸,4~解锁道闸
    BYTE  byEntranceNo;//出入口编号 [1,8]
    BYTE  byUnlock;//启用解锁使能，0~为不启用，1~启用
    BYTE  byRes[12];
}NET_DVR_BARRIERGATE_CFG, *LPNET_DVR_BARRIERGATE_CFG;

typedef struct  tagNET_DVR_VEHICLE_CONTROL_LIST_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel;//通道号0xff - 全部通道（ITC 默认是1）
    DWORD  dwDataIndex;//数据流水号（平台维护的数据唯一值，客户端操作的时候，该值不会起效。该值主要用于数据增量同步）
    char   sLicense[MAX_LICENSE_LEN]; //车牌号码
    BYTE   byListType;//名单属性（名单）0-允许名单，1-禁止名单
    BYTE   byPlateType;    //车牌类型
    BYTE   byPlateColor;    //车牌颜色
    BYTE   byRes[21];
    char   sCardNo[MAX_CARDNO_LEN]; // 卡号
    NET_DVR_TIME_V30  struStartTime;//有效开始时间
    NET_DVR_TIME_V30  struStopTime;//有效结束时间
    //操作数（平台同步表流水号不会重复，用于增量更新，代表同步到同步表的某一条记录了，存在相机内存，重启后会清0）2014-03-03
    char        sOperateIndex[MAX_OPERATE_INDEX_LEN]; 
    BYTE  byRes1[224]; // 保留字节
} NET_DVR_VEHICLE_CONTROL_LIST_INFO,*LPNET_DVR_VEHICLE_CONTROL_LIST_INFO;

typedef struct tagNET_DVR_VEHICLE_CONTROL_COND
{
    DWORD  dwChannel;//通道号0xffffffff - 全部通道（ITC 默认是1）
    DWORD  dwOperateType;//操作类型，参照VCA_OPERATE _TYPE。（可复选）
    char   sLicense[MAX_LICENSE_LEN];//车牌号码
    char   sCardNo[MAX_CARDNO_LEN]; // 卡号
    BYTE   byListType;//名单属性0-允许名单，1-禁止名单，0xff-全部
    //2014-02-25
    BYTE   byRes1[3];
    DWORD  dwDataIndex;//数据流水号     
    BYTE   byRes[116];
}NET_DVR_VEHICLE_CONTROL_COND,*LPNET_DVR_VEHICLE_CONTROL_COND;


typedef struct tagNET_DVR_VEHICLE_CONTROL_ALARM
{
    DWORD dwSize;
    BYTE  byListType;   //名单属性0-允许名单，1-禁止名单，2-临时名单
    BYTE  byPlateType;  //车牌类型
    BYTE  byPlateColor;    //车牌颜色
    BYTE  byRes1;
    char  sLicense[MAX_LICENSE_LEN];//车牌号码
    char  sCardNo[MAX_CARDNO_LEN];  // 卡号
    NET_DVR_TIME_V30 struAlarmTime; //报警时间
    DWORD dwChannel;          //设备通道号，如果直连的是IPC，则为ipc通道号；如果连的DVR\nvr,则为DVR\NVR的通道号
    DWORD dwPicDataLen;   //图片数据大小，0表示无图片，不为0是表示后面带图片数据
    BYTE  byPicType;    //图片类型，0-JPEG
    BYTE  byPicTransType;        //图片数据传输方式: 0-二进制；1-url
    BYTE  byRes3[2];
    char    *pPicData;
    BYTE  byRes2[48];
}NET_DVR_VEHICLE_CONTROL_ALARM,*LPNET_DVR_VEHICLE_CONTROL_ALARM;

typedef struct tagNET_DVR_FIRE_ALARM
{
    DWORD            dwSize;
    NET_DVR_TIME_V30 struAlarmTime;//报警时间
    BYTE             byRes[128];
}NET_DVR_FIRE_ALARM,*LPNET_DVR_FIRE_ALARM;


typedef struct tagNET_DVR_GATELAMP_INFO
{
    DWORD dwSize;
    DWORD dwChannel; //通道号
    BYTE  byLaneNo; //道闸号（0-表示无效值(设备需要做有效值判断),1-道闸1）
    BYTE  byBrightlampCtrl;//0-关闭常亮灯，1-开启常亮灯
    BYTE  byRes[14]; 
}NET_DVR_GATELAMP_INFO,*LPNET_DVR_GATELAMP_INFO;

typedef struct tagNET_DVR_MATRIX_BASE_CFG
{
    DWORD dwSize; 
    DWORD dwValidInputNum;     //有效的输入通道数
    DWORD dwValidOutputNum;    //有效的输出通道数
    BYTE  byRes[64]; 
}NET_DVR_MATRIX_BASE_CFG, *LPNET_DVR_MATRIX_BASE_CFG;

typedef struct tagNET_DVR_MATRIX_SWITCH_INFO
{
    DWORD   dwSize; 
    DWORD   dwInputChan;        //输入通道号，为0表示取消和指定输出的关联关系
    DWORD   dwOutputChan;       //要切换到的输出通道号, (屏幕服务器为屏幕索引号(1字节设备号+1字节保留+2字节屏幕索引号)), 0xffffffff表示切换到所有输出
    DWORD   dwMatrixID; //矩阵ID号
    BYTE    byRes[28]; 
}NET_DVR_MATRIX_SWITCH_INFO, *LPNET_DVR_MATRIX_SWITCH_INFO;

typedef struct tagNET_DVR_IO_RELATION_INFO
{
    DWORD   dwSize; 
    DWORD   dwIORelation[MATRIX_MAX_OUTPUT_NUM];  //输出通道关联的输入通道, dwIORelation[i] = j表示输出通道(i + 1)和输入通道j关联,
    //dwIORelation[i] = 0表示输出通道i + 1未关联输入通道                                                                
    BYTE    byRes[256]; 
}NET_DVR_IO_RELATION_INFO, *LPNET_DVR_IO_RELATION_INFO;

typedef struct tagNET_DVR_EXTERNAL_DEVCOND
{
    DWORD  dwSize;
    BYTE   byExternalDevTpye;//0-其他(保留)，1-远距离读头设备，2-出入口控制机，3-led屏  0xff-全部信息（长连接获取时使用）
    BYTE   byRelativeIndex;//0-其他(保留)，索引(相对于接入类型) 范围 1~8 Led的相对索引范围是（1～255）   0xff-全部信息（长连接获取时使用）
    //    BYTE   byLaneID;// 逻辑车道号    
    BYTE   byRes[30];
}NET_DVR_EXTERNAL_DEVCOND,*LPNET_DVR_EXTERNAL_DEVCOND;

typedef struct tagNET_DVR_EXTERNAL_DEVCFG
{
    DWORD         dwSize;
    BYTE          byExternalDevTpye;//0-其他，1-远距离读头设备，2-出入口控制机，3-led屏 
    BYTE          byRes2[3];
    char          sDevName[MAX_DEVNAME_LEN];
    union
    {
        BYTE    byUnionLen[656];
        struct
        {
            NET_DVR_IPADDR  struDevIP;//DEV IP地址 144
            WORD     wDevPort;//设备端口
            BYTE     byRes[510];
        }struRrReader;//远距离读头设备
        struct
        {
            BYTE byRs485No; //RS485编号(外接设备类型一样，该编号可以重复；类型不一样，该编号互斥)
            BYTE byDevCtrlCode;//拨码地址，用于区分设备(1-255)
            BYTE byAutoIssuedData;//是否自动下发卡片数据 0-不自动下发，1-自动下发
            BYTE byOfflineDetEnable;//离线检测 0-关闭，1-开启
            BYTE byDetCycle;//检测周期（0～60 单位 s）
            BYTE byRes[651];
        }struGateway;//出入口控制机
        struct
        {
            BYTE byExternalMode;//0-RS485,1-网络
            BYTE byRes[3];
            NET_DVR_IPADDR  struDevIP;//DEV IP地址 144 (在byExternalMode == 1 时生效)
            WORD wDevPort;//设备端口(在byExternalMode == 1 时生效)
            BYTE byRs485No; //RS485编号(外接设备类型一样，该编号可以重复；类型不一样，该编号互斥)
            BYTE byDevCtrlCode;//拨码地址，用于区分设备(1-255)
            //led屏通过控制卡控制显示的，不同的控制卡类型支持的显示方式不同
            BYTE byCtrlCardType;//控制卡类型 0-保留(无效值) 1- EQ2013
            BYTE byLedScreenType;//屏类型 0-单色屏 1-双色屏
            BYTE byLedScreenUse;//屏用途0-其它 1-区位屏 2-提示屏 3-收费屏
            BYTE byLedDisplayMode;//屏幕字体显示方式: 1 "立即显示",    2 "左移" ,3 "右移" ,4 "上移",     5 "下移"
            char sLedCustomInfo[MAX_LED_INFO];//屏幕字体显示信息
            //led屏是由控制卡控制的，led屏可以根据项目实际使用更换大小，此时需要终端通知控制卡目前使用的屏宽和屏高
            DWORD dwLedScreenH;//显示屏组成高度上需要的LED点数
            DWORD dwLedScreenW;//显示屏组成宽度上需要的LED点数
            BYTE byRes1[236];
        }struLed;//led屏
    }uExternalDevInfo; //由byExternalMode 值来决定哪个有效
    BYTE byRes[128];
}NET_DVR_EXTERNAL_DEVCFG, *LPNET_DVR_EXTERNAL_DEVCFG;

typedef struct tagNET_DVR_EXTERNAL_DEVSTATUS//远距离读头设备
{
    DWORD  dwSize;
    char   sDevName[MAX_DEVNAME_LEN];//设备名称
    BYTE   byExternalDevTpye;//0-其他(保留)，1-远距离读头设备，2-出入口控制机，3-led屏  0xff-全部信息（长连接获取时使用）
    BYTE   byRelativeIndex;//0-其他(保留)，相对索引(相对于接入类型能) 范围 1~8  0xff-全部信息（长连接获取时使用）
    BYTE   byOnline;//0-不在线，1-在线
    BYTE   byRes[125];
}NET_DVR_EXTERNAL_DEVSTATUS,*LPNET_DVR_EXTERNAL_DEVSTATUS;

typedef struct tagNET_DVR_ENTRANCEDET_CFG
{
    DWORD   dwSize;        //结构长度
    //离线检测开启时，如果检测到设备在线，则由终端匹配卡片信息，并发送道闸控制指令给出入口控制机；否则由出入口控制机自身匹配控制道闸
    BYTE   byOfflineDetEnable;//离线检测 0-关闭，1-开启
    BYTE   byDetCycle;//检测周期（0～60 单位 s）
    BYTE   byDevCtrlCode;//出入口控制机拨码地址，用于区分设备(1-255)
    BYTE   byRes[61];
}NET_DVR_ENTRANCEDET_CFG,*LPNET_DVR_ENTRANCEDET_CFG;

typedef struct tagNET_DVR_ENTRANCEDEV_COMMAND
{
    DWORD  dwSize; //结构长度
    BYTE   byDevCtrlCode;//出入口控制机拨码地址，用于区分设备(1-255)
    BYTE   byManualIssuedData;//手动数据下发 0-关闭，1-开启 
    BYTE   byRes[62];
}NET_DVR_ENTRANCEDEV_COMMAND,*LPNET_DVR_ENTRANCEDEV_COMMAND;

typedef struct tagNET_DVR_ENISSUED_DATADEL
{
    DWORD   dwSize; //结构长度
    BYTE   byDevCtrlCode;//出入口控制机拨码地址，用于区分设备(1-255)
    BYTE   byRes[27];
}NET_DVR_ENISSUED_DATADEL,*LPNET_DVR_ENISSUED_DATADEL;


typedef struct  _tagNET_ITS_HANDOVER_INFO
{
    DWORD   dwSize;        //结构长度
    BYTE    byOperatorName[MAX_OPERATORNAME_LEN]; //操作人员名称
    BYTE    byOperatorCard[MAX_CARD_LEN]; //操作人员卡号
    BYTE    byStartTime[MAX_TIME_LEN];//上班时间格式形如yyyymmddhh24miss
    BYTE    byEndTime[MAX_TIME_LEN]; //下班时间格式形如yyyymmddhh24miss
    float   fTotal_Pay;    //本次上班期间总的收费金额(单位元)
    DWORD   dwTotal_Records;   //本次上班期间总的过车收费的记录条数
    BYTE    byRes[64]; //预留
}NET_ITS_HANDOVER_INFO, *LPNET_ITS_HANDOVER_INFO;

typedef struct tagNET_DVR_CURTRIGGERMODE //(3.7Ver)
{
    DWORD  dwSize;
    DWORD  dwTriggerType; //触发类型，详见ITC_TRIGGERMODE_TYPE 
    BYTE   byRes[24]; 
}NET_DVR_CURTRIGGERMODE, *LPNET_DVR_CURTRIGGERMODE;

typedef struct tagNET_DVR_TEMP_HUMI
{ 
    DWORD    dwSize;            // 内容长度 && 版本（用于后期扩展）
    DWORD       dwChannel;         // 通道号，默认1
    int      iHumidity;         // 湿度，整数部分：val/1000，小数部分：val%1000
    int      iTemp;             // 温度，整数部分：val/1000，小数部分：val%100
    BYTE     byRes[8];          // 保留字节    
}NET_DVR_TEMP_HUMI, *LPNET_DVR_TEMP_HUMI;

typedef struct tagNET_DVR_ALARMSOUNDMODE_CFG
{
    DWORD    dwSize;      // 内容长度 && 版本（用于后期扩展）
    DWORD    dwChannel;     // 通道号，默认1
    DWORD    dwSoundMode;   // 报警模式: 0提醒模式；1警报模式；2静音模式
    BYTE     byRes[12];     // 保留字节
}NET_DVR_ALARMSOUNDMODE_CFG, *LPNET_DVR_ALARMSOUNDMODE_CFG;

typedef struct tagNET_DVR_SECURITYMODE
{ 
       DWORD    dwSize;// 内容长度 && 版本（用于后期扩展）
    DWORD    dwChannel;         // 通道号，默认1
    DWORD    dwMode;        // 安全模式: 1启用，码流加密；2不启用，码流不加密
    char     szRandCode[6];   //设备出厂的"随机验证码"
    BYTE     byRes[6];         // 保留字节
}NET_DVR_SECURITYMODE, *LPNET_DVR_SECURITYMODE;

typedef struct tagNET_DVR_MOBILE_CAPTUREPIC_CFG
{
    DWORD dwSize;
    BYTE  byPreviewFpsAdjMode;   /* 预览帧率调节模式:0-不调节，标准帧率预览,1-标准低帧率预览,2-根据GPS速度进行帧率调节 */
    BYTE  bySelPeccType;           /* 是否选择违章类型 */    
    BYTE  byOptHabit;             /* 取证操作习惯, 0:长按取证;1:短按两次取证 */    
    BYTE  byEnablePeccRec;      /* 1: 使能违章录像抓取, 0: 禁止违章录像抓取 */
    BYTE  byPicSize;                /*0=CIF,1=QCIF,2=D1,3=UXGA(1600x1200), 4=SVGA(800x600), 5=HD720p(1280x720),6-VGA，7-XVGA，8-HD900p，9-HD1080，10-2560*1920，11-1600*304，12-2048*1536，13-2448*2048,14-2448*1200，15-2448*800，16-XGA(1024*768)，17-SXGA(1280*1024),18-WD1(960*576/960*480),19-1080i */
    BYTE  byPicQuality;            /* 图片质量系数 0-最好 1-较好 2-一般 */
    BYTE  byRes[62];
}NET_DVR_MOBILE_CAPTUREPIC_CFG,*LPNET_DVR_MOBILE_CAPTUREPIC_CFG;

typedef struct tagNET_DVR_CMS_PARAM
{
    DWORD         dwSize;
    NET_DVR_IPADDR    struAddr;                    // 平台服务器IP
    WORD            wServerPort;                   // 平台服务器侦听端口，
    BYTE         bySeverProtocolType;            //平台协议类型 1-私有，2-Ehome
    BYTE            byStatus;                         //设备注册到该平台的状态，1-未注册，2-已注册
    BYTE         sDeviceId[NAME_LEN/*32*/];     //设备ID，由平台提供
    char         sPassWord[PASSWD_LEN];  //密码
    /********* IPC5.1.7 新增参数 Begin 2014-03-21***********/
    BYTE         sPlatformEhomeVersion[NAME_LEN];//平台EHOME协议版本
    /********* IPC5.1.7 新增参数 end 2014-03-21***********/
    BYTE         byNetWork;                //网络类型：0- 无意义，1-自动，2-有线网络优先，3-有线网络，4-3G网络（无线网络），5-有线网络1，6-有线网络2
    BYTE         byAddressType;            //0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
    BYTE         byProtocolVersion;            //协议版本 0 - 无意义, 1 – v2.0，2 – v4.0,3-v2.6
    BYTE            byRes1;
    BYTE         sDomainName[MAX_DOMAIN_NAME/*64*/]; //平台服务器域名，byAddressType为2时有效
    BYTE        byEnable;      //0-关闭，1-开启
    BYTE            byRes[139];          // 保留字节
}NET_DVR_CMS_PARAM, *LPNET_DVR_CMS_PARAM;

typedef struct tagNET_DVR_HEATMAP_COND
{
    DWORD   dwSize;
    DWORD   dwChannel; //通道号
    BYTE    byDetSceneID;//检测场景号[1],球机当前支持1个场景, IPC默认是0
    BYTE    byRes[63]; 
}NET_DVR_HEATMAP_COND, *LPNET_DVR_HEATMAP_COND;

typedef struct tagNET_DVR_HEATMAP_PARAM
{
    BYTE byTargetTrackEnable;//目标跟踪：0-关闭，1-开启，默认0-关闭
    BYTE bySensitivity;  //灵敏度参数，范围1-100，默认50
    BYTE byBackgroundUpdateRate;//背景更新速度：范围1-100，默认50
    BYTE bySceneChangeLevel;//场景变化等级：范围1-100，默认50
    BYTE byMinTargetSize;//最小目标尺寸：范围1-100，默认50
    /*
    0-	默认上传类型：COMM_UPLOAD_HEATMAP_RESULT；
    1-	上传类型：COMM_UPLOAD_HEATMAP_RESULT_PDC 和 COMM_UPLOAD_HEATMAP_RESULT_DURATION；
    */
    BYTE byUploadHeatMapResultType;
    BYTE byDayReport;
    BYTE byWeekReport;
    float fConfidence;//置信度[0.00,100.00]
    BYTE byMonthReport;
    BYTE byYearReport;
    BYTE byRes[6];
}NET_DVR_HEATMAP_PARAM, *LPNET_DVR_HEATMAP_PARAM;

typedef struct tagNET_DVR_HEATMAP_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //使能，是否开启
    BYTE  byRes[3];
    NET_VCA_POLYGON struRegion[MAX_HEATMAPREGION_NUM/*8*/];//区域范围
    NET_DVR_HEATMAP_PARAM  struHeatMap ; 
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    //布防时间
    NET_DVR_SCHEDTIME struAlarmSched[MAX_DAYS/*7*/][MAX_TIMESEGMENT_V30/*8*/]; 
    BYTE  byRes1[512];
}NET_DVR_HEATMAP_CFG, *LPNET_DVR_HEATMAP_CFG;

typedef struct tagNET_DVR_HEATMAP_RESULT
{
    DWORD  dwSize;
    NET_VCA_DEV_INFO  struDevInfo;/*设备信息*/
    NET_DVR_TIME_EX   struStartTime;/*开始时间*/
    NET_DVR_TIME_EX   struEndTime;/*结束时间*/
    DWORD  dwMaxHeatMapValue;//最大热度值
    DWORD  dwMinHeatMapValue;//最小热度值
    DWORD  dwTimeHeatMapValue;// (时间热度值)平均热度值
    WORD   wArrayLine;//图片像素点行值 
    WORD   wArrayColumn;//图片像素点列值 （当行列值为0的时候，像素点值内存信息不存在）
    BYTE*  pBuffer;  //热度图片像素点数据信息
    BYTE   byDetSceneID;//检测场景号[1],球机当前支持1个场景, IPC默认是0
    BYTE   byBrokenNetHttp;     //断网续传标志位，0-不是重传数据，1-重传数据
    WORD   wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    BYTE   byTimeDiffFlag;      /*时差字段是否有效  0-时差无效， 1-时差有效 */
    char   cStartTimeDifferenceH;      /*开始时间与UTC的时差（小时），-12 ... +14，+表示东区*/
    char   cStartTimeDifferenceM;      /*开始时间与UTC的时差（分钟），-30, 30, 45，+表示东区*/
    char   cStopTimeDifferenceH;        /*结束时间与UTC的时差（小时），-12 ... +14， +表示东区*/
    char   cStopTimeDifferenceM;       /*结束时间与UTC的时差（分钟），-30, 30, 45，+表示东区*/
    BYTE   byArrayUnitType; //矩阵单元数据类型（矩阵信息中每个像素点数据的数据类型），1-byte，2-short,4-int
    BYTE   byRes1[2];
    DWORD  dwTotalTime;//停留时间总和，单位秒，按人员停留时间报警时上传
    BYTE   byRes[112];
}NET_DVR_HEATMAP_RESULT,*LPNET_DVR_HEATMAP_RESULT;

typedef struct tagNET_DVR_HEATMAP_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel ;//通道号
    NET_DVR_TIME_EX   struStartTime;/*开始时间*/
    NET_DVR_TIME_EX   struEndTime;/*结束时间*/
    BYTE    byReportType;//0-无效值，1-日报表，2-周报表，3-月报表，4-年报表
    BYTE    byDetSceneID;//检测场景号[1],球机当前支持1个场景, IPC默认是0
    BYTE    byHeatMapInfoType;//0~获取空间热度图片方式，1~获取空间热度矩阵信息方式，2~获取空间热度图片和空间热度矩阵信息
    BYTE    byStatisticalModel;//统计模式  0s-保留（默认），1-停留时间，2-按人数统计）
    BYTE    byRes[124];
}NET_DVR_HEATMAP_QUERY_COND,*LPNET_DVR_HEATMAP_QUERY_COND;

typedef struct tagNET_DVR_HEATMAP_INFO
{
    DWORD  dwSize;
    NET_DVR_TIME_EX   struStartTime;/*间隔开始时间*/
    NET_DVR_TIME_EX   struEndTime;  /*间隔结束时间*/
    DWORD  dwHeatMapPicLen;         /*空间热度图片长度(当含有图片的时候，该字段为非0，没有图片的时候，该字段为0)*/
    BYTE*  pBuffer;                 //热度图片数据信息
    DWORD  dwTimeHeatMapValue ;     //时间热度值(含有空热度图的时候,该字段不需要传值)
    DWORD  dwHeatMapMaxValue;//检测区域最高热度点人员活动时间(s)(空间热度图时有效)
    DWORD  dwHeatMapMinValue;//检测区域最低热度点人员活动时间(s) (空间热度图时有效)
    WORD   wArrayLine;//图片像素点行值 （上传热度矩阵信息时生效）
    WORD   wArrayColumn;//图片像素点列值 （当行列值为0的时候，像素点值内存信息不存在）（上传热度矩阵信息时生效）
    BYTE*  pArrayBuffer;//热度矩阵数据信息（矩阵数据的透传，信息长度为wArrayLine* wArrayColumn*单元数据类型长度（例如byArrayUnitType为1表示为int型，这里就要乘以4个字节））
    BYTE   byArrayUnitType;//矩阵单元数据类型（矩阵信息中每个像素点数据的数据类型），0~byte，1~int；(当设备有返回矩阵信息时生效)
    BYTE   byRes[107];
}NET_DVR_HEATMAP_INFO,*LPNET_DVR_HEATMAP_INFO;

typedef struct tagNET_DVR_PDC_QUERY_COND
{
    DWORD   dwSize;
    DWORD   dwChannel; //通道号
    NET_DVR_TIME_EX   struStartTime; //开始时间
    NET_DVR_TIME_EX   struEndTime; //结束时间
    BYTE    byReportType; //0-无效值，1-日报表，2-周报表，3-月报表，4-年报表
    BYTE    byEnableProgramStatistics; //是否按节目统计，0-否，1-是
    BYTE    byTriggerPeopleCountingData;//触发客流统计数据的使能, 0-否，1-是
    BYTE    byMultiChannelSearch;//多通道查询使能, 0-否，1-是（pSearchChannel 、dwSearchChannelNum有效）
    DWORD   dwPlayScheduleNo; //按节目统计时关联的日程号
    BYTE    byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char cStartTimeDifferenceH;   //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    char cStartTimeDifferenceM;   //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    char cStopTimeDifferenceH;    //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    char cStopTimeDifferenceM;    //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    BYTE    byRes1[3];
    DWORD dwSearchChannelNum; //查询通道数目
    char*    pSearchChannel;     //查询通道号，大小为sizeof(DWORD)* dwSearchChannelNum
    BYTE    byChild;//只检测儿童, 0-否，1-是
    BYTE    byMinTimeInterva;// 最小时间间隔,0-无效，1-15分钟, 2-30分钟, 3一小时, 4-天, 5-周, 6-月
    BYTE	byStatisticType;//统计类型，0-无效值，1-进入人数，2-离开人数，3-全部,4-进入离开重复人数,5-人脸属性(需要下发具体支持的人脸属性),0-无效值表示不进行统计类型的条件查询，相当于保留字节。全部表示统计类型为进入和离开（不包括经过）。
    BYTE    byFaceExpression;//参见FACE_EXPRESSION_GROUP_ENUM
    BYTE    byGender;//性别，1-男，2-女，3-全部，0xff-算法支持，但是没有识别出来
    BYTE    byMask;//是否戴口罩 0-表示“未知”（算法不支持），1-不戴，2-戴，3-全部，0xff-算法支持的，但是没有识别出来
    BYTE    byAgeGroup;//年龄段，参见HUMAN_AGE_GROUP_ENUM
    BYTE    byGlasses;  /*是否带眼镜，0-未知，1-是，2-否，3-戴墨镜,  4 - 全部,  0xff-算法支持，但是没有识别出来*/
    BYTE    byRes[96];
}NET_DVR_PDC_QUERY_COND,*LPNET_DVR_PDC_QUERY_COND;

typedef struct tagNET_DVR_PROGRAM_INFO
{
    DWORD   dwProgramNo; //节目编号
    BYTE    sProgramName[NAME_LEN]; //节目名称
    BYTE    byRes[16];
}NET_DVR_PROGRAM_INFO, *LPNET_DVR_PROGRAM_INFO;

typedef struct tagNET_DVR_POSINFO_OVERLAY
{
    DWORD   dwSize;
    BYTE    byEnable;// Pos信息叠加，0-不叠加，1-叠加
    BYTE    byBackpackEnanble;//是否叠加背包信息是否叠加，0-不叠加，1-叠加
    BYTE    bySexEnanble;//是否叠加性别信息是否叠加，0-不叠加，1-叠加
    BYTE    byCarryEnanble;//是否叠加拎东西信息是否叠加，0-不叠加，1-叠加
    BYTE    byRideEnanble;//是否叠加骑车信息是否叠加，0-不叠加，1-叠加
    BYTE    byMaskEnanble;//是否叠加带口罩信息是否叠加，0-不叠加，1-叠加
    BYTE    byHatEnanble;//是否叠加戴帽子信息是否叠加，0-不叠加，1-叠加
    BYTE    bySleeveEnanble;//是否叠加长短袖情况，0-不叠加，1-叠加
    BYTE    byPantsTypeEnanble;//是否叠加裤子属性信息是否叠加，0-不叠加，1-叠加
    BYTE    byHairEnanble;//是否叠加长短发信息是否叠加，0-不叠加，1-叠加
    BYTE    byGlassesEnanble;//是否叠加戴眼镜信息是否叠加，0-不叠加，1-叠加
    BYTE    byAgeEnanble;//是否叠加年龄信息是否叠加，0-不叠加，1-叠加
    BYTE    byHeightEnanble;//是否叠加身高信息是否叠加，0-不叠加，1-叠加
    BYTE    byRes[511];
}NET_DVR_POSINFO_OVERLAY, *LPNET_DVR_POSINFO_OVERLAY;

typedef struct tagNET_DVR_PDC_RESULT
{
    DWORD   dwSize;
    NET_DVR_TIME_EX   struStartTime;/*开始时间*/
    NET_DVR_TIME_EX   struEndTime;/*结束时间*/
    DWORD   dwEnterNum;   //进入人数
    DWORD   dwLeaveNum;  //离开人数
    NET_DVR_PROGRAM_INFO struProgramInfo;        //节目信息
    DWORD   dwPeoplePassing;        //经过人数
    BYTE    byRes1[8];    //保留字节
    BYTE    byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char cStartTimeDifferenceH;   //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    char cStartTimeDifferenceM;   //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    char cStopTimeDifferenceH;    //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    char cStopTimeDifferenceM;    //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    BYTE     byRes3[3];    //保留字节
    DWORD    dwDuplicatePeople;        // 重复人数
    DWORD    dwExpressionUnknown;  //表情未知
    DWORD    dwPokerFace;  //表情中性
    DWORD    dwHappy; //表情高兴
    DWORD    dwSurprised; //表情惊讶
    DWORD    dwDisgusted; //表情厌恶
    DWORD    dwSad; //表情难过
    DWORD    dwAngry; //表情愤怒
    DWORD    dwContemptuous; //表情轻蔑
    DWORD    dwPanic; //表情害怕
    DWORD    dwGenderUnknown; //性别未知
    DWORD    dwFemale; //性别女
    DWORD    dwMale; //性别男
    DWORD    dwMaskUnknown; //面具未知
    DWORD    dwMaskYes; //戴面具
    DWORD    dwMaskNo; //不戴面具
    DWORD    dwGlassUnknown; //眼镜未知
    DWORD    dwGlassYes; //戴眼镜
    DWORD    dwGlassNo; //不戴眼镜
    DWORD    dwSunglasses; //墨镜
    DWORD    dwAgeGroupUnknown; //年龄段未知
    DWORD    dwChild;  //年龄段少年
    DWORD    dwYoung; //年龄段青年
    DWORD    dwMiddle; //年龄段中年
    DWORD    dwOld; //年龄段老年
    DWORD    dwInfant; //年龄段婴幼儿
    DWORD    dwKid; //年龄段儿童
    DWORD    dwTeenager; //年龄段青少年
    DWORD    dwPrime; //年龄段壮年
    DWORD    dwMiddleAged; //年龄段中老年
    BYTE     byRes[64];
}NET_DVR_PDC_RESULT, *LPNET_DVR_PDC_RESULT;

typedef struct tagNET_DVR_MOBILE_PLATE_RECOGCFG
{
    DWORD dwSize;
    BYTE  byDefaultCHN[MAX_CHJC_NUM]; /*设备运行省份的汉字简写  3 */ 
    BYTE  byTimeOsd;// 时间信息叠加 0 - 不叠加， 1- 叠加
    BYTE  byRecogResultOsd;//识别结果叠加  0 - 不叠加， 1- 叠加
    BYTE  byRecogHint;//识别成功提示 0 - 不提示， 1- 提示
    BYTE  byRecogDir;//识别方向 0: 正向, 1: 背向
    BYTE  byRecogEnv;//识别环境 0: 白天, 1: 晚上
    BYTE  byRecogPlateType;//0-小车牌识别，1-大车牌识别
    BYTE  byUploadPlate;//是否上传车牌 0 -不上传， 1-上传
    BYTE  byRes[62];
}NET_DVR_MOBILE_PLATE_RECOGCFG,*LPNET_DVR_MOBILE_PLATE_RECOGCFG;

typedef struct tagNET_DVR_MOBILE_RADAR_CFG
{    
    DWORD  dwSize;
    BYTE   byEnableRadar;   /* 0:不开启雷达  1:开启雷达 */    
    BYTE   byEnableAlarm;   /* 0:不开启报警  1:开启报警 */    
    WORD   wOverSpeed;    /* 范围为20~250 */    
    BYTE   bySpeedUnits;  /* 0:公里/小时   1:英里/小时 */    
    BYTE   bydirection;     /* 0:反向（雷达与车相向） 1:正向（雷达与车反向） */    
    BYTE   byMeasureMode;   /* 0:静态 (雷达状态)       1:动态 (雷达状态)*/    
    BYTE   byTargetType;    /* 0:最快(雷达测速车辆最快)  1:最近(雷达测速车辆最近)*/    
    BYTE   bySensitivity;  /* 灵敏度[0,100] */                          
    BYTE   byCaptureNum;   /* 抓拍张数[0,255] */                                
    BYTE   byUploadPlate;  /*是否上传超速抓拍图片 0-不上传，1-上传*/    
    BYTE   byRes[61];
}NET_DVR_MOBILE_RADAR_CFG,*LPNET_DVR_MOBILE_RADAR_CFG;

typedef struct tagNET_DVR_MOBILE_LOCALPLATECHK_CFG
{
    DWORD       dwSize;
    BYTE  byCheck;  /* 稽查任务是否进行禁止名单稽查 0-稽查，1-不稽查*/    
    BYTE  byCheckAlarm;/* 稽查成功报警 0-不报警，1-报警*/    
    BYTE  byCheckHint; /* 稽查成功提示 (软件提示) 0-不提示，1-提示*/    
    BYTE  byUploadUnlicensedCar; /*是否上传非法车信息 0-不上传，1-上传*/
    BYTE  byRes[64];
}NET_DVR_MOBILE_LOCALPLATECHK_CFG,*LPNET_DVR_MOBILE_LOCALPLATECHK_CFG;

typedef struct tagNET_DVR_VEHICLE_CHECK
{
    DWORD dwSize;
    DWORD  dwChannel;//通道号0xff - 全部通道（默认是1,代表一个通道）
    NET_DVR_PLATE_INFO  struPlateInfo; //车牌信息
    WORD  wIllegalType; //违章类型采用国标定义 （参考附件）
    BYTE  byRes[2];
    char sIllegalTypeInfo[128];// 违规类型信息（128）
    NET_DVR_TIME_V30  struIllegalTime;//违规时间
    BYTE  byIllegalVehicleNum;//车辆违法次数
    BYTE  byRes1[3];
    char sCustomInfo[64];//自定义信息
    BYTE  byRes2[128]; // 保留字节
}NET_DVR_VEHICLE_CHECK,*LPNET_DVR_VEHICLE_CHECK;



typedef struct tagNET_DVR_WIPER_CONTINUEWORK_PARAM
{
    BYTE  byWorkTimeInterval;//工作时间间隔（单位：秒）[2s~60s]
    BYTE  byRes[3];
    DWORD dwContinueWorkTime;//持续工作时间（单位：秒）[2min~24h]界面显示按分钟单位
    BYTE  byRes1[8];
}NET_DVR_WIPER_CONTINUEWORK_PARAM,*LPNET_DVR_WIPER_CONTINUEWORK_PARAM;


typedef struct tagNET_DVR_WIPERINFO_CFG
{
    DWORD dwSize;
    //雨刷工作模式
    //0-单次模式，1-持续模式（针对配置结构NET_DVR_ROTATE_OPERATE_PARAM），2-智能模式，0xff-关闭
    BYTE  byWiperWorkMode;
    BYTE  byRes1;
    WORD  wSensitivity;//降雨灵敏度
    BYTE  byRes[20];
    NET_DVR_WIPERMODE_PARAM_UNION ustruWiperModeParam;
}NET_DVR_WIPERINFO_CFG,*LPNET_DVR_WIPERINFO_CFG;

typedef struct tagNET_DVR_AUTOFOCUS_TESTCFG
{ 
       DWORD     dwSize;
    DWORD     dwChannel;            //通道号
    BYTE      byRes[24];            // 保留字节
}NET_DVR_AUTOFOCUS_TESTCFG,*LPNET_DVR_AUTOFOCUS_TESTCFG;

typedef struct tagNET_DVR_VIDEO_OUT_CFG
{    
    BYTE    byDisplayMode;        //显示模式，1-标准，2-冷色，3-暖色，0xff-自定义
    BYTE     byBrightnessLevel;     // 亮度值0-100
    BYTE    byContrastLevel;     // 对比度0-100
    BYTE     bySharpnessLevel;     // 锐度0-100
    BYTE     bySaturationLevel;     // 饱和度0-100
    BYTE     byHueLevel;         // 色调0-100
    BYTE    byImageMode;        // 图像模式，0-正常模式，1-夜模式1，2-夜模式2，3-夜模式3，4-日照模式1，5-日照模式2，6-日照模式3
    BYTE    byRes[5];            // 保留
}NET_DVR_VIDEO_OUT_CFG, *LPNET_DVR_VIDEO_OUT_CFG;

typedef struct tagNET_DVR_COLOR_TEMPERATURE_CFG
{    
    BYTE    byRed;                //红色， 0-100
    BYTE    byGreen;            //绿色， 0-100
    BYTE    byBlue;                //蓝色，0-100
    BYTE    byRedOffset;        //红色偏移，0-100
    BYTE    byGreenOffset;        //绿色偏移，0-100
    BYTE    byBlueOffset;        //蓝色偏移，0-100
    BYTE    byRes[6];        
}NET_DVR_COLOR_TEMPERATURE_CFG, *LPNET_DVR_COLOR_TEMPERATURE_CFG;

typedef struct tagNET_DVR_ADC_CFG
{    
    BYTE    byGainR;            //增益R， 0-100
    BYTE    byGainG;            //增益G，0-100
    BYTE    byGainB;            //增益B，0-100
    BYTE    byOffsetR;            //偏移量R，0-100
    BYTE    byOffsetG;            //偏移量G，0-100
    BYTE    byOffsetB;            //偏移量B，0-100
    BYTE    byRes[6];
}NET_DVR_ADC_CFG, *LPNET_DVR_ADC_CFG;

typedef struct tagNET_DVR_SCREEN_EDGE_CFG
{        
    BYTE    byEnable;            //是否启用屏幕边缘 0-不启用 1-启用
    BYTE    byLeftEdge;            //左边缘，0-100
    BYTE    byRightEdge;        //右边缘，0-100
    BYTE    byTopEdge;            //上边缘，0-100
    BYTE    byLowerEdge;        //下边缘，0-100
    BYTE    byRes[7];
}NET_DVR_SCREEN_EDGE_CFG, *LPNET_DVR_SCREEN_EDGE_CFG;

typedef struct tagNET_DVR_SCREEN_DISPLAY_CFG
{
    DWORD   dwSize;    
    BYTE    byCfgType;       /*设置的参数类型，获取时此参数无效，0-无效，1-背光参数，2-视频参数，3-色温参数，4-ADC参数，5-屏幕边缘参数*/
    BYTE    byBackLight;    //背光 0~100
    BYTE    byRes1[2];
    NET_DVR_VIDEO_OUT_CFG           struVideoOutCfg;     //视频参数（画面模式）
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTempCfg;  //色温参数
    NET_DVR_ADC_CFG               struAdcCfg;        //ADC参数
    NET_DVR_SCREEN_EDGE_CFG       struScreenEdgeCfg; //屏幕边缘参数
    BYTE byRes[32];
}NET_DVR_SCREEN_DISPLAY_CFG, *LPNET_DVR_SCREEN_DISPLAY_CFG;


typedef struct tagNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL
{
    DWORD       dwSize;    
    BYTE        byControlType;    //1-电源开，2-电源关，3-信号源，4-菜单，5-确定，6-上，7-下，8-左，9-右,  10-INFO, 11-返回上一层,12-数字按键,13-开关一体按键
    BYTE       byControlParam; //操作参数，操作类型为12时，表示按键值（0-9），其他操作时此参数无效
    BYTE        byRes[14];
}NET_DVR_SIMULATE_SCREEN_REMOTE_CTRL,*LPNET_DVR_SIMULATE_SCREEN_REMOTE_CTRL;

typedef struct tagNET_DVR_SCREEN_SIGNAL_CFG
{
    DWORD    dwSize;    
    BYTE     bySignalSourceType;    //输入源索引，见枚举 NET_DVR_CAM_MODE
    BYTE     byNoSignalPic;            //无信号画面模式，1-蓝屏，2-黑屏，3-LOGO画面
    BYTE     byRes[14];
}NET_DVR_SCREEN_SIGNAL_CFG, *LPNET_DVR_SCREEN_SIGNAL_CFG;

typedef struct tagNET_DVRSCREEN_SPLICE_CFG
{
    DWORD   dwSize;    
    BYTE    bySpliceIndex;            //自拼接屏号，0就是没有拼接，其他值表示自拼接屏的屏号。例如拼接0101~0202这4块屏，则这4块屏的bySpliceIndex必须相同，且非0.
    BYTE    bySpliceX;                //屏幕在自拼接屏中的行位置
    BYTE    bySpliceY;                //屏幕在自拼接屏中的列位置
    BYTE    byWidth;                //拼接规模宽，以屏幕为单位
    BYTE    byHeight;               //拼接规模高，以屏幕为单位
    BYTE    byRes[11];
}NET_DVR_SCREEN_SPLICE_CFG, *LPNET_DVR_SCREEN_SPLICE_CFG;

typedef struct tagNET_DVR_SCREEN_FAN_WORK_MODE_CFG
{
    DWORD       dwSize;    
    BYTE        byWorkMode;                 //1-常开，2-自动
    BYTE        byTemperatureLimitValue; //风扇开启的温度阀值，工作模式为自动时该参数有效。
    BYTE        byRes[14];
}NET_DVR_SCREEN_FAN_WORK_MODE_CFG, *LPNET_DVR_SCREEN_FAN_WORK_MODE_CFG;

typedef struct tagNET_DVR_SCREEN_VGA_CFG
{
    DWORD       dwSize;    
    BYTE        byEnableAutoAdjust;      //是否自动调整，0-否，1-是，当自动调整启用时以下参数无效
    BYTE        byHorizontalPosition;   //水平位置 0-100
    BYTE        byVerticalPosition;      //垂直位置 0-100
    BYTE        byClock;                //时钟 ，0-100
    BYTE        byPhase;                //相位，0-100
    BYTE        byRes[11];
}NET_DVR_SCREEN_VGA_CFG, *LPNET_DVR_SCREEN_VGA_CFG;

typedef struct tagNET_DVR_SCREEN_MENU_CFG
{
    DWORD       dwSize;    
    BYTE        byMenuLanguage; //语言，1-中文，2-英文
    BYTE        byTransparency; //透明度 0-不透明，1-低，2-中，3-高
    BYTE        byDuration;        //持续时间，0-常开，1-5秒，2-15秒，3-30秒
    BYTE        byRes[13];
}NET_DVR_SCREEN_MENU_CFG, *LPNET_DVR_SCREEN_MENU_CFG;

typedef struct tagNET_DVR_PIP_CFG
{
    DWORD   dwSize;    
    BYTE    byEnable;    //是否启用画中画 0-不启用 1-启用
    BYTE    bySubWindowSource;    //子画面信号源，参考枚举NET_DVR_CAM_MODE
    BYTE    bySubWindowBorderColor;    //子画面边框颜色， 1-蓝色，2-黑色
    BYTE    byRes1;
    NET_DVR_RECTCFG  struPosition;    //子画面位置，屏幕总大小为100*100
    BYTE    byRes2[12];
}NET_DVR_PIP_CFG, *LPNET_DVR_PIP_CFG;

typedef struct tagNET_DVR_DEFOG_LCD
{
    DWORD   dwSize;    
    BYTE    byDefogEnable;    //开启透雾开关，0~关闭，1~开启
    BYTE    byDefogModel;     //透雾模式，0~自动去雾，1~手动去雾
    BYTE    byDefogLevel;     //透雾强度等级，1-7个等级，默认等级为4。等级1为0.5；等级2为0.55；等级3为0.60；等级4为0.65；等级5为0.70；等级6为0.75；等级7为0.80。（去雾模式为手动去雾时，可配置去雾强度等级）
    BYTE    byRes[33];
}NET_DVR_DEFOG_LCD,*LPNET_DVR_DEFOG_LCD;

typedef struct tagNET_DVR_SCREEN_WALL_CFG
{
    DWORD    dwSize;
    BYTE    byEnable; //状态开关。0-为关闭；1-为开启
    BYTE    byRes[35];
}NET_DVR_SCREEN_WALL_CFG, *LPNET_DVR_SCREEN_WALL_CFG;

typedef struct tagNET_DVR_SCREEN_POS_CFG
{
    DWORD     dwSize;
    BYTE     byScreenRowNum;//屏幕行号。
    BYTE     byScreenColNum;//屏幕列号。
    BYTE     byRes[34];
}NET_DVR_SCREEN_POS_CFG, *LPNET_DVR_SCREEN_POS_CFG;

typedef struct tagNET_DVR_VIDEO_AUDIOIN_CFG
{
    DWORD     dwSize;     //结构体的长度
    DWORD     dwChanNo;   //视音频通道号， 绑定且启用后，被绑定的语音对讲通道则作为该通道的音频源
    BYTE      byEnable;   //是否启用语音对讲作为音频输入源 0-不启用 1-启用
    BYTE      byRes[31];          //保留
}NET_DVR_VIDEO_AUDIOIN_CFG, *LPNET_DVR_VIDEO_AUDIOIN_CFG;

typedef struct _NET_DVR_VCA_DETION_CFG
{    
    DWORD   dwSize; 
    BYTE    byEnable;//使能
    BYTE    byRes1[3];
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    NET_DVR_HANDLEEXCEPTION_V40 struHandleException;  //异常处理方式
    DWORD    dwMaxRelRecordChanNum ;  //报警触发的录象通道 数（只读）最大支持数量
    DWORD    dwRelRecordChanNum ;     //报警触发的录象通道 数 实际支持的数量
    DWORD    dwRelRecordChan[MAX_CHANNUM_V30/*64*/];//触发录像通道号
    BYTE    byEnablePreset[MAX_CHANNUM_V30];
    BYTE    byPresetNo[MAX_CHANNUM_V30];
    BYTE    byEnableCruise[MAX_CHANNUM_V30];
    BYTE    byCruiseNo[MAX_CHANNUM_V30];
    BYTE    byEnablePtzTrack[MAX_CHANNUM_V30];
    BYTE    byPTZTrack[MAX_CHANNUM_V30];
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30/*8*/]; //假日布防时间
    BYTE  byRes[224];;
}NET_DVR_VCA_DETION_CFG, *LPNET_DVR_VCA_DETION_CFG;

typedef struct tagNET_DVR_VCA_DETECTION_CFG_V40
{    
    DWORD dwSize;  //结构体大小
    BYTE    byEnable;//使能
    BYTE   byRes1[3];
    NET_DVR_SCHEDTIME    struAlarmSched[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD   dwHandleType;        //异常处理,异常处理方式的"或"结果   
    /*0x00: 无响应*/
    /*0x01: 监视器上警告*/
    /*0x02: 声音警告*/
    /*0x04: 上传中心*/
    /*0x08: 触发报警输出*/
    /*0x10: 触发JPRG抓图并上传Email*/
    /*0x20: 无线声光报警器联动*/
    /*0x40: 联动电子地图(目前只有PCNVR支持)*/
    /*0x200: 抓图并上传FTP*/ 
    DWORD   dwMaxRelAlarmOutChanNum ; //触发的报警输出通道数（只读）最大支持数量
    DWORD   dwRelAlarmOut[MAX_ALARMOUT_V40/*4128*/]; //* 实际触发的报警输出号，按值表示,采用紧凑型排列，从下标0开始顺序读取，如果遇到0xffffffff则后续无效*/ 
    /*触发的录像通道*/
    DWORD     dwMaxRecordChanNum;   //设备支持的最大关联录像通道数-只读
    DWORD     dwRelRecordChan[MAX_CHANNUM_V40/*512*/];     /* 实际触发录像通道，按值表示,采用紧凑型排列，从下标0开始顺序读取，如果遇到0xffffffff,则后续无效*/ 
    DWORD dwEnablePresetChanNum;  //当前已启用预置点的数目
    NET_DVR_PRESETCHAN_INFO struPresetChanInfo[MAX_CHANNUM_V40/*512*/]; //启用的预置点信息，当dwEnablePresetChanNum不为0时，数组下标0-(dwEnablePresetChanNum -1)有效，当为0时，表示未启用预置点
    BYTE byRes2[516];                    /*保留*/
    DWORD dwEnableCruiseChanNum;  //当前已启用巡航的通道数目
    NET_DVR_CRUISECHAN_INFO struCruiseChanInfo[MAX_CHANNUM_V40/*512*/]; //启用巡航功能通道的信息，当dwEnableCruiseChanNum不为0时，数组下标0-( dwEnableCruiseChanNum -1)有效，当为0时，表示未启用巡航
    DWORD dwEnablePtzTrackChanNum;  //当前已启云台轨迹通道数目
    NET_DVR_PTZTRACKCHAN_INFO struPtzTrackInfo[MAX_CHANNUM_V40/*512*/]; //调用云台轨迹的通道信息，当dwEnablePtzTrackChanNum不为0时，数组下标0-(dwEnablePresetChanNum -1)有效，当为0时，表示未启用云台轨迹
    NET_DVR_SCHEDTIME struHolidayTime[MAX_TIMESEGMENT_V30]; //假日布防时间
    BYTE    byRes[224];
}NET_DVR_VCA_DETECTION_CFG_V40, *LPNET_DVR_VCA_DETECTION_CFG_V40;

typedef struct tagNET_DVR_CLOUD_STORAGE_CFG
{
    DWORD    dwSize;  //结构体大小;
    BYTE     byEnableCS;  //开启云存储服务  0-关闭 1-开启
    BYTE     byRes[511];     //保留
} NET_DVR_CLOUD_STORAGE_CFG, *LPNET_DVR_CLOUD_STORAGE_CFG;

typedef struct tagNET_DVR_CHANS_RECORD_STATUS_CFG
{
    DWORD dwSize ; //结构体大小
    BYTE    byValid;       //是否有效
                           /*(只读)录像类型，0: 不在录像；1：在录像 2-空闲 
                           3-无连接 4-无输入视频 5-未加载 6-存档中 7-回传中 
    8-用户名或密码错 9-未验证,10-存档中和录像中 11-录像回传中和录像中*/
    BYTE    byRecord;     
    DWORD   dwRelatedHD;  //关联磁盘
    BYTE    byOffLineRecord;  //断网录像功能 0-关闭 1-开启
    BYTE     byRes[63];        //保留字节
}NET_DVR_CHAN_RECORD_STATUS_CFG, *LPNET_DVR_CHAN_RECORD_STATUS_CFG;

typedef struct  tagNET_DVR_UPLOAD_RECORD_INFO
{
    DWORD             dwSize;   
    DWORD             dwRecordType; //录像类型  0- 定时录像，1- 移动侦测录像，2- 报警录像，3- 报警或移动侦测录像，4- 报警和移动侦测录像， 5- 命令触发，6- 手动录像，7- 震动报警，8- 环境触发报警，9- 智能报警，10- 回传录像
    BYTE              sCameraID[MAX_CAMERAID_LEN]; //camera id;
    NET_DVR_TIME_EX   struStartTime;  //录像开始时间
    NET_DVR_TIME_EX   struStopTime;  //录像结束时间 
    DWORD             dwStoragePoolID; //存储池ID
    BYTE              byFormatType ;     //封装类型：1-裸流，2-RTP封装，3-PS封装，4-TS封装，5-私有，6-FLV，7-ASF，8-3GP，9-RTP+PS（国标：GB28181），0xff-无效
    BYTE              byVideoEncType ;       //视频编码类型：0-私有264，1-标准h264，2-标准mpeg4，7-M-JPEG，8-MPEG2，0xfe- 自动（和源一致），0xff-无效 
    BYTE              byAudioEncType;  //音频编码类型：0-G722，1-G711_U，2-G711_A，5-MP2L2，6-G726，7-AAC，0xfe- 自动（和源一致），0xff-无效 
    BYTE   	          byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char       cStartTimeDifferenceH;   //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    char       cStartTimeDifferenceM;   //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    char       cStopTimeDifferenceH;    //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    char       cStopTimeDifferenceM;    //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    BYTE              byRes[120];
}NET_DVR_UPLOAD_RECORD_INFO,*LPNET_DVR_UPLOAD_RECORD_INFO;

typedef struct tagNET_DVR_IOOUT_COND
{
    DWORD dwSize;
    BYTE  bySyncOutputNo;//同步输出号(0-F1,1-F2,2-F3)
    BYTE  byRes[63];
}NET_DVR_IOOUT_COND,*LPNET_DVR_IOOUT_COND;

typedef struct tagNET_DVR_IOOUT_CFG
{
    DWORD  dwSize;
    BYTE   byWorkMode;// 0-报警输出,1-频闪灯(默认)
    BYTE   byRes1[3];
    union
    {
        BYTE    byUnionLen[128];
        struct
        {
            BYTE   byDefaultState;//默认状态 0-低电平(默认)，1-高电平
            BYTE   byWorkState;//生效状态 0-低电平(默认),1-高电平,2-脉冲
            BYTE   byFreqMulti;//倍频，数值范围[1,15]
            BYTE   byDutyRatio;//占空比，[0,40%]
            BYTE   byRes[3];
            BYTE   byFlashLightEnable;    //设置闪光灯时间使能:0-关;1-开
            NET_DVR_SCHEDTIME  struFlashLightTime;//启用闪光灯时间
            BYTE   byRes1[116];
        }struStrobeLamp;    // 频闪灯 时有效
    }uWorkModeInfo;
    BYTE   byRes2[128];
}NET_DVR_IOOUT_CFG,*LPNET_DVR_IOOUT_CFG;

typedef struct tagNET_DVR_SIGNAL_SYNCCFG
{
    DWORD  dwSize;
    WORD   wPhase;//相位(0~360)
    BYTE   byLineLock;//电源同步 0-否，1-是
    BYTE   byRes[125];
}NET_DVR_SIGNAL_SYNCCFG,*LPNET_DVR_SIGNAL_SYNCCFG;


typedef struct tagNET_DVR_ALARM_RELATE_COND
{
    DWORD  dwSize;
    /*
    0表示移动侦测， 
    1表示视频遮挡， 
    2表示视频丢失， 
    3表示PIR报警， 
    4表示无线报警， 
    5表示呼救报警， 
    6表示智能抓图， 
    7表示人脸侦测， 
    8表示越界侦测侦测， 
    9表示区域入侵侦测， 
    10表示场景变更侦测，
    11 表示异常侦测，
    0xff 表示报警输入
    */
    BYTE  byAlarmType; 
    //联动动作 0-无效,1-抓图上传FTP,2-Jpeg抓图上传Email
    BYTE  byRelateActType;
    BYTE  byRes[2];
    //报警输入号或者通道号或者无线编号
    //(当byAlarmType ==0xff时,dwChannel表示的是报警输入号)
    //(当byAlarmType ==4时,dwChannel表示的是无线编号)
    DWORD  dwChannel;
    BYTE  byRes1[64];
}NET_DVR_ALARM_RELATE_COND,*LPNET_DVR_ALARM_RELATE_COND;

typedef struct tagNET_DVR_ALARM_RELATE_CFG
{
    DWORD   dwSize;
    DWORD   dwMaxRelateChanNum ; //触发的报警关联通道数（只读）最大支持数量
    //dwRelateChan的初始值是0xffffffff;数组内填写是实际的通道号;
    DWORD   dwRelateChan[MAX_CHANNUM_V40/*512*/];
    BYTE    byRes1[256];
}NET_DVR_ALARM_RELATE_CFG,*LPNET_DVR_ALARM_RELATE_CFG;

typedef struct tagNET_DVR_PTZ_BASICPARAMCFG
{
    DWORD  dwSize;
    BYTE   byProportionalPan; //启用比例变倍配置 0-否，1-是
    BYTE   byPresetFreezing; //启用预置点视频冻结 0-否，1-是
    BYTE   byPresetSpeed;//预置点速度等级 1--8，默认4
    BYTE   byKeyboardCtrlSpeed;//手控速度等级0-低,1-中,2-高
    BYTE   byAutoScanSpeed;//扫描速度等级：1--40，默认28
    BYTE   byZoomingSpeed;//变倍速度：1--3，默认3
    BYTE   byManualControlSpeed;//手控速度模式：0-兼容，1-行人，2-非机动车，3-机动车，4-自适应
    BYTE   byPTZMotionTrack;//启用运动跟踪（锁定云台操作） 0-默认（开启），1-关闭
    BYTE   byRes[124]; 
}NET_DVR_PTZ_BASICPARAMCFG,*LPNET_DVR_PTZ_BASICPARAMCFG;

typedef struct tagNET_DVR_PTZ_OSDCFG
{
    DWORD  dwSize;
    BYTE   byZoomStatus; //镜头倍数显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
    BYTE   byPtStatus;    //方位角显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
    BYTE   byPresetStatus;//预置点标题显示：1-2秒、2-5秒、3-10秒、0xff-常关、0-常开，默认2秒
    BYTE   byPositionDisplayFormat;//方位角显示格式 0-按照PT显示(例 P179|T-02)，1-按照方位显示(SE123|T-02)
    BYTE   byRes[124]; 
}NET_DVR_PTZ_OSDCFG,*LPNET_DVR_PTZ_OSDCFG;

typedef struct tagNET_DVR_PTZ_POWEROFFMEMCFG
{
    DWORD  dwSize;
    BYTE   byResumeTimePoint; //掉电记忆模式：Oxff-禁用、1-30秒、2-60秒、3-300秒、4-600秒，默认30秒
    BYTE   byRes[127]; 
}NET_DVR_PTZ_POWEROFFMEMCFG,*LPNET_DVR_PTZ_POWEROFFMEMCFG;

typedef struct tagNET_DVR_PTZ_LIMITCOND
{
    DWORD  dwSize;
    DWORD  dwChan; //通道号
    BYTE   byLimitMode; //限位模式 0-保留，1-键控限位，2-扫描限位
    BYTE   byRes[63]; 
}NET_DVR_PTZ_LIMITCOND, *LPNET_DVR_PTZ_LIMITCOND;

typedef struct tagNET_DVR_PTZ_LIMITCFG
{
    DWORD  dwSize;
    BYTE   byEnable;//启用使能，0-否，1-是
    BYTE   byLimitStatus; //限位状态 0-未限位，1-已限位（不可编辑） 
    BYTE   byRes[122]; 
}NET_DVR_PTZ_LIMITCFG,*LPNET_DVR_PTZ_LIMITCFG;

typedef struct tagNET_DVR_PTZ_LIMITCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//通道号
    BYTE   byLimitMode; //限位模式 0-保留，1-键控限位，2-扫描限位
    BYTE   byWorkMode ;//0-设置，1-清除
    BYTE   byRes[122]; 
}NET_DVR_PTZ_LIMITCTRL,*LPNET_DVR_PTZ_LIMITCTRL;

typedef struct tagNET_DVR_PTZ_LOCKCFG
{
    DWORD   dwSize;
    BYTE   byWorkMode ;//云台锁定控制 0-解锁，1-锁定
    BYTE   byRes[123]; 
}NET_DVR_PTZ_LOCKCFG,*LPNET_DVR_PTZ_LOCKCFG;

typedef struct tagNET_DVR_PTZLOCKINFO_COND
{
    DWORD   dwSize;
    DWORD   dwChannel ;//通道号
    BYTE    byRes[64];
}NET_DVR_PTZLOCKINFO_COND,*LPNET_DVR_PTZLOCKINFO_COND;

typedef struct tagNET_DVR_PTZLOCKINFO
{
    DWORD   dwSize;
    DWORD   dwRemainingSec ;//剩余秒数
    BYTE    byRes[128];    //保留字节
}NET_DVR_PTZLOCKINFO, *LPNET_DVR_PTZLOCKINFO;

typedef struct tagNET_DVR_CRUISEPOINT_COND
{
    DWORD  dwSize;
    DWORD  dwChan;//通道号
    WORD   wRouteNo;//巡航路径号
    BYTE   byRes[30];
}NET_DVR_CRUISEPOINT_COND,*LPNET_DVR_CRUISEPOINT_COND;




typedef struct tagNET_DVR_TEST_VERSION_HEAD
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
}NET_DVR_TEST_VERSION_HEAD, *LPNET_DVR_TEST_VERSION_HEAD;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V1
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
}NET_DVR_TEST_VERSION_HEAD_V1, *LPNET_DVR_TEST_VERSION_HEAD_V1;

typedef struct tagNET_DVR_TEST_VERSION_HEAD_V2
{
    DWORD        dwSize;
    DWORD        dwParam1;
    BYTE         byParam2;
    BYTE         byRes[31];
    DWORD        dwParam1_1;
    BYTE         byParam1_2;
    BYTE         byRes1[31];
    DWORD        dwParam2_1;
    BYTE         byParam2_2;
    BYTE         byRes2[31];
}NET_DVR_TEST_VERSION_HEAD_V2, *LPNET_DVR_TEST_VERSION_HEAD_V2;

typedef struct tagNET_DVR_VIDEOWALLDISPLAYMODE
{
    DWORD dwSize;
    BYTE  byEnable;//使能
    BYTE  byRes1[3];
    NET_DVR_RECTCFG_EX struRect;//坐标范围，依据基准坐标计算出支持的拼控模式
    BYTE  sName[NAME_LEN]; //电视墙名称
    BYTE  byRes2[100];
}NET_DVR_VIDEOWALLDISPLAYMODE, *LPNET_DVR_VIDEOWALLDISPLAYMODE;

typedef struct tagNET_DVR_DISPLAYPARAM
{
    DWORD dwDisplayNo;//显示输出号
    BYTE  byDispChanType;/*输出连接模式,1-BNC，2-VGA，3-HDMI，4-DVI，5-SDI, 6-FIBER, \
                                    7-RGB, 8-YPrPb, 9-VGA/HDMI/DVI自适应，10-3GSDI,11-VGA/DVI自适应，12-HDBaseT,13-HDTVI, 14-TVI，0xff-无效*/

    BYTE  byRes[11];
}NET_DVR_DISPLAYPARAM,*LPNET_DVR_DISPLAYPARAM;

typedef struct tagNET_DVR_DISPLAYCFG
{
    DWORD  dwSize;
    NET_DVR_DISPLAYPARAM struDisplayParam[MAX_DISPLAY_NUM/*512*/] ;
    BYTE  byRes[128];
}NET_DVR_DISPLAYCFG,*LPNET_DVR_DISPLAYCFG;

typedef struct tagNET_DVR_VIDEOWALLDISPLAYPOSITION
{
    DWORD   dwSize;
    BYTE    byEnable;
    BYTE    byCoordinateType;//坐标类型。0-基准坐标，1-实际坐标
    BYTE    byRes1[2];
    //墙号,1字节墙号（高字节，对于合码器设备，为合码通道号）+3字节保留
    DWORD    dwVideoWallNo; 
    DWORD   dwDisplayNo;//显示输出号
    //坐标须为基准坐标的整数倍（1920*1920），宽度和高度值不用设置，即为基准值
    NET_DVR_RECTCFG_EX struRectCfg;
    BYTE    byRes2[64];
}NET_DVR_VIDEOWALLDISPLAYPOSITION,*LPNET_DVR_VIDEOWALLDISPLAYPOSITION;

typedef struct tagNET_DVR_VIDEOWALLWINDOWPOSITION
{
    DWORD dwSize;
    BYTE  byEnable;  //窗口使能,0-不使能，1-使能 
    BYTE  byWndOperateMode;  //窗口操作模式，0-统一坐标，1-分辨率坐标
    BYTE  byRes1[6];
    DWORD dwWindowNo;//窗口号
    DWORD dwLayerIndex;//窗口相对应的图层号，图层号到最大即置顶，置顶操作
    NET_DVR_RECTCFG_EX struRect; //目的窗口统一坐标(相对显示墙)，获取或按统一坐标设置时有效
    NET_DVR_RECTCFG_EX struResolution; //目的窗口分辨率坐标，获取或按分辨率坐标设置有效
   DWORD dwXCoordinate; //LED区域左上角X坐标（统一坐标），获取或按分辨率坐标设置有效
   DWORD dwYCoordinate; //LED区域左上角Y坐标（统一坐标），获取或按分辨率坐标设置有效
   BYTE  byRes2[36];
}NET_DVR_VIDEOWALLWINDOWPOSITION,*LPNET_DVR_VIDEOWALLWINDOWPOSITION;

typedef struct tagNET_DVR_VIDEO_WALL_INFO
{
    DWORD dwSize;
    //窗口号：1字节墙号（对于合码器设备，为合码通道号）+1字节保留+2字节窗口号
    DWORD    dwWindowNo; 
    DWORD   dwSceneNo;//场景号
    DWORD   dwDestWallNo; //目的墙号
    DWORD   dwDestSceneNo;//目的场景号
    BYTE    byRes[12];
}NET_DVR_VIDEO_WALL_INFO,*LPNET_DVR_VIDEO_WALL_INFO;

typedef struct tagNET_DVR_VIRTUALLED_PARAM 
{
    DWORD   dwSize;
    BYTE    byEnable; //使能
    BYTE    byDispMode; //显示模式，1-透明，2-半透明，3-覆盖
    BYTE    byWndOperateMode; //窗口操作模式，0-统一坐标，1-分辨率坐标
    BYTE    byType; //虚拟LED类型，0-文本，1-时间
    BYTE    byDirection; //虚拟LED方向，0-水平方向，1-垂直方向
    BYTE    byTimeType; //时间类型，byType为1时有效，0-无效，1-只显示时间，2-显示日期和时间
    BYTE    byDateFormat; //日期显示格式，byTimeType为2时有效
    //0-无效，1-XXXX-XX-XX(年月日)，2-XX-XX-XXXX(月日年)，3-XX-XX-XXXX(日月年)，4-XXXX年XX月XX日，5-XX月XX日XXXX年，6-XX日XX月XXXX年
    BYTE    byTimeFormat; //时间显示格式，byTimeType不为零时有效
    //0-无效，1-H:MM:SS，2-HH:MM:SS
    NET_DVR_RGB_COLOR   struContentColor; //字体颜色
    NET_DVR_RGB_COLOR   struBackColor; //背景颜色
    NET_DVR_RECTCFG_EX  struRect;
    DWORD   dwContentNum; //文本内容长度，byType为0时有效
    BYTE    byLedContent[MAX_LEDCONTENT_NUM/*512*/]; //文本内容，byType为0时有效
    BYTE    byMoveMode; //移动模式，1-普通；2-平滑；3-静止
    BYTE    byFontSize; //字体大小，1-1倍，2-2倍，3-4倍
    BYTE    byMoveDirection; //移动方向，0-默认（从左到右），1-从左到右，2-从右到左，3-从上到下，4-从下到上，动态虚拟LED时有效
    BYTE    byMoveSpeed; //移动速度，1-速度1，2-速度2，动态虚拟LED时有效
    NET_DVR_RECTCFG_EX struResolution; //目的窗口分辨率坐标，获取或按分辨率坐标设置有效
    DWORD   dwXCoordinate; //LED区域左上角X坐标（统一坐标），获取或按分辨率坐标设置有效
    DWORD   dwYCoordinate; //LED区域左上角Y坐标（统一坐标），获取或按分辨率坐标设置有效
    BYTE    byHourFormat; //时间制式，byTimeType不为零时有效，0-无效，1-12小时制，2-24小时制
    BYTE    byAMFormat; //AM格式，byHourFormat为1时有效，0-无效，1-AM，2-上午
    BYTE    byPMFormat; //PM格式，byHourFormat为1时有效，0-无效，1-PM，2-下午
    BYTE    byAlignmentX; //水平对齐方式，byDirection为0时有效，0-无效，1-左对齐，2-居中对齐，3-右对齐
    BYTE    byAlignmentY; //垂直对齐方式，byDirection为1时有效，0-无效，1-顶端对齐，2-居中对齐，3-底端对齐
    BYTE    byFontType; //字体类型，0-默认，1-宋体，2-黑体，3-楷体，255-自定义
    BYTE    byRes2[90];
}NET_DVR_VIRTUALLED_PARAM,*LPNET_DVR_VIRTUALLED_PARAM;

typedef struct tagNET_DVR_IMAGE_CUT_MODE
{
    DWORD dwSize;
    BYTE  byCutMode;  //图像切割模式，1-4:3,2-16:9
    BYTE  byRes[31];
}NET_DVR_IMAGE_CUT_MODE,*LPNET_DVR_IMAGE_CUT_MODE;

typedef struct tagNET_DVR_USING_SERIALPORT
{ 
    DWORD  dwSize ;
    DWORD  dwSerialPort; //当前使用串口号
    BYTE byProtocolType; //串口协议类型，1-LCD-S1 , 2-LCD-S2 , 3-LCD-L1 ， 4-LCD-DLP， 5-LCD-S3 , 6-LCD-D20，7-LCD-L2,8-LCD-Z1，9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+ 
    BYTE byRes[31];
}NET_DVR_USING_SERIALPORT,*LPNET_DVR_USING_SERIALPORT;

typedef struct tagNET_DVR_VIDEOWALLSCENECFG
{
    DWORD dwSize;
    BYTE  sSceneName[NAME_LEN];//场景名称
    BYTE  byEnable;//场景是否有效 1-有效，0-无效
    BYTE  bySceneIndex;     //场景号，只能获取。获取所有场景时使用该参数
    BYTE  byRes [78];
}NET_DVR_VIDEOWALLSCENECFG, *LPNET_DVR_VIDEOWALLSCENECFG;

typedef struct tagNET_DVR_SCENE_CONTROL_INFO
{
    DWORD dwSize;
    NET_DVR_VIDEO_WALL_INFO struVideoWallInfo; //电视墙信息
    DWORD dwCmd; //场景控制命令，1-场景模式切换（如果要切换的是当前场景，则不进行切换），2-初始化场景（将此场景的配置清空，如果是当前场景，则同时对当前场景进行清屏操作），3-强制切换（无论是否是当前场景，强制切换），4-保存当前模式到某场景 5-删除场景 ,6-场景复制
    BYTE  byRes[4];
}NET_DVR_SCENE_CONTROL_INFO, *LPNET_DVR_SCENE_CONTROL_INFO;

typedef struct tagNET_DVR_SHOW_CONTROL_INFO
{ 
    DWORD dwSize;
    DWORD dwDisplayNo;  //显示输出口号，0xffffffff表示对所用输出口进行操作
    BYTE  byEnable;     //使能显示，0-不显示，1-显示
    BYTE  byChanType;   //显示的通道类型，1-显示通道号，2-虚拟屏号
    BYTE  byRes1[2];
    DWORD dwWallNo; //墙号，1字节墙号（高位）+3字节保留，显示屏幕序号时有效
    BYTE byRes2[56];
}NET_DVR_SHOW_CONTROL_INFO,*LPNET_DVR_SHOW_CONTROL_INFO;

typedef struct tagNET_DVR_BUF_INFO
{
    void*   pBuf;    //缓冲区指针
    DWORD   nLen;    //缓冲区长度
}NET_DVR_BUF_INFO, *LPNET_DVR_BUF_INFO;

typedef struct tagNET_DVR_IN_PARAM
{
    NET_DVR_BUF_INFO struCondBuf;            //条件缓冲区
    NET_DVR_BUF_INFO struInParamBuf;         //参数缓冲区
    DWORD  dwRecvTimeout;      //接收数据超时时间，单位：ms,置0采用接口默认超时
    BYTE   byRes[32];
}NET_DVR_IN_PARAM,LPNET_DVR_IN_PARAM;

typedef struct tagNET_DVR_OUT_PARAM
{
    NET_DVR_BUF_INFO struOutBuf;            //输出参数缓冲区
    void*  lpStatusList;       //状态缓冲区    
    BYTE   byRes[32];
}NET_DVR_OUT_PARAM,LPNET_DVR_OUT_PARAM;

typedef struct tagNET_DVR_AUDIO_CHAN_INFO
{
    DWORD dwSize;    
    DWORD dwChannel;   //音频通道号组合（1字节设备号+1字节子板号+2字节音频通道号）
    BYTE  byRes[48];   
}NET_DVR_AUDIO_CHAN_INFO, *LPNET_DVR_AUDIO_CHAN_INFO; 

typedef struct tagNET_DVR_AUDIO_CHAN_CFG
{
    DWORD         dwSize;
    BYTE          sChanName[NAME_LEN]; //音频通道名称
    BYTE          byEnable; //音频是否开启， 0-关， 1-开
    BYTE          byAudioSwitchType; //音频切换方式，1-按前端源方式，2-按窗口解码源方式 
    BYTE          byRes[2]; 
    NET_DVR_PU_STREAM_CFG_V41 struAudioSrcInfo;  //音频源信息 byAudioSwitchType为1时有效
    DWORD         dwWindowNo; //子窗口号（1字节墙号+1字节子窗口号+2字节窗口号），byAudioSwitchType为2时有效
    BYTE          byRes2[28]; 
}NET_DVR_AUDIO_CHAN_CFG, *LPNET_DVR_AUDIO_CHAN_CFG;

typedef struct tagNET_DVR_MAINBOARD_SERIAL_CFG
{
    DWORD dwSize;
    BYTE bySerialWorkMode; //串口工作模式，1-RS484,2-RS232
    BYTE byFunType; //串口功能，1-键盘控制，2-屏幕控制，3-透明通道模式 4-PTZ控制  5-矩阵控制 6-控制台
    BYTE byDataBit;// 数据有几位 0－5位，1－6位，2－7位，3－8位;
    BYTE byStopBit;// 停止位 0－1位，1－2位;
    DWORD dwBaudRate;//波特率0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;
    BYTE byParity;// 校验 0－无校验，1－奇校验，2－偶校验;
    BYTE byFlowcontrol;// 0－无，1－软流控,2-硬流控
    WORD wProtocol;//串口协议，不同串口功能对应串口协议不一样
    BYTE byVariable ;  //串口是否可变，1-不可变  2-可变 （只获取）
    BYTE byGateWayEnable; //是否用于网关，0-不用于网关，!0用于网关
    BYTE byRes[30];
}NET_DVR_MAINBOARD_SERIAL_CFG, *LPNET_DVR_MAINBOARD_SERIAL_CFG;

typedef struct tagNET_DVR_SUBBOARD_INFO
{
    DWORD      dwSize;   
    BYTE       byBoardType;    //类型，0-主板，1-DVI-I输入，2-YPbPr输入，3-BNC输入，4-SDI输入， 5-DVI双链路输入， 6-普通解码板输入， 7-DVI-I输出， 8-SDI输出, 9-增强型解码板输入，10-DP输入，11-HDTVI输入，12-HDBaseT输出，13-HDMI输入，14-HDBaseT，15-DVI-T输入，16-HDMI输出，17-HDMI-HD输入 ,18-HDMI-UHD输入 , 19-DP_UHD输入,0xff-未知类型 //类型，0-主板，1-DVI-I输入，2-YPbPr输入，3-BNC输入，4-SDI输入， 5-DVI双链路输入， 6-普通解码板输入， 7-DVI-I输出， 8-SDI输出, 9-增强型解码板输入，10-DP输入，11-HDTVI输入，12-HDBaseT输出，13-HDMI输入，14-HDBaseT，15-DVI-T输入，16-HDMI输出，17-HDMI-HD输入 ,18-HDMI-UHD输入 , 19-DP_UHD输入,0xff-未知类型 
    BYTE       byInterfaceNum;  //接口数
    BYTE       byStatus;        //状态，0-异常， 1-正常
	BYTE       bySyncStatus;   // 超高清板同步状态，0-未启用同步， 1-启用同步  
    DWORD      dwSlotNo;       //所在槽位号 
    BYTE       byRes2[32];  
}NET_DVR_SUBBOARD_INFO, *LPNET_DVR_SUBBOARD_INFO; 

typedef struct tagNET_DVR_DEVICE_SUBBOARD_INFO
{
    DWORD     dwSize;
    BYTE      byBackBoardType;  //背板类型， 1-4U， 2-8U， 3-13U, 0xff-未知类型
    BYTE      bySoltNum;        //槽位数目
    BYTE      byBoardNum;   //有效数目
    BYTE      byRes1[1];
    NET_DVR_SUBBOARD_INFO struSubBoadInfo[MAX_SUBBOARD_NUM]; //前byBoardNum项有效 
    BYTE       byRes2[32]; 
}NET_DVR_DEVICE_SUBBOARD_INFO, *LPNET_DVR_DEVICE_SUBBOARD_INFO; 

typedef struct tagNET_DVR_DEVICE_BOARD_EXCEPINFO
{
    DWORD       dwSize;
    BYTE         byExceptNum;         //异常项数
    BYTE        byRes1[3];               
    BYTE        byMajor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //主类型
    WORD        wMinor[MAX_SINGLE_BOARD_EXCEPTION_NUM];    //次类型
    BYTE        byRes2[32]; 
}NET_DVR_DEVICE_BOARD_EXCEPINFO, *LPNET_DVR_DEVICE_BOARD_EXCEPINFO;

typedef struct tagNET_DVR_LINEARSCAN
{
    DWORD   dwSize;
    DWORD   dwChan;           //通道号
    BYTE    byLinearScanType; //限位类型，0-保留,1-左边界设置,2-右边界设置
    BYTE    byRes[63]; 
}NET_DVR_LINEARSCAN, *LPNET_DVR_LINEARSCAN;

typedef struct tagNET_DVR_STREAM_ATTACHINFO_CFG
{
    DWORD dwSize;          //结构体大小
    BYTE  byStreamWithVca; //码流中叠加智能信息，可供进行后检索。0-不叠加,1-叠加
    BYTE  byRes[127];      //保留
}NET_DVR_STREAM_ATTACHINFO_CFG,*LPNET_DVR_STREAM_ATTACHINFO_CFG;

typedef struct tagNET_DVR_SUBSYSTEM_NETCFG
{
    DWORD  dwSize;    
    BYTE   byDefaultRoute;  //默认路由，0表示struEtherNet[0]，1表示struEtherNet[1]
    BYTE   byNetworkCardNum;      //设备实际可配置的网卡数目
    BYTE   byRes1[2]; //保留
    NET_DVR_ETHERNET_MULTI struEtherNet [MAX_NETWORK_CARD]; //以太网口
    BYTE   byRes2[128];
}NET_DVR_SUBSYSTEM_NETCFG, *LPNET_DVR_SUBSYSTEM_NETCFG;

typedef struct tagNET_DVR_CLEARCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//通道号
    BYTE   byAllPreset; //清除所有的预置点：0-否,1-是
    BYTE   byAllPatrols; //清除所有的巡航路径：0-否,1-是
    BYTE   byAllPatterms; //清除所有的花样扫描：0-否,1-是
    BYTE   byAllPrivacyMasks; //清除所有的隐私块：0-否,1-是
    BYTE   byAllPTZLimited; //清除所有的限位设置：0-否,1-是
    BYTE   byAllScheduledTasks; //清除所有的定时任务：0-否,1-是
    BYTE   byAllParkAction; //清除所有的守望：0-否,1-是
    BYTE   byRes[125]; 
}NET_DVR_CLEARCTRL, *LPNET_DVR_CLEARCTRL;

typedef struct tagNET_DVR_PTZ_PRIORITIZECFG
{
    DWORD  dwSize;
    BYTE   byPTZPrioritize; //云台优先：0-Rs485，1-网络，默认网络
    BYTE   byRes[3];
    DWORD   dwDelay; //延时：2---200秒
    BYTE   byRes1[124]; 
}NET_DVR_PTZ_PRIORITIZECFG, *LPNET_DVR_PTZ_PRIORITIZECFG;

typedef struct tagNET_DVR_INITIALPOSITIONCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//通道号
    BYTE   byWorkMode ;//0-设置，1-清除
    BYTE   byRes[127]; 
}NET_DVR_INITIALPOSITIONCTRL,*LPNET_DVR_INITIALPOSITIONCTRL;

typedef struct tagNET_DVR_PRIVACY_MASKS_COND
{
    DWORD  dwSize;
    DWORD  dwChan; //通道号
    BYTE   byRegionalID; //区域ID号 1～24
    //删除当前ID对应的隐私遮蔽信息 0-保留，1-删除 （WriteOnly）
    BYTE   byDelPrivacyMaskCfg;
    BYTE   byRes[62]; 
}NET_DVR_PRIVACY_MASKS_COND, *LPNET_DVR_PRIVACY_MASKS_COND;

typedef struct tagNET_DVR_PRIVACY_MASKS_CFG
{
    DWORD  dwSize;
    BYTE   byEnable;//是否启用 0-否，1-是
    //隐私遮蔽区域配置参数是否显示  0-否，1-是 （ReadOnly）
    BYTE   byPrivacyMaskCfgEnable;
    BYTE   byColorType; //0-保留,1-灰、2-红、3-绿、4-蓝、5-橙、6-黄、0xff-马赛克
    BYTE   byActiveZoomRatio;//屏蔽倍率：1--100
    char  sPrivacyMaskName[NAME_LEN/*32*/];//遮挡区域名称，只使用16个字节
    NET_VCA_POLYGON  struRegion;//区域范围
    //当前区域坐标是否有效 0-否，1-是 （针对单个区域设置区域坐标信息，和单场景下的多区域设置区域坐标信息）
    BYTE   byCurrentRegionEnable;
    //当前倍率使用字段 0- byActiveZoomRatio ;1- fActiveZoomRatio(支持能力节点curActiveZoomRatioType)
    BYTE   byCurZoomRatio ;
    BYTE   byRes[2];
    float  fActiveZoomRatio; //屏蔽倍率(精确到小数点1位)：[1.0-100.0]
    BYTE   byRes1[120];
}NET_DVR_PRIVACY_MASKS_CFG, *LPNET_DVR_PRIVACY_MASKS_CFG;

typedef struct tagNET_DVR_PRIVACY_MASKS_ENABLECFG
{
    DWORD  dwSize;
    BYTE   byEnable;//启用使能，0-否，1-是
    BYTE   byRes[127]; 
}NET_DVR_PRIVACY_MASKS_ENABLECFG,*LPNET_DVR_PRIVACY_MASKS_ENABLECFG;

typedef struct tagNET_DVR_SMARTTRACKCFG
{
    DWORD dwSize;
    BYTE  byEnable;//启动使能 0-否，1-是
    BYTE  byRes[3];
    DWORD dwDuration;//持续时间：0--300秒，默认300秒
    BYTE  byRes1[124];
}NET_DVR_SMARTTRACKCFG,*LPNET_DVR_SMARTTRACKCFG;

typedef struct tagNET_DVR_ZOOMRATIOCTRL
{
    DWORD  dwSize;
    DWORD  dwChan;//通道号
    BYTE   byRes[128]; 
}NET_DVR_ZOOMRATIOCTRL,*LPNET_DVR_ZOOMRATIOCTRL;

typedef struct tagNET_DVR_DIAL_SWITCH_CFG
{
    DWORD  dwSize;
    DWORD  dwSwitchState;//拨号开关状态
    BYTE   byRes[28]; 
}NET_DVR_DIAL_SWITCH_CFG,*LPNET_DVR_DIAL_SWITCH_CFG;

typedef struct tagNET_ALARM_RECORDFILE_LOSS //录像丢失报警子结构 
{
    NET_DVR_TIME_EX struInspectStart; //巡检开始时间
    NET_DVR_TIME_EX struInspectEnd;   //巡检结束时间
    NET_DVR_IPADDR  struIP;           //录像丢失对应通道的IP地址 
    DWORD  dwChanNo;                //通道号
    DWORD  dwIDIndex;                //编码器ID
    BYTE   sName[STREAM_ID_LEN];       //编码器名称 
    NET_DVR_TIME_EX struLossStartTime; //录像丢失开始时间
    NET_DVR_TIME_EX struLossEndTime;   //录像丢失结束时间
    DWORD  dwLostNum;                 //录像丢失个数 0xffffffff表示全部丢失
    BYTE   byRes[240];
} NET_ALARM_RECORDFILE_LOSS, *LPNET_ALARM_RECORDFILE_LOSS;

typedef struct tagNET_ALARM_STREAM_EXCEPTION //取流异常报警  子结构 
{
    NET_DVR_IPADDR  struIP;           //发生视频异常通道的IP地址 
    DWORD  dwChanNo;                //通道号
    DWORD  dwIDIndex;                //编码器ID
    BYTE   sName[STREAM_ID_LEN];       //编码器名称 
    BYTE   byExceptionCase;           //异常原因，0-数据写入异常 1-网络接收异常
    BYTE   byRes[307];                //保留
} NET_ALARM_STREAM_EXCEPTION, *LPNET_ALARM_STREAM_EXCEPTION;

typedef struct tagNET_ALARM_RESOURCE_USAGE  //资源使用报警 子结构
{ 
    BYTE   byLevel;    //使用情况，严重程度递增： 0-正常，1-一级告警上限 2-二级告警上限 3-三级告警上限  
    BYTE   byRes[491]; //保留
}NET_ALARM_RESOURCE_USAGE, *LPNET_ALARM_RESOURCE_USAGE;

typedef struct tagNET_ALARM_RECORD_EXCEPTION //录像异常报警 子结构
{ 
    BYTE    byReason;    //异常原因 0-录像卷满 1-录像卷异常 2-无可用lun卷
    BYTE    byRes1[3];   //保留
    BYTE    sVolumeName[MAX_VOLUMENAME_LEN];
    DWORD  dwVolumeID;  //录像卷ID（硬盘号）
    BYTE    byRes[452];  //保留
}NET_ALARM_RECORD_EXCEPTION, *LPNET_ALARM_RECORD_EXCEPTION;


typedef struct tagNET_DVR_ALARMINFO_DEV_V40
{
    DWORD            dwAlarmType; //报警子类型 0-编码器(通道)信号量报警；1-私有卷二损坏；2- NVR服务退出；3-编码器状态异常；4-系统时钟异常；5-录像卷剩余容量过低；6-编码器(通道)移动侦测报警；
    //7-编码器(通道)遮挡报警; 8-录像丢失报警; 9-视频实时监测报警; 10-资源使用率告警; 11- CVR自动修复异常， 12-录像异常
    NET_DVR_TIME     struTime;
    NET_ALARM_CVR_SUBINFO_UNION  uSubAlarmInfo; //报警信息子结构 报警类型为8,9,10,11,12时该联合体有效
    BYTE             byRes[256];
    DWORD            dwNumber; //可变数据个数
    WORD             *pNO; //当类型为0、3、6、7时，可能会有通道号；当类型为5时，可能会有磁盘号。可表示的值范围为0~65535    
}NET_DVR_ALARMINFO_DEV_V40, *LPNET_DVR_ALARMINFO_DEV_V40;

typedef struct tagNET_DVR_CONTROL_START_CFG //一键开始控制信息
{
    BYTE    byUseDefine; //使用自定义， 0-使用默认，1-使用自定义
    BYTE    byRes1;
    WORD    wCourseIndex; //课程索引
    BYTE    byRes[128];
}NET_DVR_CONTROL_START_CFG, *LPNET_DVR_CONTROL_START_CFG;

typedef struct tagNET_DVR_CONTROL_DELAY_CFG//一键延长录像控制信息
{
    BYTE    byUseDefine; //使用自定义， 0-使用默认，1-使用自定义
    BYTE    byRes1;
    WORD    wDelayTime; //录像延长时间<继续录像时间以此为准>，单位s
    BYTE    byRes[128];
}NET_DVR_CONTROL_DELAY_CFG, *LPNET_DVR_CONTROL_DELAY_CFG;


typedef struct  tagNET_DVR_RECORDING_CONTROL_CFG_
{
    DWORD    dwSize;        //结构体大小
    WORD    wCmdType;    //控制命令类型，0-一键开始，1-一键结束，2-一键暂停，3-一键恢复，4-一键延长,5-一键开始屏蔽 6-一键停止屏蔽
    BYTE    byRes1 [2]; //保留
    NET_DVR_CONTROL_INFO_UNION struControlInfo; //控制信息，具体使用结合控制命令类型
    BYTE    byRes[256]; //保留
}NET_DVR_RECORDING_CONTROL_CFG, *LPNET_DVR_RECORDING_CONTROL_CFG;

typedef struct tagNET_DVR_RECORDING_HOST_CFG
{
    DWORD     dwSize;  //结构体大小
    DWORD    dwOneKeyDelayTime; //一键本地延迟时间  录像继续录的时间 单位 S
    BYTE     byDirectedMode; //导播模式，0-自动导播，1手动导播，2-半自动导播
    BYTE     byClassroomType;    //教室类型，0-无效，1-主教室，2-从教室
    BYTE     byCourseDataStorageEnabled;//课堂数据统计是否存储在硬盘, 0-不存储，1-存储
    BYTE     byElectronicEnlargeMode;//是否使用电子放大导播, 0-不使用，1-使用
    BYTE     byRes[124];     //保留
}NET_DVR_RECORDING_HOST_CFG, *LPNET_DVR_RECORDING_HOST_CFG;

typedef struct tagNET_DVR_STATISTIC_DATA_COND
{
    DWORD        dwSize;
    DWORD        dwTypeTarget; //统计对象类型，详见TARGET_TYPE
    NET_DVR_TIME   struStartTime;//开始统计时间
    NET_DVR_TIME   struStopTime;//结束统计时间
    BYTE        byRes[280];
}NET_DVR_STATISTIC_DATA_COND, *LPNET_DVR_STATISTIC_DATA_COND;

typedef struct tagNET_DVR_STATISTIC_DATA_CFG
{
    DWORD        dwSize;
    DWORD        dwTypeTarget; //统计对象类型，详见TARGET_TYPE
    NET_DVR_TIME   struStartTime;//事件开始时间
    NET_DVR_TIME   struStopTime;//事件结束时间
    BYTE        byRes[300];
}NET_DVR_STATISTIC_DATA_CFG, *LPNET_DVR_STATISTIC_DATA_CFG;

typedef struct tagNET_DVR_AUTO_TRACK_CFG
{
    DWORD  dwSize;   //结构体大小
    NET_DVR_DIRECT_CONNECT_CHAN_INFO struSDIInfo[MAX_CHANNUM_V30] ; 
    //SDI通道，设备端实际的流返回形式是模拟通道，而控制前端使用IP通道。
    BYTE   byCameraType[MAX_CHANNUM_V30];     //通道接入的相机类型，值为 0-无意义，1-老师跟踪，2-学生跟踪，3-老师全景，4-学生全景，5-多媒体，6-教师定位,7-学生定位,8-板书定位,9-板书相机, 0xff-未接入
    BYTE   byRes[64];     //保留
}NET_DVR_AUTO_TRACK_CFG, *LPNET_DVR_AUTO_TRACK_CFG; 

typedef struct tagNET_DVR_PUBLISH_FTP_CFG
{
    BYTE                byProtocolType;    //协议类型 0-FTP，1-SFTP
    BYTE                byRes1;     //保留
    WORD                wFTPPort;  //端口
    BYTE                   byAddress[MAX_DOMAIN_NAME];  //IP或者域名,需要设备解析
    //解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    BYTE                szUserName[NAME_LEN/*32*/];        //用户名<加密>
    BYTE                szPassWord[PASSWD_LEN/*16*/];        //密码<加密>
    BYTE                szCustomDir[128];    //发布目录,支持目录结构
    BYTE                byRes[12]; //保留
} NET_DVR_PUBLISH_FTP_CFG, *LPNET_DVR_PUBLISH_FTP_CFG;

typedef struct tagNET_DVR_PUBLISH_HTTP_CFG
{
    BYTE   strUrl[256]; //发布的URL地址信息
}NET_DVR_PUBLISH_HTTP_CFG, *LPNET_DVR_PUBLISH_HTTP_CFG;

typedef struct tagNET_DVR_PUBLISH_FTP_CFG_DIR
{
    BYTE                byProtocolType;    //协议类型 0-FTP，1-SFTP
    BYTE                byRes1;     //保留
    WORD                wFTPPort;  //端口
    BYTE               byAddress[MAX_DOMAIN_NAME];  //IP或者域名,需要设备解析
    //解析方式为有字母存在且有'.'则认为是域名,否则为IP地址
    BYTE                szUserName[NAME_LEN/*32*/];        //用户名<加密>
    BYTE                szPassWord[PASSWD_LEN/*16*/];        //密码<加密>
    BYTE                  byDirLevel;                     /*0 = 不使用目录结构，直接保存在根目录,1 = 使用1级目录,2=使用2级目录*/
    BYTE                byTopDirMode;         /* 一级目录，0x1 = 使用设备名,0x2 = 使用设备号,0x3 = 使用设备ip地址                     0xff=使用自定义*/
    BYTE                bySubDirMode;         /*二级目录，0x1=使用通道名称,0x2=使用通道号，0x3=使用课程名称，0x4-使用授课日期，0xff-使用自定义*/
    BYTE              byRes2;
    BYTE               byTopCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*自定义一级目录*/
    BYTE               bySubCustomDir[MAX_CUSTOMDIR_LEN/*32*/];/*自定义二级目录*/   
    BYTE                byRes[72]; //保留
}NET_DVR_PUBLISH_FTP_CFG_DIR, *LPNET_DVR_PUBLISH_FTP_CFG_DIR;


typedef struct  tagNET_DVR_CHAN_RECORD_PUBLISH_INFO //通道录像发布信息
{
    BYTE    byPublish; //是否发布，0-不发布， 1-发布
    BYTE    byRes1[3];
    DWORD  dwStreamType;   //一键发布码流类型，按位表示
    //&0x1-表示主码流 
    //&0x2-表示子码流
    //&0x4-表示码流三
    BYTE    byRes[12];     //保留
}NET_DVR_RECORD_PUBLISH_INFO,*LPNET_DVR_RECORD_PUBLISH_INFO;

typedef struct tagNET_DVR_PUBLISH_CFG
{
    DWORD  dwSize;  //结构体大小
    BYTE   byPublishType;    //发布方式，0-http,1-ftp,2-Dir FTP
    BYTE   byRes1[3]; //保留
    NET_DVR_PUBLISH_ADD_UNION struPublishAddr;  //一键发布地址信息
    NET_DVR_RECORD_PUBLISH_INFO  struChanPublish[MAX_CHANNUM_V30]; //通道录像发布信息 struChanPublis[0]表示通道1对应录像发布信息
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //导播通道录像发布信息
    BYTE                  byUploadTime;      //是否启动定时ftp上传功能 0-无意义，1-不启动，2-启用
    BYTE                byTimerMode;      //0-无意义，1-按课表定时上传最近一节课的录像，2-按时间点方式上传前24小时录像
    BYTE                  byUploadStartHour;    //按时间定时上传起始时间  时
    BYTE                byUoploadStartMin;    //按时间定时上传 开始时间 分
    BYTE                byRes[1020]; //保留
}NET_DVR_PUBLISH_CFG, *LPNET_DVR_PUBLISH_CFG;

typedef struct tagNET_DVR_ONEKEY_PUBLISH_CFG
{
    DWORD  dwSize;  //结构体大小
    BYTE  byUseDefine;  //使用自定义  0-使用默认发布配置信息，1-使用自定义发布配置信息
    BYTE  byRes1[3];
    NET_DVR_RECORD_PUBLISH_INFO struChanPublish[MAX_CHANNUM_V30]; //通道录像发布信息 struChanPublis[0]表示通道1对应录像发布信息
    NET_DVR_RECORD_PUBLISH_INFO struDirectChanPublish; //导播通道录像发布信息
    NET_DVR_TIME_EX  struStartTime;  //课程开始时间
    NET_DVR_TIME_EX  struEndTime;   //课程结束时间
    BYTE    bySchedulePublish;  //是否按课表发布，0不按课表发布1按课表发布
    BYTE    sFileName[COURSE_NAME_LEN/*32*/];  //发布文件名称
    BYTE    byRes[31];
}NET_DVR_ONEKEY_PUBLISH_CFG,*LPNET_DVR_ONEKEY_PUBLISH_CFG;

typedef struct  tagNET_DVR_COURSE_RECORDING_INFO
{
    DWORD    dwSize;  
    char    sCourseName[COURSE_NAME_LEN/*32*/];  
    char    sInstructorName[INSTRUCTOR_NAME_LEN/*16*/]; 
    char    sCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE    byIndex;        //课程索引
    BYTE    byRes[15];
}NET_DVR_COURSE_RECORDING_INFO, *LPNET_DVR_COURSE_RECORDING_INFO;

typedef struct tagNET_DVR_EACH_LESSON_INFO_
{
    NET_DVR_SCHEDTIME struSchedTime ;   //课程起止时间
    WORD  wCourseIndex ;        //课程索引
    WORD  wSessionIndex ;        //节次
    BYTE   byRes[4] ;            //保留
}NET_DVR_EACH_LESSON_INFO,*LPNET_DVR_EACH_LESSON_INFO ;

typedef struct tagNET_DVR_CURRICULUM_CFG  //课表计划 按年月日配置
{ 
    DWORD  dwSize ;         //结构体大小
    NET_DVR_EACH_LESSON_INFO struLessonInfo[MAX_TIMESEGMENT_V40/*16*/] ; //每节课信息
    BYTE   byRes[256] ; //保留
}NET_DVR_CURRICULUM_CFG, *LPNET_DVR_CURRICULUM_CFG;


typedef struct _NET_DVR_PPT_DETECT_CFG_
{
    DWORD    dwSize ;
    BYTE    byEnablePPTDetect; //是否启用PPT检测
    BYTE    byPptDetLevel; //灵敏度
    BYTE    byEnablePartScreen; //是否配置部分区域
    BYTE    byRes1;
    WORD    wX; //区域坐标
    WORD    wY;
    WORD    wWidth;
    WORD    wHeight;
    DWORD   dwChangePixelNum;//像素点检测阈值[0,1000](ps : 一幅图像有多少像素在变化)
    BYTE    byRes[28];
}NET_DVR_PPT_DETECT_CFG,*LPNET_DVR_PPT_DETECT_CFG;

typedef struct _NET_DVR_SCREEN_SWITCH_
{
    DWORD dwSize;
    BYTE  byRes[64];     //保留
}NET_DVR_SCREEN_SWITCH, *LPNET_DVR_SCREEN_SWITCH;

typedef struct _NET_DVR_PPT_CHANNEL_CFG_
{
    DWORD    dwSize ;
    BYTE    byChan[MAX_PPT_CHAN]; 
    BYTE    byRes[32];
}NET_DVR_PPT_CHANNEL_CFG,*LPNET_DVR_PPT_CHANNEL_CFG;

typedef struct tagNET_DVR_BACKUP_RECORD_INFO
{
    BYTE   byEnable;   //是否启用
    BYTE   byRes[11];
    //备份码流类型，按位表示
    //&0x1-表示主码流 
    //&0x2-表示子码流
    //&0x4-表示码流三
    DWORD  dwStreamType;  
}NET_DVR_BACKUP_RECORD_INFO, *LPNET_DVR_BACKUP_RECORD_INFO;

typedef struct tagNET_DVR_BACKUP_RECORD_PARAM
{
    DWORD     dwSize ;
    NET_DVR_BACKUP_RECORD_INFO   struChanBackUp[MAX_CHANNUM_V30/*64*/];  //需要备份的通道,数组下标对应相应的通道号
    NET_DVR_BACKUP_RECORD_INFO   struDirectedChanBackUp;  //导播通道备份信息
    BYTE    byRes[256];      // 保留字节 
}NET_DVR_BACKUP_RECORD_PARAM, *LPNET_DVR_BACKUP_RECORD_PARAM;

typedef struct tagNET_DVR_INDOOR_UNIT_DEVICEID
{
    SHORT wFloorNumber;   //层号
    WORD  wRoomNumber;    //房间号
    WORD  wDevIndex;      //室内机编号，0-10
    BYTE  byRes[122];     //保留
}NET_DVR_INDOOR_UNIT_DEVICEID,*LPNET_DVR_INDOOR_UNIT_DEVICEID;

typedef struct tagNET_DVR_OUTDOOR_UNIT_DEVICEID
{
    WORD wPeriod;  //期号, 范围[0,9]
    WORD wBuildingNumber; //楼号
    WORD wUnitNumber;  //单元号
    SHORT wFloorNumber;  //层号
    WORD wDevIndex;  //门口机序号，每一层中门口机的序号唯一，从0开始
    BYTE byRes[118]; //保留
}NET_DVR_OUTDOOR_UNIT_DEVICEID,*LPNET_DVR_OUTDOOR_UNIT_DEVICEID;

typedef struct tagNET_DVR_OUTDOOR_FENCE_DEVICEID
{
    WORD wPeriod;  //期号, 范围[0,9]
    WORD wDevIndex;  //围墙机序号，每一层中门口机的序号唯一，从0开始
    BYTE byRes[124]; //保留
}NET_DVR_OUTDOOR_FENCE_DEVICEID,*LPNET_DVR_OUTDOOR_FENCE_DEVICEID;

typedef struct tagNET_DVR_MANAGE_UNIT_DEVICEID
{
    WORD wPeriod; //期号，范围[0,9]
    WORD wDevIndex;  //管理机序号，每一期中管理机的序号唯一,从0开始
    BYTE byRes[124]; //保留
}NET_DVR_MANAGE_UNIT_DEVICEID,*LPNET_DVR_MANAGE_UNIT_DEVICEID;


typedef struct tagNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG
{   
    DWORD dwSize; //结构体大小
    BYTE byUnitType;   //设备类型，1-门口机，2-管理机 4-围墙机,5-别墅门口机，6-二次确认机，7-门禁智能设备,8-4200客户端, 9-APP,10-交互终端，11-IPC设备，12-解码器设备,13-模拟室内机
    BYTE byIsAutoReg;  //是否自动注册，0-否，1-是
    BYTE byRes1[2];  //保留
    NET_DVR_VIDEO_INTERCOM_UNIT_DEVICEID_UNION uVideoIntercomUnit; //取值参考byUnitType
    BYTE byRes2[128]; //保留
}NET_DVR_VIDEO_INTERCOM_DEVICEID_CFG,*LPNET_DVR_VIDEO_INTERCOM_DEVICEID_CFG;


typedef struct tagNET_DVR_PRIVILEGE_PASSWORD_CFG
{   
    DWORD  dwSize; //结构体大小
    BYTE   byPwdType; //密码类型，参考PRIVILEGE_PASSWORD_TYPE_ENUM
    BYTE   byRes1[3];  //保留
    BYTE   byOldPassword[PASSWD_LEN];  //旧密码
    BYTE   byNewPassword[PASSWD_LEN]; //新密码
    BYTE   byRes2[128]; //保留
}NET_DVR_PRIVILEGE_PASSWORD_CFG,*LPNET_DVR_PRIVILEGE_PASSWORD_CFG;

typedef struct tagNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime; //最大监视时间，范围[10,60]秒
    DWORD dwMaxRingTime; //最大振铃时间，范围[15,60]秒
    DWORD dwCallForwardingTime; //呼叫转移超时时间，范围[0,20]秒
    DWORD dwRingDurationTime; //响铃超时时间，范围[30,60]秒，默认30秒
    BYTE  byRes[112];//保留
}NET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_INDOOR_UNIT_OPERATION_TIME_CFG;

typedef struct tagNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMessageTime; //最大留言时间，范围[30,60]秒
    DWORD dwMaxTalkTime; //最大通话时间，范围[90,120]秒
    BYTE   byRes[120]; //保留
}NET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_OUTDOOR_UNIT_OPERATION_TIME_CFG;

typedef struct tagNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG
{
    DWORD dwMaxMonitoringTime;  //最大监视时间，范围[10,60]秒
    DWORD dwMaxRingTime;        //最大振铃时间，范围[15,60]秒
    DWORD dwMaxTalkTime;        //最大通话时间，单位s
    BYTE  byRes[116];           //保留
}NET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG,*LPNET_DVR_MANAGE_UNIT_OPERATION_TIME_CFG;


typedef struct tagNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG
{   
    DWORD dwSize; //结构体大小
    BYTE byUnitType; //设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机
    BYTE byRes1[3];  //保留
    NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_UNION uVideoIntercomUnit; //取值参考byUnitType
    BYTE byRes2[128]; //保留
}NET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG,*LPNET_DVR_VIDEO_INTERCOM_OPERATION_TIME_CFG;

typedef struct tagNET_DVR_INDOOR_UNIT_RELATEDEV
{
    NET_DVR_IPADDR struOutdoorUnit; //主门口机IP
    NET_DVR_IPADDR struManageUnit;  //管理机IP
    NET_DVR_IPADDR struSIPServer;    //SIP服务器IP
    NET_DVR_IPADDR struAgainUnit;   //二次确认机IP
    BYTE             byOutDoorType;  //主门口机类型，0保留，1-主单元门口机，2-主别墅门口机
    BYTE             byOutInConnectMode;  //门口机与室内分机组网模式：1-门口机与室内分机同一局域网,2-门口机与室内分机不同局域网；
    BYTE             byIndoorConnectMode;  //室内主机与室内分机组网模式：1-通过无线网卡、2-通过有线网卡；
    BYTE           byRes1;
    NET_DVR_IPADDR struIndoorUnit; //室内主机IP
    BYTE  byManageCenterID[32];  //标准sip模式下使用，管理中心ID，支持数字，字母，@和.
    BYTE           byRes[268];       //保留
}NET_DVR_INDOOR_UNIT_RELATEDEV,*LPNET_DVR_INDOOR_UNIT_RELATEDEV;

typedef struct tagNET_DVR_OUTDOOR_UNIT_RELATEDEV
{   
    NET_DVR_IPADDR struMainOutdoorUnit; //主门口机IP，副门口机时有效
    NET_DVR_IPADDR struManageUnit;   //管理机IP
    NET_DVR_IPADDR struSIPServer;     //SIP服务器IP，副门口机时无效
    BYTE           byManageCenterID[32];   //标准sip模式下使用，管理中心ID，支持数字，字母，@和.
    BYTE           byRes[560];       //保留
}NET_DVR_OUTDOOR_UNIT_RELATEDEV,*LPNET_DVR_OUTDOOR_UNIT_RELATEDEV;

typedef struct tagNET_DVR_AGAIN_RELATEDEV
{   
    NET_DVR_IPADDR   struSIPServer;       //SIP服务器IP
    NET_DVR_IPADDR   struCenterAddr;      //中心平台IP
    WORD             wCenterPort;         //中心平台端口
    BYTE             byRes1[2];
    NET_DVR_IPADDR   struIndoorUnit; //室内主机IP
    NET_DVR_IPADDR struAgainAddr; //主二次确认机IP（副二次确认机配置该字段）
    BYTE             byRes[444];//保留
}NET_DVR_AGAIN_RELATEDEV,*LPNET_DVR_AGAIN_RELATEDEV;

typedef struct tagNET_DVR_MANAGE_UNIT_RELATEDEV
{
    NET_DVR_IPADDR  struSIPServer;     //SIP服务器IP
    BYTE   byRes[880];       //保留
}NET_DVR_MANAGE_UNIT_RELATEDEV,*LPNET_DVR_MANAGE_UNIT_RELATEDEV;


typedef struct tagNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG
{   
    DWORD dwSize; //结构体大小
    BYTE byUnitType; //设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机，7-门禁智能设备
    BYTE byRes1[3];  //保留
    NET_DVR_VIDEO_INTERCOM_UNIT_RELATEDEV_UNION uVideoIntercomUnit; //取值参考byUnitType
    BYTE byRes2[128]; //保留
}NET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG,*LPNET_DVR_VIDEO_INTERCOM_RELATEDEV_CFG;

typedef struct tagNET_DVR_CONTROL_GATEWAY
{
    DWORD dwSize; //结构体大小
    DWORD dwGatewayIndex; //门禁序号，从1开始
    BYTE   byCommand; //操作命令，0-关闭，1-打开，2-常开（通道状态），3-恢复（普通状态）
    BYTE   byLockType; //锁类型，0-普通（以前默认都为0）,1-智能锁
    WORD    wLockID; //锁ID，从1开始（远程开门口机锁时，0表示门口机本机控制器上接的锁、1表示外接控制器上接的锁）
    BYTE   byControlSrc[NAME_LEN]; //操作发起源信息
    BYTE   byControlType; //开锁类型，1-监视，2-通话
    BYTE  byRes3[3];
    BYTE  byPassword[PASSWD_LEN];       //锁密码，当byLockType为智能锁时有效
    BYTE  byRes2[108]; //保留
}NET_DVR_CONTROL_GATEWAY,*LPNET_DVR_CONTROL_GATEWAY;

typedef struct tagNET_DVR_NOTICE_PIC
{
    BYTE*  pPicData; //图片指针
    DWORD dwPicDataLen; //图片数据长度
    BYTE   byRes[32]; //保留
}NET_DVR_NOTICE_PIC,*LPNET_DVR_NOTICE_PIC;

typedef struct tagNET_DVR_NOTICE_DATA
{
    DWORD dwSize; //结构体大小
    NET_DVR_TIME_EX struTime; //公告时间
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //公告编号
    BYTE   byNoticeTheme[MAX_NOTICE_THEME_LEN];//公告主题
    BYTE   byNoticeDetail[MAX_NOTICE_DETAIL_LEN]; //公告详情
    BYTE   byLevel; //公告等级，1-广告类信息；2-物业信息；3-报警类信息;4-通知类信息
    BYTE   byPicNum; //公告图片数量
    BYTE   byRes1[2]; //保留    
    NET_DVR_NOTICE_PIC struNoticePic[MAX_NOTICE_PIC_NUM]; //公告图片
    BYTE   byRes2[128]; //保留
}NET_DVR_NOTICE_DATA,*LPNET_DVR_NOTICE_DATA;

typedef struct tagNET_DVR_OPERATION_AUTH
{
    DWORD dwSize; //结构体大小
    BYTE   byPassword[PASSWD_LEN]; //验证密码
    BYTE   byRes[128]; //保留
}NET_DVR_OPERATION_AUTH,*LPNET_DVR_OPERATION_AUTH;


typedef struct tagNET_DVR_UNLOCK_RECORD_INFO
{
    BYTE   byUnlockType; //开锁方式，参考UNLOCK_TYPE_ENUM
    BYTE   byRes1[3]; //保留
    BYTE   byControlSrc[NAME_LEN]; //操作发起源信息，刷卡开锁时为卡号，蓝牙开锁时为萤石的APP账号，二维码开锁时为访客的手机号，其余情况下为设备编号
    DWORD  dwPicDataLen; //图片数据长度
    BYTE*  pImage; //图片指针
    DWORD  dwCardUserID; //持卡人ID
    SHORT  nFloorNumber;//刷卡开锁时有效，为楼层号
    WORD   wRoomNumber; //操作发起源附加信息，刷卡开锁时有效，为房间号，
    WORD   wLockID; //（对于门口机，0-表示本机控制器上接的锁、1-表示外接控制器上接的锁）
    BYTE   byRes2[2];
    BYTE   byLockName[LOCK_NAME_LEN]; //刷卡开锁时有效，锁名称，对应门参数配置中门名称
    BYTE   byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //工号（人员ID）
    BYTE   byMask; //是否带口罩：0-保留，1-未知，2-未戴口罩，3-戴口罩
    BYTE   byRes[135]; //保留
}NET_DVR_UNLOCK_RECORD_INFO,*LPNET_DVR_UNLOCK_RECORD_INFO;

typedef struct tagNET_DVR_NOTICEDATA_RECEIPT_INFO
{
    BYTE   byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //公告编号
    BYTE   byRes[224];  //保留
}NET_DVR_NOTICEDATA_RECEIPT_INFO,*LPNET_DVR_NOTICEDATA_RECEIPT_INFO;

typedef struct tagNET_DVR_AUTH_INFO
{
    BYTE   byAuthResult; //认证结果：0-无效，1-认证成功，2-认证失败
    BYTE   byAuthType; //认证方式：0-无效，1-指纹，2-人脸
    BYTE   byRes1[2]; //保留
    BYTE   byCardNo[ACS_CARD_NO_LEN/*32*/]; //卡号
    DWORD dwPicDataLen; //图片数据长度（当认证方式byAuthType为人脸时有效）
    BYTE*  pImage; //图片指针（当认证方式byAuthType为人脸时有效）
    BYTE   byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN/*32*/]; //工号（人员ID
    BYTE   byRes[180];  //保留
}NET_DVR_AUTH_INFO, *LPNET_DVR_AUTH_INFO;

typedef struct tagNET_DVR_UPLOAD_PLATE_INFO
{
    char sLicense[MAX_LICENSE_LEN];        //车牌号码
    BYTE   byColor;                      //车牌颜色，参考结构VCA_PLATE_COLOR
    BYTE   byRes[239];  //保留
}NET_DVR_UPLOAD_PLATE_INFO, *LPNET_DVR_UPLOAD_PLATE_INFO;

typedef struct tagNET_DVR_SEND_CARD_INFO
{
    BYTE   byCardNo[ACS_CARD_NO_LEN/*32*/]; //卡号
    BYTE   byRes[224];  //保留
}NET_DVR_SEND_CARD_INFO, *LPNET_DVR_SEND_CARD_INFO;

typedef struct tagNET_DVR_MAGNETIC_DOOR_STATUS
{
    BYTE   byMagneticDoorStatus; //门磁状态 1-打开 2-关闭
    BYTE   byRes[255];  //保留
} NET_DVR_MAGNETIC_DOOR_STATUS, *LPNET_DVR_MAGNETIC_DOOR_STATUS;


typedef struct tagNET_DVR_VIDEO_INTERCOM_EVENT
{
    DWORD dwSize; //结构体大小
    NET_DVR_TIME_EX struTime; //时间
    BYTE   byDevNumber[MAX_DEV_NUMBER_LEN]; //设备编号
    BYTE   byEventType; //事件信息类型，1-开锁记录，2-公告信息阅读回执，3-认证记录，4-车牌信息上传，5非法卡刷卡事件，6-门口机发卡记录(需要启动门口机发卡功能，刷卡时才会上传该事件)，7-口罩检测事件，8-门磁状态记录
    BYTE   byPicTransType;        //图片数据传输方式: 0-二进制；1-url
    BYTE   byRes1[2]; //保留
    NET_DVR_VIDEO_INTERCOM_EVENT_INFO_UINON uEventInfo; //事件信息，具体内容参考byEventType取值
    DWORD dwIOTChannelNo;    //IOT通道号
    BYTE  byRes2[252]; //保留
}NET_DVR_VIDEO_INTERCOM_EVENT,*LPNET_DVR_VIDEO_INTERCOM_EVENT;

typedef struct tagNET_DVR_ZONE_ALARM_INFO
{
    BYTE   byZoneName[NAME_LEN]; //防区名称
    DWORD  dwZonendex; //防区号
    BYTE   byZoneType; //防区类型，参考DETECTOR_TYPE
    BYTE   byRes[219];  //保留
}NET_DVR_ZONE_ALARM_INFO,*LPNET_DVR_ZONE_ALARM_INFO;

typedef struct tagNET_DVR_LOCK_ALARM_INFO
{
    DWORD   dwLockID;   //锁ID，从0开始
    BYTE    byRes[252]; //保留字节
}NET_DVR_LOCK_ALARM_INFO, *LPNET_DVR_LOCK_ALARM_INFO;


typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM
{
    DWORD dwSize;  //结构体大小
    NET_DVR_TIME_EX struTime; //报警时间
    BYTE  byDevNumber[MAX_DEV_NUMBER_LEN]; //设备编号
    BYTE  byAlarmType; //报警类型，1-防区报警，2-防拆报警，3-劫持报警，4-多次密码开锁失败报警,5-门没开，6-门没关 7-SOS 、8-通话对讲，9-智能锁劫持指纹报警， 10-智能锁劫持密码报警，11-智能锁撬门报警，12-智能锁门锁锁定报警，13-智能锁电量不足报警 ,14-禁止名单报警,15-智能锁掉线
    //，16-门禁安全模块防拆报警，17-设备开始对讲，18-设备停止对讲, 19-取消SOS ,20-未佩戴口罩报警 21-消防输入报警 22-消防输入恢复 23-门磁被外力打开，24-卫生间报警，25-取消卫生间报警，26-换药提醒，27-人脸测温报警，28-取消换药提醒
    BYTE  byRes1[3]; //保留
    NET_DVR_VIDEO_INTERCOM_ALARM_INFO_UNION uAlarmInfo; //报警信息，具体内容参考字段byAlarmType取值
    WORD  wLockID; //（0-表示门口机本机控制器上接的锁、1-表示外接控制器上接的锁）（报警类型为5和6时有效）
    BYTE  byRes3[2]; //保留
    DWORD dwIOTChannelNo;    //IOT通道号
    BYTE  byRes2[248]; //保留
}NET_DVR_VIDEO_INTERCOM_ALARM,*LPNET_DVR_VIDEO_INTERCOM_ALARM;

typedef struct tagNET_DVR_PEOPLE_REGION
{
    BYTE byID;//区域ID
    BYTE byNumber;//区域中的人员数量 0-表示区域中没有人员
    BYTE byDressType;//着装类型 0-未知，1-法袍、2-徽章、3-制服
    BYTE byRes;
    NET_VCA_RECT  struRegion;
    DWORD  dwPicLen;//检测图片长度 (0表示没有长度)
    char*  pPicBuffer;//具体的图片数据
    BYTE byRes1[24];//保留(预留后期扩展区域属性)
}NET_DVR_PEOPLE_REGION,*LPNET_DVR_PEOPLE_REGION;

typedef struct tagNET_DVR_PEOPLE_DETECTION_RESULT
{
    DWORD     dwSize;
    DWORD     dwRelativeTime; //相对时标
    DWORD    dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO  struDevInfo;//前端设备信息
    NET_DVR_PEOPLE_REGION  struPeopleRegion[MAX_PEOPLE_DETECTION_NUM/*8*/];
    /*人员检测报警类型
    （0-    未知，
    （1-    审讯室内打架斗殴报警
    （2-    审讯人员瞌睡检测报警
    （3-    被审讯人员起身检测报警
    （4-    审判人员检测）
    */
    BYTE  byPeopleAlarmType; 
    BYTE  byRes[255];
}NET_DVR_PEOPLE_DETECTION_RESULT,*LPNET_DVR_PEOPLE_DETECTION_RESULT;





typedef struct tagNET_DVR_OIS_CFG
{
    DWORD        dwSize;//结构体大小
    BYTE        byMode;  //是否光学防抖：0-关闭，1-普通，2-专家 
    BYTE      byOISLevel; //光学防抖等级，0-低，1-中，2-高
    BYTE      byOISSensitivity;//光学防抖灵敏度，0-低，1-中，2-高
    BYTE        byRes[125];
}NET_DVR_OIS_CFG, *LPNET_DVR_OIS_CFG;

typedef struct tagNET_DVR_MACFILTER_CFG
{
    DWORD    dwSize;//结构体大小
    BYTE     byEnabled;  //是否开启MAC地址过滤：0-否，1-是
    BYTE     byPermissionType; //MAC地址过滤类型，0-禁止，1-允许
    BYTE     byRes1[2];
    BYTE     szMacAddress[MAC_ADDRESS_NUM][MACADDR_LEN];
    BYTE     byRes[128];
}NET_DVR_MACFILTER_CFG, *LPNET_DVR_MACFILTER_CFG;


typedef struct tagNET_DVR_EAGLEFOCUSING_CALCFG
{
    DWORD   dwSize;
    BYTE    byEnabled;//是否开启标定：0-中止标定，1-开始标定（该节点设置时有效，获取时无效）
    BYTE    byRes1[3];
    NET_DVR_EAGLEFOCUSING_SENCE struEagleFoucsing[MAX_SENCE_NUM/*16*/];
    BYTE   byRes[512];
}NET_DVR_EAGLEFOCUSING_CALCFG, *LPNET_DVR_EAGLEFOCUSING_CALCFG;

typedef struct tagNET_DVR_EAGLEFOCUSING_CTRL
{
    DWORD    dwSize;
    BYTE     byEnable;//使能：0-关闭鹰视聚焦，1-开启鹰视聚焦
    BYTE     byHeightCompensationEnable;//高度补偿使能
    BYTE     byHeightCompensationValue;//高度补偿值, 范围1-5,默认3,一个值代表0.5米
    BYTE     byRes[509];
}NET_DVR_EAGLEFOCUSING_CTRL, *LPNET_DVR_EAGLEFOCUSING_CTRL;

typedef struct tagNET_DVR_SMARTCALIBRATION_REGION
{
    BYTE        byRuleID;//规则编号
    BYTE        byMode;//0-default Mode,1-pix Mode,2-actual Mode
    BYTE        byStrategy;//过滤策略 0-area(面积),1-widthHeight(宽高) (<!---,if mode == pix Mode -->)
    BYTE        byPriority;//优先级 0-默认值, 1-低，2-中，3-高
    NET_VCA_POLYGON struMaxTargetSize;//最大目标尺寸
    NET_VCA_POLYGON struMinTargetSize;//最小目标尺寸
}NET_DVR_SMARTCALIBRATION_REGION, *LPNET_DVR_SMARTCALIBRATION_REGION;

typedef struct tagNET_DVR_SMARTCALIBRATION_CFG
{
    DWORD        dwSize;//结构体大小
    /* SmartType:
    0-linedetection,
    1-fielddetection,
    2-regionEntrance,
    3-regionExiting,
    4-loitering,
    5-rapidMove,
    6-parking,
    7-unattendedBaggage,
    8-attendedBaggage
    */
    BYTE        bySmartType;//智能类型
    BYTE        byRes[3];
    NET_DVR_SMARTCALIBRATION_REGION strRegion[RULE_REGION_MAX/*128*/];
    BYTE        byRes1[128];
}NET_DVR_SMARTCALIBRATION_CFG, *LPNET_DVR_SMARTCALIBRATION_CFG;

typedef struct tagNET_DVR_SMARTCALIBRATION_COND
{
    DWORD        dwSize;//结构体大小
    /* SmartType:
    0-linedetection,
    1-fielddetection,
    2-regionEntrance,
    3-regionExiting,
    4-loitering,
    5-rapidMove,
    6-parking,
    7-unattendedBaggage,
    8-attendedBaggage
    */
    BYTE        bySmartType;//智能类型
    BYTE        byRes[3];
    DWORD        dwChannel;//通道号
    BYTE        byRes1[128];
}NET_DVR_SMARTCALIBRATION_COND, *LPNET_DVR_SMARTCALIBRATION_COND;

typedef struct tagNET_DVR_SMARTCALIBRATION_REGION_CFG
{
    DWORD        dwSize;//结构体大小
    NET_DVR_SMARTCALIBRATION_REGION strRegion[RULE_REGION_MAX/*128*/];
    BYTE        byRes1[128];
}NET_DVR_SMARTCALIBRATION_REGION_CFG, *LPNET_DVR_SMARTCALIBRATION_REGION_CFG;


typedef struct tagNET_DVR_VALID_PERIOD_CFG
{
    BYTE byEnable; //使能有效期，0-不使能，1使能
    BYTE byBeginTimeFlag;      //是否限制起始时间的标志，0-不限制，1-限制
    BYTE byEnableTimeFlag;     //是否限制终止时间的标志，0-不限制，1-限制
    BYTE byTimeDurationNo;     //有效期索引,从0开始（时间段通过SDK设置给锁，后续在制卡时，只需要传递有效期索引即可，以减少数据量）
    NET_DVR_TIME_EX struBeginTime; //有效期起始时间
    NET_DVR_TIME_EX struEndTime; //有效期结束时间
    BYTE byTimeType; //时间类型：0-设备本地时间（默认），1-UTC时间（对于struBeginTime，struEndTime字段有效）
    BYTE byRes2[31];
}NET_DVR_VALID_PERIOD_CFG, *LPNET_DVR_VALID_PERIOD_CFG;

typedef struct tagNET_DVR_CARD_CFG
{
    DWORD dwSize;
    DWORD dwModifyParamType; 
    // 需要修改的卡参数，设置卡参数时有效，按位表示，每位代表一种参数，1为需要修改，0为不修改
    // #define CARD_PARAM_CARD_VALID       0x00000001 //卡是否有效参数
    // #define CARD_PARAM_VALID            0x00000002  //有效期参数
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //卡类型参数
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //门权限参数
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //首卡参数
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //最大刷卡次数参数
    // #define CARD_PARAM_GROUP            0x00000040  //所属群组参数
    // #define CARD_PARAM_PASSWORD         0x00000080  //卡密码参数
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //卡权限计划参数
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //已刷卡次数
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
    BYTE byCardValid; //卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
    BYTE byCardType; //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，默认普通卡
    BYTE byLeaderCard; //是否为首卡，1-是，0-否
    BYTE byRes1;
    DWORD dwDoorRight; //门权限，按位表示，1为有权限，0为无权限，从低位到高位表示对门1-N是否有权限
    NET_DVR_VALID_PERIOD_CFG struValid; //有效期参数
    DWORD dwBelongGroup; //所属群组，按位表示，1-属于，0-不属于，从低位到高位表示是否从属群组1-N
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //卡密码
    BYTE byCardRightPlan[MAX_DOOR_NUM][MAX_CARD_RIGHT_PLAN_NUM]; //卡权限计划，取值为计划模板编号，同个门不同计划模板采用权限或的方式处理
    DWORD dwMaxSwipeTime; //最大刷卡次数，0为无次数限制
    DWORD dwSwipeTime; //已刷卡次数
    WORD wRoomNumber;  //房间号
    SHORT wFloorNumber;   //层号
    BYTE byRes2[20];
}NET_DVR_CARD_CFG, *LPNET_DVR_CARD_CFG;

typedef struct _NET_DVR_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwCardNum; //设置或获取卡数量，获取时置为0xffffffff表示获取所有卡信息
    BYTE  byCheckCardNo; //设备是否进行卡号校验，0-不校验，1-校验
    BYTE           byRes1[3];
    WORD wLocalControllerID; //就地控制器序号，表示往就地控制器下发离线卡参数，0代表是门禁主机
    BYTE  byRes2[2];
    DWORD dwLockID;  //锁ID
    BYTE  byRes3[20];
}NET_DVR_CARD_CFG_COND, *LPNET_DVR_CARD_CFG_COND;

typedef struct _NET_DVR_CARD_CFG_SEND_DATA
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
    DWORD dwCardUserId;    //持卡人ID
    BYTE byRes[12];
}NET_DVR_CARD_CFG_SEND_DATA, *LPNET_DVR_CARD_CFG_SEND_DATA;

typedef struct tagNET_DVR_CARD_USER_INFO_CFG  /*对应配置结构体*/
{
    DWORD dwSize;
    BYTE sUsername[NAME_LEN];                /* 用户名*/
    BYTE	byAssociateNetUser;            //关联的网络用户编号
    BYTE byRes2[255];                       //byRes2[0]--网络报警主机用作用户号
}NET_DVR_CARD_USER_INFO_CFG, *LPNET_DVR_CARD_USER_INFO_CFG;

typedef struct tagNET_DVR_ACS_PARAM_TYPE
{
    DWORD dwSize;
    DWORD dwParamType; //参数类型，按位表示    
    //#define ACS_PARAM_DOOR_STATUS_WEEK_PLAN        0x00000001 //门状态周计划参数
    //#define ACS_PARAM_VERIFY_WEEK_PALN             0x00000002 //读卡器周计划参数
    //#define ACS_PARAM_CARD_RIGHT_WEEK_PLAN         0x00000004 //卡权限周计划参数
    //#define ACS_PARAM_DOOR_STATUS_HOLIDAY_PLAN     0x00000008 //门状态假日计划参数
    //#define ACS_PARAM_VERIFY_HOLIDAY_PALN          0x00000010 //读卡器假日计划参数
    //#define ACS_PARAM_CARD_RIGHT_HOLIDAY_PLAN      0x00000020 //卡权限假日计划参数
    //#define ACS_PARAM_DOOR_STATUS_HOLIDAY_GROUP    0x00000040 //门状态假日组参数
    //#define ACS_PARAM_VERIFY_HOLIDAY_GROUP         0x00000080 //读卡器验证方式假日组参数
    //#define ACS_PARAM_CARD_RIGHT_HOLIDAY_GROUP     0x00000100 //卡权限假日组参数
    //#define ACS_PARAM_DOOR_STATUS_PLAN_TEMPLATE    0x00000200 //门状态计划模板参数
    //#define ACS_PARAM_VERIFY_PALN_TEMPLATE         0x00000400 //读卡器验证方式计划模板参数
    //#define ACS_PARAM_CARD_RIGHT_PALN_TEMPLATE     0x00000800 //卡权限计划模板参数
    //#define ACS_PARAM_CARD                         0x00001000 //卡参数
    //#define ACS_PARAM_GROUP                        0x00002000 //群组参数
    //#define ACS_PARAM_ANTI_SNEAK_CFG               0x00004000 //反潜回参数
    //#define ACS_PAPAM_EVENT_CARD_LINKAGE          0x00008000 //事件及卡号联动参数
    //#define ACS_PAPAM_CARD_PASSWD_CFG             0x00010000 //密码开门使能参数
    //#define ACS_PARAM_PERSON_STATISTICS_CFG       0x00020000 //人数统计参数
    //#define ACS_PARAM_BLOCKLIST_PICTURE          0x00040000 //禁止名单图片参数
    //#define ACS_PARAM_ID_BLOCKLIST               0x00080000 //身份证禁止名单参数
    //#define ACS_PARAM_EXAM_INFO                   0x00100000 //考试信息参数
    //#define ACS_PARAM_EXAMINEE_INFO               0x00200000 //考生信息参数
    //#define ACS_PARAM_FAILED_FACE_INFO             0x00400000 //升级设备人脸建模失败记录
    WORD wLocalControllerID; //就地控制器序号[1,64],0代表门禁主机
    BYTE byRes[30];
}NET_DVR_ACS_PARAM_TYPE, *LPNET_DVR_ACS_PARAM_TYPE;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOIN_CFG
{
    DWORD   dwSize;                 // 结构体大小
    BYTE    byIOUseType;     //用途，0-禁用，1-开门按钮，2-门状态，0xff-自定义
    BYTE    byRes[63];              // 保留字节
}NET_DVR_VIDEO_INTERCOM_IOIN_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOIN_CFG;

typedef struct tagNET_DVR_VIDEO_INTERCOM_IOOUT_CFG
{
    DWORD   dwSize;                 // 结构体大小
    BYTE    byIOUseType;     //用途，0-禁用，1-电锁，0xff-自定义
    BYTE    byRes[63];              // 保留字节
}NET_DVR_VIDEO_INTERCOM_IOOUT_CFG, *LPNET_DVR_VIDEO_INTERCOM_IOOUT_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG
{
    DWORD   dwSize;                 // 结构体大小
    BYTE    byEnable;   //是否启用梯控，0-否，1-是
    BYTE    byRes1;     //保留
    BYTE    byInterfaceType; //接口类型，0-无，1-RS485,2-网口
    BYTE    byRS485Protocol; //RS485协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为1时有效
    BYTE    byNetworkType;  //网口协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为2时有效
    BYTE    byRes[63];              // 保留字节
}NET_DVR_ELEVATORCONTROL_CFG, *LPNET_DVR_ELEVATORCONTROL_CFG;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG_V40
{
    DWORD   dwSize;                 // 结构体大小
    BYTE    byEnable;               //是否启用梯控，0-否，1-是
    BYTE    byRes1;                 //保留
    BYTE    byInterfaceType;        //接口类型，0-无，1-RS485,2-网口
    BYTE    byRS485Protocol;        //RS485协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为1时有效
    BYTE    byNetworkType;          //网口协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为2时有效
    BYTE    byRes2;                 //保留
    WORD    wServerPort;            //梯控服务器端口号，当网卡协议类型为1-私有 时有效
    NET_DVR_IPADDR    struServerIP; //梯控服务器IP，当网卡协议类型为1-私有 时有效
    BYTE    byRes[256];              // 保留字节
}NET_DVR_ELEVATORCONTROL_CFG_V40, *LPNET_DVR_ELEVATORCONTROL_CFG_V40;

typedef struct tagNET_DVR_ELEVATORCONTROL_CFG_V50
{
    DWORD   dwSize;                 //结构体大小
    BYTE    byEnable;                 //是否启用梯控，0-否，1-是
    BYTE    byNegativeFloor;           //负楼层层数
    BYTE    byInterfaceType;           //接口类型，0-无，1-RS485,2-网口
    BYTE    byRS485Protocol;        //RS485协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为1时有效
    BYTE    byNetworkType;         //网口协议类型，0-未知，1-私有，0xff-自定义，当byInterfaceType取值为2时有效
    BYTE    byElevatorControlType;      //梯控器类型：0-无效，1-DS-K2201，2-DS-K2210，0xff-自定义
    WORD    wServerPort;            //梯控服务器端口号，当网卡协议类型为1-私有 时有效
    NET_DVR_IPADDR    struServerIP; //梯控服务器IP，当网卡协议类型为1-私有 时有效
    BYTE    sUserName[NET_DVR_LOGIN_USERNAME_MAX_LEN]; //用户名，当网卡协议类型为1-私有 时有效（只能设置，不能获取）
    BYTE    sPassword[NET_DVR_LOGIN_PASSWD_MAX_LEN]; //密码，当网卡协议类型为1-私有 时有效（只能设置，不能获取）
    BYTE    byRes[256];              //保留字节
}NET_DVR_ELEVATORCONTROL_CFG_V50, *LPNET_DVR_ELEVATORCONTROL_CFG_V50;

typedef struct tagNET_DVR_ROOM_CUSTOM_COND
{
    DWORD   dwSize;
    DWORD   dwRoomNumber; //房间数目（设置时有效）
    BYTE    byRes[128];
}NET_DVR_ROOM_CUSTOM_COND, *LPNET_DVR_ROOM_CUSTOM_COND;

typedef struct tagNET_DVR_ROOM_CUSTOM_CFG
{
    DWORD   dwSize;
    DWORD   dwFormerRoomNo; //原房间号
    DWORD   dwCustomRoomNo; //自定义序号
    BYTE    byRes[128];
}NET_DVR_ROOM_CUSTOM_CFG, *LPNET_DVR_ROOM_CUSTOM_CFG;

typedef struct tagNET_DVR_ROOM_CUSTOM_STATUS
{
    DWORD   dwSize;
    DWORD   dwFormerRoomNo; //原房间号
    BYTE    byStatus;  //下发状态：0-无效，1-失败，2-处理中，3-成功
    BYTE    byRes[127];
}NET_DVR_ROOM_CUSTOM_STATUS, *LPNET_DVR_ROOM_CUSTOM_STATUS;

typedef struct tagNET_DVR_VIDEOINTERCOM_STREAM
{
    DWORD dwSize;
    BYTE  byVisDevID[MAX_NAMELEN]; // 可视对讲设备编号，即长号，设备类型为IPC时全部为0
    BYTE  byDeviceName[NAME_LEN];  //设备名称
    BYTE  bySourceType;            //视频源类型，0无意义，1-IPC、2-DVR/DVS/NVR、3-门口机、4-围墙机、5-二次确认机
    BYTE  byRes[255];              //保留
}NET_DVR_VIDEOINTERCOM_STREAM, LPNET_DVR_VIDEOINTERCOM_STREAM;

typedef struct tagNET_DVR_DOOR_CFG
{
    DWORD dwSize;
    BYTE byDoorName[DOOR_NAME_LEN]; //门名称
    BYTE byMagneticType; //门磁类型，0-常闭，1-常开
    BYTE byOpenButtonType; //开门按钮类型，0-常闭，1-常开
    BYTE byOpenDuration; //开门持续时间，1-255s（楼层继电器动作时间）
    BYTE byAccessibleOpenDuration; //特殊群体卡开门持续时间，1-255s
    BYTE byMagneticAlarmTimeout; //门磁检测超时报警时间，0-255s，0表示不报警
    BYTE byEnableDoorLock; //是否启用闭门回锁，0-否，1-是
    BYTE byEnableLeaderCard; //是否启用首卡常开功能，0-否，1-是
    BYTE byLeaderCardMode; //首卡模式，0-不启用首卡功能，1-首卡常开模式，2-首卡授权模式（使用了此字段，则byEnableLeaderCard无效）
    DWORD dwLeaderCardOpenDuration; //首卡常开持续时间，1-1440min
    BYTE byStressPassword[STRESS_PASSWORD_LEN]; //胁迫密码
    BYTE bySuperPassword[SUPER_PASSWORD_LEN]; //超级密码
    BYTE byUnlockPassword[UNLOCK_PASSWORD_LEN];         //解除码NET_DVR_LOCAL_CONTROLLER_STATUS
    BYTE byUseLocalController; //只读，是否连接在就地控制器上，0-否，1-是
    BYTE byRes1;
    WORD wLocalControllerID; //只读，就地控制器序号，1-64,0代表未注册
    WORD wLocalControllerDoorNumber; //只读，就地控制器的门编号，1-4,0代表未注册
    WORD wLocalControllerStatus; //只读，就地控制器在线状态：0-离线，1-网络在线，2-环路1上的RS485串口1，3-环路1上的RS485串口2，4-环路2上的RS485串口1，5-环路2上的RS485串口2，6-环路3上的RS485串口1，7-环路3上的RS485串口2，8-环路4上的RS485串口1，9-环路4上的RS485串口2（只读）
    BYTE byLockInputCheck; //是否启用门锁输入检测(1字节，0不启用，1启用，默认不启用)
    BYTE byLockInputType; //门锁输入类型(1字节，0常闭，1常开，默认常闭)
    BYTE byDoorTerminalMode; //门相关端子工作模式(1字节，0防剪防短，1普通，默认防剪防短)
    BYTE byOpenButton; //是否启用开门按钮(1字节，0是，1否，默认是)
    BYTE byLadderControlDelayTime; //梯控访客延迟时间，1-255min
    BYTE byRes2[43];
}NET_DVR_DOOR_CFG, *LPNET_DVR_DOOR_CFG;

typedef struct tagNET_DVR_VIS_DEV_INFO
{
    DWORD   dwSize;
    BYTE    szDevNumber[MAX_DEV_NUMBER_LEN];    //设备编号
    BYTE    byRes[64];                          //保留
}NET_DVR_VIS_DEV_INFO,*LPNET_DVR_VIS_DEV_INFO;

typedef struct tagNET_DVR_VIS_REGISTER_INFO
{
    DWORD       dwSize;
    DWORD       dwID;                                  //ID
    BYTE        szDevNumber[MAX_DEV_NUMBER_LEN];    //设备编号
    BYTE        byMACAddr[MACADDR_LEN];             //mac地址
    BYTE        byRes1[2];                           //保留
    BYTE        sSerialNumber[SERIALNO_LEN];        //设备序列号
    NET_DVR_IPADDR   struDevIP;                     //设备IP地址
    NET_DVR_TIME_EX struRegisterTime;                 //注册时间
    BYTE        byRegisterType;                     //注册类型，0-保留、1-门口机，2-管理机、3-室内机、4-围墙机、5-别墅门口机、6-二次确认机、7-8700客户端、8-4200客户端
    BYTE        byRes[127];                         //保留
}NET_DVR_VIS_REGISTER_INFO,*LPNET_DVR_VIS_REGISTER_INFO;

typedef struct tagNET_DVR_CALLER_INFO
{
    DWORD dwSize;          //结构体大小
    WORD   wBuildingNo;    //楼号
    SHORT   wFloorNo;    //层号
    BYTE   byZoneNo;        //期号
    BYTE   byUnitNo;    //单元号
    BYTE   byDevNo;    //设备编号
    BYTE    byDevType;   //设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机，7-8700客户端，8-4200客户端，9-APP, 10- 门铃机，11-VOIP客户端，12-监控点IPC设备
    BYTE    byLockNum;//锁数量0-按照老的逻辑走，其他值-代表实际锁的数量
    BYTE   byHighDevNo;    // 设备编号高8位,用于支持1-9999的范围
    BYTE   byRes1[2];     // 保留
    BYTE   byVoipNo[16];   // VOIP客户端号码 byDevType：为11时有效
    BYTE   byRes[80];     // 保留
}NET_DVR_CALLER_INFO,*LPNET_DVR_CALLER_INFO;

typedef struct tagNET_DVR_CALL_STATUS
{
    DWORD dwSize;          //结构体大小
    BYTE   byCallStatus; //获取通话状态，1-无呼叫、2-响铃、3-正在通话
    BYTE   byRes[127];
}NET_DVR_CALL_STATUS, *LPNET_DVR_CALL_STATUS;

typedef struct tagNET_DVR_SERVER_DEVICE_CFG
{
    BYTE    byDeviceName[NAME_LEN];   //设备名称
    BYTE       byDeviceType; ////设备类型，1-门口机，2-管理机，3-室内机
    BYTE       byDeviceID; //门口机编号
    BYTE    byLockNum; //锁数量0-按照老的逻辑走，其他值-代表实际锁的数量
    BYTE    byRes[5]; 	   //保留
}NET_DVR_SERVER_DEVICE_CFG,*LPNET_DVR_SERVER_DEVICE_CFG;

typedef struct tagNET_DVR_SERVER_DEVICE_INFO
{
    DWORD   dwSize;  //结构体大小
    DWORD     dwDeviceNum; //设备数
    NET_DVR_SERVER_DEVICE_CFG    struDeviceCfg[MAX_SERVER_DEVICE_NUMBER];   //设备信息
    BYTE    byRes[200];        //保留
}NET_DVR_SERVER_DEVICE_INFO,*LPNET_DVR_SERVER_DEVICE_INFO;

typedef struct tagNET_DVR_VIDEO_CALL_PARAM
{
    DWORD    dwSize;
    DWORD   dwCmdType;      //信令类型  0-请求呼叫，1-取消本次呼叫，2-接听本次呼叫 3-拒绝本地来电呼叫 4-被叫响铃超时 5-结束本次通话，6-设备正在通话中，7-客户端正在通话中，8室内机不在线
    WORD wPeriod;  //期号, 范围[0,9]
    WORD wBuildingNumber; //楼号
    WORD wUnitNumber;  //单元号
    SHORT wFloorNumber;  //层号
    WORD  wRoomNumber;    //房间号
    WORD  wDevIndex; //设备编号
    BYTE    byUnitType; //设备类型，1-门口机，2-管理机，3-室内机，4-围墙机，5-别墅门口机，6-二次确认机，7-8700客户端，8-4200客户端，9-APP
    BYTE    byRes[115];     //保留
}NET_DVR_VIDEO_CALL_PARAM,*LPNET_DVR_VIDEO_CALL_PARAM;

typedef struct tagNET_DVR_DEV_IP_INFO
{
    BYTE byUserName[NAME_LEN]; //用户名
    BYTE byPassWord[PASSWD_LEN]; //密码
    NET_DVR_IPADDR struIPAddr; //IP地址
    WORD wPort; //端口号
    BYTE byRes[24];    
}NET_DVR_DEV_IP_INFO, *LPNET_DVR_DEV_IP_INFO;


typedef struct tagNET_DVR_SCREEN_INDEX_CFG
{
    DWORD dwSize;
    BYTE byEnbale; //使能，0-不使能，1-使能
    BYTE byDevAddType; //设备添加方式，0-按特征码(服务器和屏幕使用串口通信)，1-按IP地址(服务器和屏幕使用网络通信)
    BYTE byRes1[2];
    NET_DVR_SCREEN_BASE_INFO struScreenBaseInfo; //屏幕设备基本信息
    BYTE byRes[32];
}NET_DVR_SCREEN_INDEX_CFG,*LPNET_DVR_SCREEN_INDEX_CFG;

typedef struct tagNET_DVR_SIMULATE_REMOTE_CTRL
{
    BYTE        byControlType;    //1-电源开，2-电源关，3-信号源，4-菜单，5-确定，6-上，7-下，8-左，9-右,  10-INFO, 11-返回上一层,12-数字按键
    BYTE        byControlParam; //操作参数，操作类型为12时，表示按键值(0-9)，其他操作时此参数无效
    BYTE        byRes[14];
}NET_DVR_SIMULATE_REMOTE_CTRL, *LPNET_DVR_SIMULATE_REMOTE_CTRL;

typedef struct tagNET_DVR_SCREEN_WALL_CTRL
{
    BYTE byEnable; //状态开关。0-为关闭；1-为开启
    BYTE byRes[15];
}NET_DVR_SCREEN_WALL_CTRL, *LPNET_DVR_SCREEN_WALL_CTRL;

typedef struct tagNET_DVR_AREA_ZOOM_CFG
{
    BYTE byCmd;    //区域放大还原指令，1-放大，2-还原
    BYTE byRes[3];
    NET_DVR_RECTCFG struArea; //需要放大的区域，以1920*1920作为屏幕总大小，还原时此参数无效
}NET_DVR_AREA_ZOOM_CFG, *LPNET_DVR_AREA_ZOOM_CFG;


typedef struct tagNET_DVR_SCREEN_CONTROL
{     
    DWORD     dwSize;             
    DWORD      dwCommand ;      /* 控制方法 1-开 2-关 3-屏幕输入源选择 4-显示单元颜色控制 5-显示单元位置控制*/
    BYTE       byProtocol;      //串口协议类型,1:LCD-S1,2:LCD-S2
    BYTE    byRes1[3];
    NET_DVR_SCREEN_CONTROL_PARAM    struControlParam;
    BYTE       byRes2[52];    
}NET_DVR_SCREEN_CONTROL, *LPNET_DVR_SCREEN_CONTROL;

typedef struct tagNET_DVR_SCREEN_CONTROL_V41
{     
    DWORD   dwSize;
    BYTE    bySerialNo;        //串口号
    BYTE    byRes[2];
    BYTE       byProtocol;    // 串口协议类型 1-LCD-S1,2-LCD-S2,3-LCD-L1,4-LCD-DLP,5-LCD-S3,6-LCD-D20，7-LCD-L2,8-LCD-Z1，
    //9-LCD-D20/D,10-LCD-D20/S,11-LCD-D20/P,12-LCD-D20/T,13-LCD-D20/F,14-LCD-D20/DF,15-LCD-D20/FS,
    //16-LCD-D20/FP,17-LCD-D20/FT,18-LCD-D5022,19-LCD-D5032,20-LCD-D5042+,21-LCD-D20/Z  0xff-无效，使用预先绑定的协议类型 
    DWORD      dwCommand ;      /* 控制方法 1-开 2-关 3-屏幕输入源选择 4-显示单元颜色控制 5-显示单元位置控制，6-模拟遥控按键,7-显示屏幕状态,
    8-显示屏幕特征码（此命令矩形区域起始坐标设为（0,0），宽高均设为0xffffffff）, 9-屏幕维墙,10-恢复屏幕默认参数，11-显示IP（此命令矩形区域起始坐标设为（0,0），宽高均设为0xffffffff）,12-屏幕USB升级 13-区域放大还原*/
    NET_DVR_SCREEN_CONTROL_PARAM    struControlParam;
    BYTE    byWallNo;        // 电视墙号
    BYTE    byDevNo;         //设备号
    BYTE    bySubboardNo;    //子板号
    BYTE    byRes1;
    NET_DVR_RECTCFG_EX struRect;//根据坐标进行计算，基准坐标
    BYTE   byRes2[28];
}NET_DVR_SCREEN_CONTROL_V41, *LPNET_DVR_SCREEN_CONTROL_V41;

typedef struct tagNET_DVR_MSC_SPLICE_CFG
{
    DWORD dwSize;
    BYTE bySpliceNo; //拼接屏号
    BYTE byWallNo; //电视墙号
    BYTE byEnable; //是否使能，0-否，1-是
    BYTE byRes1[1];
    NET_DVR_RECTCFG_EX struRectCfg; //需要进行拼接的区域，获取的时候此参数填0
    BYTE byRes2[32];
}NET_DVR_MSC_SPLICE_CFG,*LPNET_DVR_MSC_SPLICE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_INTERFACE_CFG
{
    DWORD dwSize;
    BYTE  byInterfaceType;    //输入源索引，见枚举 INPUT_INTERFACE_TYPE
    BYTE  byNoSignalPic;        //无信号画面模式，1-蓝屏，2-黑屏，3-LOGO画面
    BYTE  byRes[30];       
}NET_DVR_MSC_SCREEN_INTERFACE_CFG,*LPNET_DVR_MSC_SCREEN_INTERFACE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_BACKLIGHT_CFG
{
    DWORD dwSize;
    BYTE byBacklight; //背光，0-100
    BYTE byRes[15];
}NET_DVR_MSC_SCREEN_BACKLIGHT_CFG,*LPNET_DVR_MSC_SCREEN_BACKLIGHT_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_PIP_CFG
{
    DWORD dwSize;
    BYTE    byEnable;    //是否启用画中画 0-不启用 1-启用
    BYTE    bySubWindowSource;    //子画面信号源，参考枚举INPUT_INTERFACE_TYPE
    BYTE    bySubWindowBorderColor;    //子画面边框颜色， 1-蓝色，2-黑色
    BYTE    byRes1;
    NET_DVR_RECTCFG_EX  struPosition;    //子画面位置，屏幕总大小为1920*1920
    BYTE    byRes2[16];
}NET_DVR_MSC_SCREEN_PIP_CFG,*LPNET_DVR_MSC_SCREEN_PIP_CFG;

typedef struct tagNET_DVR_SCREEN_WORK_STATE
{
    DWORD dwSize;
    BYTE           byFanStatus;//风扇状态，0-关，1-开
    BYTE           byFanExceptionStatus;    //风扇异常状态，0-不支持，1-正常，2-异常
    BYTE           byRes1[2];
    DWORD          dwWorkingHours; //累积工作时长，单位：小时
    BYTE           byVersion[VERSION_LEN];//软件版本号
    int            iTemperature; //板卡温度，精确到个位，单位：摄氏度
    BYTE             byTempState;     //板卡温度状态，0-不支持，1-正常，2-异常
    BYTE           byRes[31];
}NET_DVR_SCREEN_WORK_STATE,*LPNET_DVR_SCREEN_WORK_STATE;

typedef struct tagNET_DVR_BOOT_LOGO_CFG
{
    DWORD dwSize;
    BYTE byEnable; //开机是否显示logo,0-不显示，1-显示
    BYTE byRes[31];    
}NET_DVR_BOOT_LOGO_CFG,*LPNET_DVR_BOOT_LOGO_CFG;

typedef struct tagNET_DVR_LCD_AUDIO_CFG
{
    DWORD   dwSize;
    BYTE    byMute; //是否静音，0-否，1-是
    BYTE    byVolume; //音量大小，0-100
    char    byBalance; //声道平衡，-50-+50
    BYTE    byRes[33];
}NET_DVR_LCD_AUDIO_CFG, *LPNET_DVR_LCD_AUDIO_CFG;


typedef struct tagNET_DVR_MSC_SCREEN_PARAM_CFG
{
    DWORD dwSize;
    BYTE byParamType; //参数类型，1-输入源参数，2-风扇工作模式参数，3-VGA信号参数，4-屏幕菜单参数，5-显示效果参数，6-色温参数，7-ADC参数，8-屏幕边缘参数，9-背光参数，10-画中画参数，11-透雾参数，12-屏幕工作状态（只能获取），13-开机LOGO是否显示参数  14-音频参数
    BYTE byRes1[3];
    NET_DVR_MSC_SCREEN_PARAM struParam; //屏幕参数
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_CFG,*LPNET_DVR_MSC_SCREEN_PARAM_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_REMOTE_CFG
{
    DWORD dwSize;
    BYTE byWallNo; //电视墙号
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRectCfg; //屏幕区域
    NET_DVR_MSC_SCREEN_PARAM_CFG struScreenParam; //配置的屏幕参数
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_REMOTE_CFG,*LPNET_DVR_MSC_SCREEN_REMOTE_CFG;

typedef struct tagNET_DVR_MSC_SCREEN_PARAM_COND
{
    DWORD dwSize;
    BYTE byWallNo; //电视墙号
    BYTE byParamType; //参数类型，1-输入源参数，2-风扇工作模式参数，3-VGA信号参数，4-屏幕菜单参数，5-显示效果参数，6-色温参数，7-ADC参数，8-屏幕边缘参数，9-背光参数，10-画中画参数，11-透雾参数，12-屏幕工作状态（只能获取），13-开机LOGO是否显示参数 14-音频参数
    BYTE byRes1[2];
    NET_DVR_RECTCFG_EX struRectCfg; //屏幕区域
    BYTE byRes2[32];
}NET_DVR_MSC_SCREEN_PARAM_COND,*LPNET_DVR_MSC_SCREEN_PARAM_COND;

typedef struct tagNET_DVR_SWITCH_DAY_TIME
{
    BYTE byEnable; //是否启用该时间点,0-不启用，1-启用
    BYTE bySwitchType; //开关机类型，0-关机，1-开机
    BYTE byRes1[2];
    NET_DVR_DAYTIME struTimePoint; //开关机时间点
    BYTE byRes2[8];
}NET_DVR_SWITCH_DAY_TIME,*LPNET_DVR_SWITCH_DAY_TIME;

typedef struct tagNET_DVR_SWITCH_TIME_POINT
{
    BYTE byEnable; //是否启用该时间点,0-不启用，1-启用
    BYTE bySwitchType; //开关机类型，0-关机，1-开机
    BYTE byRes1[2];
    NET_DVR_SYSTEM_TIME struTimePoint; //开关机时间点
    BYTE byRes2[16];
}NET_DVR_SWITCH_TIME_POINT,*LPNET_DVR_SWITCH_TIME_POINT;

typedef struct tagNET_DVR_TIME_SWITCH_CFG
{
    DWORD dwSize;
    NET_DVR_SWITCH_DAY_TIME struSwitchDayTime[MAX_DAYS][MAX_DAY_TIME_POINT]; //周开关机计划
    NET_DVR_SWITCH_TIME_POINT struSwitchTimePoint[MAX_TIME_POINT]; //按时间点开关机参数
	BYTE byRes1[3];
	BYTE byEnable;//是否启用定时开关机,0-不启用，1-启用
	BYTE byRes[60];
}NET_DVR_TIME_SWITCH_CFG,*LPNET_DVR_TIME_SWITCH_CFG;

typedef struct tagNET_DVR_VIDEO_WALL_AREA
{
    DWORD dwSize;
    BYTE byWallNo; //电视墙号
    BYTE byRes1[3];
    NET_DVR_RECTCFG_EX struRect; //屏幕范围
    BYTE byRes2[32];
}NET_DVR_VIDEO_WALL_AREA, *LPNET_DVR_VIDEO_WALL_AREA;

typedef struct tagNET_DVR_DELAY_TIME
{
    DWORD dwSize;
    DWORD dwDelayTime; //延时时间，0-3000，单位：ms
    BYTE byRes[32];
}NET_DVR_DELAY_TIME,*LPNET_DVR_DELAY_TIME;


typedef struct tagNET_DVR_BV_SAMPLE_CALIB_POINT
{   
    BYTE  byCalibPtID;   //标定点ID，范围[1,5]。表示此点在双目标定过程中的序号
    BYTE  byRes1[3];     //保留
    NET_VCA_POINT struPoint;  //标定点坐标
    BYTE  byRes2[16];    //保留
}NET_DVR_BV_SAMPLE_CALIB_POINT,*LPET_DVR_BV_SAMPLE_CALIB_POINT;

typedef struct tagNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM
{
    DWORD  dwCameraHeight;  //摄像机高度，单位cm
    DWORD  dwHumanHeight;  //人体身高，单位cm
    BYTE    byRes[248];      //保留
}NET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_BEGIN_PARAM;

typedef struct tagNET_DVR_BV_SAMPLE_CALIB_SET_PARAM
{
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint; //标定点。即当人员保持直立行走，人脸出现在特定画面区域中时，此点表示对象两眼连线的中点。
    BYTE byRes[228]; //保留
}NET_DVR_BV_SAMPLE_CALIB_SET_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_SET_PARAM;

typedef struct tagNET_DVR_BV_SAMPLE_CALIB_END_PARAM
{
    BYTE byRes[256]; //保留
}NET_DVR_BV_SAMPLE_CALIB_END_PARAM,*LPNET_DVR_BV_SAMPLE_CALIB_END_PARAM;



typedef struct tagNET_DVR_BV_SAMPLE_CALIBRATION
{   
    DWORD   dwSize;     //结构体大小
    DWORD   dwChannel;  //通道号
    BYTE    byCommand; //标定命令，参见BV_SAMPLE_CALIB_CMD _ENUM
    BYTE    byRes1[3];    //保留
    NET_DVR_BV_SAMPLE_CALIB_PARAM_UNION uCalibParam; //标定输入参数，取值依赖于字段byCommand
    BYTE    byRes2[256] ;  //保留
}NET_DVR_BV_SAMPLE_CALIBRATION,*LPNET_DVR_BV_SAMPLE_CALIBRATION;

typedef struct tagNET_DVR_BV_SAMPLE_CALIB_CFG
{
    DWORD  dwSize;             //结构体大小
    DWORD  dwCameraHeight;    //摄像机高度，单位cm
    float  fPitchAngle;   //摄像机俯视角度[0°, 60°],
    float  fInclineAngle; //摄像机倾斜角度[-20°,20°]
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPoint[MAX_SAMPLE_NUM]; //标定点组
    NET_DVR_BV_SAMPLE_CALIB_POINT struCalibPointEx[MAX_SAMPLE_NUM_EX/*7*/]; //标定点组扩展
    BYTE  byRes[60]; //保留
}NET_DVR_BV_SAMPLE_CALIB_CFG,*LPNET_DVR_BV_SAMPLE_CALIB_CFG;

typedef struct tagNET_DVR_BINOC_RECTIFY_PARAM
{   
    float   fCamInternalMatrix[3][3];  //相机内参矩阵，包括焦距及主点坐标
    float   fDistCoeffs[8];            //镜头畸变系数
    float   fRotateMatrix[3][3];       //校正后的旋转矩阵
    float   fProjectMatrix[3][4];      //校正后的投影矩阵
    BYTE    byRes[64];              //保留
}NET_DVR_BINOC_RECTIFY_PARAM, *LPNET_DVR_BINOC_RECTIFY_PARAM;

typedef struct _tagNET_DVR_BV_CORRECT_PARAM
{
    DWORD  dwSize;                       //结构大小
    float      fReprojectMatrix[4][4];   //重投影矩阵
    NET_DVR_BINOC_RECTIFY_PARAM  struLCamParam; //左相机校正参数
    NET_DVR_BINOC_RECTIFY_PARAM  struRCamParam; //右相机校正参数
    BYTE    byLensType;             //镜头焦距类型，0-未知,1-8mm,2-12mm,3-16mm,4-25mm,5-35mm,6-50mm,7-4mm,8-6mm,9-2.0mm,10-2.8mm,11-4.3mm
    BYTE    byRes1[3]; //保留
    /*RotateMatrix 是双目标定后左相机相对于右相机的旋转矩阵,
    TransMatrix是平移矩阵,
    RotateMatrix和TransMatrix联合起来描述的是左相机相对于右相机的位置关系*/
    float   fRotateMatrix[3][3]; //旋转矩阵
    float   fTransMatrix[3]; //平移矩阵
    DWORD dwOriImgWidth; //原始标定图像的宽（如果是1920*1080分辨率的图像，则为1920）
    DWORD dwOriImgHeight; //原始标定图像的高（如果是1920*1080分辨率的图像，则为1080）
    BYTE    byRes[196]; //保留
} NET_DVR_BV_CORRECT_PARAM,*LPNET_DVR_BV_CORRECT_PARAM;

typedef struct tagNET_DVR_OUTPUT_VIDEO_TYPE
{
    DWORD  dwSize;     //结构大小
    BYTE   byType;     //输出视频类型，1-拼接图，2-深度图
    BYTE   byRes[63];  //保留
}NET_DVR_OUTPUT_VIDEO_TYPE,*LPNET_DVR_OUTPUT_VIDEO_TYPE;

typedef struct tagNET_DVR_DEVICE_SELF_CHECK_STATE
{
    DWORD        dwSize;  
    DWORD        dwRS485Chan[MAX_CHECK_485CHAN];//RS485通断情况有问题的通道号，值表示通道号，位表示槽位号
    DWORD        dwSensorChan[4];//模拟量无效的通道号，按位表示
       BYTE         byRes[32];      // 保留字节 
}NET_DVR_DEVICE_SELF_CHECK_STATE, *LPNET_DVR_DEVICE_SELF_CHECK_STATE;

typedef struct tagNET_DVR_COMPLETE_RESTORE_INFO_
{
    DWORD   dwSize ; //结构体长度
    DWORD   dwChannel; //通道号
    BYTE    byRes[64]; 
}NET_DVR_COMPLETE_RESTORE_INFO, *LPNET_DVR_COMPLETE_RESTORE_INFO;

typedef struct  tagNET_DVR_UPLOAD_PICTURE_INFO
{
    DWORD       dwSize;   
    DWORD        dwChannel;   //图片对应的通道号
    BYTE        byPictureType;//图片格式,0-bmp，1-jpeg，2-PNG 3-SWF 4-GIF 
    BYTE    byRes1[3];
    NET_DVR_TIME_V30 struTime;  //图片生成时间
    char*        sPictureBuffer;//图片缓冲区
    DWORD        dwPictureLength;//图片长度
    DWORD        dwPicMangeNo;  //图片管理号
    BYTE        sPicName[NAME_LEN];  //图片名称
    BYTE        byUseType;    //图片使用类型：0-屏保图片 1-开机logo图片
    BYTE        byRes[91];
}NET_DVR_UPLOAD_PICTURE_INFO,*LPNET_DVR_UPLOAD_PICTURE_INFO;

typedef struct  tagNET_DVR_UPLOAD_FILE_RET
{
    BYTE  sUrl[MAX_UPLOADFILE_URL_LEN] ;   //url
    BYTE byRes[260];
} NET_DVR_UPLOAD_FILE_RET,*LPNET_DVR_UPLOAD_FILE_RET;

typedef struct tagNET_DVR_FACE_EXTRA_INFO
{
    NET_VCA_RECT struVcaRect[MAX_FACE_PIC_NUM];  //人脸子图坐标信息
    BYTE     byRes[64];        
}NET_DVR_FACE_EXTRA_INFO, *LPNET_DVR_FACE_EXTRA_INFO;


typedef struct    tagNET_DVR_FIND_PICTURE_V40   //查找结果结构体
{
    char    sFileName[PICTURE_NAME_LEN];//图片名
    NET_DVR_TIME struTime;//图片的时间
    DWORD dwFileSize;//图片的大小
    char    sCardNum[CARDNUM_LEN_V30];    //卡号
    BYTE   byPlateColor ;//参考结构 VCA_PLATE_COLOR
    BYTE   byVehicleLogo;//参考结构 VLR_VEHICLE_CLASS
    BYTE   byFileType ;  //文件类型， :0定时抓图1 移动侦测抓图 2 报警抓图3  报警 | 移动侦测抓图 4 报警 & 移动侦测抓图     6 手动抓图 ,9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,    0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测, 0x32-防区报警, 0x33-紧急求助, 0x34-业务咨询
    BYTE   byRecogResult ;//识别结果参考结构VTR_RESULT
    char   sLicense[MAX_LICENSE_LEN/*16*/];    //车牌号码
    BYTE   byEventSearchStatus; //连续图片表示同一查找结果的时候，0-表示后面没有图片信息，1-表示后面还有图片信息。总共图片信息包括最后一张状态为0的图片。
    BYTE   byRes1[2];        //  保留字节
    BYTE   byThermometryUnit;//测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
    float  fFaceSnapTemperature; // 人脸抓拍温度信息，精确到小数点后1位 ，(浮点数 + 100） * 10 取正数传输），单位固定为摄氏度（℃）。当byFileType为0x25-人脸抓拍时有效，其余情况下该字段为0值
    BYTE   byRes[68];        //  保留字节
    NET_DVR_PIC_EXTRA_INFO_UNION  uPicExtraInfo; //图片附件信息
}NET_DVR_FIND_PICTURE_V40,*LPNET_DVR_FIND_PICTURE_V40;

typedef struct    tagNET_DVR_FIND_PICTURE_V50   //查找结果结构体
{
    char        sFileName[PICTURE_NAME_LEN];//图片名
    NET_DVR_TIME struTime;//图片的时间
    DWORD    dwFileSize;//图片的大小
    char        sCardNum[CARDNUM_LEN_V30];    //卡号
    BYTE   byPlateColor;//参考结构 VCA_PLATE_COLOR
    BYTE   byVehicleLogo;//参考结构 VLR_VEHICLE_CLASS
    BYTE   byFileType;  //文件类型， :0定时抓图1 移动侦测抓图 2 报警抓图3  报警 | 移动侦测抓图 4 报警 & 移动侦测抓图     6 手动抓图 ,9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,\
                       0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测, 0x70-通道定时抓图
    BYTE   byRecogResult;//识别结果参考结构VTR_RESULT
    char   sLicense[MAX_LICENSE_LEN/*16*/];    //车牌号码
    BYTE   byEventSearchStatus; //连续图片表示同一查找结果的时候，0-表示后面没有图片信息，1-表示后面还有图片信息。总共图片信息包括最后一张状态为0的图片。
    NET_DVR_ADDRESS	struAddr;		//图片所在的地址信息，图片下载时用到
    BYTE   	        byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char     cTimeDifferenceH;   //与UTC的时差（小时），-12 ... +14
    char     cTimeDifferenceM;   //与UTC的时差（分钟），-30,0, 30, 45
    BYTE            byRes[253];        //  保留字节
    NET_DVR_PIC_EXTRA_INFO_UNION  uPicExtraInfo; //图片附件信息
}NET_DVR_FIND_PICTURE_V50, *LPNET_DVR_FIND_PICTURE_V50;

typedef struct tagNET_DVR_THUMBNAILS_COND
{
    DWORD  dwSize;             // 结构体大小 
    NET_DVR_STREAM_INFO   struStreamInfo;     //流信息
    BYTE   bySearchDataType;   // 查找数据类型 0-I帧数据（CVR 一路的情况下，1s最多28个I帧），1-图片数据
    BYTE   byRes[3];          // 保留字节
    NET_DVR_TIME_V30  struStartTime;      //查找开始时间
    NET_DVR_TIME_V30  struStopTime;       // 查找结束时间
    DWORD  dwIntervalTime;  //间隔时间，单位秒，范围：0~24*60*60，若查找结束时间等于查找开始时间，则填0，填其他值无效
    BYTE   byRes1[512];        // 保留字节
}NET_DVR_THUMBNAILS_COND, *LPNET_DVR_THUMBNAILS_COND;

typedef struct    tagNET_DVR_THUMBNAILS_RESULT   //查找结果结构体
{
    BYTE     byResultDataType;      // 查找结果数据类型0-I帧数据（CVR 一路的情况下，1s最多28个I帧），1-系统头数据， 2-图片数据
    BYTE     byIFrameType;          // I帧类型，0-数据帧，1-参考帧（本数据只需送入播放库，但是不需要转为图片显示）
    BYTE     byRes1[2];                // 保留字节
    NET_DVR_TIME_SEARCH struTime;        //数据时间
    BYTE     byRes[252];            // 保留字节
    DWORD   dwFileSize;            //数据大小
    char*     pBuffer;                //数据信息(数据类型和条件结构体中NET_DVR_THUMBNAILS_RESULT 的字段 byResultDataType 值相关)
}NET_DVR_THUMBNAILS_RESULT, *LPNET_DVR_THUMBNAILS_RESULT;

typedef struct tagNET_DVR_REGIONENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    /*
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    */
    BYTE byDetectionTarget;
    BYTE byAlarmConfidence;    // 报警置信度, 0-低,1-较低,2-较高,3-高
    BYTE byRecordConfidence;    // 录像置信度, 0-低,1-较低,2-较高,3-高
    BYTE byRes[60];             //保留
}NET_DVR_REGIONENTRANCE_REGION, *LPNET_DVR_REGIONENTRANCE_REGION;


typedef struct tagNET_DVR_SMART_REGION_COND
{
    DWORD dwSize; 
    DWORD dwChannel;        //通道号 
    DWORD dwRegion;         //区域ID号
}NET_DVR_SMART_REGION_COND, *LPNET_DVR_SMART_REGION_COND;

typedef struct tagNET_DVR_ENTRANCE_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byDetectionTarget;
    BYTE byAlarmConfidence;    //报警置信度, 0-低,1-较低,2-较高,3-高
    BYTE byRecordConfidence;   //录像置信度, 0-低,1-较低,2-较高,3-高
    BYTE byRes[60];            //保留
}NET_DVR_ENTRANCE_REGION, *LPNET_DVR_ENTRANCE_REGION;

typedef struct tagNET_DVR_DENSEFOGDETECTION_CFG
{
    DWORD dwSize;
    BYTE    byEnable;//使能
    BYTE   bySensitivity;  //灵敏度参数，范围[0,100]
    BYTE   byRes[258];
}NET_DVR_DENSEFOGDETECTION_CFG, *LPNET_DVR_DENSEFOGDETECTION_CFG;



typedef struct  tagNET_DVR_ANR_ARMING_HOST
{
    DWORD   dwSize;//sizeof(NET_DVR_ANR_ ARMING_HOST)
    NET_DVR_IPADDR struANRArmingHostIpAddr; //断网续传的主机IP地址
    WORD    wANRAlarmHostPort; //断网续传的主机布防端口号
    BYTE     byANRAlarmType;//断网续传连接类型， 0-SDK私有断网续传连接，1-ehome断网续传连接
    BYTE     byConfirmMechanismEnabled;// 是否开启确认机制方式布防连接，0-保留，1-没有开启 2-开启
    BYTE     byRes[512];      //保留字节
}NET_DVR_ANR_ARMING_HOST, *LPNET_DVR_ANR_ARMING_HOST;

typedef struct tagNET_DVR_REGIONEXITING_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    /*
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    */
    BYTE byDetectionTarget;
    BYTE byAlarmConfidence;     //报警置信度, 0-低,1-较低,2-较高,3-高
    BYTE byRecordConfidence;    //录像置信度, 0-低,1-较低,2-较高,3-高
    BYTE byRes[60];             //保留
}NET_DVR_REGIONEXITING_REGION, *LPNET_DVR_REGIONEXITING_REGION;


typedef struct tagNET_DVR_LOITERING_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byTimeThreshold; //时间阈值，范围[0-10]，单位：s
    BYTE byRes[62];             //保留
}NET_DVR_LOITERING_REGION, *LPNET_DVR_LOITERING_REGION;


typedef struct tagNET_DVR_GROUPDETECTION_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE byObjectOccup; //占比，范围[1-100]
    BYTE bySensitivityLevel; //灵敏度，范围1-100，默认65
    BYTE byDurationTime; //持续时间，范围1-600秒，默认3秒
    BYTE byFilterTime; //过滤时间，范围1-10分钟（表示，触发报警后，在此时间内不再触发报警）
    BYTE byMinTriggerNumber; //最低触发人数，范围2-50人，默认5人
    BYTE byLinkageTime; //联动球机检测时间，范围5-30秒，默认5秒（枪机触发后，联动球机转到触发报警的位置后停留的时间，该配置不区分枪机球机是否同一个账户登录，可以不同）
    BYTE byRes[58];             //保留
}NET_DVR_GROUPDETECTION_REGION, *LPNET_DVR_GROUPDETECTION_REGION;

typedef struct tagNET_DVR_POS_HIDDEN_INFORMATION
{
    char szKeyWord[KEY_WORD_NUM/*3*/][KEY_WORD_LEN/*128*/];
    BYTE    byRes[128];
}NET_DVR_POS_HIDDEN_INFORMATION, *LPNET_DVR_POS_HIDDEN_INFORMATION;

typedef struct tagNET_DVR_HIDDEN_INFORMATION_CFG
{
    DWORD  dwSize;
    BYTE   byFuncType;//0-Pos功能
    BYTE   Res1[3];
    NET_DVR_POS_HIDDEN_INFORMATION struPosInfo;
    BYTE    byRes[1024];
}NET_DVR_HIDDEN_INFORMATION_CFG, *LPNET_DVR_HIDDEN_INFORMATION_CFG;


typedef struct tagNET_DVR_RAPIDMOVE_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    /*
    检测目标，可支持多选，具体定义为：
    0~所有目标（表示不锁定检测目标，所有目标都将进行检测）
    0x01 ~ 人，
    0x02 ~ 车，
    0x04 ~ 其他，
    该字段支持多选，按位取值，例如3表示1+2.
    */
    BYTE byDetectionTarget;
    BYTE byRes[62];             //保留
}NET_DVR_RAPIDMOVE_REGION, *LPNET_DVR_RAPIDMOVE_REGION;


typedef struct tagNET_DVR_PARKING_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byTimeThreshold; //时间阈值，范围[0-10]，单位：s
    BYTE byRes[62];             //保留
}NET_DVR_PARKING_REGION, *LPNET_DVR_PARKING_REGION;


typedef struct tagNET_DVR_UNATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byTimeThreshold; //时间阈值，范围[0-10]，单位：s
    WORD wTimeThreshold;//时间阈值，范围[5-3600], 单位：s
    BYTE byTimeThresholdMode;//(只写字段，用于兼容区域)0-字段byTimeThreshold生效，1-字段wTimeThreshold生效
    BYTE byRes[59];             //保留留
}NET_DVR_UNATTENDED_BAGGAGE_REGION, *LPNET_DVR_UNATTENDED_BAGGAGE_REGION;


typedef struct tagNET_DVR_ATTENDED_BAGGAGE_REGION
{
    NET_VCA_POLYGON struRegion;//区域范围
    BYTE bySensitivity;        //灵敏度参数，范围[1-100]
    BYTE byTimeThreshold; //时间阈值，范围[0-10]，单位：s
    WORD wTimeThreshold;//时间阈值，范围[5-3600], 单位：s
    BYTE byTimeThresholdMode;//(只写字段，用于兼容区域)0-字段byTimeThreshold生效，1-字段wTimeThreshold生效
    BYTE byRes[59];             //保留
}NET_DVR_ATTENDED_BAGGAGE_REGION, *LPNET_DVR_ATTENDED_BAGGAGE_REGION;


typedef struct tagNET_DVR_REGION_CLIP_COND
{
    DWORD dwSize; 
    DWORD dwChannel;        //通道号 
    DWORD dwStreamType;     //码流类型：0- 主码流，1- 子码流，2- 第三码流
    BYTE   byRes[8];
}NET_DVR_REGION_CLIP_COND, *LPNET_DVR_REGION_CLIP_COND;

typedef struct tagNET_DVR_REGION_CLIP_CFG
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否使能：0- 否，1- 是
    BYTE        byRes1[3];
    WORD      wResolutionWidth; //分辨率的长
    WORD      wResolutionHeight; //分辨率的宽
    NET_VCA_POLYGON    struRegion[MAX_REGION_NUM];
    BYTE        byRes2[64];
}NET_DVR_REGION_CLIP_CFG, *LPNET_DVR_REGION_CLIP_CFG;

typedef struct tagNET_DVR_WIRELESSDIAL_CFG
{
    DWORD        dwSize;//结构体大小
    BYTE        byEnabled;  //是否启用无线拨号：0-否，1- 是
    BYTE       byDialMode; // 0-自动（Auto）、1-手动（Manual），默认自动，手动模式下可设置拨号计划、下线时间、手动拨号
    BYTE       byNetworkMode; //0-自动，1-4G优先，2-3G优先，3-手动切换2G，4-手动切换3G，5-手动切换4G，6-有线优先
    BYTE        byRes1;
    BYTE       byDialNum[MAX_DIALNUM_LENGTH]; //拨号号码
    BYTE       byUserName[NAME_LEN]; //用户名
    BYTE       byPassword[NAME_LEN]; //密码
    BYTE       byAPNName[NAME_LEN];  //APN
    BYTE       byUIMCardNum[NAME_LEN];  //手机号码
    BYTE       byVerifProtocol;  // 0-自动（Auto），1-CHAP，2-PAP
    BYTE       byRes2;
    WORD      wMTU; //MTU
    DWORD      dwOffineTime;  //下线时间，30-65535，单位秒，手动模式下有效
    BYTE       byNetAPN[NAME_LEN];  //私有专网APN字段配置
    BYTE       byEnabled4G;  //是否开启4G功能：0-否，1- 是
    BYTE       byEnabledDNS;  //是否开启DNS功能：0-否，1- 是
    BYTE       byRes3[30];
}NET_DVR_WIRELESSDIAL_CFG, *LPNET_DVR_WIRELESSDIAL_CFG;





typedef struct tagNET_DVR_CALIBRATION
{
    DWORD            dwSize;//结构体大小
    NET_VCA_POLYGON  struRegion;//标定区域
    BYTE        byRes[64];
}NET_DVR_CALIBRATION,*LPNET_DVR_CALIBRATION;



typedef struct tagNET_DVR_STD_CONTROL
{
    void*        lpCondBuffer;    //[in]条件参数(码字格式),例如通道号等.可以为NULL
    DWORD        dwCondSize;        //[in] dwCondSize指向的内存大小
    void*        lpStatusBuffer;    //[out]返回的状态参数(XML格式),获取成功时不会赋值,如果不需要,可以置NULL
    DWORD        dwStatusSize;    //[in] lpStatusBuffer指向的内存大小
    void*       lpXmlBuffer;    //[in/out]byDataType = 1时有效,xml格式数据
    DWORD       dwXmlSize;      //[in/out]lpXmlBuffer指向的内存大小,获取时同时作为输入和输出参数，获取成功后会修改会实际长度，设置时表示实际长度，而不是整个内存大小
    BYTE        byDataType;     //[in]输入/输出参数类型,0-使用结构体类型lpCondBuffer有效,1-使用XML类型lpXmlBuffer有效
    BYTE        byRes[55];
}NET_DVR_STD_CONTROL, *LPNET_DVR_STD_CONTROL;

typedef struct tagNET_DVR_MIME_UNIT
{
    //格式如下
    //Content-Disposition: form-data; name="upload"; filename="C:\Users\test\Desktop\11.txt"
    //Content-Type: text/plain
    char szContentType[32];               //对应Content-Type
    char szName[MAX_FILE_PATH_LEN];       //对应name字段
    char szFilename[MAX_FILE_PATH_LEN];   //对应filename字段
    DWORD dwContentLen;                   //Content的长度，大小限制512K以内
    char* pContent;                       //数据指针
    BYTE bySelfRead;                 // 0-外界传入文件 1-内部读取数据（通过szFilename传递完整路径），下发数据时该字段生效，获取数据时无效
    BYTE byRes[15];
}NET_DVR_MIME_UNIT, *LPNET_DVR_MIME_UNIT;

typedef struct tagNET_DVR_MIME_DATA
{
    BYTE  byContentType;   //文件类型 0-无效, 1-json, 2-bmp
    BYTE  byRes1[3];    //保留
    void  *lpContent;  //文件内容，如果指针为空，表示无文件
    DWORD  dwContentSize;  //文件内容大小，大小限制为512k以内
    char  sContentID[32];      //表单格式中Content-ID头域的值，与ISAPI报文中特定节点值一一对应
    BYTE  byRes[512];  //保留
}NET_DVR_MIME_DATA, *LPNET_DVR_MIME_DATA;

typedef struct tagNET_DVR_XML_CONFIG_INPUT
{
    DWORD   dwSize;                     //结构体大小
    void*   lpRequestUrl;               //请求信令，字符串格式
    DWORD   dwRequestUrlLen;            //请求信令长度，字符串长度
    void*   lpInBuffer;                 //输入参数缓冲区，XML格式
    DWORD   dwInBufferSize;             //输入参数缓冲区大小
    DWORD   dwRecvTimeOut;              //接收超时时间，单位：ms，填0则使用默认超时5s
    BYTE    byForceEncrpt;              //是否强制加密，0-否，1-是
    BYTE    byNumOfMultiPart;           //0-无效，其他值表示报文分段个数，非零时lpInBuffer传入的是NET_DVR_MIME_UNIT结构体数组的指针，该值即代表结构体个数
    BYTE    byMIMEType;               //0-无效，1-表示使用NET_DVR_MIME_UNIT结构体，2-表示使用NET_DVR_MIME_DATA结构体，该字段仅在byNumOfMultiPart有效时生效
    BYTE    byRes[29];
}NET_DVR_XML_CONFIG_INPUT, *LPNET_DVR_XML_CONFIG_INPUT;

typedef struct tagNET_DVR_XML_CONFIG_OUTPUT
{
    DWORD   dwSize;                        //结构体大小
    void*    lpOutBuffer;                //输出参数缓冲区，XML格式
    DWORD    dwOutBufferSize;            //输出参数缓冲区大小(内存大小)
    DWORD   dwReturnedXMLSize;            //实际输出的XML内容大小
    void*    lpStatusBuffer;                //返回的状态参数(XML格式),获取命令成功时不会赋值,如果不需要,可以置NULL
    DWORD    dwStatusSize;                //状态缓冲区大小(内存大小)
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    void*     lpDataBuffer;                     //当byNumOfMultiPart>0时，配合报文结构体使用，存放透传数据内容，通过NET_DVR_MIME_UNIT的dwContentLen偏移访问
#else
    void*     lpDataBuffer;                     //当byNumOfMultiPart>0时，配合报文结构体使用，存放透传数据内容，通过NET_DVR_MIME_UNIT的dwContentLen偏移访问
    BYTE    byRes2[4];
#endif  
    BYTE    byNumOfMultiPart;           //0-无效。 其他值表示报文分段个数，非零时lpInBuffer传入的是NET_DVR_MIME_UNIT结构体数组的指针，该值即代表结构体个数。
    BYTE    byRes[23];
}NET_DVR_XML_CONFIG_OUTPUT, *LPNET_DVR_XML_CONFIG_OUTPUT;

typedef struct tagNET_DVR_FORM_DATA_CFG
{
    DWORD  dwSize;  //结构体大小
    void  *lpBuffer;  //数据缓冲区，指向NET_DVR_MIME_DATA结构体数组
    DWORD  dwBufferSize;  //数据缓冲区大小
    BYTE byNumOfMultiPart;  // 0-无效，其他值表示报文分段个数，非零时lpBuffer传入的是NET_DVR_MIME_DATA结构体数组的指针，该值即代表结构体个数，限制最多为3个
    BYTE   byRes[67];  //保留
}NET_DVR_FORM_DATA_CFG, *LPNET_DVR_FORM_DATA_CFG;

typedef struct tagNET_DVR_JSON_DATA_CFG
{
    DWORD  dwSize;  //结构体大小
    void  *lpJsonData;  //JSON报文
    DWORD  dwJsonDataSize;  //JSON报文大小
    void  *lpPicData;  //图片内容
    DWORD  dwPicDataSize;  //图片内容大小
    DWORD   dwInfraredFacePicSize;   //红外人脸图片数据大小，等于0时，代表无人脸图片数据(当JSON报文为当ResponseStatus（JSON）报文时，该字段无意义；当Inbound Data（JSON）报文中没有infraredFaceURL时，该字段需要带上二进制图片内容）
    void*  lpInfraredFacePicBuffer;      //红外人脸图片数据缓存
    BYTE   byRes[248];  //保留
}NET_DVR_JSON_DATA_CFG, *LPNET_DVR_JSON_DATA_CFG;

typedef struct tagNET_DVR_SIMPLE_DAYTIME
{
    BYTE byHour; //时
    BYTE byMinute; //分
    BYTE bySecond; //秒
    BYTE byRes;
}NET_DVR_SIMPLE_DAYTIME, *LPNET_DVR_SIMPLE_DAYTIME;

typedef struct tagNET_DVR_TIME_SEGMENT
{
    NET_DVR_SIMPLE_DAYTIME struBeginTime; //开始时间点
    NET_DVR_SIMPLE_DAYTIME struEndTime;   //结束时间点
}NET_DVR_TIME_SEGMENT, *LPNET_DVR_TIME_SEGMENT;

typedef struct tagNET_DVR_SINGLE_PLAN_SEGMENT
{
    BYTE byEnable; //是否使能，1-使能，0-不使能
    BYTE byDoorStatus; //门状态模式（梯控模式），0-无效，1-休眠，2-常开状态（自由），3-常闭状态（禁用），4-普通状态（门状态计划使用）
    BYTE byVerifyMode; //验证方式，0-无效，1-刷卡，2-刷卡+密码(读卡器验证方式计划使用)，3-刷卡,4-刷卡或密码(读卡器验证方式计划使用), 5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码（无先后顺序），10-人脸或指纹或刷卡或密码，11-人脸+指纹，
    //12-人脸+密码，13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡,23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸,26-刷卡或人脸或指纹,
    //27-刷卡或指纹或密码,28-人脸或密码,29-工号+人脸+密码,30-刷卡或人脸或人脸+刷卡，31-人脸或指纹或密码，32-虹膜，33-人脸或指纹或刷卡或密码或虹膜，34-人脸或刷卡或密码或虹膜
    BYTE byRes[5];
    NET_DVR_TIME_SEGMENT struTimeSegment; //时间段参数
}NET_DVR_SINGLE_PLAN_SEGMENT, *LPNET_DVR_SINGLE_PLAN_SEGMENT;

typedef struct tagNET_DVR_WEEK_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //是否使能，1-使能，0-不使能
    BYTE byRes1[3];
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_DAYS][MAX_TIMESEGMENT_V30]; //周计划参数
    BYTE byRes2[16];
}NET_DVR_WEEK_PLAN_CFG, *LPNET_DVR_WEEK_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_PLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否使能，1-使能，0-不使能
    BYTE byRes1[3];    
    NET_DVR_DATE struBeginDate; //假日开始日期
    NET_DVR_DATE struEndDate; //假日结束日期
    NET_DVR_SINGLE_PLAN_SEGMENT struPlanCfg[MAX_TIMESEGMENT_V30]; //时间段参数
    BYTE byRes2[16];
}NET_DVR_HOLIDAY_PLAN_CFG, *LPNET_DVR_HOLIDAY_PLAN_CFG;

typedef struct tagNET_DVR_HOLIDAY_PLAN_COND
{
    DWORD dwSize;
    DWORD dwHolidayPlanNumber; //假日计划编号
    WORD wLocalControllerID; //就地控制器序号[1,64]
    BYTE byRes[106];
}NET_DVR_HOLIDAY_PLAN_COND, *LPNET_DVR_HOLIDAY_PLAN_COND;

typedef struct tagNET_DVR_WEEK_PLAN_COND
{
    DWORD dwSize;
    DWORD dwWeekPlanNumber; //周计划编号
    WORD wLocalControllerID; //就地控制器序号[1,64]
    BYTE byRes[106];
}NET_DVR_WEEK_PLAN_COND, *LPNET_DVR_WEEK_PLAN_COND;

typedef struct tagNET_DVR_HOLIDAY_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否启用，1-启用，0-不启用
    BYTE byRes1[3];
    BYTE byGroupName[HOLIDAY_GROUP_NAME_LEN]; //假日组名称
    DWORD dwHolidayPlanNo[MAX_HOLIDAY_PLAN_NUM]; //假日计划编号，就前填充，遇0无效
    BYTE byRes2[32];
}NET_DVR_HOLIDAY_GROUP_CFG, *LPNET_DVR_HOLIDAY_GROUP_CFG;

typedef struct tagNET_DVR_HOLIDAY_GROUP_COND
{
    DWORD dwSize;
    DWORD dwHolidayGroupNumber; //假日组编号
    WORD wLocalControllerID; //就地控制器序号[1,64]
    BYTE byRes[106];
}NET_DVR_HOLIDAY_GROUP_COND, *LPNET_DVR_HOLIDAY_GROUP_COND;

typedef struct tagNET_DVR_PLAN_TEMPLATE
{
    DWORD dwSize;
    BYTE byEnable; //是否启用，1-启用，0-不启用
    BYTE byRes1[3];
    BYTE byTemplateName[TEMPLATE_NAME_LEN]; //模板名称
    DWORD dwWeekPlanNo; //周计划编号，0为无效
    DWORD dwHolidayGroupNo[MAX_HOLIDAY_GROUP_NUM]; //假日组编号，就前填充，遇0无效
    BYTE byRes2[32];
}NET_DVR_PLAN_TEMPLATE, *LPNET_DVR_PLAN_TEMPLATE;

typedef struct tagNET_DVR_PLAN_TEMPLATE_COND
{
    DWORD dwSize;
    DWORD dwPlanTemplateNumber; //计划模板编号，从1开始，最大值从门禁能力集获取
    WORD wLocalControllerID; //就地控制器序号[1,64]，0无效
    BYTE byRes[106];
}NET_DVR_PLAN_TEMPLATE_COND, *LPNET_DVR_PLAN_TEMPLATE_COND;

typedef struct tagNET_DVR_DOOR_STATUS_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //计划模板编号，为0表示取消关联，恢复默认状态（普通状态）
    BYTE byRes[64];
}NET_DVR_DOOR_STATUS_PLAN, *LPNET_DVR_DOOR_STATUS_PLAN;

typedef struct tagNET_DVR_CARD_READER_PLAN
{
    DWORD dwSize;
    DWORD dwTemplateNo; //计划模板编号，为0表示取消关联，恢复默认状态（刷卡开门）
    BYTE byRes[64];
}NET_DVR_CARD_READER_PLAN, *LPNET_DVR_CARD_READER_PLAN;

typedef struct _tagNET_DVR_GROUP_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否启用，0-不启用，1-启用    
    BYTE byRes1[3];
    NET_DVR_VALID_PERIOD_CFG struValidPeriodCfg; //群组有效期参数
    BYTE byGroupName[GROUP_NAME_LEN]; //群组名称
    BYTE byRes2[32];
}NET_DVR_GROUP_CFG, *LPNET_DVR_GROUP_CFG;

typedef struct tagNET_DVR_GROUP_COMBINATION_INFO
{
    BYTE byEnable; //是否启用该群组组合    
    BYTE byMemberNum; //刷卡成员数量
    BYTE bySequenceNo; //群组刷卡次序号
    BYTE byRes;
    DWORD dwGroupNo;  //群组编号,0xffffffff表示远程开门，0xfffffffe表示超级密码
}NET_DVR_GROUP_COMBINATION_INFO, *LPNET_DVR_GROUP_COMBINATION_INFO;

typedef struct tagNET_DVR_MULTI_CARD_GROUP_CFG
{
    BYTE byEnable; //是否启用该多重卡组参数，0-不启用，1-启用
    BYTE byEnableOfflineVerifyMode; //是否启用主机离线时验证方式（超级密码代替远程开门）
    BYTE byRes1[2];
    DWORD dwTemplateNo; //启用多重卡功能的计划模板编号
    NET_DVR_GROUP_COMBINATION_INFO struGroupCombination[GROUP_COMBINATION_NUM]; //群组组合参数
}NET_DVR_MULTI_CARD_GROUP_CFG, *LPNET_DVR_MULTI_CARD_GROUP_CFG;

typedef struct tagNET_DVR_MULTI_CARD_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否启用多重卡功能，0-不启用，1-启用
    BYTE bySwipeIntervalTimeout; //刷卡间隔超时时间，1-255s，默认10s    
    BYTE byRes1[2];
    NET_DVR_MULTI_CARD_GROUP_CFG struGroupCfg[MULTI_CARD_GROUP_NUM]; //群组刷卡参数
    BYTE byRes2[32];    
}NET_DVR_MULTI_CARD_CFG, *LPNET_DVR_MULTI_CARD_CFG;

typedef struct tagNET_DVR_GROUP_COMBINATION_INFO_V50
{
    BYTE byEnable; //是否启用该群组组合
    BYTE byMemberNum; //刷卡成员数量
    BYTE bySequenceNo; //群组刷卡次序号
    BYTE byRes;
    DWORD dwGroupNo;  //群组编号,0xffffffff表示远程开门，0xfffffffe表示超级密码
}NET_DVR_GROUP_COMBINATION_INFO_V50, *LPNET_DVR_GROUP_COMBINATION_INFO_V50;

typedef struct tagNET_DVR_MULTI_CARD_GROUP_CFG_V50
{
    BYTE byEnable; //是否启用该多重卡组参数，0-不启用，1-启用
    BYTE byEnableOfflineVerifyMode; //是否启用主机离线时验证方式（超级密码代替远程开门），1-启用，0-不启用
    BYTE byRes1[2];
    DWORD dwTemplateNo; //启用多重卡功能的计划模板编号
    NET_DVR_GROUP_COMBINATION_INFO_V50 struGroupCombination[GROUP_COMBINATION_NUM]; //群组组合参数
}NET_DVR_MULTI_CARD_GROUP_CFG_V50, *LPNET_DVR_MULTI_CARD_GROUP_CFG_V50;

typedef struct tagNET_DVR_MULTI_CARD_CFG_V50
{
    DWORD dwSize;
    BYTE byEnable; //是否启用多重卡功能，0-不启用，1-启用
    BYTE bySwipeIntervalTimeout; //刷卡间隔超时时间，1-255s，默认10s
    BYTE byRes1[2];
    NET_DVR_MULTI_CARD_GROUP_CFG_V50 struGroupCfg[NET_SDK_MULTI_CARD_GROUP_NUM_20]; //群组刷卡参数
    BYTE byRes2[32];
}NET_DVR_MULTI_CARD_CFG_V50, *LPNET_DVR_MULTI_CARD_CFG_V50;

typedef struct 
{
    DWORD  dwSize;//结构体大小
    WORD   wPort;  //端口号
    //(设备通过端口控制（端口号设备端固定，上层不做配置），开始单独socket连接，单独交互T1测试内容，走XML格式)
    //0- 关闭(关闭设备的连接线程，释放端口)，1- 开启(设备内部单独起连接线程)
    BYTE   byPortState;  
    BYTE   byRes[61];     //保留
}NET_DVR_T1TEST_PARAMCFG,*LPNET_DVR_T1TEST_PARAMCFG;

typedef struct tagNET_DVR_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //使能反潜回功能，1-使能，0-不使能
    BYTE byRes1[3];
    DWORD dwStartCardReaderNo; //反潜回起始读卡器编号    
    BYTE byRes2[64];
}NET_DVR_ANTI_SNEAK_CFG, *LPNET_DVR_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_CARD_READER_ANTI_SNEAK_CFG
{
    DWORD dwSize;
    BYTE byEnable;  //是否加入反潜回路径，1-加入，0-不加入
    BYTE byRes1[3];
    DWORD dwFollowUpCardReader[MAX_SNEAK_PATH_NODE]; //后续读卡器编号，为0表示不关注起始读卡器编号
    BYTE byRes2[32];
}NET_DVR_CARD_READER_ANTI_SNEAK_CFG, *LPNET_DVR_CARD_READER_ANTI_SNEAK_CFG;

typedef struct tagNET_DVR_PHONE_DOOR_RIGHT_CFG
{
    DWORD   dwSize;
    BYTE    byOpenRight[MAX_DOOR_NUM_256];         //按数组表示,是否有开门权限，-无权限，-有权限
    BYTE    byCloseRight[MAX_DOOR_NUM_256];        //按数组表示,是否有关门权限，-无权限，-有权限
    BYTE    byNormalOpenRight[MAX_DOOR_NUM_256];   //按数组表示,是否有常开权限，-无权限，-有权限
    BYTE    byNormalCloseRight[MAX_DOOR_NUM_256];  //按数组表示,是否有常闭权限，-无权限，-有权限
    BYTE    byArmRight[MAX_ALARMHOST_ALARMIN_NUM]; //按数组表示,是否有布防权限，-无权限，-有权限
    BYTE    byDisarmRight[MAX_ALARMHOST_ALARMIN_NUM];  //按数组表示,是否有撤防权限，-无权限，-有权限
    BYTE    byRes[256];                              //保留
}NET_DVR_PHONE_DOOR_RIGHT_CFG,*LPNET_DVR_PHONE_DOOR_RIGHT_CFG;

typedef struct tagNET_DVR_MULTI_DOOR_INTERLOCK_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否启用多门互锁功能，1-启用，0-不启用
    BYTE byRes1[3];
    DWORD dwMultiDoorGroup[MAX_MULTI_DOOR_INTERLOCK_GROUP][MAX_INTER_LOCK_DOOR_NUM]; //多门互锁组参数，取值为门编号
    BYTE byRes2[64];
}NET_DVR_MULTI_DOOR_INTERLOCK_CFG, *LPNET_DVR_MULTI_DOOR_INTERLOCK_CFG;

typedef struct tagNET_DVR_CARD_READER_CFG
{
    DWORD dwSize;
    BYTE byEnable; //是否使能，1-使能，0-不使能
    BYTE byCardReaderType; //读卡器类型，1-DS-K110XM/MK/C/CK，2-DS-K192AM/AMP，3-DS-K192BM/BMP，4-DS-K182AM/AMP，5-DS-K182BM/BMP，6-DS-K182AMF/ACF，7-韦根或485不在线,8- DS-K1101M/MK，9- DS-K1101C/CK，10- DS-K1102M/MK/M-A
                            //11- DS-K1102C/CK，12- DS-K1103M/MK，13- DS-K1103C/CK，14- DS-K1104M/MK，15- DS-K1104C/CK，16- DS-K1102S/SK/S-A，17- DS-K1102G/GK，18- DS-K1100S-B，19- DS-K1102EM/EMK，20- DS-K1102E/EK，
                            //21- DS-K1200EF，22- DS-K1200MF，23- DS-K1200CF，24- DS-K1300EF，25- DS-K1300MF，26- DS-K1300CF，27- DS-K1105E，28- DS-K1105M，29- DS-K1105C，30- DS-K182AMF，31- DS-K196AMF，32-DS-K194AMP
                            //33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C，35-DS-K1T105E/E-C/M/M-C/C/C-C，36-DS-K1T803F/MF/SF/EF，37-DS-K1A801F/MF/SF/EF,38-DS-K1107M/MK,39-DS-K1107E/EK,
                            //40-DS-K1107S/SK,41-DS-K1108M/MK,42-DS-K1108E/EK,43-DS-K1108S/SK,44-DS-K1200F,45-DS-K1S110-I,46-DS-K1T200M-PG/PGC,47-DS-K1T200M-PZ/PZC,48-DS-K1109H
    BYTE byOkLedPolarity; //OK LED极性，0-阴极，1-阳极
    BYTE byErrorLedPolarity; //Error LED极性，0-阴极，1-阳极
    BYTE byBuzzerPolarity; //蜂鸣器极性，0-阴极，1-阳极
    BYTE bySwipeInterval; //重复刷卡间隔时间，单位：秒
    BYTE byPressTimeout;  //按键超时时间，单位：秒
    BYTE byEnableFailAlarm; //是否启用读卡失败超次报警，0-不启用，1-启用
    BYTE byMaxReadCardFailNum; //最大读卡失败次数
    BYTE byEnableTamperCheck;  //是否支持防拆检测，0-disable ，1-enable
    BYTE byOfflineCheckTime;  //掉线检测时间 单位秒
    BYTE byFingerPrintCheckLevel;   //指纹识别等级，1-1/10误认率，2-1/100误认率，3-1/1000误认率，4-1/10000误认率，5-1/100000误认率，6-1/1000000误认率，7-1/10000000误认率，8-1/100000000误认率，9-3/100误认率，10-3/1000误认率，11-3/10000误认率，12-3/100000误认率，13-3/1000000误认率，14-3/10000000误认率，15-3/100000000误认率，16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure
    BYTE byUseLocalController; //只读，是否连接在就地控制器上，0-否，1-是
    BYTE byRes1;
    WORD wLocalControllerID; //只读，就地控制器序号，1-64,0代表未注册
    WORD wLocalControllerReaderID; //只读，就地控制器的读卡器ID，0代表未注册
    WORD wCardReaderChannel; //只读，读卡器通信通道号，0韦根或离线，1-RS485A,2-RS485B
    BYTE byRes[16];
}NET_DVR_CARD_READER_CFG, *LPNET_DVR_CARD_READER_CFG;

typedef struct tagNET_DVR_CARD_READER_CFG_V50
{
    DWORD dwSize;
    BYTE byEnable; //是否使能，1-使能，0-不使能
    BYTE byCardReaderType; //读卡器类型，1-DS-K110XM/MK/C/CK，2-DS-K192AM/AMP，3-DS-K192BM/BMP，4-DS-K182AM/AMP，5-DS-K182BM/BMP，6-DS-K182AMF/ACF，7-韦根或485不在线，8- DS-K1101M/MK，9- DS-K1101C/CK，10- DS-K1102M/MK/M-A，11- DS-K1102C/CK，12- DS-K1103M/MK，13- DS-K1103C/CK，14- DS-K1104M/MK，15- DS-K1104C/CK，16- DS-K1102S/SK/S-A，17- DS-K1102G/GK，18- DS-K1100S-B，19- DS-K1102EM/EMK，20- DS-K1102E/EK，21- DS-K1200EF，22- DS-K1200MF，23- DS-K1200CF，24- DS-K1300EF，25- DS-K1300MF，26- DS-K1300CF，27- DS-K1105E，28- DS-K1105M，29- DS-K1105C，30- DS-K182AMF，31- DS-K196AMF，32-DS-K194AMP，33-DS-K1T200EF/EF-C/MF/MF-C/CF/CF-C,34-DS-K1T300EF/EF-C/MF/MF-C/CF/CF-C，35-DS-K1T105E/E-C/M/M-C/C/C-C,36-DS-K1T803F/F-M/F-S/F-E,37-DS-K1A801F/F-M/F-S/F-E,38-DS-K1107M/MK,39-DS-K1107E/EK,40-DS-K1107S/SK,41-DS-K1108M/MK,42-DS-K1108E/EK,43-DS-K1108S/SK,44-DS-K1200F,45-DS-K1S110-I,46-DS-K1T200M-PG/PGC,47-DS-K1T200M-PZ/PZC,48-DS-K1109H
    BYTE byOkLedPolarity; //OK LED极性，0-阴极，1-阳极
    BYTE byErrorLedPolarity; //Error LED极性，0-阴极，1-阳极
    BYTE byBuzzerPolarity; //蜂鸣器极性，0-阴极，1-阳极
    BYTE bySwipeInterval; //重复刷卡间隔时间，单位：秒
    BYTE byPressTimeout;  //按键超时时间，单位：秒
    BYTE byEnableFailAlarm; //是否启用读卡失败超次报警，0-不启用，1-启用
    BYTE byMaxReadCardFailNum; //最大读卡失败次数
    BYTE byEnableTamperCheck;  //是否支持防拆检测，0-disable ，1-enable
    BYTE byOfflineCheckTime;  //掉线检测时间 单位秒
    BYTE byFingerPrintCheckLevel; //指纹识别等级，1-1/10误认率，2-1/100误认率，3-1/1000误认率，4-1/10000误认率，5-1/100000误认率，6-1/1000000误认率，7-1/10000000误认率，8-1/100000000误认率，9-3/100误认率，10-3/1000误认率，11-3/10000误认率，12-3/100000误认率，13-3/1000000误认率，14-3/10000000误认率，15-3/100000000误认率，16-Automatic Normal,17-Automatic Secure,18-Automatic More Secure（目前门禁不支持）
    BYTE byUseLocalController; //只读，是否连接在就地控制器上，0-否，1-是
    BYTE  byRes1;
    WORD wLocalControllerID; //只读，就地控制器序号, byUseLocalController=1时有效，1-64,0代表未注册
    WORD wLocalControllerReaderID; //只读，就地控制器的读卡器ID，byUseLocalController=1时有效，0代表未注册
    WORD wCardReaderChannel; //只读，读卡器通信通道号，byUseLocalController=1时有效，0韦根或离线，1-RS485A,2-RS485B
    BYTE byFingerPrintImageQuality; //指纹图像质量，0-无效，1-低质量(V1)，2-中等质量(V1)，3-高质量(V1)，4-最高质量(V1)，5-低质量(V2)，6-中等质量(V2)，7-高质量(V2)，8-最高质量(V2)
    BYTE byFingerPrintContrastTimeOut; //指纹对比超时时间，0-无效，范围1-20代表:1s-20s，0xff-无限大
    BYTE byFingerPrintRecogizeInterval; //指纹连续识别间隔，0-无效，范围1-10代表:1s-10s，0xff-无延迟
    BYTE byFingerPrintMatchFastMode; //指纹匹配快速模式，0-无效，范围1-5代表:快速模式1-快速模式5，0xff-自动
    BYTE byFingerPrintModuleSensitive; //指纹模组灵敏度，0-无效，范围1-8代表：灵敏度级别1-灵敏度级别8
    BYTE byFingerPrintModuleLightCondition; //指纹模组光线条件，0-无效，1-室外，2-室内
    BYTE byFaceMatchThresholdN; //人脸比对阀值，范围0-100
    BYTE byFaceQuality; //人脸质量，范围0-100
    BYTE byFaceRecogizeTimeOut; //人脸识别超时时间，范围1-20代表：1s-20s，0xff-无限大
    BYTE byFaceRecogizeInterval; //人脸连续识别间隔，0-无效，范围1-10代表：1s-10s，0xff-无延迟
    WORD wCardReaderFunction; //只读，读卡器种类，按位表示：第1位-指纹，第二位-人脸，第三位-指静脉，第四位-虹膜
    BYTE byCardReaderDescription[CARD_READER_DESCRIPTION]; //读卡器描述
    WORD wFaceImageSensitometry; //只读，人脸图像曝光度，范围0-65535
    BYTE byLivingBodyDetect; //真人检测，0-无效，1-不启用，2-启用
    BYTE byFaceMatchThreshold1; //人脸1:1匹配阀值，范围0-100
    WORD wBuzzerTime; //蜂鸣时间，范围0s-5999s（0-代表长鸣）
    BYTE byFaceMatch1SecurityLevel; //人脸1:1识别安全等级，0-无效，1-一般，2-较强，3-极强
    BYTE byFaceMatchNSecurityLevel; //人脸1:N识别安全等级，0-无效，1-一般，2-较强，3-极强
    BYTE byEnvirMode;//人脸识别环境模式，0-无效，1-室内，2-其他；
    BYTE byLiveDetLevelSet;//活体检测阈值等级设置，0-无效，1-低，2-中，3-高；
    BYTE byLiveDetAntiAttackCntLimit;//活体检测防攻击次数， 0-无效，1-255次（客户端、设备统一次数限制，根据能力级限制）；
    BYTE byEnableLiveDetAntiAttack;//活体检测防攻击使能，0-无效，1-不启用，2-启用
    BYTE bySupportDelFPByID;//只读，读卡器是否支持按手指ID删除指纹，0-无效，1-不支持，2-支持
    BYTE byFaceContrastMotionDetLevel;//人脸比对时移动侦测级别，0-无效，1-低，2-中，3-高，0xff-禁用
    BYTE byDayFaceMatchThresholdN; //白天人脸1:N匹配阀值，范围0-100
    BYTE byNightFaceMatchThresholdN; //夜晚人脸1:N匹配阀值，范围0-100
    BYTE byFaceRecogizeEnable; //人脸识别使能：0-无效，1-开启，2-关闭
    BYTE byBlockListMatchThreshold; //禁止名单匹配阀值，范围0-100
    BYTE byRes3;
    BYTE byDefaultVerifyMode; //只读，读卡器默认验证方式（出厂默认），1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码，5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码，10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡，23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码
    DWORD dwFingerPrintCapacity;//只读，指纹容量
    DWORD dwFingerPrintNum;//只读，已存在指纹数量
    BYTE byEnableFingerPrintNum;//只读，指纹容量使能：0-不使能，1-使能（只有当该字段为1-使能时，dwFingerPrintCapacity和dwFingerPrintNum才有效）
    BYTE byEnableReverseCardNo; //卡号翻转使能 0-不使能1-使能
    BYTE byRes2[2];
    DWORD dwIndependSwipeIntervals;//人员认证间隔（每个人单独计算间隔，区别于重复认证间隔）；
    BYTE byRes[224];
}NET_DVR_CARD_READER_CFG_V50, *LPNET_DVR_CARD_READER_CFG_V50;

typedef struct tagNET_DVR_FAILED_FACE_COND
{
    DWORD       dwSize;
    BYTE  byRes[128];          //保留
}NET_DVR_FAILED_FACE_COND, *LPNET_DVR_FAILED_FACE_COND;

typedef struct tagNET_DVR_FAILED_FACE_INFO
{
    DWORD  dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //人脸关联的卡号 
    BYTE  byErrorCode;  //建模失败详细错误,0-无效，1-读取文件失败，2-打开文件失败，3-内存不足，4-注册人脸失败，5-眼间距太小，6-卡权限不存在
    BYTE byRes1[3];
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //工号（人员ID）
    BYTE byRes[92];
}NET_DVR_FAILED_FACE_INFO, *LPNET_DVR_FAILED_FACE_INFO;

typedef struct tagNET_DVR_FACE_PARAM_COND
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];    //人脸关联的卡号（设置时该参数可不设置）
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //人脸的读卡器是否有效，0-无效，1-有效（设置时该参数可不设置）
    DWORD dwFaceNum;    //设置或获取人脸数量，获取时置为0xffffffff表示获取所有人脸信息
    BYTE  byFaceID;     //人脸编号，有效值范围为1-2   0xff表示该卡所有人脸（设置时该参数可不设置）
    BYTE  byRes[127];   //保留
}NET_DVR_FACE_PARAM_COND, *LPNET_DVR_FACE_PARAM_COND;

typedef struct tagNET_DVR_FACE_PARAM_CFG
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];    //人脸关联的卡号 
    DWORD dwFaceLen;    //人脸数据长度<DES加密处理>，设备端返回的即加密后的数据
    char* pFaceBuffer;  //人脸数据指针
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //需要下发人脸的读卡器，按数组表示，从低位到高位表示，0-不下发该读卡器，1-下发到该读卡器
    BYTE  byFaceID;     //人脸编号，有效值范围为1-2
    BYTE  byFaceDataType;   //人脸数据类型：0-模板（默认），1-图片
    BYTE  byRes[126];
}NET_DVR_FACE_PARAM_CFG, *LPNET_DVR_FACE_PARAM_CFG;

typedef struct tagNET_DVR_FACE_PARAM_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //人脸关联的卡号
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //人脸读卡器状态，按字节表示，0-失败，1-成功，2-重试或人脸质量差，3-内存已满(人脸数据满)，4-已存在该人脸，5-非法人脸ID
    //,6-算法建模失败，7-未下发卡权限，8-未定义（保留），9-人眼间距小距小，10-图片数据长度小于1KB，11-图片格式不符（png/jpg/bmp）,12-图片像素数量超过上限，13-图片像素数量低于下限，14-图片信息校验失败，15-图片解码失败，16-人脸检测失败，17-人脸评分失败
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //下发错误信息，当byCardReaderRecvStatus为4时，表示已存在人脸对应的卡号
    DWORD dwCardReaderNo;  //纹读卡器编号，可用于下发错误返回
    BYTE  byTotalStatus;  //下发总的状态，0-当前人脸未下完所有读卡器，1-已下完所有读卡器(这里的所有指的是门禁主机往所有的读卡器下发了，不管成功与否)
    BYTE  byFaceID;     //人脸编号，有效值范围为1-2
    BYTE  byRes[130];
}NET_DVR_FACE_PARAM_STATUS, *LPNET_DVR_FACE_PARAM_STATUS;

typedef struct tagNET_DVR_FACE_PARAM_BYCARD
{
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //人脸关联的卡号 
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //人脸的读卡器信息，按数组表示
    BYTE  byFaceID[MAX_FACE_NUM];        //需要删除的人脸编号，按数组下标，值表示0-不删除，1-删除该人脸
    BYTE  byRes1[42];          //保留
}NET_DVR_FACE_PARAM_BYCARD, *LPNET_DVR_FACE_PARAM_BYCARD;

typedef struct tagNET_DVR_FACE_PARAM_BYREADER
{
    DWORD dwCardReaderNo;  //按值表示，人脸读卡器编号
    BYTE  byClearAllCard;  //是否删除所有卡的人脸信息，0-按卡号删除人脸信息，1-删除所有卡的人脸信息
    BYTE  byRes1[3];       //保留
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //人脸关联的卡号 
    BYTE  byRes[548];          //保留
}NET_DVR_FACE_PARAM_BYREADER, *LPNET_DVR_FACE_PARAM_BYREADER;


typedef struct tagNET_DVR_FACE_PARAM_CTRL
{
    DWORD       dwSize;
    BYTE  byMode;          //删除方式，0-按卡号方式删除，1-按读卡器删除
    BYTE  byRes1[3];        //保留
    NET_DVR_DEL_FACE_PARAM_MODE struProcessMode;  //处理方式
    BYTE  byRes[64];          //保留
}NET_DVR_FACE_PARAM_CTRL, *LPNET_DVR_FACE_PARAM_CTRL;


typedef struct tagNET_DVR_LOCAL_CONTROLLER_STATUS
{
    DWORD            dwSize;
    WORD wLocalControllerID; //就地控制器序号(分控器序号)
    BYTE byLocalAntiDismantleStatus; //就地控制器防拆状态，0-关闭，1-开启
    BYTE byPowerSupplyStatus; //设备供电状态，1-交流电供电，2-蓄电池供电
    WORD wBatteryVoltage; //蓄电池电压值，实际值乘10，单位：伏特
    BYTE byBatteryLowVoltage; //蓄电池是否处于低压状态，0-否，1-是
    BYTE byFireAlarm; //消防报警，0-正常，1-短接报警，2-断开报警
    BYTE bySerialNumber[SERIALNO_LEN];  //设备序列号
    BYTE byMagneticStatus[MAX_DOOR_NUM];// 门磁状态：0正常关闭，1正常开启，2破坏短路报警，3破坏断路报警，4异常报警
    BYTE byDoorLockStatus[MAX_DOOR_NUM]; //门锁状态，0正常关闭，1正常开启，2破坏短路报警，3破坏断路报警，4异常报警  
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM]; //读卡器在线状态，0-不在线，1-在线
    WORD wLocalControllerStatus; //只读，就地控制器在线状态(分控器在线状态)：0-离线，1-网络在线，2-环路1上的RS485串口1，3-环路1上的RS485串口2，4-环路2上的RS485串口1，5-环路2上的RS485串口2，6-环路3上的RS485串口1，7-环路3上的RS485串口2，8-环路4上的RS485串口1，9-环路4上的RS485串口2（只读）
    BYTE byRes2[122];
}NET_DVR_LOCAL_CONTROLLER_STATUS, *LPNET_DVR_LOCAL_CONTROLLER_STATUS;

typedef struct tagNET_DVR_ONLINE_LOCAL_CONTROLLER_CFG
{
    DWORD            dwSize;
    BYTE byLocalControllerName[LOCAL_CONTROLLER_NAME_LEN]; //就地控制器名称
    WORD wLocalControllerID; //就地控制器序号
    WORD    wDevPort;                 // 设备端口号
    NET_DVR_IPADDR    struDevIP;       // 设备IP地址
    NET_DVR_IPADDR    struSubnetMask;  // 设备子网掩码
    NET_DVR_IPADDR    struGateway;     // 设备网关
    BYTE         bySearchProgress; //搜索进度，0表示未开始，100表示同步完成
    BYTE         byEffectData;//是否为有效数据,0表示有效，1表示设备只返回搜索进度，作为心跳包
    BYTE byRes[302];
}NET_DVR_ONLINE_LOCAL_CONTROLLER_CFG, *LPNET_DVR_ONLINE_LOCAL_CONTROLLER_CFG;

typedef struct tagNET_DVR_ACS_WORK_STATUS
{
    DWORD dwSize;
    BYTE byDoorLockStatus[MAX_DOOR_NUM]; //门锁状态，0-关，1-开
    BYTE byDoorStatus[MAX_DOOR_NUM]; //门状态，1-休眠，2-常开状态，3-常闭状态，4-普通状态
    BYTE byMagneticStatus[MAX_DOOR_NUM]; //门磁状态，0-闭合，1-开启
    BYTE byCaseStatus[MAX_CASE_SENSOR_NUM]; ////事件触发器状态，0-无输入，1-有输入
    WORD wBatteryVoltage; //蓄电池电压值，实际值乘10，单位：伏特
    BYTE byBatteryLowVoltage; //蓄电池是否处于低压状态，0-否，1-是
    BYTE byPowerSupplyStatus; //设备供电状态，1-交流电供电，2-蓄电池供电
    BYTE byMultiDoorInterlockStatus; //多门互锁状态，0-关闭，1-开启
    BYTE byAntiSneakStatus; //反潜回状态，0-关闭，1-开启
    BYTE byHostAntiDismantleStatus; //主机防拆状态，0-关闭，1-开启
    BYTE byIndicatorLightStatus; //指示灯状态，0-掉线，1-在线
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM]; //读卡器在线状态，0-不在线，1-在线
    BYTE byCardReaderAntiDismantleStatus[MAX_CARD_READER_NUM]; //读卡器防拆状态，0-关闭，1-开启
    BYTE byCardReaderVerifyMode[MAX_CARD_READER_NUM]; //读卡器当前验证方式，1-刷卡，2-刷卡+密码，3-刷卡，4-刷卡或密码
    BYTE bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//报警输入口布防状态，0-对应报警输入口处于撤防状态，1-对应报警输入口处于布防状态
    BYTE byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //报警输入口报警状态，0-对应报警输入口当前无报警，1-对应报警输入口当前有报警
    BYTE byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //报警输出口状态，0-对应报警输出口无报警，1-对应报警输出口有报警
    DWORD dwCardNum; //已添加的卡数量
    BYTE byRes2[32];
}NET_DVR_ACS_WORK_STATUS, *LPNET_DVR_ACS_WORK_STATUS;

typedef struct tagNET_DVR_ACS_WORK_STATUS_V50
{
    DWORD dwSize;
    BYTE byDoorLockStatus[MAX_DOOR_NUM_256]; //门锁状态(继电器开合状态)，0-正常关，1-正常开，2-短路报警，3-断路报警，4-异常报警
    BYTE byDoorStatus[MAX_DOOR_NUM_256]; //门状态(楼层状态)，1-休眠，2-常开状态(自由)，3-常闭状态(禁用)，4-普通状态(受控)
    BYTE byMagneticStatus[MAX_DOOR_NUM_256]; //门磁状态，0-正常关，1-正常开，2-短路报警，3-断路报警，4-异常报警
    BYTE byCaseStatus[MAX_CASE_SENSOR_NUM]; //事件触发器状态，0-无输入，1-有输入    
    WORD wBatteryVoltage; //蓄电池电压值，实际值乘10，单位：伏特
    BYTE byBatteryLowVoltage; //蓄电池是否处于低压状态，0-否，1-是
    BYTE byPowerSupplyStatus; //设备供电状态，1-交流电供电，2-蓄电池供电
    BYTE byMultiDoorInterlockStatus; //多门互锁状态，0-关闭，1-开启
    BYTE byAntiSneakStatus; //反潜回状态，0-关闭，1-开启
    BYTE byHostAntiDismantleStatus; //主机防拆状态，0-关闭，1-开启
    BYTE byIndicatorLightStatus; //指示灯状态，0-掉线，1-在线
    BYTE byCardReaderOnlineStatus[MAX_CARD_READER_NUM_512]; //读卡器在线状态，0-不在线，1-在线
    BYTE byCardReaderAntiDismantleStatus[MAX_CARD_READER_NUM_512]; //读卡器防拆状态，0-关闭，1-开启
    BYTE byCardReaderVerifyMode[MAX_CARD_READER_NUM_512]; //读卡器当前验证方式，1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码
    BYTE  bySetupAlarmStatus[MAX_ALARMHOST_ALARMIN_NUM];//报警输入口布防状态，0-对应报警输入口处于撤防状态，1-对应报警输入口处于布防状态
    BYTE byAlarmInStatus[MAX_ALARMHOST_ALARMIN_NUM]; //按位表示报警输入口报警状态，0-对应报警输入口当前无报警，1-对应报警输入口当前有报警
    BYTE byAlarmOutStatus[MAX_ALARMHOST_ALARMOUT_NUM]; //按位表示报警输出口状态，0-对应报警输出口无报警，1-对应报警输出口有报警
    DWORD dwCardNum; //已添加的卡数量
    BYTE byFireAlarmStatus; //消防报警状态显示：0-正常、1-短路报警、2-断开报警
    BYTE byBatteryChargeStatus; //电池充电状态：0-无效；1-充电中；2-未充电
    BYTE byMasterChannelControllerStatus; //主通道控制器在线状态：0-无效；1-不在线；2-在线
    BYTE bySlaveChannelControllerStatus; //从通道控制器在线状态：0-无效；1-不在线；2-在线
    BYTE byAntiSneakServerStatus; //反潜回服务器状态：0-无效，1-未启用，2-正常，3-断开
    BYTE byRes3[3];
    DWORD dwAllowFaceNum; //已添加的允许名单人脸数量（通过能力集判断）
    DWORD dwBlockFaceNum; //已添加的禁止名单人脸数量（通过能力集判断）
    BYTE byRes2[108];
}NET_DVR_ACS_WORK_STATUS_V50, *LPNET_DVR_ACS_WORK_STATUS_V50;

typedef struct tagNET_DVR_CASE_SENSOR_CFG
{
    DWORD dwSize;
    BYTE  byHostBuzzer;  //触发主机蜂鸣器，0-不触发，1-触发
    BYTE  byRes1[3];
    BYTE  byCardReaderBuzzer[MAX_CARD_READER_NUM]; //触发读卡器蜂鸣器，1-触发，0-不触发
    BYTE  byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  //关联触发的报警输出，1-关联，0-不关联
    BYTE  byDoorOpen[MAX_DOOR_NUM]; //对门1-N关联门打开，0-不关联，1-关联（即打开）
    BYTE  byDoorClose[MAX_DOOR_NUM]; //对门1-N关联门关闭，0-不关联，1-关联（即关闭）
    BYTE  byRes2[64];
}NET_DVR_CASE_SENSOR_CFG, *LPNET_DVR_CASE_SENSOR_CFG;


typedef struct tagNET_DVR_ACS_EVENT_INFO
{
    DWORD dwSize;
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号，为0无效
    BYTE byCardType; //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
    BYTE byAllowListNo; //允许名单单号,1-8，为0无效
    BYTE byReportChannel; //报告上传通道，1-布防上传，2-中心组1上传，3-中心组2上传，为0无效
    BYTE byCardReaderKind; //读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
    DWORD dwCardReaderNo; //读卡器编号，为0无效
    DWORD dwDoorNo; //门编号(楼层编号)，为0无效（当接的设备为人员通道设备时，门1为进方向，门2为出方向）
    DWORD dwVerifyNo; //多重卡认证序号，为0无效
    DWORD dwAlarmInNo;  //报警输入号，为0无效
    DWORD dwAlarmOutNo; //报警输出号，为0无效
    DWORD dwCaseSensorNo; //事件触发器编号
    DWORD dwRs485No;    //RS485通道号，为0无效
    DWORD dwMultiCardGroupNo; //群组编号
    WORD wAccessChannel;    //人员通道号
    BYTE  byDeviceNo;    //设备编号，为0无效
    BYTE  byDistractControlNo;//分控器编号，为0无效
    DWORD dwEmployeeNo; //工号，为0无效
    WORD wLocalControllerID; //就地控制器编号，0-门禁主机，1-64代表就地控制器
    BYTE  byInternetAccess; //网口ID：（1-上行网口1,2-上行网口2,3-下行网口1）
    BYTE    byType;     //防区类型，0:即时防区,1-24小时防区,2-延时防区 ,3-内部防区，4-钥匙防区 5-火警防区 6-周界防区 7-24小时无声防区  8-24小时辅助防区，9-24小时震动防区,10-门禁紧急开门防区，11-门禁紧急关门防区 0xff-无
    BYTE  byMACAddr[MACADDR_LEN]; //物理地址，为0无效
    BYTE  bySwipeCardType;//刷卡类型，0-无效，1-二维码
    BYTE  byMask; //是否带口罩：0-保留，1-未知，2-不戴口罩，3-戴口罩
    DWORD dwSerialNo; //事件流水号，为0无效
    BYTE  byChannelControllerID; //通道控制器ID，为0无效，1-主通道控制器，2-从通道控制器
    BYTE  byChannelControllerLampID; //通道控制器灯板ID，为0无效（有效范围1-255）
    BYTE  byChannelControllerIRAdaptorID; //通道控制器红外转接板ID，为0无效（有效范围1-255）
    BYTE  byChannelControllerIREmitterID; //通道控制器红外对射ID，为0无效（有效范围1-255）
    BYTE  byHelmet;//可选，是否戴安全帽：0-保留，1-未知，2-不戴安全, 3-戴安全帽
    BYTE  byRes[3];
}NET_DVR_ACS_EVENT_INFO, *LPNET_DVR_ACS_EVENT_INFO;

typedef struct tagNET_DVR_ACS_EVENT_INFO_EXTEND
{
    DWORD dwFrontSerialNo; //事件流水号，为0无效（若该字段为0，平台根据dwSerialNo判断是否丢失事件；若该字段不为0，平台根据该字段和dwSerialNo字段共同判断是否丢失事件）（主要用于解决报警订阅后导致dwSerialNo不连续的情况）
    BYTE  byUserType; //人员类型：0-无效，1-普通人（主人），2-来宾（访客），3-禁止名单人，4-管理员
    BYTE  byCurrentVerifyMode; //读卡器当前验证方式：0-无效，1-休眠，2-刷卡+密码，3-刷卡，4-刷卡或密码，5-指纹，6-指纹+密码，7-指纹或刷卡，8-指纹+刷卡，9-指纹+刷卡+密码，10-人脸或指纹或刷卡或密码，11-人脸+指纹，12-人脸+密码，13-人脸+刷卡，14-人脸，15-工号+密码，16-指纹或密码，17-工号+指纹，18-工号+指纹+密码，19-人脸+指纹+刷卡，20-人脸+密码+指纹，21-工号+人脸，22-人脸或人脸+刷卡，23-指纹或人脸，24-刷卡或人脸或密码，25-刷卡或人脸，26-刷卡或人脸或指纹，27-刷卡或指纹或密码，28-人脸或密码，29-工号+人脸+密码，30-刷卡或人脸或人脸+刷卡，31-人脸或指纹或密码，32-虹膜，33-人脸或指纹或刷卡或密码或虹膜，34-人脸或刷卡或密码或虹膜
    BYTE  byCurrentEvent; //是否为实时事件：0-无效，1-是（实时事件），2-否（离线事件）
    BYTE  byPurePwdVerifyEnable; //设备是否支持纯密码认证， 0-不支持，1-支持
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //工号（人员ID）（对于设备来说，如果使用了工号（人员ID）字段，byEmployeeNo一定要传递，如果byEmployeeNo可转换为dwEmployeeNo，那么该字段也要传递；对于上层平台或客户端来说，优先解析byEmployeeNo字段，如该字段为空，再考虑解析dwEmployeeNo字段）
    BYTE  byAttendanceStatus; //考勤状态：0-未定义,1-上班，2-下班，3-开始休息，4-结束休息，5-开始加班，6-结束加班
    BYTE  byStatusValue; //考勤状态值
    BYTE  byRes2[2];
    BYTE  byUUID[NET_SDK_UUID_LEN/*36*/]; //UUID（该字段仅在对接萤石平台过程中才会使用）
    BYTE  byDeviceName[NET_DEV_NAME_LEN];   //设备序列号
    BYTE  byRes[24];
}NET_DVR_ACS_EVENT_INFO_EXTEND, *LPNET_DVR_ACS_EVENT_INFO_EXTEND;

typedef struct tagNET_DVR_ACS_EVENT_INFO_EXTEND_V20
{
    BYTE byRemoteCheck; //是否需要远程核验（0-无效，1-不需要（默认），2-需要）
    BYTE byThermometryUnit; //测温单位（0-摄氏度（默认），1-华氏度，2-开尔文）
    BYTE byIsAbnomalTemperature; //人脸抓拍测温是否温度异常：1-是，0-否
    BYTE byRes2;
    float fCurrTemperature; //人脸温度（精确到小数点后一位）
    NET_VCA_POINT struRegionCoordinates; //人脸温度坐标
    DWORD dwQRCodeInfoLen; //二维码信息长度，不为0是表示后面带数据
    DWORD dwVisibleLightDataLen; //热成像相机可见光图片长度，不为0是表示后面带数据
    DWORD dwThermalDataLen; //热成像图片长度，不为0是表示后面带数据
    char *pQRCodeInfo; //二维码信息指针
    char *pVisibleLightData; //热成像相机可见光图片指针
    char *pThermalData; //热成像图片指针
    BYTE  byAttendanceLabel[64]; //考勤自定义名称
    BYTE  byRes[960];
}NET_DVR_ACS_EVENT_INFO_EXTEND_V20, *LPNET_DVR_ACS_EVENT_INFO_EXTEND_V20;

typedef struct tagNET_DVR_ACS_ALARM_INFO
{
    DWORD dwSize;
    DWORD dwMajor; //报警主类型，参考宏定义
    DWORD dwMinor; //报警次类型，参考宏定义
    NET_DVR_TIME struTime; //时间
    BYTE    sNetUser[MAX_NAMELEN] ;//网络操作的用户名
    NET_DVR_IPADDR    struRemoteHostAddr ;//远程主机地址
    NET_DVR_ACS_EVENT_INFO struAcsEventInfo; //详细参数
    DWORD dwPicDataLen;   //图片数据大小，不为0是表示后面带数据
    char    *pPicData;
    WORD  wInductiveEventType; //归纳事件类型，0-无效，客户端判断该值为非0值后，报警类型通过归纳事件类型区分，否则通过原有报警主次类型（dwMajor、dwMinor）区分
    BYTE    byPicTransType;        //图片数据传输方式: 0-二进制；1-url
    BYTE    byRes1;             //保留字节
    DWORD dwIOTChannelNo;    //IOT通道号
    char    *pAcsEventInfoExtend;    //byAcsEventInfoExtend为1时，表示指向一个NET_DVR_ACS_EVENT_INFO_EXTEND结构体
    BYTE    byAcsEventInfoExtend;    //pAcsEventInfoExtend是否有效：0-无效，1-有效
    BYTE    byTimeType; //时间类型：0-设备本地时间，1-UTC时间（struTime的时间）
    BYTE    byRes2;             //保留字节
    BYTE    byAcsEventInfoExtendV20;    //pAcsEventInfoExtendV20是否有效：0-无效，1-有效
    char    *pAcsEventInfoExtendV20;    //byAcsEventInfoExtendV20为1时，表示指向一个NET_DVR_ACS_EVENT_INFO_EXTEND_V20结构体
    BYTE byRes[4];
}NET_DVR_ACS_ALARM_INFO, *LPNET_DVR_ACS_ALARM_INFO;

typedef struct tagNET_DVR_AUDIO_ACTIVATION_CFG 
{
    DWORD   dwSize;
    BYTE    byEnable;    //是否启用
    BYTE    byRes1[3];
    DWORD   dwChanNo;    //语音激励的视频通道号 
    BYTE    bySensitivity; //灵敏度 1-100，灵敏度越高，表示较低的音量就能使能该音频输入激励功能；灵敏度越低，表示需要较高的音量才能使能该音频输入的激励功能
    BYTE    byPriority;     //优先级  0-优先级0，1-优先级1， 值越大级别越高
    WORD    wDelayTime;  //语音激励结束画面切换延迟时间，单位s, 超时后自动回到预置点1对应的画面
    BYTE    byRes2;      //保留
    BYTE    byEnablePreset; //是否启用预置点
    WORD    wPreset;    //预置点
    WORD    wBase;           /*基准点编号*/
    BYTE    byRes3[2];
       BYTE    byVoChanNo[JUDGE_MAX_VIDEOOUT_NUM];          //语音激励是否输出到视频输出口。值0表示不输出，1-表示输出。下标表示通道顺序如下：0-VGA1,1-VGA2, 2-VGA3,3-VGA4,4-VGA5~10,5-HDMI1,6-HDMI2
    BYTE    byRes[255]; //保留
}NET_DVR_AUDIO_ACTIVATION_CFG,*LPNET_DVR_AUDIO_ACTIVATION_CFG;

typedef struct tagNET_DVR_INFRARED_OUTPUT_CTRL_CFG
{
    DWORD  dwSize;       //结构体大小
    BYTE   byIROutPort;   //红外输出索引，1-红外输出口1，2-红外输出口2
    BYTE   byIRCmdIndex; //红外学码命令对应的索引；
    BYTE   byRes[254]; //保留
}NET_DVR_INFRARED_OUTPUT_CTRL_CFG, *LPNET_DVR_INFRARED_OUTPUT_CTRL_CFG;

typedef struct tagNET_DVR_INFRARED_CMD_INFO   //红外命令名称信息
{
    char   sCmdName[MAX_IR_CMD_NAME_LEN];  //红外命令名称
    BYTE   byRes[8];         //保留
} NET_DVR_INFRARED_CMD_INFO,*LPNET_DVR_INFRARED_CMD_INFO;

typedef struct tagNET_DVR_INFRARED_LEARN_CODE_CFG_
{
    DWORD  dwSize;  //结构体大小
    BYTE      sIROutName[MAX_IR_CMD_NAME_LEN];  //红外输出口名称
    NET_DVR_INFRARED_CMD_INFO  struIRCmdInfo[MAX_IR_CMD_NUM];  //红外命令子信息
    BYTE   byRes[256];
} NET_DVR_INFRARED_CMD_NAME_CFG,*LPNET_DVR_INFRARED_CMD_NAME_CFG;


typedef struct tagNET_DVR_INFRARED_LEARN_INFO
{
    DWORD dwSize;       //结构体大小
    BYTE  byIROutPort;  //红外输出索引，1-红外输出口1，2-红外输出口2
    BYTE  byIRCmdIndex; //红外学码命令对应的索引 
    BYTE  byRes[30];    //保留   
} NET_DVR_INFRARED_LEARN_INFO, *LPNET_DVR_INFRARED_LEARN_INFO;

typedef struct tagNET_DVR_INFRARED_LEARN_END
{
    DWORD  dwSize;       //结构体大小
    BYTE   bySaveLearnInfo;      //保存学码信息，0-保存，1-不保存
    BYTE   byRes[255];
} NET_DVR_INFRARED_LEARN_END,*LPNET_DVR_INFRARED_LEARN_END;

typedef struct tagNET_DVR_VIDEOIN_TYPE_INFO
{
    WORD  wInType;   //输入源类型  0-SDI,1-VGA, 2-HDMI,3-IP,4-PIP
    WORD  wInNum;  //支持的输入个数
    WORD  wStartNo;  //输入对应的起始号 
    BYTE   byRes[6];
}NET_DVR_VIDEOIN_TYPE_INFO, *LPNET_DVR_VIDEOIN_TYPE_INFO;


typedef struct tagNET_DVR_CASE_INFO
{
    DWORD   dwSize;       //结构体大小
    BYTE    byCaseNo[CASE_NO_LEN];  //案件编号
    BYTE    byCaseName[CASE_NAME_LEN]; //案件名称；
    BYTE    byLitigant1[LITIGANT_LEN]; //当事人1；
    BYTE    byLitigant2[LITIGANT_LEN]; //当事人2；
    BYTE    byChiefJudge[CHIEF_JUDGE_LEN];//审判长
    BYTE    byCaseType; //案件类型；1-刑事案件、2-民事案件、3- sCaseTypeCustom生效
    BYTE    byShowCaseInfoTime; /* 案件信息显示时间,单位秒, 取值范围1~30*/ 
    BYTE    byRes1[2]; //保留
    char    sCaseTypeCustom[NET_SDK_CASETYPE_LEN/*32*/];//自定义案件类型
    BYTE    byRes[220]; //保留
}NET_DVR_CASE_INFO, *LPNET_DVR_CASE_INFO;





typedef struct tagNET_DVR_LAMP_STATUS
{
    BYTE     byEnable;  //是否启用
    BYTE     byRes1[3];
    BYTE     byLampName[LAMP_NAME];   //Lamp 名称，报警输出3、4口为Lamp1。报警5、6输出口为lamp2。
    BYTE     byLampState1[LAMP_STATE_NAME];   //状态1对应名称， 
    BYTE     byLampState2[LAMP_STATE_NAME];   //状态2对应名称
    BYTE     byLampState3[LAMP_STATE_NAME];   //状态3对应名称
    BYTE     byRes[32];
}NET_DVR_LAMP_STATUS,*LPNET_DVR_LAMP_STATUS;



typedef struct tagNET_DVR_TPS_PARAM
{
    BYTE                byStart;          // 开始码
    BYTE                byCMD;         // 命令号，01-进入指令，02-离开指令，03-拥堵状态指令(为03时，只有byLaneState和byQueueLen有效)，04-多线圈状态（为04时，wLoopState和wStateMask有效，表示byLane车道上多个线圈的过车状态）
    WORD                wSpaceHeadway;        //车头间距，以米来计算
    WORD                wDeviceID;      // 设备ID
    WORD                wDataLen;       // 数据长度
    BYTE                byLane;         // 对应车道号
    BYTE                bySpeed;        // 对应车速（KM/H）
    BYTE                  byLaneState;     // 车道状态；0-无状态，1-畅通，2-拥挤，3-堵塞
    BYTE                  byQueueLen;       // 堵塞状态下排队长度（比如50米）
    WORD                wLoopState;         //线圈状态，第几位表示几号线圈状态。状态1-到达，0-离开，线圈编号从镜头由近到远依次增大，用户在解析时优先解析车道号，再解析线圈号，单个车道的线圈号是唯一的。
    WORD                wStateMask;         //线圈状态掩码，掩码位为1对应wLoopState状态位有效，为0表示无效
    DWORD               dwDownwardFlow;     //当前车道 从上到下车流量
    DWORD               dwUpwardFlow;       //当前车道 从下到上车流量
    BYTE                byJamLevel;         //拥堵等级，当byLaneState为3时有效，1-轻度，2-中度，3-重度
    BYTE               byVehicleDirection; //0-未知，1-由上而下，2-由下而上
    BYTE               byJamFlow;          //拥堵新增流量，每新增一辆车就上报一次累计车辆的信息
    BYTE                byChannelizationLane;         //渠化车道号（渠化表示，车道数量变化的情况，一般为路口车道的数目）
    BYTE                byVehicleType; //车型识别：0- 未知，1- 客车(大型)，2- 货车(大型)，3- 轿车(小型)，4- 非机动车
    BYTE               byRes1[5];        //保留
    WORD                wTimeHeadway;        // 车头时距，以秒计算
}NET_DVR_TPS_PARAM, *LPNET_DVR_TPS_PARAM;

typedef struct tagNET_DVR_TPS_REAL_TIME_INFO
{
    DWORD                 dwSize;          // 结构体大小
    DWORD                 dwChan;//通道号
    NET_DVR_TIME_V30      struTime;    //检测时间
    NET_DVR_TPS_PARAM     struTPSRealTimeInfo;// 交通参数统计信息
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    BYTE*                 pAddInfoBuffer;
#else
    /*附加信息指针,指向NET_DVR_TPS_ADDINFO结构体*/
    BYTE*                 pAddInfoBuffer;
    BYTE                  byRes2[4];
#endif  
    /*附加信息标识（即是否有NET_DVR_TPS_ADDINFO结构体）,0-无附加信息, 1-有附加信息。*/
    BYTE                  byAddInfoFlag;
    BYTE                  byRes1[3];      // 保留
    DWORD                 dwDeviceIDEx;   // 设备ID扩展
    BYTE                  byRes[8];       // 保留
}NET_DVR_TPS_REAL_TIME_INFO, *LPNET_DVR_TPS_REAL_TIME_INFO;

typedef struct tagNET_DVR_TPS_LANE_PARAM
{
    BYTE                  byLane;             // 对应车道号
    BYTE                  bySpeed;             // 车道过车平均速度
    WORD                  wArrivalFlow;        //到达流量
    DWORD               dwLightVehicle;      // 小型车数量
    DWORD               dwMidVehicle;        // 中型车数量
    DWORD               dwHeavyVehicle;      // 重型车数量
    DWORD               dwTimeHeadway;      // 车头时距，以秒计算
    DWORD               dwSpaceHeadway;     // 车头间距，以米来计算
    float               fSpaceOccupyRation; // 空间占有率，百分比计算,浮点数*1000
    float               fTimeOccupyRation;  // 时间占有率，百分比计算,浮点数*1000
    BYTE                  byStoppingTimes; //平均停车次数
    BYTE               byQueueLen;       // 堵塞状态下排队长度（比如50米）
    BYTE                byFlag;          //上传标识，0-表示T1时间的统计结果,1-表示T2时间的统计
    BYTE                  byVehicelNum;         //区域车辆数
    WORD                  wDelay;         //平均延误
    BYTE                byRes1[6];               // 保留
    DWORD               dwNonMotor;      // 非机动车数量
}NET_DVR_TPS_LANE_PARAM, *LPNET_DVR_TPS_LANE_PARAM;

typedef struct tagNET_DVR_PANORAMA_LINKAGE
{
    DWORD            dwSize;
    BYTE             byEnable;//0-关闭，1-开启
    BYTE             byRes[127];
}NET_DVR_PANORAMA_LINKAGE, *LPNET_DVR_PANORAMA_LINKAGE;

typedef struct tagNET_DVR_TPS_STATISTICS_PARAM
{
    BYTE                byStart;          // 开始码
    BYTE                byCMD;         // 命令号， 08-定时成组数据指令
    BYTE                byRes[2];        // 预留字节
    WORD                wDeviceID;      // 设备ID
    WORD                wDataLen;       // 数据长度
    BYTE                byTotalLaneNum;  // 有效车道总数
    BYTE                byRes2[3];
    DWORD               dwDeviceIDEx;      // 设备ID扩展
    BYTE                byRes1[8];
    NET_DVR_TIME_V30    struStartTime;    //统计开始时间
    DWORD                dwSamplePeriod;    //统计时间,单位秒
    NET_DVR_TPS_LANE_PARAM  struLaneParam[MAX_TPS_RULE/*8*/];
}NET_DVR_TPS_STATISTICS_PARAM, *LPNET_DVR_TPS_STATISTICS_PARAM;

typedef struct tagNET_DVR_TPS_STATISTICS_INFO
{
    DWORD                 dwSize;          // 结构体大小
    DWORD                 dwChan ;//通道号
    NET_DVR_TPS_STATISTICS_PARAM     struTPSStatisticsInfo;// 交通参数统计信息
    DWORD           dwJsonLen;//Json报警信息长度
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    BYTE*                 pJsonBuf;
#else
    // Json报警信息指针,其JSON对应到EventNotificationAlert Json Block
    BYTE*                 pJsonBuf;
    BYTE                  byRes2[4];
#endif  
    BYTE                  byJsonInfoFlag;         //是否有Json透传数据，0-无，1-有
    BYTE                  byBrokenNetHttp;        //断网续传标志位，0-不重传数据，1-重传数据
    BYTE                  byRes[114];             //保留
}NET_DVR_TPS_STATISTICS_INFO, *LPNET_DVR_TPS_STATISTICS_INFO;

typedef struct tagNET_DVR_DPC_PARAM
{
    DWORD   dwSize;
    DWORD   dwChannel; //通道号
    WORD    wCtrlType ;//参考宏定义
    /*
    手动校正：默认为手动校正模式，使用wCtrlType操作类型进行手动校正。
    自动校正：设备将自动进行校正，无需再进行手动校正，此时wCtrlType、struPoint参数无效。
    */
    BYTE    byDPCMode;//坏点校正模式：0-手动校正，1-自动校正
    BYTE    byRes;
    NET_VCA_POINT struPoint; /*输入的图像平面坐标，归一化到0-1*/
    BYTE    byRes1[64]; 
}NET_DVR_DPC_PARAM, *LPNET_DVR_DPC_PARAM;

typedef struct tagNET_DVR_FFC_MANUAL_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    BYTE   byRes[64]; 
}NET_DVR_FFC_MANUAL_INFO, *LPNET_DVR_FFC_MANUAL_INFO;

typedef struct tagNET_DVR_FFC_BACKCOMP_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    BYTE   byRes[64]; 
}NET_DVR_FFC_BACKCOMP_INFO, *LPNET_DVR_FFC_BACKCOMP_INFO;

typedef struct tagNET_DVR_STORAGE_SERVER_SWITCH_CFG
{
    DWORD  dwSize;
    /*存储图片开关；按位表示，0-关闭，1-开启
    数组0-移动侦测抓图(暂不支持)
    数组1-报警抓图(暂不支持)
    ……
    */
    BYTE  byPicEnable[MAX_PIC_SWITCH_STORAGE_SERVER]; 
    /*存储附加信息开关；按位表示，0-关闭，1-开启
    数组0-热度图(暂不支持)
    数组1-客流量(暂不支持)
    ……
    */       
    BYTE  byAddInfoEnable[MAX_INFO_SWITCH_STORAGE_SERVER]; 
    BYTE  byRes[324];
} NET_DVR_STORAGE_SERVER_SWITCH_CFG,

typedef struct tagNET_DVR_FORCESTOP_FORENSICS_CFG
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    BYTE    byRes[64]; 
}NET_DVR_FORCESTOP_FORENSICS_CFG, *LPNET_DVR_FORCESTOP_FORENSICS_CFG;

typedef struct tagNET_DVR_DEC_VCA_ALARM
{
    DWORD dwSize;
    DWORD dwDisplayNo; //产生智能报警的显示通道号
    BYTE  bySubWinNo;  //产生智能报警的子窗口号
    BYTE  byRes1[3];
    NET_DVR_TIME_V30 struTime; //产生报警时间
    NET_DVR_PU_STREAM_CFG_V41 struSourceInfo; //码流源信息
    BYTE  *byAlarmPic; //报警图片缓冲区
    DWORD dwAlarmPicSize; //报警图片大小，单位：字节
    BYTE  byRes2[64];
}NET_DVR_DEC_VCA_ALARM, *LPNET_DVR_DEC_VCA_ALARM;

typedef struct tagNET_DVR_DEC_VCA_ALARM_LOGO
{
    BYTE byEnableLogo;  //是否叠加智能报警logo，0-不叠加，非0-叠加
    BYTE byFlash;   //是否闪烁，0-不闪烁，非0-闪烁
    WORD wFlashTime; //闪烁时间，单位：秒，取值范围从解码器能力集获取 
    DWORD dwLogoX;  //logo X坐标，解码窗口总大小：1920*1920
    DWORD dwLogoY;  //logo Y坐标
    BYTE byRes[32];
}NET_DVR_DEC_VCA_ALARM_LOGO, *LPNET_DVR_DEC_VCA_ALARM_LOGO;

typedef struct tagNET_DVR_DEC_VCA_ALARM_PIC
{
    BYTE byUploadPic; //智能报警时是否上传报警图片，0-不上传，非0-上传
    BYTE byOverlayTargetInfo; //报警图片是否叠加目标信息，0-不叠加，非0-叠加
    BYTE byOverlayRuleInfo; //报警图片是否叠加智能规则信息，0-不叠加，非0-叠加
    BYTE byPicQuality;            //图片质量系数 0-最好 1-较好 2-一般
    /*图片大小 可以通过能力集获取
    0-CIF，           1-QCIF，           2-D1，         3-UXGA(1600x1200), 4-SVGA(800x600),5-HD720p(1280x720)，
    6-VGA，           7-XVGA，           8-HD900p，     9-HD1080，     10-2560*1920，
    11-1600*304，     12-2048*1536，     13-2448*2048,  14-2448*1200， 15-2448*800，
    16-XGA(1024*768), 17-SXGA(1280*1024),18-WD1(960*576/960*480),      19-1080i,      20-576*576，     
    21-1536*1536,     22-1920*1920,      23-320*240,    24-720*720,    25-1024*768,
    26-1280*1280,     27-1600*600,       28-2048*768,   0xff-Auto(使用当前码流分辨率)*/
    BYTE byPicSize;
    BYTE byRes[27];
}NET_DVR_DEC_VCA_ALARM_PIC, *LPNET_DVR_DEC_VCA_ALARM_PIC;

typedef struct tagNET_DVR_DEC_VCA_ALARM_CFG
{
    DWORD dwSize;
    NET_DVR_DEC_VCA_ALARM_LOGO struAlarmLogo; //智能报警logo叠加参数    
    NET_DVR_DEC_VCA_ALARM_PIC  struAlarmPic;  //智能报警图片参数
    BYTE byRes[64];
}NET_DVR_VCA_ALARM_CFG, *LPNET_DVR_DEC_VCA_ALARM_CFG;

typedef struct tagNET_DVR_OUTPUT_PIC_INFO
{
    DWORD  dwSize;
    BYTE   sPicName[NAME_LEN];//图片名称
    BYTE   byUsed; //是否已存在，0-不存在，1-存在
    BYTE   byRes[31];
}NET_DVR_OUTPUT_PIC_INFO,*LPNET_DVR_OUTPUT_PIC_INFO;

typedef struct tagNET_DVR_OUTPUT_PIC_CFG
{
    DWORD dwSize;
    DWORD  dwOutputPicNo;  //图片序号
    BYTE   byEnable; //logo是否显示，1-显示，0-隐藏
    BYTE   byRes1[3];    
    NET_DVR_RECTCFG_EX struRect;//logo位置，输出口范围总大小为1920*1920
    BYTE   byFlash;  //是否闪烁1-闪烁，0-不闪烁
    BYTE   byTranslucent; //是否半透明1-半透明，0-不半透明
    BYTE   byRes2[2];                //保留
    DWORD  dwOutputPicWinNo; //输出口图片窗口号（1字节设备号+1字节输出口号+2字节输出口图片窗口号）,获取全部时有效
    BYTE   byRes3[28];
}NET_DVR_OUTPUT_PIC_CFG,*LPNET_DVR_OUTPUT_PIC_CFG;

typedef struct tagNET_DVR_OUTPUT_OSD_CFG
{
    DWORD   dwSize;
    BYTE     byEnable; //OSD是否显示，0-不显示，1-显示
    BYTE     byFontSize; //字体大小，1-大，2-中，3-小
    BYTE     byOSDColor; //OSD颜色配置，0-默认， 1-黑，2-白，3-红，4-绿，5-蓝
    BYTE     byRes1[1];    
    BYTE     byOsdContent[MAX_OSD_LEN]; //OSD内容
    NET_DVR_RECTCFG_EX struRect;//OSD位置，输出口范围总大小为1920*1920
    DWORD dwOsdWinNo; //输出口OSD窗口号（1字节设备号+1字节输出口号+2字节OSD窗口号），获取所有时有效
    BYTE     byRes2[32];                //保留
}NET_DVR_OUTPUT_OSD_CFG,*LPNET_DVR_OUTPUT_OSD_CFG;

typedef struct tagNET_DVR_CHAN_RELATION_RESOURCE
{
    DWORD dwSize;
    DWORD dwDisplayChan; //显示通道号（1字节设备号+1字节保留+2字节显示通道号）
    BYTE  byRelateAudio; //是否关联子窗口音频
    BYTE  byRes1[3];
    DWORD dwSubWinNo; //关联音频的子窗口号（1字节电视墙号+1字节子窗口号+2字节窗口号）
    DWORD dwChannel; //编码通道号，获取全部时有效
    BYTE byRes2[32];
}NET_DVR_CHAN_RELATION_RESOURCE, *LPNET_DVR_CHAN_RELATION_RESOURCE;

typedef struct tagNET_DVR_ALARM_CHAN_ABLITITY
{
    DWORD    dwSize;
    BYTE    bySensorChan[64];//模拟量通道 下标表示通道号 0-表示不支持，1-表示支持
    BYTE    byAlarmInChan[64];//报警输入通道 下标表示通道号 0-表示不支持，1-表示支持
    BYTE    byAlarmOutChan[64];//报警输出通道 下标表示通道号 0-表示不支持，1-表示支持
    BYTE    by485Chan[64];//485通道 下标表示通道号 0-表示不支持，1-表示支持
    BYTE    byRes[128];
}NET_DVR_ALARM_CHAN_ABLITITY, *LPNET_DVR_ALARM_CHAN_ABLITITY;




typedef struct tagNET_DVR_REMOTECONTROL_COND
{
    DWORD   dwSize;    //结构大小
    DWORD   dwChannel; //通道号
    BYTE    byRes[64]; 
}NET_DVR_REMOTECONTROL_COND, *LPNET_DVR_REMOTECONTROL_COND;

typedef struct tagNET_DVR_REMOTECONTROL_STATUS_
{
    DWORD   dwSize;               //结构大小
    BYTE    byAlarmStatus;//布防状态，0-保留,1-撤防,2-布防
    BYTE    byRes[3]; 
    WORD    wAlarmDealyTime;//布防延迟时间，单位s
    WORD    wDisAlarmDealyTime;//撤防延迟时间，单位s
    BYTE    byRes1[64]; 
} NET_DVR_REMOTECONTROL_STATUS, *LPNET_DVR_REMOTECONTROL_STATUS;

typedef struct tagNET_DVR_SECURITY_CFG
{ 
    DWORD    dwSize;
    BYTE    byCommuMode;//私有协议通信模式，0-兼容模式，1-安全模式
    BYTE    byRes1[2];
    BYTE    byWebAuthentication;    //web认证配置 0-digest、1-basic、2-digest/basic;默认basic认证
    BYTE    byRtspAuthentication;   //rtsp认证配置 0-disable、1-basic、2-digest、3-digest/basic;默认basic认证
    BYTE    byTelnetServer;         //telnet设置 0～禁用，1～启用
    BYTE    bySSHServer;            //SSH设置 0～禁用(默认)，1～启用
    BYTE    byIllegalLoginLock;     //开启登陆锁定, 0-启用（默认），1-禁用
    BYTE    byStreamEncryption;     //码流加密 0-不加密，1-加密
    BYTE    byAntiAttack;          //是否开启防攻击功能，0- 不启用，1-启用(socket延时5s关闭)
    BYTE    byRes[26];
}NET_DVR_SECURITY_CFG,*LPNET_DVR_SECURITY_CFG;

typedef struct tagNET_DVR_PASSWORD_MANAGE_CFG
{
    DWORD    dwSize;
    BYTE     byRes[3];
    BYTE     byLockCount;      //对应用户名或IP被几次连续的错误密码登录后，对该用户进行锁定，0-不锁定，其他值为锁定的次数。 默认为0，例如1表示错误登录1次以后就锁定该用户名。
    DWORD  dwLockTime;       //锁定时间，表示错误后锁定的时间，单位：秒。不能为0，byLockCount不为0时，dwLockTime才有效
    BYTE     byRes1[128];        //4字节对齐
} NET_DVR_PASSWORD_MANAGE_CFG,*LPNET_DVR_PASSWORD_MANAGE_CFG;

typedef struct tagNET_DVR_UNLOCK_INFO
{
    DWORD    dwSize;
    BYTE    byUnlockType;    //0-无效， 1-按IP解锁，2-解锁所有IP
    BYTE    byIPVersion;    //1-IPV4，2-IPV6，当byUnlockType为1时，该参数有效
    BYTE    byRes1[2];
    NET_DVR_IPADDR struIPAddr;        //IP地址
    BYTE     byRes[64];
} NET_DVR_UNLOCK_INFO,*LPNET_DVR_UNLOCK_INFO;


typedef struct tagNET_DVR_VEHICLE_PARA
{
    BYTE  sLicense[MAX_LICENSE_LEN];
                            /*国家索引值
                            0-算法库不支持牌识国家，1-捷克共和国(CZ - Czech Republic)，2-法国(FRA - France)，
                            3-德国(DE - Germany),4-西班牙(E - Spain), 5-意大利(IT - Italy)，6-荷兰(NL - Netherlands)，7-波兰(PL - Poland)，8-斯洛伐克(SVK - Slovakia), 9-白俄罗斯(BY - Belorussia), 10-摩尔多瓦(MDA - Moldova)，11-俄罗斯(RU - Russia)，12-乌克兰(UA - Ukraine),
                            169-加拿大(Canada), 172-美国(US), 227-澳大利亚(Australia), 0xfe-无法识别    
    */
    BYTE  byCountry;                   // 国家索引值

    BYTE  byRes[239];
}NET_DVR_VEHICLE_PARA, *LPNET_DVR_VEHICLE_PARA;

typedef struct tagNET_DVR_FACE_PIC_DATA_INFO
{
    DWORD              dwImageLen;   //图片大小
    NET_VCA_RECT       struVcaRect;  //子图在大图中的坐标位置，归一化坐标
    DWORD              dwFaceScore;  //相似度，取值范围0-100
    BYTE               byVcaRectOnly;   //是否只上传坐标：0-否；1-是
    BYTE               byRes1[3];
    DWORD              dwPID;   //图片ID
    DWORD              dwFaceSearchNum;// 搜索人脸区域个数
    NET_VCA_RECT       struMultiVcaRect[NET_DVR_MAX_FACE_SEARCH_NUM];//（多个）子图在大图中的坐标位置，归一化坐标, byVcaRectOnly=1时启用，紧凑排列
    BYTE                byRes[136];
    BYTE               *pImage;  //其中图片要求为jpg格式
}NET_DVR_FACE_PIC_DATA_INFO, *LPNET_DVR_FACE_PIC_DATA_INFO;

typedef struct  tagNET_DVR_BEHAVIOUR_COND
{
    DWORD dwSearchType;   //搜索类型
    //&0x1 - 穿越警戒线
    //&0x2 - 区域入侵
    //&0x4 - 物品遗留
    //&0x8 - 物品拿取
    //&0x10 - 进入区域
    //&0x20 - 离开区域
    //&0x40 - 非法停车
    //&0x80 - 徘徊
    //&0x100 -人员聚集
    //&0x200 - 快速移动  
    //&0x400 - 离岗检测  
    //&0x800 - 人数变化  
    //&0x1000 - 剧烈运动  
    //&0x2000 - 人员奔跑 
    //&0x4000 - 人员倒地
    //&0x8000 - 人员滞留
    //&0x10000 –态势分析
    //&0x20000 – 玩手机
    BYTE byHumanMisinfo;// 只获取人体误报信息 0-否，1-是 
    BYTE byRes[251];  //保留
}NET_DVR_BEHAVIOUR_COND, *LPNET_DVR_BEHAVIOUR_COND;


typedef struct tagNET_DVR_SMART_SEARCH_PIC_PARA  //智能图片搜索结构体 size 344
{
    DWORD                dwChanNo;               //通道号
    DWORD                byStreamID[STREAM_ID_LEN] ;   //流ID信息，与dwChanNo相比，优先级较高，即当byStreamID不为空时，则使用流ID，为空的情况下使用dwChanNo字段
    NET_DVR_TIME_EX         struStartTime;               //录像开始的时间
    NET_DVR_TIME_EX         struEndTime;            //录像停止的时间
    WORD                wSearchType;            //智能查找类型  0-车辆检索 ，1-人脸属性， 2-以图索图 ，3-行为分析
    BYTE               byRes1[2];
    NET_DVR_SMARTSEARCH_PIC_UNION   uSmartSearchCond;  //智能查找条件
    BYTE   	    byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char cStartTimeDifferenceH;   //开始时间与UTC的时差（小时），-12 ... +14， 正数表示东时区
    char cStartTimeDifferenceM;   //开始时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    char cStopTimeDifferenceH;    //结束时间与UTC的时差（小时），-12 ... +14，正数表示东时区
    char cStopTimeDifferenceM;    //结束时间与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    BYTE        byRes[59];
}NET_DVR_SMART_SEARCH_PIC_PARA, *LPNET_DVR_SMART_SEARCH_PIC_PARA;

typedef struct tagNET_DVR_FACE_SUB_PIC_INFO
{
    DWORD          dwSimilarity;   //相似度 0-100
    NET_VCA_RECT   struVcaRect;    //人脸区域，归一化坐标
    BYTE           byRes2[236];   //保留
}NET_DVR_FACE_SUB_PIC_INFO ,*LPNET_DVR_FACE_SUB_PIC_INFO;

typedef struct tagNET_DVR_BEHAVIOR_INFO
{
    NET_VCA_RECT struVcaRect;
    WORD         wPeopleNum;       //区域人数，仅图片类型（NET_DVR_SMART_SEARCH_PIC_RET 中wPicType）为态势分析时有效
    BYTE         byRes2[238];   //保留
}NET_DVR_BEHAVIOR_INFO ,*LPNET_DVR_BEHAVIOR_INFO;


typedef struct tagNET_DVR_SMART_SEARCH_PIC_RET
{
    char                sFileName[PICTURE_NAME_LEN];//文件名
    NET_DVR_TIME_EX     struTime;                      //图片的抓图时间
    DWORD   dwFileSize;                 //文件的大小
    WORD    wPicType;                  //图片类型  0-车辆检索 ，1-人脸属性， 2-以图索图 ，3-穿越警戒线，4-区域入侵， 5-物品遗留， 6-物品拿取， 7-进入区域， 8-离开区域， 9-非法停车，10-徘徊，11-人员聚集，12-快速移动,13-人员奔跑，14-剧烈运动，15-人员倒地，16-人数异常，17-离岗检测，18-人员滞留，19-态势分析  20-玩手机
    BYTE    byRes1[2];                  //保留
    NET_DVR_PIC_FEATURE_UNION   uPicFeature;  //图片属性
    BYTE   	    byISO8601;  //是否是8601的时间格式，即时差字段是否有效0-时差无效，年月日时分秒为设备本地时间 1-时差有效 
    char cTimeDifferenceH;   //与UTC的时差（小时），-12 ... +14， 正数表示东时区
    char cTimeDifferenceM;   //与UTC的时差（分钟），-30, 0, 30, 45，正数表示东时区
    BYTE    byRes[29];
}NET_DVR_SMART_SEARCH_PIC_RET, *LPNET_DVR_SMART_SEARCH_PIC_RET; 

typedef struct tagNET_DVR_T1TEST_SEND_DATA_BUZZER
{
    BYTE  byHearSound;   //是否听到声音 0-未听到，1-听到
    BYTE  byRes[31];     //保留
}NET_DVR_T1TEST_SEND_DATA_BUZZER,*LPNET_DVR_T1TEST_SEND_DATA_BUZZER;


typedef struct tagNET_DVR_T1TEST_SEND_DATA
{
    DWORD     dwSize;     //结构体大小
    BYTE  byDataType;  //数据类型 0-蜂鸣器，1-pc本地时间
    BYTE  byRes1[3];
    NET_DVR_T1TEST_DATA_UNION uSendData;  //发送的数据内容
    BYTE  byRes[64];
}NET_DVR_T1TEST_SEND_DATA,*LPNET_DVR_T1TEST_SEND_DATA;

typedef struct tagNET_DVR_PIC_MODEL_CFG  //图像建模参数配置
{
    DWORD       dwSize;    //结构体大小
    BYTE         byEnable;     //是否启用
    BYTE         byRes[63];
}NET_DVR_PIC_MODEL_CFG, *LPNET_DVR_PIC_MODEL_CFG;

typedef struct  tagNET_DVR_MOUSE_EVENT_PARAM  //鼠标信息配置
{
    DWORD           dwSize;   //结构体大小
    BYTE            byMouseEvent;  //鼠标事件类型， 0-鼠标左键单击，1-鼠标左键双击，2-鼠标右键，3-滚轮上滚，4-滚轮下滚
    BYTE            byRes1[3];    //保留
    NET_VCA_POINT   struPoint;    //鼠标点位置坐标，归一化处理
    BYTE            byRes[64];    //保留
}NET_DVR_MOUSE_EVENT_PARAM, *LPNET_DVR_MOUSE_EVENT_PARAM;

typedef struct tagNET_DVR_AUTO_LIMIT_WAVE_CFG
{
    BYTE  byFBCEnable;         //FBC开关 0-不开启，1-开启
    BYTE  byMode;              //模式, 0-快速, 1-普通,2-慢速
    BYTE  byFilterQValue;      //自适应滤波器Q值，单位Oct, 0-1/40,1-1/10, 默认值为1/40 Oct
    BYTE  byStaticFilterNum;   //静态滤波器数量，取值范围0-12  
    BYTE  byRes[16];
}NET_DVR_AUTO_LIMIT_WAVE_CFG,*LPNET_DVR_AUTO_LIMIT_WAVE_CFG;

typedef struct _NET_DVR_DSP_PARAMETER_CFG
{
    BYTE  byFBCEnable;         //FBC开关 0-不开启，1-开启
    BYTE  byVolume;            //输入音量 取值范围0~255
    BYTE  byRes[22];
}NET_DVR_DSP_PARAMETER_CFG, *LPNET_DVR_DSP_PARAMETER_CFG;

typedef struct tagNET_DVR_MIX_AUDIOIN_CFG
{
    DWORD  dwSize;  //结构体大小
    DWORD  dwHighPassFilter;         //高通滤波器 取值范围 0-127, 具体索引代表含义以能力集为准
    DWORD  dwNoiseMargin;            //噪声门限，取值范围 0-127, 具体索引代表含义以能力集为准
    NET_DVR_AUTO_LIMIT_WAVE_CFG  struLimitWave;  //自动限波控制参数，当音频输入源为macIn时有效
    NET_DVR_DSP_PARAMETER_CFG  struDSPParameter;  //数字信号处理芯片参数
    BYTE   byRes[40];
}NET_DVR_MIX_AUDIOIN_CFG,*LPNET_DVR_MIX_AUDIOIN_CFG;

typedef struct tagNET_DVR_MIX_AUDIOOUT_CFG
{
    DWORD   dwSize;  //结构体大小
    BYTE    byModulatorEnbale;  //是否启用相位调制器
    BYTE    byPostFilter;       //Post Filter开关，0-关闭，1-开启，默认开启
    BYTE    byLimitPressure;    //输出压限开关 0-关闭，1-开启，默认开启
    BYTE    byRes1;             //保留 
    WORD    wModulatorValue;    //相位调制量 取值范围 0-127, 具体索引代表含义以能力集为准，默认10
    WORD    wTriggerTime;       //压限触发时间，取值范围 0-127, 具体索引代表含义以能力集为准
    WORD    wFreeTime;          //压限释放时间，取值范围 0-127, 具体索引代表含义以能力集为准
    BYTE    byCompressThreshold; //压缩门限 0-1X,1-2X,2-4X,3-8X  X表示倍，比如2X表示2倍
    BYTE    byCompressMode;     //压缩方式，0-硬压缩，1-软压缩，默认为硬压缩
    BYTE    byCompressRate;    //压缩率 
    BYTE    byRecoveryGain;    //回复增益 0-1X,1-2X,2-4X,3-8X
    BYTE    byOutputGain;      //输出增益 0 ~100（负值）
    BYTE    byOutputMute;      //输出静音，0-关闭，1-开启
    int     iOutputGainEx;      //输出增益扩展，返回正值为放大，负值为缩小
    BYTE    bySoundQualityHanding;      //音质处理，0-关闭，1-开启
    BYTE    byRes[55];
}NET_DVR_MIX_AUDIOOUT_CFG,*LPNET_DVR_MIX_AUDIOOUT_CFG;

typedef struct tagNET_DVR_VOLUME_CFG
{
    DWORD    dwSize;  //结构体大小
    WORD    wVolume[MAX_AUDIOOUT_PRO_TYPE];      //音量大小 取值范围 0-127, 具体索引代表含义以能力集为准
    BYTE    byPhantomPowerSupply;    //是否使用幻象电源供电(音频输入通道为MIC时有效)，0-无意义，1-不供电，2-供电
    BYTE    byEnableAEC;    //是否启用全局的回声消除,0-不启用，1-启用
    WORD    wTalkVolume;   //支持对讲的设备，对讲时音量大小
    BYTE    byEnableFBC[MAX_AUDIOOUT_PRO_TYPE];    //是否启用FBC(啸叫抑制),0-不启用，1-启用
    WORD    wVolumeEx[MAX_AUDIOOUT_PRO_TYPE];      //音量大小扩展 取值范围 0-127, 具体索引代表含义以能力集为准
    BYTE    byRes[4];     //保留
}NET_DVR_VOLUME_CFG,*LPNET_DVR_VOLUME_CFG;

typedef struct tagNET_DVR_VIDEOOUT_RESOLUTION_CFG  //视频输出口分辨率配置
{
    DWORD       dwSize;    //结构体大小
    BYTE         byResolution;     //分辨率 0-1024x768, 1-1280x720,  2-1280x1024,  3-1680x1050, 4-1920x1080, 5-3840*2160
    BYTE         byRes[63];
}NET_DVR_VIDEOOUT_RESOLUTION_CFG, *LPNET_DVR_VIDEOOUT_RESOLUTION_CFG;

typedef struct tagNET_DVR_ADDR_DOMAIN_INFO
{
    BYTE   szDomainAddr[MAX_DOMAIN_NAME];  /* 主机IP地址或者域名,需要设备解析,解析方式为有字母存在且有'.'则认为是域名,否则为IP地址  */
    WORD   wPort;
    BYTE   byRes[2];
}NET_DVR_ADDR_DOMAIN_INFO,*LPNET_DVR_ADDR_DOMAIN_INFO;

typedef struct tagNET_DVR_ALARMCENTER_NETCFG
{
    DWORD    dwSize;
    BYTE    byAuxiliaryAlarmAddr[MAX_DOMAIN_NAME];  /* 辅报警主机IP地址或者域名,需要设备解析,解析方式为有字母存在且有’.’则认为是域名,否则为IP地址 */
    WORD    wAuxiliaryAlarmPort;     /* 辅报警主机端口号 */
    NET_DVR_ADDR_DOMAIN_INFO struHostAddr[MAX_CENTERNUM_V40]; //报警中心地址信息
    BYTE    byRes[172];
}NET_DVR_ALARMCENTER_NETCFG, *LPNET_DVR_ALARMCENTER_NETCFG;

typedef struct tagNET_DVR_ALARM_LINKAGE_PARAM
{
    DWORD    dwSize;
    WORD     wChanRec;  //联动录像的NVR通道，按位表示，例如最低位表示通道1，最高位表示通道16，二进制位的值：0-不录像，1-录像
    BYTE     byRes1[2];
    WORD     wRecTime[MAX_LINKAGE_CHAN_NUM];    //录像的时间，按字节表示，例如byRecTime[0]表示通道1的录像时间，byRecTime[15]表示通道16的录像时间
    WORD     wChanPic;                          //联动抓图的NVR通道，按位表示，例如最低位表示通道1，最高位表示通道16，二进制位的值：0-不抓图，1-抓图
    BYTE     byRes2[2];
    BYTE     byPicNum[MAX_LINKAGE_CHAN_NUM];    //抓图的个数，按字节表示，例如byPicNum[0]表示通道1的抓图个数，byPicNum[15]表示通道16的抓图个数
    BYTE     byTriggerEnabled[ALARMHOST_ALARMOUT_NUM];//变量联动触发器，0-不联动，1-联动     
    BYTE	 bySensorJointAlarmOut[ALARMHOST_ALARMOUT_NUM];//遥信值按类型联动触发器，该值为byTriggerEnabled的扩充。数组下标表示触发器号，数组元素的值按位表示报警类型，各个类型间是"或"的关系。类型值定义：1bit0-限1；bit1-限2；bit2-限3；bit3-限4；bit4-故障
    BYTE   	 byRes3[128];     	//保留
}NET_DVR_ALARM_LINKAGE_PARAM, *LPNET_DVR_ALARM_LINKAGE_PARAM;

typedef struct tagNET_DVR_ALARM_RADARINFO
{
    DWORD             dwSize;
    DWORD             dwRadarTriggerTimeSecond;//雷达触发时间，秒
    DWORD             dwRadarTriggerTimeMSecond;//雷达触发时间，毫秒
    DWORD             dwVedioTriggerTimeSecond;//视频触发时间，秒
    DWORD             dwVedioTriggerTimeMSecond;//视频触发时间，毫秒
    DWORD             dwVedioRadarDiffTimeMSecond;//雷达视频触发时间差，毫秒
    DWORD             dwRadarSpeed;//雷达速度
    BYTE              byRes[16];
} NET_DVR_ALARM_RADARINFO, *LPNET_DVR_ALARM_RADARINFO;

typedef struct tagNET_DVR_FINGER_PRINT_CFG
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号 
    DWORD dwFingerPrintLen;     //指纹数据长度
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //需要下发指纹的读卡器，按数组表示，0-不下发该读卡器，1-下发到该读卡器
    BYTE  byFingerPrintID;     //手指编号，有效值范围为1-10
    BYTE  byFingerType;       //指纹类型  0-普通指纹，1-胁迫指纹
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];        //指纹数据内容
    BYTE  byRes[64];
}NET_DVR_FINGER_PRINT_CFG,*LPNET_DVR_FINGER_PRINT_CFG;

typedef struct tagNET_DVR_FINGER_PRINT_STATUS
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //指纹读卡器状态，按字节表示，0-失败，1-成功，2-该指纹模组不在线，3-重试或指纹质量差，4-内存已满，5-已存在该指纹，6-已存在该指纹ID，7-非法指纹ID，8-该指纹模组无需配置
    BYTE  byFingerPrintID;     //手指编号，有效值范围为1-10
    BYTE  byFingerType;       //指纹类型  0-普通指纹，1-胁迫指纹
    BYTE  byTotalStatus;  //下发总的状态，0-当前指纹未下完所有读卡器，1-已下完所有读卡器(这里的所有指的是门禁主机往所有的读卡器下发了，不管成功与否)
    BYTE  byRes1;
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的卡号
    DWORD dwCardReaderNo;  //非0表示错误信息byErrMsg有效，其值代表byErrMsg对应的读卡器编号（具体什么错误查看byCardReaderRecvStatus对应编号的值）。0时表示无错误信息
    BYTE  byRes[24];
}NET_DVR_FINGER_PRINT_STATUS,*LPNET_DVR_FINGER_PRINT_STATUS;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_COND
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //指纹的读卡器信息，按数组表示
    DWORD dwFingerPrintNum; //设置或获取卡数量，获取时置为0xffffffff表示获取所有卡信息
    BYTE  byFingerPrintID;     //手指编号，有效值范围为-10   0xff表示该卡所有指纹
    BYTE  byCallbackMode;     //设备回调方式，0-设备所有读卡器下完了范围，1-在时间段内下了部分也返回
    BYTE  byRes1[26];          //保留
}NET_DVR_FINGER_PRINT_INFO_COND,*LPNET_DVR_FINGER_PRINT_INFO_COND;

typedef struct tagNET_DVR_FINGER_PRINT_CFG_V50
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号
    DWORD dwFingerPrintLen; 	//指纹数据长度
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //需要下发指纹的读卡器，按数组表示，从低位到高位表示，0-不下发该读卡器，1-下发到该读卡器
    BYTE  byFingerPrintID;     //手指编号，有效值范围为1-10
    BYTE  byFingerType;       //指纹类型  0-普通指纹，1-胁迫指纹，2-巡更指纹，3-超级指纹，4-解除指纹
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];        //指纹数据内容
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //工号（人员ID）
    BYTE  byLeaderFP[MAX_DOOR_NUM_256]; //对门是否有首次认证功能（按字节表示）：0-无首次认证功能，1-有首次认证功能
    BYTE  byRes[128];
}NET_DVR_FINGER_PRINT_CFG_V50, *LPNET_DVR_FINGER_PRINT_CFG_V50;

typedef struct tagNET_DVR_FINGER_PRINT_STATUS_V50
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号
    BYTE  byCardReaderRecvStatus[MAX_CARD_READER_NUM_512];  //指纹读卡器状态，按字节表示，0-失败，1-成功，2-该指纹模组不在线，3-重试或指纹质量差，4-内存已满，5-已存在该指纹，6-已存在该指纹ID，7-非法指纹ID，8-该指纹模组无需配置，10-指纹读卡器版本过低（无法支持工号）
    BYTE  byFingerPrintID;     //手指编号，有效值范围为1-10
    BYTE  byFingerType;       //指纹类型  0-普通指纹，1-胁迫指纹，2-巡更指纹，3-超级指纹，4-解除指纹
    BYTE  byTotalStatus;  //下发总的状态，0-当前指纹未下完所有读卡器，1-已下完所有读卡器(这里的所有指的是门禁主机往所有的读卡器下发了，不管成功与否)
    BYTE  byRecvStatus;    //主机错误状态：0-成功，1-手指编号错误，2-指纹类型错误，3-卡号错误（卡号规格不符合设备要求），4-指纹未关联工号或卡号（工号或卡号字段为空），5-工号不存在，6-指纹数据长度为0，7-读卡器编号错误，8-工号错误
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的卡号
    DWORD dwCardReaderNo;  //当byCardReaderRecvStatus为5时，表示已存在指纹对应的指纹读卡器编号，可用于下发错误返回。0时表示无错误信息
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //工号（人员ID）
    BYTE byErrorEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的工号（人员ID）
    BYTE  byRes[128];
}NET_DVR_FINGER_PRINT_STATUS_V50, *LPNET_DVR_FINGER_PRINT_STATUS_V50;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_COND_V50
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号（该字段获取时有效，设置时无效）
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //指纹的读卡器是否有效，0-无效，1-有效
    DWORD dwFingerPrintNum; //设置或获指纹数量，获取时置为0xffffffff表示获取所有指纹信息
    BYTE  byFingerPrintID;     //手指编号，有效值范围为1-10   0xff表示该卡所有指纹
    BYTE  byCallbackMode;     //设备回调方式，0-设备所有读卡器下完了返回，1-在时间段内下了部分也返回
    BYTE  byRes2[2];          //保留
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //工号（人员ID）
    BYTE  byRes1[128];          //保留
}NET_DVR_FINGER_PRINT_INFO_COND_V50, *LPNET_DVR_FINGER_PRINT_INFO_COND_V50;

typedef struct tagNET_DVR_FINGER_PRINT_BYCARD
{
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号 
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //指纹的读卡器信息，按数组表示
    BYTE  byFingerPrintID[MAX_FINGER_PRINT_NUM/*10*/];        //需要获取的指纹信息，按数组下标，值表示0-不删除，1-删除该指纹
    BYTE  byRes1[34];          //保留
}NET_DVR_FINGER_PRINT_BYCARD,*LPNET_DVR_FINGER_PRINT_BYCARD;

typedef struct tagNET_DVR_FINGER_PRINT_BYREADER
{
    DWORD dwCardReaderNo;  //按值表示，指纹读卡器编号
    BYTE  byClearAllCard;  //是否删除所有卡的指纹信息，0-按卡号删除指纹信息，1-删除所有卡的指纹信息
    BYTE  byRes1[3];       //保留
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号 
    BYTE  byRes[548];          //保留
}NET_DVR_FINGER_PRINT_BYREADER,*LPNET_DVR_FINGER_PRINT_BYREADER;


typedef struct tagNET_DVR_FINGER_PRINT_INFO_CTRL
{
    DWORD       dwSize;
    BYTE  byMode;          //删除方式，0-按卡号方式删除，1-按读卡器删除
    BYTE  byRes1[3];       //保留
    NET_DVR_DEL_FINGER_PRINT_MODE struProcessMode;  //处理方式
    BYTE  byRes[64];          //保留
}NET_DVR_FINGER_PRINT_INFO_CTRL,*LPNET_DVR_FINGER_PRINT_INFO_CTRL;

typedef struct tagNET_DVR_FINGER_PRINT_BYCARD_V50
{
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号 
    BYTE  byEnableCardReader[MAX_CARD_READER_NUM_512];  //指纹的读卡器信息，按位表示
    BYTE  byFingerPrintID[MAX_FINGER_PRINT_NUM/*10*/];	    //需要删除的手指编号，按数组下标，值表示0-不删除，1-删除该指纹
    BYTE  byRes1[2];
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //工号（人员ID）
}NET_DVR_FINGER_PRINT_BYCARD_V50, *LPNET_DVR_FINGER_PRINT_BYCARD_V50;

typedef struct tagNET_DVR_FINGER_PRINT_BYREADER_V50
{
    DWORD dwCardReaderNo;  //按值表示，指纹读卡器编号
    BYTE  byClearAllCard;  //是否删除所有卡的指纹信息，0-按卡号（人员ID）删除指纹信息，1-删除所有卡（人员ID）的指纹信息
    BYTE  byRes1[3];       //保留
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号 
    BYTE  byEmployeeNo[NET_SDK_EMPLOYEE_NO_LEN]; //工号（人员ID）
    BYTE  byRes[516];          //保留
}NET_DVR_FINGER_PRINT_BYREADER_V50, *LPNET_DVR_FINGER_PRINT_BYREADER_V50;


typedef struct tagNET_DVR_FINGER_PRINT_INFO_CTRL_V50
{
    DWORD dwSize;
    BYTE  byMode;          //删除方式，0-按卡号（人员ID）方式删除，1-按读卡器删除
    BYTE  byRes1[3];       //保留
    NET_DVR_DEL_FINGER_PRINT_MODE_V50 struProcessMode;  //处理方式
    BYTE  byRes[64];          //保留
}NET_DVR_FINGER_PRINT_INFO_CTRL_V50, *LPNET_DVR_FINGER_PRINT_INFO_CTRL_V50;

typedef struct tagNET_DVR_FINGER_PRINT_INFO_STATUS_V50
{
    DWORD dwSize;
    DWORD dwCardReaderNo;  //按值表示，指纹读卡器编号
    BYTE  byStatus;         //状态：0-无效，1-处理中，2-删除失败，3-成功
    BYTE  byRes[63];          //保留
}NET_DVR_FINGER_PRINT_INFO_STATUS_V50, *LPNET_DVR_FINGER_PRINT_INFO_STATUS_V50;





typedef struct tagNET_DVR_EVENT_LINKAGE_INFO
{
    WORD          wMainEventType;                     //事件主类型，0-设备事件，1-报警输入事件，2-门事件，3-读卡器事件
    WORD          wSubEventType;                      //事件次类型
    BYTE          byRes[28];
}NET_DVR_EVENT_LINKAGE_INFO,*LPNET_DVR_EVENT_LINKAGE_INFO;


typedef struct tagNET_DVR_EVENT_CARD_LINKAGE_CFG
{
    DWORD            dwSize;    //结构体大小
    BYTE              byProMode;                          //联动方式，0-事件，1-卡号   
    BYTE            byRes1[3];
    DWORD           dwEventSourceID;                    //事件源ID，当主类型为设备事件时无效， 当主类型是门事件时为门编号;当主类型为读卡器事件时，为读卡器ID;当为报警输入事件时为防区报警输入ID或事件报警输入ID
    NET_DVR_EVETN_CARD_LINKAGE_UNION     uLinkageInfo;  //联动方式参数
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //关联的报警输出号，按数组表示，为0表示不关联，为1表示关联
    BYTE           byRes2[32];                         //保留
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //按数组表示,是否联动开门，0-不联动，1-联动
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //按数组表示,是否联动关门，0-不联动，1-联动
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //按数组表示,是否联动常开，0-不联动，1-联动
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //按数组表示,是否联动常关，0-不联动，1-联动
    BYTE           byMainDevBuzzer;                    //主机蜂鸣器   0-不联动，1-联动输出
    BYTE           byCapturePic;                           //是否联动抓拍，0-不联动抓拍，1-联动抓拍
    BYTE           byRecordVideo;                          //是否联动录像，0-不联动录像，1-联动录像
    BYTE           byRes3[29];                         //保留
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //联动读卡器蜂鸣器，按数组表示，0-不联动，1-联动
    BYTE           byRes[128];                           //保留
}NET_DVR_EVENT_CARD_LINKAGE_CFG,*LPNET_DVR_EVENT_CARD_LINKAGE_CFG;

typedef struct tagNET_DVR_EVENT_LINKAGE_CARD_CFG_V50
{
    DWORD            dwSize;    //结构体大小
    BYTE              byProMode;                          //联动方式，0-事件，1-卡号, 2-MAC地址   
    BYTE           byRes1[3];
    DWORD         dwEventSourceID;                    //事件源ID，当主类型为设备事件时无效， 当主类型是门事件时为门编号;当主类型为读卡器事件时，为读卡器ID;当为报警输入事件时为防区报警输入ID或事件报警输入ID。0xffffffff表示联动全部
    NET_DVR_EVETN_CARD_LINKAGE_UNION     uLinkageInfo;  //联动方式参数
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //关联的报警输出号，按位表示，为0表示不关联，为1表示关联
    BYTE           byRes2[32];                         //保留
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //按位表示,是否联动开门，0-不联动，1-联动
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //按位表示,是否联动关门，0-不联动，1-联动
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //按位表示,是否联动常开，0-不联动，1-联动
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //按位表示,是否联动常关，0-不联动，1-联动
    BYTE           byMainDevBuzzer;                    //主机蜂鸣器   0-不联动，1-联动输出
    BYTE           byCapturePic;                           //是否联动抓拍，0-不联动抓拍，1-联动抓拍
    BYTE           byRecordVideo;                          //是否联动录像，0-不联动录像，1-联动录像
    BYTE           byRes3[29];                         //保留
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //联动读卡器蜂鸣器，按位表示，0-不联动，1-联动
    BYTE           byAlarmOutClose[MAX_ALARMHOST_ALARMOUT_NUM];            //关联报警输出关闭，按字节表示，为0表示不关联，为1表示关联
    BYTE           byAlarmInSetup[MAX_ALARMHOST_ALARMIN_NUM];  //关联防区布防，按字节表示，为0表示不关联，为1表示关联
    BYTE           byAlarmInClose[MAX_ALARMHOST_ALARMIN_NUM];  //关联防区撤防，按字节表示，为0表示不关联，为1表示关联
    BYTE           byRes[500];                           //保留
}NET_DVR_EVENT_CARD_LINKAGE_CFG_V50, *LPNET_DVR_EVENT_CARD_LINKAGE_CFG_V50;

typedef struct tagNET_DVR_EVENT_LINKAGE_CARD_CFG_V51
{
    DWORD          dwSize;    //结构体大小
    BYTE           byProMode;                          //联动方式，0-事件，1-卡号，2-MAC地址，3-工号（人员ID）
    BYTE           byRes1[3];
    DWORD         dwEventSourceID;                    //事件源ID，当主类型为设备事件时无效， 当主类型是门事件时为门编号;当主类型为读卡器事件时，为读卡器ID;当为报警输入事件时为防区报警输入ID或事件报警输入ID。0xffffffff表示联动全部
    NET_DVR_EVETN_CARD_LINKAGE_UNION    uLinkageInfo;  //联动方式参数
    BYTE           byAlarmout[MAX_ALARMHOST_ALARMOUT_NUM];            //关联的报警输出号，按位表示，为0表示不关联，为1表示关联
    BYTE           byRes2[32];                         //保留
    BYTE           byOpenDoor[MAX_DOOR_NUM_256];     //按位表示,是否联动开门，0-不联动，1-联动
    BYTE           byCloseDoor[MAX_DOOR_NUM_256];    //按位表示,是否联动关门，0-不联动，1-联动
    BYTE           byNormalOpen[MAX_DOOR_NUM_256];   //按位表示,是否联动常开，0-不联动，1-联动
    BYTE           byNormalClose[MAX_DOOR_NUM_256];  //按位表示,是否联动常关，0-不联动，1-联动
    BYTE           byMainDevBuzzer;                    //主机蜂鸣器   0-不联动，1-联动输出
    BYTE           byCapturePic;                           //是否联动抓拍，0-不联动抓拍，1-联动抓拍
    BYTE           byRecordVideo;                          //是否联动录像，0-不联动录像，1-联动录像
    BYTE           byMainDevStopBuzzer;               //主机停止蜂鸣   0-不联动，1-联动输出
    WORD           wAudioDisplayID;                    //联动语音播放ID：0-不联动，目前范围1-32
    BYTE           byAudioDisplayMode;                 //联动语音播放模式：0-关闭，1-单次播放，2-循环播放
    BYTE           byRes3[25];                         //保留
    BYTE           byReaderBuzzer[MAX_CARD_READER_NUM_512]; //联动读卡器蜂鸣器，按位表示，0-不联动，1-联动
    BYTE           byAlarmOutClose[MAX_ALARMHOST_ALARMOUT_NUM];            //关联报警输出关闭，按字节表示，为0表示不关联，为1表示关联
    BYTE           byAlarmInSetup[MAX_ALARMHOST_ALARMIN_NUM];  //关联防区布防，按字节表示，为0表示不关联，为1表示关联
    BYTE           byAlarmInClose[MAX_ALARMHOST_ALARMIN_NUM];  //关联防区撤防，按字节表示，为0表示不关联，为1表示关联
    BYTE           byReaderStopBuzzer[MAX_CARD_READER_NUM_512]; //联动读卡器停止蜂鸣，按字节表示，0-不联动，1-联动
    BYTE           byRes[512];                   //保留
}NET_DVR_EVENT_CARD_LINKAGE_CFG_V51, *LPNET_DVR_EVENT_CARD_LINKAGE_CFG_V51;

typedef struct tagNET_DVR_EVENT_CARD_LINKAGE_COND
{
    DWORD dwSize;
    DWORD dwEventID; //事件ID
    WORD wLocalControllerID; //就地控制器序号[1,64]
    BYTE byRes[106];
}NET_DVR_EVENT_CARD_LINKAGE_COND, *LPNET_DVR_EVENT_CARD_LINKAGE_COND;

typedef struct tagNET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM
{
    DWORD dwSize;
    DWORD dwFileSize;     //文件大小，单位：字节（上传音频文件时有效，下载音频文件时无效）
    DWORD dwAudioID;      //音频ID（0xffffffff代表上传/下载全部音频文件，目前设备仅支持全量上传/下载，不支持单个音频ID上传/下载）
    BYTE  byRes[256];
}NET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM, *LPNET_DVR_RIGHT_CONTROLLER_AUDIO_PARAM;

typedef struct tagNET_DVR_CLIENT_CALIBFILE_PARAM
{
    DWORD dwSize;
    DWORD dwFileLen;     //文件大小
    BYTE  byChannel;     //通道号
    BYTE  byFileType;    //0-3200W标定文件,1-800W标定文件
    BYTE  byRes[22];
}NET_DVR_CLIENT_CALIBFILE_PARAM, *LPNET_DVR_CLIENT_CALIBFILE_PARAM;

typedef struct tagNET_DVR_RATIOSTITCHING_PARAM
{
    DWORD  dwSize;
    DWORD  dwFileLen;    //文件大小
    BYTE      byChannel;// 多个senor拼接后通道号
    BYTE      byRes[23];
}NET_DVR_RATIOSTITCHING_PARAM, *LPNET_DVR_RATIOSTITCHING_PARAM;

typedef struct tagNET_DVR_VIDEOWALL_MATERIAL_COND
{
    DWORD dwSize;
    BYTE byWallNo;   //电视墙墙号，从1开始
    BYTE byWindowType;   //窗口类型，0-图文窗口,1-字幕窗口
    BYTE byFileType;   //文件类型，0-图片
    BYTE byRes1;   //保留字节
    DWORD dwWindowNo;	//窗口编号，从1开始
    DWORD dwMaterialNo;	//素材编号，从1开始
    BYTE  byRes[32];
}NET_DVR_VIDEOWALL_MATERIAL_COND, *LPNET_DVR_VIDEOWALL_MATERIAL_COND;

typedef struct tagNET_DVR_CORRECT_TABLE_3200W_PARAM
{
    DWORD dwSize;
    DWORD dwFileLen;     //文件大小
    BYTE  byChannel;     //通道号
    BYTE  byFileType;    //0-3200W标定文件,1-800W标定文件
    BYTE  byRes[22];
}NET_DVR_CORRECT_TABLE_3200W_PARAM, *LPNET_DVR_CORRECT_TABLE_3200W_PARAM;

typedef struct tagNET_DVR_FOUR_CAMERAS_PICTURES
{
    DWORD dwSize;
    DWORD dwFileLen;    //文件大小
    BYTE  byChannel;    //通道号
    BYTE  byRes[23];
}NET_DVR_FOUR_CAMERAS_PICTURES, *LPNET_DVR_FOUR_CAMERAS_PICTURES;

typedef struct tagNET_DVR_DEVTYPE_CALIBFILE_PARAM
{
    DWORD  dwSize;
    DWORD  dwFileLen;     //文件长度
    BYTE   byChannel;     //通道号
    BYTE   byFileType;    //0-3200W标定文件,1-800W标定文件
    BYTE   byRes[22];
}NET_DVR_DEVTYPE_CALIBFILE_PARAM, *LPNET_DVR_DEVTYPE_CALIBFILE_PARAM;

typedef struct tagNET_DVR_ANTI_SNEAK_HOST_INFO
{
    NET_DVR_ADDRESS   struDVRIP;     //主机IP地址
    BYTE   byIsStartAddr; //是否为开始地址，0-否，1-是
    BYTE   byHostNo;      //主机编号，1-8，主要用于读卡器顺序设置
    BYTE   byRes[34];     //保留
}NET_DVR_ANTI_SNEAK_HOST_INFO,*LPNET_DVR_ANTI_SNEAK_HOST_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_HOST_READER_INFO
{
    BYTE  byAntiSnealHostNo;   //反潜回主机编号
    BYTE  byRes[5];           //保留
    WORD wFollowUpCardReader; //该反潜回主机下的读卡器编号
}NET_DVR_ANTI_SNEAK_HOST_READER_INFO, *LPNET_DVR_ANTI_SNEAK_HOST_READER_INFO;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG
{
    DWORD       dwSize;
    BYTE byEnable; //是否加入反潜回路径，1-加入，0-不加入
    BYTE byRes1[3];
    NET_DVR_ANTI_SNEAK_HOST_INFO struSneakHost[MAX_SNEAK_PATH_NODE]; //后续主机地址信息
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struStartReader;  //起始读卡器编号 当该内容全为0时，表示不关注从哪个读卡器开始
    BYTE byRes2[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_READER_CFG
{
    BYTE         byEnable;             //是否加入反潜回路径，1-加入，0-不加入
    BYTE          byAntiSnealHostNo;   //反潜回主机编号
    WORD         wReaderID;              //读卡器ID
    NET_DVR_ANTI_SNEAK_HOST_READER_INFO struSneakReaderInfo[MAX_SNEAK_PATH_NODE]; //后续主机读卡器编号
    BYTE byRes2[8];
}NET_DVR_ANTI_SNEAK_READER_CFG, *LPNET_DVR_ANTI_SNEAK_READER_CFG;

typedef struct tagNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG
{
    DWORD           dwSize;
    NET_DVR_ANTI_SNEAK_READER_CFG struReaderCfg[MAX_READER_ROUTE_NUM];  //读卡器信息
    BYTE            byRes[128];
}NET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG, *LPNET_DVR_ANTI_SNEAK_MULTI_HOST_READERS_CFG;

typedef struct tagNET_DVR_ACS_CFG
{
    DWORD           dwSize;            //结构体大小
    BYTE            byRS485Backup;  //是否启用下行RS485通信备份功能，0-不启用，1-启用
    BYTE            byShowCapPic;    //是否显示抓拍图片， 0-不显示，1-显示
    BYTE            byShowCardNo;    //是否显示卡号，0-不显示，1-显示
    BYTE            byShowUserInfo;  //是否显示用户信息，0-不显示，1-显示
    BYTE            byOverlayUserInfo;//是否叠加用户信息，0-不叠加，1-叠加
    BYTE            byVoicePrompt;  //是否启用语音提示，0-不启用，1-启用
    BYTE             byUploadCapPic;     //联动抓拍是否上传图片，0-不上传，1-上传
    BYTE             bySaveCapPic;    //是否保存抓拍图片，0-不保存，1-保存
    BYTE            byInputCardNo;  //是否是否允许按键输入卡号，0-不允许，1-允许
    BYTE            byEnableWifiDetect;  //是否启动wifi探针，0-不启动，1-启动
    BYTE            byEnable3G4G;  //3G4G使能，0-不使能，1-使能
    BYTE            byProtocol;//读卡器通信协议类型，0-私有协议（默认），1-OSDP协议
    BYTE byRes[500];
}NET_DVR_ACS_CFG, *LPNET_DVR_ACS_CFG;

typedef struct tagNET_DVR_PLATFORM_VERIFY_CFG
{
    DWORD       dwSize;
    DWORD        dwDoorNo; //门编号
    BYTE        byResultType; //认证结果类型，0：非法，1：合法
    BYTE        byRes1[3];
    BYTE        byScreenDisplay[MAX_SCREEN_DISPLAY_LEN]; //LED屏幕显示，用于显示认证相关信息
    BYTE        byRes[300];                  // 保留字节
}NET_DVR_PLATFORM_VERIFY_CFG, *LPNET_DVR_PLATFORM_VERIFY_CFG;

typedef struct tagNET_DVR_PERSON_STATISTICS_CFG
{
    DWORD dwSize;
    BYTE byEnableStatistics;  //是否开启人数统计，0：不开启；1：开启；
    BYTE byEnableOfflineStatistics;  //是否开启离线人数统计，0：不开启；1：开启；
    BYTE byCountSignalStatisticalStandard;  //计数信号统计标准，0：无效；1：红外检测通行统计；2：认证数量统计
    BYTE byRes[605];
}NET_DVR_PERSON_STATISTICS_CFG, *LPNET_DVR_PERSON_STATISTICS_CFG;

typedef struct tagNET_DVR_ACS_SCREEN_DISPLAY_CFG
{
    DWORD dwSize;
    DWORD dwFontSize;  //字体大小，[1,10]；
    DWORD dwRowSpacing;  //行间距，单位：像素点；
    DWORD dwColumnSpacing;  //列间距，单位：像素点；
    DWORD dwFirstRowPosition;  //起始行位置在屏幕哪一个分块，0：0、 1：1/8:、 2：2/8、 3：3/8、 4：4/8、 5：5/8、 6：6/8:、 7：7/8；
    BYTE byDegree;  //字符显示方向角度，0-0度（正常），1-90度（侧着）；
    BYTE byScreenType;  //屏幕类型，0-DC48270RS043_01T，1-DC80480B070_03T；
    BYTE byRes[306];
}NET_DVR_ACS_SCREEN_DISPLAY_CFG, *LPNET_DVR_ACS_SCREEN_DISPLAY_CFG;

typedef struct tagNET_DVR_GATE_TIME_CFG
{
    DWORD dwSize;
    DWORD dwHoldOnALarmTime;  //延续报警器蜂鸣时间，单位ms
    DWORD dwHoldOnGateOpenTime;  //闸门收到关闭命令前继续保持打开状态时间，单位ms
    DWORD dwPostponeIntrusionAlarmTime;  //推迟触发闯入欺骗行为报警时间，单位ms
    DWORD dwNoLaneAccessTimeLimitTime;  //通道收到有效通行认证信号，但无人通行超时报警时间，单位s
    DWORD dwSafetyZoneStayTime;  //通道收到有效通行认证信号，乘客到达安全区后滞留通道超时报警时间，单位s
    BYTE byIRTriggerTimeoutTime;  //红外触发超时时间，单位：秒（0-255）
    BYTE byRes[299];
}NET_DVR_GATE_TIME_CFG, *LPNET_DVR_GATE_TIME_CFG;

typedef struct tagNET_DVR_CARD_PASSWD_CFG
{
    DWORD dwSize; 
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //卡密码
    DWORD dwErrorCode; //获取卡密码开门使能配置返回的错误码，成功为0，失败返回错误码
    BYTE byCardValid; //卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
    BYTE byRes2[23];
}NET_DVR_CARD_PASSWD_CFG, *LPNET_DVR_CARD_PASSWD_CFG;

typedef struct tagNET_DVR_CARD_PASSWD_STATUS
{
    DWORD dwSize; 
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
    DWORD dwErrorCode; //发送卡密码开门使能配置返回的错误码，成功为0，失败返回错误码 
    BYTE byRes2[24];
}NET_DVR_CARD_PASSWD_STATUS, *LPNET_DVR_CARD_PASSWD_STATUS;

typedef struct tagNET_DVR_VEHICLE_RECOG_COND
{
    DWORD  dwSize;
    DWORD  dwChannel;
    BYTE   byRes[64];
} NET_DVR_VEHICLE_RECOG_COND, *LPNET_DVR_VEHICLE_RECOG_COND;

typedef struct tagNET_DVR_VEHICLE_RECOG_CFG
{
    DWORD  dwSize;
    //数据流水号 和（上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段sDataIndex对应）
    char   sDataIndex[DATA_INDEX_LEN];
    //任务处理号 和 (上传数据NET_DVR_VEHICLE_RECOG_RESULT中的字段dwTaskNo对应)
    WORD  wTaskNo;
    BYTE  byRes1[2];
    NET_VCA_RECT  struPlateRect;//车牌位置
    char  sLicense[MAX_LICENSE_LEN/*16*/];//车牌号码
    /*
    车辆图片二次识别操作
    bit0-车牌识别：0-不启用识别，1-启用识别； 
    bit1-车辆类型识别：0-不启用识别，1-启用识别；
    bit2-车身颜色识别：0-不启用识别，1-启用识别；
    bit3-车辆品牌识别：0-不启用识别，1-启用识别；
    bit4-遮挡板识别(主驾驶)：0-不启用识别，1-启用识别；
    bit5-安全带识别(主驾驶)：0-不启用识别，1-启用识别；
    bit6-遮挡板识别(副驾驶)：0-不启用识别，1-启用识别；
    bit7-安全带识别(副驾驶)：0-不启用识别，1-启用识别；
    bit8-车辆图片叠加使能：0-不启用识别，1-启用识别；
    bit9-上传车辆图片使能(通过SDK)：0-不启用识别，1-启用识别；
    bit10-上传车辆图片使能(通过URL)：0-不启用识别，1-启用识别；
    bit11-黄标车：0-不启用识别，1-启用识别；
    bit12-打手机：0-不启用识别，1-启用识别；
    bit13-挂件：0-不启用识别，1-启用识别；
    bit14-危险品车: 0-不启用识别，1-启用识别；
    bit15-车辆天窗站人检测: 0-不启用识别，1-启用识别；
    */
    DWORD  dwRecogOperate;
    /*
    车辆图片数据上传
    bit0-车牌图片：0-不上传，1-上传； 
    bit1-车辆图片：0-不上传，1-上传；
    bit2-人脸子图(主驾驶)：0-不上传，1-上传；
    bit3-人脸子图(副驾驶)：0-不上传，1-上传；
    bit4-安全带子图(主驾驶)：0-不上传，1-上传；
    bit5-安全带子图(副驾驶)：0-不上传，1-上传；
    */
    DWORD  dwDataUploadType;
    DWORD  dwPostID;//卡口ID。
    NET_DVR_TIME_V30 struPostTime;//过车时间
    DWORD  dwJsonLen; //Json透传数据长度
    BYTE	*pJsonBuffer;//Json数据指针,参考4.2.4Json数据格式
    BYTE   byRes[107];
    BYTE   byPicDataType;//图片数据类型，0-图片数据，1-URL
    //图片数据
    //当byPicDataType == 0的时候，该字段内的数据无效，图片数据在结构体后面
    //当byPicDataType == 1的时候，是指定的图片的URL信息
    char  sPicDataPath[256];
}NET_DVR_VEHICLE_RECOG_CFG, *LPNET_DVR_VEHICLE_RECOG_CFG;

typedef struct tagNET_DVR_VEHICLERECOG_TASK_RESULT
{
    DWORD  dwSize;
    //设备数据流水号,每次提交任务，设备会自行生成唯一的流水号返回给上层。
    char     sDevDataIndex[MAX_DEV_DATAINDEX_LEN/*64*/];
    BYTE   byRes[256];
}NET_DVR_VEHICLERECOG_TASK_RESULT, *LPNET_DVR_VEHICLERECOG_TASK_RESULT;

typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    char   sDataIndex[DATA_INDEX_LEN];//数据流水号    全0的时候表示获取全部 
    WORD  wTaskNo;//任务处理号         值为0的时候表示全部任务
                  /*
                  任务状态
                  bit0-完成状态的任务：0-不查询，1-查询；
                  bit1-执行中的任务：0-不查询，1-查询；
                  bit2-等待中的任务：0-不查询，1-查询；
    */
    BYTE   byTask;
    BYTE   byRes1;
    //设备数据流水号查询,每次提交任务，设备会自行生成唯一的流水号。
    char   sDevDataIndex[MAX_DEV_DATAINDEX_LEN/*64*/];
    BYTE   byRes[60];
}NET_DVR_VEHICLE_RECOG_TASK_COND, *LPNET_DVR_VEHICLE_RECOG_TASK_COND;

typedef struct tagNET_DVR_VEHICLE_RECOG_TASK_INFO
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    char   sDataIndex[DATA_INDEX_LEN];//数据流水号
    WORD  wTaskNo;//任务处理号
    WORD  wTaskProgress;//任务执行进度（实际进度*1000）
    BYTE   byTaskState;//任务状态，0-等待中，1-执行中，2-完成
    BYTE   byRes1[3];
    /*
    车辆图片二次识别操作
    bit0-车牌识别：0-不启用识别，1-启用识别； 
    bit1-车辆类型识别：0-不启用识别，1-启用识别；
    bit2-车身颜色识别：0-不启用识别，1-启用识别；
    bit3-车辆品牌识别：0-不启用识别，1-启用识别；
    bit4-遮挡板识别(主驾驶)：0-不启用识别，1-启用识别；
    bit5-安全带识别(主驾驶)：0-不启用识别，1-启用识别；
    bit6-遮挡板识别(副驾驶)：0-不启用识别，1-启用识别；
    bit7-安全带识别(副驾驶)：0-不启用识别，1-启用识别；
    bit8-车辆图片叠加使能：0-不启用识别，1-启用识别；
    bit9-上传车辆图片使能(通过SDK)：0-不启用识别，1-启用识别；
    bit10-上传车辆图片使能(通过URL)：0-不启用识别，1-启用识别；
    bit11-黄标车：0-不启用识别，1-启用识别；
    bit12-打手机：0-不启用识别，1-启用识别；
    bit13-挂件：0-不启用识别，1-启用识别；
    bit14-危险品车: 0-不启用识别，1-启用识别；
    bit15-车辆天窗站人检测: 0-不启用识别，1-启用识别；
    */
    DWORD  dwRecogOperate;
    DWORD  dwPostID;//卡口ID。
    NET_DVR_TIME_V30 struPostTime;//过车时间
    DWORD  dwJsonLen; //Json透传数据长度（预留，JSON内容暂不实现）
    BYTE   *pJsonBuffer;//Json数据指针, （预留，JSON内容暂不实现）
    BYTE   byRes[104];
}NET_DVR_VEHICLE_RECOG_TASK_INFO, *LPNET_DVR_VEHICLE_RECOG_TASK_INFO;

typedef struct tagNET_DVR_VEHICLE_RECOG_RESULT
{
    DWORD dwSize;   //结构
    //数据流水号 和（任务提交NET_DVR_VEHICLE_RECOG_CFG中的字段sDataIndex对应）
    char   sDataIndex[DATA_INDEX_LEN];
    //任务处理号 和 (任务提交NET_DVR_VEHICLE_RECOG_CFG中的字段wTaskNo对应)
    WORD  wTaskNo; 
    BYTE   byRes[2];
    NET_VCA_RECT  struPlateRect;//车牌位置
    char  sLicense[MAX_LICENSE_LEN/*16*/];//车牌号码
    BYTE  byVehicleType;    //车辆类型，参考VTR_RESULT
    BYTE  byColorDepth;     //车身颜色深浅，参考 0-深色，1-浅色
    BYTE  byColor;         //车身颜色,  参考VCR_CLR_CLASS
    BYTE  byVehicleLogoRecog; //车辆主品牌
    BYTE  byVehicleSubLogoRecog; //车辆子品牌
    BYTE  byPilotSafebelt;//0-表示未知,1-不系安全带,2-系安全带
    BYTE  byCopilotSafebelt;//0-表示未知,1-不系安全带,2-系安全带
    BYTE  byPilotSunVisor;//0-表示未知,1-不打开遮阳板,2-打开遮阳板
    BYTE  byCopilotSunVisor;//0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    BYTE  byVehicleModel;// 参考文档  车辆子品牌年款
    WORD  wVehicleLogoRecog;  //车辆主品牌，参考"车辆主品牌.xlsx" 
    BYTE  byRes1[251];
    // 0-数据直接上传; 1-云存储服务器URL原先的图片数据变成URL数据，图片长度变成URL长度
    BYTE  byDataType;
    /*
    上传图片类型信息:
    bit0-车辆图：0-不上传，1-上传； 
    bit1-车牌图：0-不上传，1-上传；
    bit2-人脸子图(主驾驶)：0-不上传，1-上传；
    bit3-人脸子图(副驾驶)：0-不上传，1-上传；
    bit4-安全带识别(主驾驶)：0-不上传，1-上传；
    bit5-安全带识别(副驾驶)：0-不上传，1-上传；
    */
    DWORD  dwPicType; //0:无图片信息;: 车辆图;:车牌图;
    BYTE    *pVehicleBuffer;    //车辆图片数据指针
    DWORD  dwVehicleBufferLen ;// 车辆图片数据长度
    BYTE    *pPlateBuffer;    //车牌图片数据指针
    DWORD  dwPlateBufferLen ;// 车牌图片数据长度
    BYTE    *pPilotFaceBuffer;    //人脸子图(主驾驶)图片数据指针
    DWORD  dwPilotFaceBufferLen ;// 人脸子图(主驾驶)图片数据长度
    BYTE    *pCopilotFaceBuffer;    //人脸子图(副驾驶)图片数据指针
    DWORD  dwCopilotFaceBufferLen ;// 人脸子图(副驾驶)图片数据长度
    BYTE    *pPilotSafebeltBuffer;    //安全带识别(主驾驶)图片数据指针
    DWORD  dwPilotSafebeltBufferLen ;// 安全带识别(主驾驶)图片数据长度
    BYTE    *pCopilotSafebeltBuffer;// 安全带识别(副驾驶)图片数据指针
    DWORD  dwCopilotSafebeltBufferLen ;// 安全带识别(副驾驶)图片数据长度
    NET_VCA_RECT  struVehicleRect ;//车身矩形坐标
    NET_VCA_RECT  struPilotRect ;//主驾驶矩形坐标
    NET_VCA_RECT  struCopilotRect ;//副驾驶矩形坐标
    BYTE    *pJsonBuffer;//Json数据指针,参考JSON数据格式
    DWORD   dwJsonBufferLen;// Json数据长度
    DWORD   dwPostID;//卡口ID
    NET_DVR_TIME_V30 struPostTime;//过车时间
    BYTE    Res2[56];
}NET_DVR_VEHICLE_RECOG_RESULT, *LPNET_DVR_VEHICLE_RECOG_RESULT;

typedef struct tagNET_DVR_CENTER_SERVER_CFG_
{
    DWORD                    dwSize;
    BYTE    byAddressType;    //0 - ipv4/ipv6地址，1 - 域名
    BYTE    byRes1;
    WORD    wServerPort;                //服务器端口
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];
            BYTE            byRes2[80];
        }struDomain;                    //服务器域名
        struct
        {
            NET_DVR_IPADDR    struIp;
        }struAddrIP;                    //IP地址
    }unionServer;//使用联合体结构，通过byAddressType字段表示是IP地址还是域名
    WORD                    wInterval;    //报警间隔时间,0-30s
    BYTE                    byRes3[514];
}NET_DVR_CENTER_SERVER_CFG,*LPNET_DVR_CENTER_SERVER_CFG;

typedef struct tagNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG_
{
    BYTE    byDDNSType;        //域名服务器类型：0 - 无效，1 - IPServer(私有DNS)，2 - hiDDNS
    BYTE    byRes1;
    WORD    wDDNSPort;                        //域名服务器端口号
    BYTE    byServerAddr[MAX_DOMAIN_NAME];    //域名服务器地址
    BYTE    byDevName[MAX_DOMAIN_NAME];            //设备名称
    BYTE    byDevSerialNum[SERIALNO_LEN];    //设备序列号
    BYTE    byAddressType;    //0 - ipv4/ipv6地址，1 - 域名
    BYTE    byRes2;
    WORD    wDevPort;        //设备端口号    
    union
    {
        struct
        {
            BYTE            szDomain[MAX_DOMAIN_NAME];
            BYTE            byRes2[80];
        }struDomain;                                    //域名
        struct
        {
            NET_DVR_IPADDR    struIp;
        }struAddrIP;                                    //IP地址
    }unionDevAddr;//使用联合体结构，通过byAddressType字段表示是IP地址还是域名
    BYTE    sUserName[NAME_LEN/*32*/];    //用户名
    BYTE    sPassword[PASSWD_LEN/*16*/];//密码
    DWORD    dwChannel;                    //联动通道号
    BYTE    byRes3[32];
}NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_SINGLE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_REGION_CHANNEL_LINKAGE_CFG_
{
    DWORD    dwSize;
    NET_DVR_SINGLE_CHANNEL_LINKAGE_CFG struLinkChannels[MAX_ZONE_LINKAGE_CHAN_NUM];    // 每个防区可以关联四个视频通道
    BYTE    byRes[64];
}NET_DVR_ZONE_CHANNEL_LINKAGE_CFG,*LPNET_DVR_ZONE_CHANNEL_LINKAGE_CFG;

typedef struct tagNET_DVR_SINGLE_ASSOCIATED_CHAN_CFG
{
    BYTE    byDevSerialNo[SERIALNO_LEN];    //设备序列号
    DWORD    dwChannel;                        //联动通道号
    BYTE    byRes[64];
}NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG, *LPNET_DVR_SINGLE_ASSOCIATED_CHAN_CFG;

typedef struct tagNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG
{
    WORD    wZoneNo;
    BYTE    byRes1[2];
    NET_DVR_SINGLE_ASSOCIATED_CHAN_CFG struSingleChanCfg[MAX_ZONE_LINKAGE_CHAN_NUM];
    BYTE    byRes2[64];
}NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG, *LPNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG;

typedef struct tagNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST_
{
    DWORD    dwSize;
    NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG struAssociatedChanCfg[MAX_MAX_ALARMIN_NUM];
    BYTE    byRes[64];
}NET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST, *LPNET_DVR_ALARMIN_ASSOCIATED_CHAN_CFG_LIST;

typedef struct tagNET_DVR_LCD_ALARM
{
    DWORD dwSize;
    DWORD dwScreenID;    //屏幕索引号
    BYTE byOnOffLine;    //屏幕是否在线，0-离线，1-在线，当屏幕离线时，本结构后续参数无效
    BYTE byTempState;    //板卡温度状态，0-正常，1-异常
    BYTE byFanState;        //风扇状态，0-关，1-开
    BYTE byFanException;    //风扇异常状态，0-不支持 1-正常，2-异常
    BYTE byTemperature;    //屏幕板卡温度，单位：摄氏度
    BYTE byRes[27];
}NET_DVR_LCD_ALARM, *LPNET_DVR_LCD_ALARM;

typedef struct tagNET_DVR_SENSOR_INFO_UPLOAD
{
    DWORD   dwSize;
    NET_DVR_TIME_V30  struTime;
    char    szSensorName[MAX_SENSORNAME_LEN]; //传感器名称
    char    szSensorChan[MAX_SENSORCHAN_LEN]; //传感器通道
    BYTE    byReboot; //之前是否重启过（一般是重启的后的第一条数据带有这个标志）0-表示没有重启，1-有过重启
    BYTE    byPowerSupply;//是否正常供电 0-不在供电，1-正在供电
    BYTE    byStatusType;//设备状态:0:正常、1：异常、2、报警
    BYTE    bySensorType;//参考传感器枚举类型SENSOR_TYPE
    float      fVoltageValue;//电压值； 精确到0.001
    float    fCurrentValue;//电流值；精确到0.001
    float   fActualValue;//模拟信号转换后的数值；精确到0.001
    char    szDescription[MAX_DESCRIPTION_LEN /* 32*/]; //描述信息;当设备状态（byStatusType）为非0时生效。
    BYTE    byRes1[128];
}NET_DVR_SENSOR_INFO_UPLOAD,*LPNET_DVR_SENSOR_INFO_UPLOAD;

typedef struct tagNET_DVR_CAPTURE_UPLOAD
{
    DWORD dwSize; 
    NET_DVR_TIME_V30  struTime;
    DWORD    dwChannel;//通道号
    char    szDevName[MAX_DEVNAME_LEN_EX];
    DWORD   dwPicLen;//图片长度
    BYTE    *pBuffer;    //图片数据指针
    BYTE    byRes[124];
}NET_DVR_CAPTURE_UPLOAD,*LPNET_DVR_CAPTURE_UPLOAD;

typedef struct tagNET_DVR_PANORAMIC_LINKAGE
{
    DWORD   dwSize;
    DWORD   dwChannel;//通道号
    BYTE  byType;//图片类型，0-无意义，1-全景联动到位图片
    BYTE  byRes1[3];
    BYTE        byMACAddr[MACADDR_LEN];             //mac地址
    BYTE      byRes2[2];
    NET_DVR_IPADDR   struDevIP;                     //设备IP地址
    DWORD    dwPicLen;//全景联动到位抓拍图片长度
    char      *pPicBuff; //全景联动到位抓拍图片指针
    BYTE       byRes[128];
}NET_DVR_PANORAMIC_LINKAGE, *LPNET_DVR_PANORAMIC_LINKAGE;

typedef struct tagNET_DVR_AREA_MASK_CFG  //区域马赛克
{
    DWORD  dwSize;  //结构体大小
    BYTE   byEnable;//是否启用马赛克   0-否，1-是
    BYTE   byMaskThick;  //马赛克厚度 0-薄码，1-中码，2-厚码，薄码的区块大小为8*8，中码16*16，厚码32*32。默认为中码
    BYTE   byAutoMask;//是否启用自动马赛克   0-否，1-是
    BYTE   byRes1;
    NET_VCA_RECT  struRegion[MAX_MASK_AREA_NUM];//马赛克区域范围
    BYTE   byRes[64];
}NET_DVR_AREA_MASK_CFG, *LPNET_DVR_AREA_MASK_CFG;

typedef struct tagNET_DVR_AUDIO_DIACRITICAL_CFG  //音频变音
{
    DWORD  dwSize;  //结构体大小
    BYTE   byEnable;  //是否启用变音 0-不启用，1-启用
    char    byBassValue;   //高低音值，范围为-12-12 值越大声音越细，反之越小，0-表示不变音
    BYTE   byRes[62];
}NET_DVR_AUDIO_DIACRITICAL_CFG, *LPNET_DVR_AUDIO_DIACRITICAL_CFG;

typedef struct tagNET_DVR_RESOLUTION_SWITCH
{
    DWORD            dwSize;
    BYTE             byResolutionType;//0-all,1-20:9,2-20:6,3-原始码流模式
    BYTE             byRes[127];
}NET_DVR_RESOLUTION_SWITCH, *LPNET_DVR_RESOLUTION_SWITCH;

typedef struct tagNET_DVR_WIFI_DHCP_ADDR_CFG  //wifi模式下DHCP范围配置
{
    DWORD       dwSize;
    NET_DVR_IPADDR   struStartAddr;   //开始IP地址
    NET_DVR_IPADDR   struEndAddr;     //结束IP地址
    BYTE        byRes[256];
}NET_DVR_WIFI_DHCP_ADDR_CFG, *LPNET_DVR_WIFI_DHCP_ADDR_CFG;

typedef struct tagNET_DVR_WIFI_CLIENT_INFO  //音频变音
{
    DWORD       dwSize;
    NET_DVR_IPADDR       struAddress;  //IP地址
    BYTE        byMACAddr [MACADDR_LEN];
    WORD        wConnSpeed;    //连接速度 单位KB
    BYTE        byRSSIValue;         //接收到的信号强度，取值为负值，传输时不带赋值，范围为0~-110dbm,值越大，代表信号越强
    BYTE        byRes1;         //保留
    WORD        wBandwidth;     //网络带宽  单位KB 
    BYTE        byRes[32];
}NET_DVR_WIFI_CLIENT_INFO, *LPNET_DVR_WIFI_CLIENT_INFO;

typedef struct tagNET_DVR_MULTISTREAM_RELATION_CHAN_CFG  //多码流关联通道
{
    DWORD       dwSize;              //结构体大小
    DWORD       dwChannel;           //关联的编码通道号
    BYTE        byRes[64];
}NET_DVR_MULTISTREAM_RELATION_CHAN_CFG, *LPNET_DVR_MULTISTREAM_RELATION_CHAN_CFG;

typedef struct  
{
    BYTE byPort;   //端口
    BYTE byMasterSlaveProperty;   //端口主从属性  1-主  2-从
    BYTE byPortEthernetType;  //端口类型，1-百兆端口，2-千兆端口
    BYTE byRes[9]; 
}NET_DVR_RING_PORT_PROPERTY, *LPNET_DVR_RING_PORT_PROPERTY;

typedef struct  
{
    DWORD   dwSize; 
    BYTE     byEnable;     //是否启用， 0-不启用， !0-启用
    BYTE     byProtoType;  //协议类型， 1-光端机组网协议(私有)，2-综合平台组网协议（私有），3-G8032协议（公有）
    BYTE   byBandWidth;   //环网带宽类型，1-百兆，2-千兆
    BYTE     byRes1;        //保留字段
    NET_DVR_RING_PORT_PROPERTY struRingPort[PER_RING_PORT_NUM];  //环网端口
    BYTE      byRes2[60];    //保留字段
}NET_DVR_NS_RING_CFG,  *LPNET_DVR_NS_RING_CFG;

typedef struct  //
{
    DWORD   dwSize;   //结构体大小
    BYTE     byStatus;              //环网状态，1-正常 2-断开
    BYTE     byMasterSlaveProperty ; //光纤板主从属性 1-主  2-从
    BYTE     byRes[62];            //保留字段
} NET_DVR_NS_RING_STATUS, *LPNET_DVR_NS_RING_STATUS;

typedef struct tagNET_DVR_FIREDETECTION_ALARM
{
    DWORD   dwSize; //结构大小
    DWORD     dwRelativeTime; //相对时标
    DWORD    dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO  struDevInfo;   //前端设备信息
    WORD    wPanPos;
    WORD    wTiltPos;
    WORD    wZoomPos;
    BYTE    byPicTransType;        //图片数据传输方式: 0-二进制；1-url
    BYTE    byRes1;
    DWORD   dwPicDataLen;//报警抓拍图片长度
    BYTE    *pBuffer;    //数据指针
    NET_VCA_RECT struRect;//火点框 
    NET_VCA_POINT struPoint ;//火点框内最高温度点坐标
    WORD    wFireMaxTemperature ;//火点最高温度[300℃~4000℃]
    WORD    wTargetDistance ;//目标距离[100m ~ 10000m]
    BYTE    byStrategyType;//策略类型；0~任意报警，1~协同报警，2~多系统报警，3~指定火点报警，4~指定烟雾报警
    BYTE    byAlarmSubType;//报警子类型。0~火点检测报警，1~烟雾检测报警，2~烟火报警
    /*是否启用PTZ坐标扩展，
    0~不启用，PTZ坐标值以wPanPos、wTiltPos、wZoomPos为准。
    1~启用，PTZ坐标值以struPtzPosEx为准。但是新老PTZ都需返回。struPtzPosEx的值需转化为wPanPos、wTiltPos、wZoomPos值。
    */
    BYTE    byPTZPosExEnable;
    BYTE    byRes2;
    NET_PTZ_INFO struPtzPosEx;// ptz坐标扩展(支持高精度PTZ值，精确到小数点后三位)
    DWORD   dwVisiblePicLen;//可见光图片长度
    BYTE    *pVisiblePicBuf;    //可见光图片数据指针
    // pSmokeBuf参数当byAlarmSubType报警子类型为1（烟雾检测报警）、2（烟火报警）时生效。
    BYTE    *pSmokeBuf;    //烟雾检测报警数据指针，指向一个NET_DVR_SMOKEDETECTION_ALARM结构体
    WORD    wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    BYTE    byRes3;
    BYTE    byFireScanWaitMode; //火点扫描等待模式 0-自动   1-手动
    DWORD   dwVisibleChannel; //可见光通道通道号
    BYTE    byTimeDiffFlag;      /*时差字段是否有效  0-时差无效， 1-时差有效 */
    char    cTimeDifferenceH;         /*与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效*/
    char    cTimeDifferenceM;      	/*与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效*/
    BYTE    byRes[49];
} NET_DVR_FIREDETECTION_ALARM,*LPNET_DVR_FIREDETECTION_ALARM;

typedef struct tagNET_DVR_SMOKEDETECTION_CFG
{
    BYTE    byEnable;//使能
    BYTE    bySensitivity; //检测灵敏度: 1~100默认50
    BYTE    byPatrolSensitivity; //巡航检测灵敏度: 1~100默认50
    BYTE    byDoubleCheckSensitivity; //二次过滤灵敏度: 1~100默认50
    BYTE    byRes[56];
}NET_DVR_SMOKEDETECTION_CFG, *LPNET_DVR_SMOKEDETECTION_CFG;





typedef struct tagNET_DVR_AREA_MONITOR_COND
{
    DWORD  dwSize; 
    DWORD  dwAreaID;   //区域ID
    DWORD  dwMonitorID;  //当前开始获取的监控点编号，从1开始
    BYTE   byIsNeedGroup;  //是否查询关联分组信息
    BYTE   byRes [127];
}NET_DVR_AREA_MONITOR_COND,*LPNET_DVR_AREA_MONITOR_COND;

typedef struct tagNET_DVR_DEL_MONITOR_COND
{
    DWORD  dwSize;  
    BYTE  byDelType;     //删除类型，0-删除指定区域的所有监控点，1-删除指定区域的指定监控点
    DWORD  dwAreaID;   //区域ID
    DWORD  dwMonitorID;   //监控点ID（当byDelType为0时无效，当byDelType为1时有效），从1开始
    BYTE   byRes[64];
}NET_DVR_DEL_MONITOR_COND,*LPNET_DVR_DEL_MONITOR_COND;

typedef struct tagNET_DVR_BLOCKLIST_ALARM_COND
{
    DWORD       dwSize;         //结构体大小
    BYTE        byType;         //名单标志：- 全部，- 允许名单，- 禁止名单
    BYTE        byRes1[3];      //保留
    DWORD       dwFaceID;       //人脸名单ID
    DWORD       dwMaxSnapNum;   //最大抓拍张数，0-表示不限制
    BYTE        byRes[256];
}NET_DVR_BLOCKLIST_ALARM_COND, *LPNET_DVR_BLOCKLIST_ALARM_COND;

typedef struct tagNET_DVR_STORAGE_RESOURCE_COND
{
    DWORD      dwSize;         //结构体大小
    DWORD        dwStorageID;    //从当前编号开始获取剩余资源，从1开始
    BYTE        byRes[64];
}NET_DVR_STORAGE_RESOURCE_COND, *LPNET_DVR_STORAGE_RESOURCE_COND;

typedef struct tagNET_DVR_BLOCKLIST_ALARM_RECORD
{
    DWORD          dwSize;   //结构体大小
    DWORD            dwSnapFacePicID;    //抓拍人脸ID
    DWORD            dwRegisterID;        //名单注册ID号（只读）
    DWORD            dwGroupNo;            //分组号
    BYTE            byRes[128];
}NET_DVR_BLOCKLIST_ALARM_RECORD, *LPNET_DVR_BLOCKLIST_ALARM_RECORD;

typedef struct tagNET_DVR_BLOCKLIST_GROUP_INFO  //名单分组信息
{
    DWORD          dwSize;   //结构体大小
    DWORD          dwGroupID; //分组编号（获取时有效，添加时无效），从1开始
    DWORD            dwGroupNo;            //名单分组号
    BYTE            byGroupType;        //分组类型，0-禁止名单分组，1-允许名单分组
    BYTE            byRes1;
    WORD            wThreshold;            //报警阈值，取值范围为0-1000
    DWORD            dwListNum;            //分组名单数
    BYTE            szGroupName[NAME_LEN];  //分组名称
    BYTE            szRemark[MAX_LEN_256];
    BYTE            byStorageAddr[MAX_DOMAIN_NAME];  //存储IP地址信息
    WORD            wStoragePort;            //存储IP对应的端口号
    BYTE            byRes[126];
}NET_DVR_BLOCKLIST_GROUP_INFO, *LPNET_DVR_BLOCKLIST_GROUP_INFO;

typedef struct tagNET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD  
{
    DWORD          dwSize;   //结构体大小
    DWORD            dwGroupRecordID;            //分组记录ID，修改和查询时有效，增加时无效，从1开始
    DWORD            dwGroupNo;            //名单分组号
    DWORD            dwFaceDBID;            //人脸库ID
    DWORD            dwFaceRecordID;        //人脸记录ID
    BYTE            byAlarmLevel;        //报警等级，0-high,1-medium,2-low
    BYTE            byRes1[3];            //保留
    NET_DVR_ADDR_DOMAIN_INFO struStorageAddr;   //存储IP地址信息
    BYTE            byRes[256];
}NET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD,*LPNET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD;

typedef struct tagNET_DVR_BLOCKLIST_GROUP_RECORD_COND
{
    DWORD          dwSize;   //结构体大小
    DWORD            dwRecordID;                //从当前编号开始获取，从1开始
    BYTE            byRes[64];
}NET_DVR_BLOCKLIST_GROUP_RECORD_COND, *LPNET_DVR_BLOCKLIST_GROUP_RECORD_COND;

typedef struct tagNET_DVR_BLOCKLIST_GROUP_RECORD_CFG  //名单分组记录信息
{
    DWORD          dwSize;   //结构体大小
    DWORD            dwRecordNum;            //记录总个数
    NET_DVR_SINGLE_BLOCKLIST_GROUP_RECORD struRecord[MAX_GROUP_RECORD_NUM]; //记录参数
    BYTE            byRes[256];
}NET_DVR_BLOCKLIST_GROUP_RECORD_CFG,*LPNET_DVR_BLOCKLIST_GROUP_RECORD_CFG;

typedef struct tagNET_DVR_BLOCKLIST_GROUP_CFG  //名单分组记录信息
{
    DWORD          dwSize;   //结构体大小
    DWORD            dwGroupNum;            //分组总个数
    NET_DVR_BLOCKLIST_GROUP_INFO struGroup[MAX_GROUP_RECORD_NUM]; //记录参数
    BYTE            byRes[256];
}NET_DVR_BLOCKLIST_GROUP_CFG,*LPNET_DVR_BLOCKLIST_GROUP_CFG;

typedef struct tagNET_DVR_BLOCKLIST_GROUP_COND
{
    DWORD        dwSize;   //结构体大小
    DWORD            dwGroupID;                //从当前编号开始获取，从1开始
    BYTE            byRes[64];
}NET_DVR_BLOCKLIST_GROUP_COND, *LPNET_DVR_BLOCKLIST_GROUP_COND;






typedef struct tagNET_DVR_GB28181_SERVICE_CFG
{
    DWORD  dwSize;     //结构体大小
    BYTE   byServerID[DEV_ID_LEN];  //SIP服务器ID；
    WORD   wPort;      //SIP服务器端口号
    BYTE   byRes1[2];  //保留
    BYTE   byAuthPasswd[PASSWD_LEN];
    DWORD  dwRegisterValid;           //存活期周期，单位：秒，默认：3600 
    BYTE   byMaxHeartbeatTimeOut;    //最大心跳超时次数，默认：3次
    BYTE   byAutoAddIpc;            //是否启用自动添加ipc,0-不启用，1-启用
    BYTE   byAuthPasswdEx[MAX_PASSWD_LEN_EX];   //密码扩展为64位，设置时，byAuthPasswdEx为非空，此参数有效，byAuthPasswd无效，获取时，byAuthPasswdEx和byAuthPasswd都返回
    BYTE   byRes[190];                //保留
}NET_DVR_GB28181_SERVICE_CFG,*LPNET_DVR_GB28181_SERVICE_CFG;


typedef struct tagNET_DVR_IPDEVICE_ACTIVATE_CFG
{
    DWORD       dwSize;    //结构体大小
    BYTE        byMode;    //0-按通道激活，1-按地址激活
    BYTE        bySelfDefinePassword;//是否自定义密码,0-否,1-是,2-是,且为IPC的自定义密码
    BYTE        sPassword[PASSWD_LEN];//自定义密码
    BYTE        sUserName[NAME_LEN];//用户名
    BYTE        byRes[78];
    union
    {
        BYTE        byLen[512];//union大小
        struct
        {
            DWORD       dwChannelNo;//通道号
            BYTE        byRes[508];
        }struChannelInfo;//通道信息
        struct
        {
            NET_DVR_IPADDR   struIp;//IP地址
            WORD    wPort;//端口号
            BYTE    sProtocolDesc[DESC_LEN];//协议类型
            BYTE    byMacAddr[MACADDR_LEN];//mac地址
            BYTE    byRes[344];
        }struAddrInfo;//IP地址，来自NET_DVR_SADPINFO
    }unActivateDeviceInfo;//使用联合体结构，通过byMode字段表示是按通道还是按地址
}NET_DVR_IPDEVICE_ACTIVATE_CFG,*LPNET_DVR_IPDEVICE_ACTIVATE_CFG;

typedef struct tagNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS_
{
    DWORD  dwSize;
    BYTE   byDigitalChanPasswordStatus[MAX_CHANNUM_V30*4];//0-保留,1-IPC未激活，2-风险密码，3-密码强度弱，4-密码强度中，5-密码强度强;byDigitalChanPasswordStatus[0]表示第一个数字通道
    BYTE   byRes[1140];
}NET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS, *LPNET_DVR_DIGITAL_CHANNEL_SECURITY_STATUS;

typedef struct tagNET_DVR_CAMERACHAN_SERIALCFG
{  
    DWORD    dwSize;
    DWORD   dwBaudRate;  //波特率(bps)，0-50，1-75，2-110，3-150，4-300，5-600，6-1200，7-2400，8-4800，9-9600，10-19200，11-38400，12-57600，13-76800，14-115.2k
    BYTE    byDataBit; //数据有几位：0-5位，1-6位，2-7位，3-8位
    BYTE    byStopBit;  //停止位：0-1位，1-2位
    BYTE    byParity;  //是否校验：0-无校验，1-奇校验，2-偶校验
    BYTE    byFlowcontrol;// 是否流控：0-无，1-软流控,2-硬流控
    WORD    wPTZProtocol;  //控球协议类型，索引值
    BYTE    byRes1[6];
    DWORD   dwSerialPort; //串口号,最高位为0，表示前面板串口，最高位为1，表示后面板串口
    BYTE    bySerialAddress; //串口地址0~255
    BYTE    byRes[15];
}NET_DVR_CAMERACHAN_SERIALCFG, *LPNET_DVR_CAMERACHAN_SERIALCFG;



typedef struct  tagNET_DVR_MATRIX_STATUS
{
    DWORD dwSize;
    BYTE  byMainFrameType;   //机箱类型  1-18U机箱(V1.0) 2-18U机箱 3-14U机箱 4-11U机箱 5-8U机箱 6-7U机箱  7-5U机箱
    BYTE  bySoltNum;   //槽位数
    BYTE  byBoardNum;   //子板数
    BYTE  byRes;
    NET_DVR_MATRIX_SUBBOARD struMatrixSubboard[MAX_MATRIX_SUBBOARD_NUM];
    BYTE  byRes2[48];
}NET_DVR_MATRIX_STATUS, *LPNET_DVR_MATRIX_STATUS;


typedef struct  tagNET_DVR_MATRIX_STATUS_V50
{
    DWORD dwSize;
    BYTE  byMainFrameType; //机箱类型  1-18U机箱(V1.0) 2-18U机箱 3-14U机箱 4-11U机箱 5-8U机箱 6-7U机箱  7-5U机箱
    BYTE  bySoltNum; //槽位数
    BYTE  byBoardNum; //子板数
    BYTE  byLCDPanelStatus; //液晶面板连接状态，1-正常，2-异常
    NET_DVR_MATRIX_SUBBOARD_V50 struMatrixSubboard[MAX_MATRIX_SUBBOARD_NUM];
    DWORD dwFanSequence; //风扇编号，按位表示，最低位不使用，例如0xffffff04表示编号为1的风扇，当对应风扇被置位时，dwFanConnectStatus和dwFanOperationStatus的对应位才有效，否则认为无此编号的风扇
    DWORD dwFanConnectStatus; //风扇连接状态，按位表示，最低位不使用，例如0xffffff00表示编号为1的风扇连接正常，0xffffff04表示编号为1的风扇连接异常
    DWORD dwFanOperationStatus; //风扇运行状态，按位表示，最低位不使用，例如0xffffff00表示编号为1的风扇运行状态正常，0xffffff04表示编号为1的风扇运行异常
    BYTE  byDeviceModel[32]; //设备型号
    BYTE  byPowerNums; //电源数量
    BYTE  byMainBoardNums; //主控数量
    BYTE  byHotStandbyMode; // byMainBoardNums为2时，0-工作在M1槽位，1-工作在M2槽位
    BYTE  byRes[29];
}NET_DVR_MATRIX_STATUS_V50, *LPNET_DVR_MATRIX_STATUS_V50;

typedef struct tagNET_DVR_MATRIX_SUBBOARD_V51
{
    BYTE    byBoardNo; //子板号
    BYTE    byPcieConnectStatus; //pcie连接状态，1-连接，2-断开
    BYTE    byRes1;
    BYTE    byTemperatureAlarm; //温度报警，0-此字段无效，1-温度正常，2-温度超上限报警，3-温度超下限报警
    DWORD   dwHardwareVersion; //子板硬件版本
    DWORD dwPcieBandwidth; //pcie Link带宽
    DWORD dwTemperature; //子板温度，单位：摄氏度
    NET_DVR_SUBSYSTEM_STATUS    struSubsystemStatus[MAX_BOARD_SUBSYSTEM_NUM]; //子系统状态
    BYTE    bySubboardModel[32]; //子板型号
    BYTE    byRes2[128];
}NET_DVR_MATRIX_SUBBOARD_V51, *LPNET_DVR_MATRIX_SUBBOARD_V51;

typedef struct tagNET_DVR_MATRIX_STATUS_V51
{
    DWORD   dwSize;
    BYTE    byMainFrameType; //机箱类型 1-18U机箱（V1.0），2-18U机箱，3-14U机箱，4-11U机箱，5-8U机箱，6-7U机箱
    BYTE    bySoltNum; //槽位数
    BYTE    byBoardNum; //子板数
    BYTE    byLCDPanelStatus; //液晶面板连接状态，1-正常，2-异常
    NET_DVR_MATRIX_SUBBOARD_V51 struMatrixSubboard[MAX_MATRIX_SUBBOARD_NUM_V51];
    DWORD  dwFanSequence; //风扇编号，按位表示，例如0x00000001表示设备只有一个风扇，编号为1，0x00000101表示设备有两个风扇，编号分别为1和9，当对应风扇编号被置位时，dwFanConnectStatus和dwFanOperationStatus的对应位才有效，否则认为无此编号的风扇
    DWORD dwFanConnectStatus; //风扇连接状态，按位表示，例如0x00000001表示编号为1的风扇连接状态异常，0x00000101表示编号为1和9的风扇连接状态均异常
    DWORD dwFanOperationStatus; //风扇运行状态，按位表示，例如0x00000001表示编号为1的风扇运行状态异常，0x00000101表示编号为1和9的风扇运行状态均异常
    BYTE   byDeviceModel[32]; //设备型号
    BYTE    byFanSpeed[32]; //风扇转速，按字节表示，例如byFanSpeed[0]表示编号为1的风扇的转速，转速等级范围为[1,3]
    BYTE   byMainMemUsed; //主控内存使用率，单位：百分比
    BYTE    byMainCpuUsed; //主控CPU使用率，单位：百分比
    BYTE    byNetwordUsed; //交换板网络使用率，单位：百分比
    BYTE   byRes1;
    DWORD   dwMainSoftwareVer; //主控软件版本
    BYTE  byPowerNums; //电源数量
    BYTE  byMainBoardNums; //主控数量
    BYTE  byHotStandbyMode; // byMainBoardNums为2时，0-工作在M1槽位，1-工作在M2槽位
    BYTE     byRes2[125];
}NET_DVR_MATRIX_STATUS_V51, *LPNET_DVR_MATRIX_STATUS_V51;

typedef struct _NET_DVR_SUBWIND_INFO
{
	DWORD dwSize;
    DWORD dwSubWndNo; //子窗口号
	BYTE	byRes[8];
} NET_DVR_SUBWIND_INFO, *LPNET_DVR_SUBWIND_INFO;

typedef struct tagNET_DVR_FUSION_SCALE
{
    DWORD dwSize;
    WORD wWidth;  //图像融合宽(横向图像数目)
    WORD wHeight; //图像融合高(纵向图像数目)
    BYTE byRes[32];
}NET_DVR_FUSION_SCALE, *LPNET_DVR_FUSION_SCALE;

typedef struct tagNET_DVR_FUSION_CFG
{
    DWORD dwSize;
    BYTE byFusion;  //是否融合，0-未融合或取消融合，非0-融合
    BYTE byUseHistoryMap; //是否使用历史融合映射表，0-不使用，非0-使用
    BYTE byRes[30]; 
}NET_DVR_FUSION_CFG, *LPNET_DVR_FUSION_CFG;

typedef struct tagNET_DVR_MULTIFUNCTION_SERIALCFG
{
    DWORD dwSize ;
    BYTE  byVariable ;  //串口是否可变，1-不可变  2-可变 （只获取）
    BYTE  bySerialWorkMode;   //工作模式，1-RS485, 2-RS232（只在可变情况下，修改工作模式）
    BYTE  byFunType;   //串口功能， 1-键盘控制，2-屏幕控制，3-透明通道模式 4-PTZ控制  5-矩阵控制 6-控制台
    BYTE byDataBit;// 数据位 0－5位，1－6位，2－7位，3－8位;
    BYTE byStopBit;// 停止位 0－1位，1－2位;
    BYTE byParity;// 校验 0－无校验，1－奇校验，2－偶校验;
    BYTE byFlowcontrol;// 0－无，1－软流控,2-硬流控
    BYTE byRes1 ;   
    DWORD dwBaudRate;//波特率0－50，1－75，2－110，3－150，4－300，5－600，6－1200，7－2400，8－4800，9－9600，10－19200， 11－38400，12－57600，13－76800，14－115.2k;   
    WORD wProtocol;   //串口协议  不同串口功能对应串口协议不一样
    BYTE byRes[34];
}NET_DVR_MULTIFUNCTION_SERIALCFG, *LPNET_DVR_MULTIFUNCTION_SERIALCFG;

typedef struct tagNET_DVR_PTZ_3D_SPEED_CONTROL
{
    DWORD  dwSize;
    DWORD  dwChannel;  //通道号
    BYTE    byPSpeed;  // X轴控制速度  （取值1－64）
    BYTE    byTSpeed;  // Y轴控制速度   （取值1－64）
    BYTE    byZSpeed;  // Z速度
    BYTE    byPDirect; // P方向， 1-左， 2-右
    BYTE    byTDirect; // T方向， 1-上， 2-下
    BYTE    byZDirect;  //Z方向，  1-ZOOM+,  2-ZOOM-
    BYTE    byRes[18];  //保留字节
}NET_DVR_PTZ_3D_SPEED_CONTROL, *LPNET_DVR_PTZ_3D_SPEED_CONTROL; 

typedef struct tagNET_DVR_SENSOR_PARAM
{
    BYTE        bySensorType;//SensorType:0-CCD,1-CMOS
    BYTE        byRes[31];
    float       fHorWidth;//水平宽度 精确到小数点后两位 *10000
    float       fVerWidth;//垂直宽度 精确到小数点后两位 *10000
    float       fFold;//zoom=1没变时的焦距 精确到小数点后两位 *100
}NET_DVR_SENSOR_PARAM,*LPNET_DVR_SENSOR_PARAM;

typedef struct tagNET_DVR_TURN_DIRECTION_PARAM
{
    BYTE   byLine;//转向线编号
    BYTE   byStatus;//转向线状态，0-未知，1-进入，2-离开
    BYTE   byRes[38];
}NET_DVR_TURN_DIRECTION_PARAM, *LPNET_DVR_TURN_DIRECTION_PARAM;

typedef struct tagNET_DVR_STOP_LINE_PARAM
{
    BYTE   byStatus;//停止线状态，0-未知，1-进入，2-离开
    BYTE   byRes[39];
}NET_DVR_STOP_LINE_PARAM, *LPNET_DVR_STOP_LINE_PARAM;

typedef struct tagNET_DVR_TPS_ADDINFO
{
    NET_DVR_LLPOS_PARAM struFirstLLPos;//车流量第一辆车的经纬度位置信息(byLaneState=3且byQueueLen>0时才返回)
    NET_DVR_LLPOS_PARAM struLastLLPos;//车流量最后一辆车的经纬度位置信息(byLaneState=3且byQueueLen>0时才返回)
    char            sLicense[MAX_LICENSE_LEN/*16*/];//车牌号
    NET_DVR_TURN_DIRECTION_PARAM    struTurnDirection;//转向流量信息
    NET_DVR_STOP_LINE_PARAM  struStopLine;//停止线信息    
    BYTE   byRes[884];
}NET_DVR_TPS_ADDINFO, *LPNET_DVR_TPS_ADDINFO;

typedef struct tagNET_DVR_VEHICLE_ADDINFO
{
    NET_DVR_LLPOS_PARAM struLLPos;//车辆当前经纬度位置信息
    char   sVehicleNo[LEN_64]; /*上传的车辆唯一标识,最大长度为64*/
    BYTE   byVehicleMonitorTaskID[64];//车辆智能布控任务ID,64位字符串,创建任务时由上层下发给设备,上层确保ID唯一性
    BYTE   byUUID[LEN_64]; //通用唯一识别码,64位字符串,设备确保唯一性，用于跨服务器关联同一次抓拍,vehicleMonitor，manualVehicleMonitor，dailyVehicleMonitor报警中的linkageANPRUUID有关
    BYTE   byRes[832];
}NET_DVR_VEHICLE_ADDINFO, *LPNET_DVR_VEHICLE_ADDINFO;

typedef struct tagNET_DVR_SMOKEDETECTION_ALARM
{
    NET_PTZ_INFO struPTZPos;//可见光设备PTZF位置
    NET_PTZ_INFO struThermalPTZPos;//热成像设备PTZF位置
    NET_DVR_LLPOS_PARAM struLLPos;//设备经纬度位置
    NET_VCA_RECT  struSmokePos;//画面中烟雾区域位置
    BYTE   byRes[256];
}NET_DVR_SMOKEDETECTION_ALARM, *LPNET_DVR_SMOKEDETECTION_ALARM;


typedef struct tagNET_DVR_GIS_UPLOADINFO
{
    DWORD   dwSize;//结构体大小
    DWORD     dwRelativeTime; //相对时标
    DWORD    dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO    struDevInfo;//前端设备
    float   fAzimuth;//电子罗盘的方位信息；方位角[0.00°,360.00°)
    BYTE    byLatitudeType ;//纬度类型，0-北纬，1-南纬
    BYTE    byLongitudeType ;// 经度类型，0-东度，1-西度
    BYTE    byRes1[2] ;
    NET_DVR_LLI_PARAM    struLatitude;     /*纬度*/
    NET_DVR_LLI_PARAM    struLongitude;   /*经度*/
    float   fHorizontalValue;//水平视场角，精确到小数点后面两位
    float   fVerticalValue;//垂直视场角，精确到小数点后面两位
    float   fVisibleRadius;//当前可视半径，精确到小数点后面两位
    float   fMaxViewRadius;//最大可视半径，精确到小数点后面0位（预留处理）
    NET_DVR_SENSOR_PARAM  struSensorParam;//Sensor信息
    NET_DVR_PTZPOS_PARAM  struPtzPos; //ptz坐标
    BYTE  byRes[256];
}NET_DVR_GIS_UPLOADINFO,*LPNET_DVR_GIS_UPLOADINFO;

typedef struct  tagNET_DVR_VANDALPROOF_ALARM
{
    DWORD        dwSize;//结构体大小
    DWORD         dwRelativeTime; //相对时标
    DWORD        dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO    struDevInfo;//前端设备
    BYTE  byRes[256];
}NET_DVR_VANDALPROOF_ALARM,*LPNET_DVR_VANDALPROOF_ALARM;


typedef struct tagNET_DVR_GIS_INFO
{
    DWORD  dwSize;//结构体大小
    float  fAzimuth;//电子罗盘的方位信息；方位角[0.00°,360.00°)
    float  fHorizontalValue;//水平视场角，精确到小数点后面两位
    float  fVerticalValue;//垂直视场角，精确到小数点后面两位
    float  fVisibleRadius;//当前可视半径，精确到小数点后面两位
    float  fMaxViewRadius;//最大可视半径，精确到小数点后面0位（预留处理）
    BYTE   byLatitudeType ;//纬度类型，0-北纬，1-南纬
    BYTE   byLongitudeType ;// 经度类型，0-东经，1-西经
    BYTE byPTZPosExEnable;//是否启用PTZ坐标扩展，0~不启用，PTZ坐标值以struPtzPos 为准。1~启用，PTZ坐标值以struPtzPosEx为准。
    BYTE byRes1;
    NET_DVR_LLI_PARAM     struLatitude;     /*纬度*/
    NET_DVR_LLI_PARAM    struLongitude; /*经度*/
    NET_DVR_PTZPOS_PARAM struPtzPos; //ptz坐标
    NET_DVR_SENSOR_PARAM struSensorParam;//Sensor信息
    NET_PTZ_INFO struPtzPosEx;// ptz坐标扩展(支持高精度PTZ值，精确到小数点后三位)
    float   fMinHorizontalValue;//最小水平视场角，精确到小数点后面两位；0.0-360.00
    float   fMaxHorizontalValue;//最大水平视场角，精确到小数点后面两位；0.0-360.00
    float   fMinVerticalValue;//最小垂直视场角，精确到小数点后面两位；0.0-360.00
    float   fMaxVerticalValue;//最大垂直视场角，精确到小数点后面两位；0.0-360.00
    BYTE  byRes[220];
}NET_DVR_GIS_INFO,*LPNET_DVR_GIS_INFO;


typedef struct tagNET_DVR_TEMP_HUMI_INFO
{
    DWORD    dwSize;
    NET_DVR_TIME_V30      struCurrentTime; // 当前时间
    float        fTemperature;//设备环境温度，精确到小数点后两位，（-273 – 1000摄氏度）
    float        fHumidity;// 设备环境湿度，精确到小数点后两位。单位为：%
    BYTE       byRes[256];
}NET_DVR_TEMP_HUMI_INFO, *LPNET_DVR_TEMP_HUMI_INFO;

typedef struct tagNET_SDK_POINT_THERMOMETRY
{
    float        fPointTemperature;/*点测温当前温度, 当标定为0-点时生效。精确到小数点后一位(-40-1000),（浮点数+100）*10 */
    NET_VCA_POINT  struPoint;//点测温坐标（当规则标定类型为“点”的时候生效）
    BYTE       byRes[20];
}NET_SDK_POINT_THERMOMETRY, *LPNET_SDK_POINT_THERMOMETRY;

typedef struct tagNET_SDK_REGION_THERMOMETRY
{
    float            fMaxTemperature;//最高温度,精确到小数点后一位(-40-1000),（浮点数+100）*10 */
    float            fMinTemperature;//最低温度,精确到小数点后一位(-40-1000),（浮点数+100）*10 */
    float            fAverageTemperature;//平均温度,精确到小数点后一位(-40-1000),（浮点数+100）*10 */
    float            fTemperatureDiff;//温差,精确到小数点后一位(-40-1000),（浮点数+100）*10 */
    NET_VCA_POLYGON struRegion;//区域、线（当规则标定类型为“框”或者“线”的时候生效）
    BYTE       byRes[20];
}NET_SDK_REGION_THERMOMETRY, *LPNET_SDK_REGION_THERMOMETRY;



typedef struct tagNET_SDK_MANUALTHERM_BASICPARAM
{
    DWORD        dwSize;
    WORD         wDistance;//距离(m)[0, 10000]
    BYTE         byDistanceUnit;//距离单位: 0-米（m），1-英尺（feet）,2-厘米(centimeter)
    BYTE         byRes1[1]; //保留
    float        fEmissivity;//发射率(发射率 精确到小数点后两位)[0.01, 1.00](即：物体向外辐射能量的本领)
    BYTE         byRes[64]; //保留
}NET_SDK_MANUALTHERM_BASICPARAM, *LPNET_SDK_MANUALTHERM_BASICPARAM;

typedef struct tagNET_SDK_FIRESHIELDMASK_REGION
{
    DWORD        dwSize;
    BYTE      byMaskID;//区域ID，1~24
    BYTE      byEnabled;// 单个火点屏蔽区域使能，0~不启用，1~启用
    BYTE      byShieldZoom;//屏蔽倍率，0~32倍。屏蔽大于等于该值的光学变倍。
    BYTE      byMaskType;//屏蔽区域颜色类型，0-灰色，1-红色，2-黄色，3-蓝色，4-橙色，5-绿色，6-透明，7-半透明，8-马赛克
    BYTE      byRegionType;//区域类型（预留）0-四边形
    BYTE      byShowEnabled; //区域显示使能，该参数为只读，若该使能为false则上层不显示该区域相关信息。True为显示该区域相关信息
    BYTE         byRes1[2]; //保留
    char           szMaskName[NAME_LEN/*32*/];//屏蔽标题
    NET_VCA_POLYGON struRegion;//屏蔽区域
    BYTE         byRes[32]; //保留
}NET_SDK_FIRESHIELDMASK_REGION, *LPNET_SDK_FIRESHIELDMASK_REGION;

typedef struct tagNET_SDK_FIRESHIELDMASK_CFG
{
    DWORD        dwSize;
    BYTE      byEnabled;// 火点区域屏蔽使能，0~不启用，1~启用
    BYTE         byShieldAreaTransparency;//屏蔽区域透明度 0-不透明 1-透明 2-半透明
    BYTE         byDisplayShieldAreaEnabled;//码流叠加屏蔽区域使能
    BYTE         byRes1[1]; //保留
    NET_SDK_FIRESHIELDMASK_REGION struMaskRegion[MAX_FIRESHIELDMASK_REGION/*24*/];//火点屏蔽区域
    BYTE         byRes[256]; //保留
}NET_SDK_FIRESHIELDMASK_CFG, *LPNET_SDK_FIRESHIELDMASK_CFG;

typedef struct tagNET_SDK_SMOKESHIELDMASK_REGION
{
    DWORD        dwSize;
    BYTE      byMaskID;//区域ID，1~24
    BYTE      byEnabled;// 单个烟雾屏蔽区域使能，0~不启用，1~启用
    BYTE      byShieldZoom;//屏蔽倍率，0~32倍。屏蔽大于等于该值的光学变倍。
    BYTE      byMaskType;//屏蔽区域颜色类型，0-灰色，1-红色，2-黄色，3-蓝色，4-橙色，5-绿色，6-透明，7-半透明，8-马赛克
    BYTE      byRegionType;//区域类型（预留）0-四边形
    BYTE      byShowEnabled;// 区域显示使能，该参数为只读，若该使能为false则上层不显示该区域相关信息。True为显示该区域相关信息
    BYTE       byRes1[2]; //保留
    char           szMaskName[NAME_LEN/*32*/];//屏蔽标题
    NET_VCA_POLYGON struRegion;//屏蔽区域
    BYTE         byRes[32]; //保留
}NET_SDK_SMOKESHIELDMASK_REGION, *LPNET_SDK_SMOKESHIELDMASK_REGION;

typedef struct tagNET_SDK_SMOKESHIELDMASK_CFG
{
    DWORD        dwSize;
    BYTE      byEnabled;// 烟雾区域屏蔽使能，0~不启用，1~启用
    BYTE         byShieldAreaTransparency;//屏蔽区域透明度 0-不透明 1-透明 2-半透明
    BYTE         byDisplayShieldAreaEnabled;//码流叠加屏蔽区域使能
    BYTE         byRes1[1]; //保留
    NET_SDK_SMOKESHIELDMASK_REGION struMaskRegion[MAX_SMOKESHIELDMASK_REGION/*24*/];//烟雾屏蔽区域
    BYTE         byRes[256]; //保留
}NET_SDK_SMOKESHIELDMASK_CFG, *LPNET_SDK_SMOKESHIELDMASK_CFG;

typedef struct tagNET_SDK_AREASCAN_CFG
{
    DWORD        dwSize;
    BYTE      byScanState;//区域扫描当前设置状态，0为未设置，1为已设置（该参数为只读）
    BYTE         byRes[259]; //保留
}NET_SDK_AREASCAN_CFG, *LPNET_SDK_AREASCAN_CFG;

typedef struct tagNET_SDK_FIRESHIELDMASK_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;//通道号
    BYTE        byRegionID;//区域ID，1~24.
    BYTE         byRes[127]; //保留
}NET_SDK_FIRESHIELDMASK_COND, *LPNET_SDK_FIRESHIELDMASK_COND;

typedef struct tagNET_SDK_SMOKESHIELDMASK_COND
{
    DWORD        dwSize;
    DWORD        dwChannel;//通道号
    BYTE        byRegionID;//区域ID，1~24.
    BYTE         byRes[127]; //保留
}NET_SDK_SMOKESHIELDMASK_COND, *LPNET_SDK_SMOKESHIELDMASK_COND;







typedef struct tagNET_DVR_SIGNAL_JOINT_CFG
{
    DWORD    dwSize;
    BYTE  sCamName[NAME_LEN] ;  //拼接后信号源名称
    BYTE  byEnable;               //使能，0-不使能  !0-使能
    BYTE  byCamMode ;            //拼接后信号源类型，NET_DVR_CAM_JOINT
    BYTE  byRows ;               //拼接行数
    BYTE  byColumns ;            //拼接列数
    DWORD dwSignalNo[MAX_SIGNAL_JOINT_NUM]; //信号源号,前byRows* byColumns项有效
    DWORD dwJointNo;           //拼接编号（获取有效）
    DWORD dwSignalNoJoint;      //拼接后的信号源号（获取有效）
    BYTE  byRes[64];
} NET_DVR_SIGNAL_JOINT_CFG, *LPNET_DVR_SIGNAL_JOINT_CFG;

typedef struct  tagNET_DVR_SIGNAL_CUTPARAM
{
    DWORD    dwSize;
    DWORD    dwSignalNo;     //信号源号 
    DWORD     dwCutTop;      //上方裁剪像素值,0代表还原
    DWORD      dwCutBottom;   //下方裁剪像素值,0代表还原
    DWORD      dwCutLeft;     //左边裁剪像素值,0代表还原
    DWORD      dwCutRight;    //右边裁剪像素值,0代表还原
    BYTE     byRes2[32];  
} NET_DVR_SIGNAL_CUTPARAM, *LPNET_DVR_SIGNAL_CUTPARAM; 

typedef struct tagNET_DVR_WALL_RELATION_CFG 
{
    DWORD dwSize; 
    BYTE  byEnable;           //关联， 0-不关联 !0-关联
    BYTE  byRealWallNo ;      //物理墙号
    BYTE  byRes[14] ; 
}NET_DVR_WALL_RELATION_CFG, *LPNET_DVR_WALL_RELATION_CFG;

typedef struct tagNET_DVR_INPUTSTREAMCFG_V40
{
    DWORD        dwSize ;
    BYTE        byValid ;     //
    BYTE        byCamMode ;//见NET_DVR_CAM_MODE
    WORD        wInputNo ; //信号源序号
    BYTE        sCamName[NAME_LEN] ;
    NET_DVR_VIDEOEFFECT     struVideoEffect ;//视频参数
    NET_DVR_PU_STREAM_CFG    struPuStream ;    //ip输入时使用
    WORD        wBoardNum ;      //信号源所在的板卡号，只能获取
    WORD        wInputIdxOnBoard ; //信号源在板卡上的位置，只能获取
    DWORD    dwResolution ;//分辨率
    BYTE    byVideoFormat ;//视频制式，见VIDEO_STANDARD
    BYTE    byStatus;    //信号源状态，0-字段无效 1-有信号 2-无信号 3-异常 
    BYTE    sGroupName[NAME_LEN/*32*/];    //网络信号源分组 组名
    BYTE    byJointMatrix ;            //关联矩阵，0-不关联  1-关联，当输入信号源为NET_DVR_CAM_BNC，NET_DVR_CAM_VGA，NET_DVR_CAM_DVI，NET_DVR_CAM_HDMI,中的一种时，该参数有效。
    BYTE    byJointNo ;         //拼接信号源的拼接编号(只能获取)
    BYTE    byColorMode;      //色彩模式， 0-自定义 1-锐利 2-普通 3-柔和，当为自定义时，使用struVideoEffect设置
    BYTE    byScreenServer; //关联屏幕服务器，0-不联，1-关联
    BYTE    byDevNo; //设备号
    BYTE    byRes1;
    DWORD    dwInputSignalNo; //输入信号源编号（新）
    BYTE    byVideoEnctype; //视频编码类型，0-默认，1-Smart264
    BYTE    byAudioEnctype; //音频编码类，0-默认，1-AUDIO_G711_A，2-AUDIO_G711_U，3- AUDIO_G722_1
    BYTE    byWallStatus;    //信号源上墙状态，0-无效 1-有上墙 2- 无上墙
    BYTE    byRes[117];
}NET_DVR_INPUTSTREAMCFG_V40, *LPNET_DVR_INPUTSTREAMCFG_V40 ;

typedef struct tagNET_DVR_AUDIO_CONTROL_INFO
{
    DWORD   dwSize;
    DWORD   dwMonId;//监视器全局编号
    BYTE    bySubWindowNum;//监视器对应子窗口号
    BYTE    byWallNo; //墙号
    BYTE    byEnable; //音频开关，0-关，1-开
    BYTE    byRes[13];
}NET_DVR_AUDIO_CONTROL_INFO,*LPNET_DVR_AUDIO_CONTROL_INFO;

typedef struct  tagNET_DVR_INPUTSTREAM_PTZCFG_PARAM 
{
    DWORD    dwSize;
    WORD     wPTZProtocol;  //控球协议类型，索引值 
    BYTE     byRes[34];    
}NET_DVR_INPUTSTREAM_PTZCFG_PARAM, *LPNET_DVR_INPUTSTREAM_PTZCFG_PARAM; 



typedef struct  tagNET_DVR_VEHICLE_WEIGHT_RESULT_
{
    BYTE      byIsOverWeight;         //是否超限
    BYTE      byAxleNum;            //轴数
    WORD      wAxleModel;           //参考 enum TRUCK_AXLE_MODEL,可以根据类型解析出轴的个数
    float     fOverWeight;          //超限重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
    float     fWeight;              //车身重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
    float     fLimitWeight;         //限制重量(吨)，实际值扩大1000倍传输（实际值精确到小数点后三位）
    float     fAxleLen;             //轴距(米)，实际值扩大100倍传输（实际值精确到小数点后两位）
    char      sDevDescInfo[MAX_DEVDESC_LEN/*64*/];      //设备描述信息
    WORD      wAxleWeight[MAX_TRUCK_AXLE_NUM/*10*/];    //车轴重量，单位千克（kg）第i个元素表示第i个轴重
    WORD      wAxleDistance[MAX_TRUCK_AXLE_NUM/*10*/];  //车轴间距，单位毫米(mm).第i个元素表示第i轴和第i+1轴的间距
    DWORD     dwLength;        //车长，单位cm
    DWORD     dwWidth;        //车宽，单位cm
    DWORD     dwHeight;        //车高，单位cm
    BYTE      byTollwayVehicleType;     //收费公路车型，参考TOOLWAY_VEHICLE_TYPE
    BYTE      byRes2[11];            //预留
}NET_DVR_VEHICLE_WEIGHT_RESULT, *LPNET_DVR_VEHICLE_WEIGHT_RESULT;

typedef struct tagNET_DVR_PLATE_RESULT_V50
{
    DWORD   dwSize;        //结构长度
    DWORD   dwMatchNo;        //匹配序号,由(车辆序号,数据类型,车道号)组成匹配码
    BYTE    byGroupNum;    //图片组数量（一辆过车相机多次抓拍的数量，代表一组图片的总数，用于延时匹配数据）
    BYTE    byPicNo;        //连拍的图片序号（接收到图片组数量后，表示接收完成;接收超时不足图片组数量时，根据需要保留或删除）
    BYTE    bySecondCam;    //是否第二相机抓拍（如远近景抓拍的远景相机，或前后抓拍的后相机，特殊项目中会用到）
    BYTE    byFeaturePicNo; //闯红灯电警，取第几张图作为特写图,0xff-表示不取
    BYTE    byDriveChan;        //触发车道号
    BYTE    byVehicleType;     //车辆类型，参考VTR_RESULT
    BYTE    byDetSceneID;//检测场景号[1,4], IPC默认是0
    //车辆属性，按位表示，0- 无附加属性(普通车)，bit1- 黄标车(类似年检的标志)，bit2- 危险品车辆，值：0- 否，1- 是
    //该节点已不再使用,使用下面的byYellowLabelCar和byDangerousVehicles判断是否黄标车和危险品车
    BYTE    byVehicleAttribute;
    WORD    wIllegalType;       //违章类型采用国标定义
    BYTE    byIllegalSubType[8];   //违章子类型
    BYTE    byPostPicNo;    //违章时取第几张图片作为卡口图,0xff-表示不取
    BYTE    byChanIndex;        //通道号（保留）
    WORD    wSpeedLimit;        //限速上限（超速时有效）
    BYTE    byChanIndexEx;      //byChanIndexEx*256+byChanIndex表示真实通道号。
    BYTE    byVehiclePositionControl;  /*车辆位置布控标志,0~为普通车牌识别报警,1~为车辆位置布控触发报警
                                       (即通过PUT /ISAPI/Traffic/channels/<ID>/vehiclePositionControl?format=json触发)*/
    NET_DVR_PLATE_INFO  struPlateInfo;     //车牌信息结构
    NET_DVR_VEHICLE_INFO struVehicleInfo;    //车辆信息
    BYTE    byMonitoringSiteID[48];        //监测点编号
    BYTE    byDeviceID[48];                //设备编号
    BYTE    byDir;            //监测方向，1-上行（反向），2-下行(正向)，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南，8-其它
    BYTE    byDetectType;    //检测方式,1-地感触发，2-视频触发，3-多帧识别，4-雷达触发
    //关联车道方向类型，参考ITC_RELA_LANE_DIRECTION_TYPE
    //该参数为车道方向参数，与关联车道号对应，确保车道唯一性。
    BYTE    byRelaLaneDirectionType;
    BYTE    byCarDirectionType; //车辆具体行驶的方向，0表示从上往下，1表示从下往上（根据实际车辆的行驶方向来的区分）,2表示未知
    //当wIllegalType参数为空时，使用该参数。若wIllegalType参数为有值时，以wIllegalType参数为准，该参数无效。
    DWORD   dwCustomIllegalType; //违章类型定义(用户自定义)
    /*为0~数字格式时，为老的违章类型，wIllegalType、dwCustomIllegalType参数生效，赋值国标违法代码。
    为1~字符格式时，pIllegalInfoBuf参数生效。老的违章类型，wIllegalType、dwCustomIllegalType参数依然赋值国标违法代码*/
    BYTE*   pIllegalInfoBuf;    //违法代码字符信息结构体指针；指向NET_ITS_ILLEGAL_INFO 
    BYTE    byIllegalFromatType; //违章信息格式类型； 0~数字格式， 1~字符格式
    BYTE    byPendant;// 0-表示未知,1-车窗有悬挂物，2-车窗无悬挂物
    BYTE    byDataAnalysis;            //0-数据未分析, 1-数据已分析
    BYTE    byYellowLabelCar;        //0-表示未知, 1-非黄标车,2-黄标车
    BYTE    byDangerousVehicles;    //0-表示未知, 1-非危险品车,2-危险品车
    //以下字段包含Pilot字符均为主驾驶，含Copilot字符均为副驾驶
    BYTE    byPilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE    byCopilotSafebelt;//0-表示未知,1-系安全带,2-不系安全带
    BYTE    byPilotSunVisor;//0-表示未知,1-不打开遮阳板,2-打开遮阳板
    BYTE    byCopilotSunVisor;//0-表示未知, 1-不打开遮阳板,2-打开遮阳板
    BYTE    byPilotCall;// 0-表示未知, 1-不打电话,2-打电话
    //0-开闸，1-未开闸 (专用于历史数据中相机根据名单匹配后，是否开闸成功的标志)
    BYTE    byBarrierGateCtrlType;
    BYTE    byAlarmDataType;//0-实时数据，1-历史数据
    NET_DVR_TIME_V30  struSnapFirstPicTime;//端点时间(ms)（抓拍第一张图片的时间）
    DWORD   dwIllegalTime;//违法持续时间（ms） = 抓拍最后一张图片的时间 - 抓拍第一张图片的时间
    DWORD   dwPicNum;        //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义    
    NET_ITS_PICTURE_INFO struPicInfo[6];         //图片信息,单张回调，最多6张图，由序号区分
    NET_DVR_VEHICLE_WEIGHT_RESULT struWeightResult; //车辆称重
    BYTE     byRes[256]; //预留
}NET_DVR_PLATE_RESULT_V50, *LPNET_DVR_PLATE_RESULT_V50;

typedef struct _NET_DVR_NORMAL_SCHEDTIME_
{
    NET_DVR_SCHEDTIME struTime;
    BYTE byAlarmType;//0-外出布防，1-留守布防，2-即时布防
    BYTE byRes[3];
}NET_DVR_NORMAL_SCHEDTIME,*LPNET_DVR_NORMAL_SCHEDTIME;

typedef struct tagNET_DVR_SUBSYSTEM_ALARM
{
    DWORD dwSize;
    NET_DVR_NORMAL_SCHEDTIME struNormalSchedtime[MAX_DAYS][MAX_TIMESEGMENT_V30];
    //日常计划布防时间段
    BYTE byNormalSchedTimeOn; //日常计划是否启用
    BYTE byMandatoryAlarm;//0-非强制布防，1-强制布防 指当防区有问题是是否为旁路布防
    BYTE byRes[254];
}NET_DVR_SUBSYSTEM_ALARM,*LPNET_DVR_SUBSYSTEM_ALARM;

typedef struct _NET_DVR_ALARM_PHONECFG
{
    DWORD    dwSize; 
    BYTE    byEnable;//是否启用 0-不启用，1-启用
    BYTE    byRes1[3];
    BYTE    byPhoneNumber[MAX_PHONE_NUM/*32*/];
    DWORD    dwArmRight; //布防权限，按位，bit0为1表示对子系统1有布防权限，依此类推
    DWORD    dwDisArmRight; //撤防权限，按位，bit0为1表示对子系统1有撤防权限，依此类推
    DWORD    dwClearAlarmRight; //消警权限，按位，bit0为1表示对子系统1有消警权限，依此类推
    BYTE    byZoneReport[MAX_ALARMHOST_ALARMIN_NUM/*512*/]; //防区报告类型，0-不上传，1-上传 
    DWORD    dwNonZoneReport; //非防区报警报告 bit0-软防区报告 bit1-系统状态报告 bit2-取消报告 bit3-测试报告,bit4-布防报告 bit5-撤防报告 bit6-挟持报告 bit7-报警恢复报告 bit8-旁路报告 bit9-旁路恢复报告,bit10-探测器连接状态报告（上线、离线）,bit11-探测器电量状态报告（电压正常、欠压）,bit12-视频报警报告
    BYTE    byIntervalTime; //0-0s,1-10s,2-30s,3-1min,4-5min,5-10min,6-自定义（1~5999s）
    BYTE    byRes2;
    WORD    wDefineIntervalTime; //当byIntervalTime为6时有效，自定义时间（1~5999s）
    BYTE    byRes3[128];
}NET_DVR_ALARM_PHONECFG, *LPNET_DVR_ALARM_PHONECFG;

typedef struct tagNET_DVR_MODULE_INFO
{
    DWORD    dwSize;
    BYTE    byModuleType;            //外接触发器类型，1-键盘，2-触发器，3-防区 ，4-网络模块
    BYTE    byKeyBoardType;            //1-LCD,2-LED
    BYTE    byTriggerType;            // 1-本地触发器， 2-4路触发器，3-8路触发器，4-单防区触发器，5-32路触发器
    BYTE    byZoneType;                //防区类型，1-本地防区，2-单防区，3-双防区，4-8防区，5-8路模拟量防区, 6-单防区触发器
    WORD    wModuleAddress;            //外接触发器地址，扩展模块从0~255，0xFFFF表示无效
    BYTE    byRes2[2];                //保留
    char    sModelInfo[32];            //模块信息
    char    sDeviceVersionInfo[32];    //版本信息
    BYTE    byRes[128];                //保留
}NET_DVR_MODULE_INFO,*LPNET_DVR_MODULE_INFO;

typedef struct tagNET_DVR_ALARMHOST_DETECTOR_INFO
{
    DWORD		dwSize;
    BYTE     byDetectorSerialNo[16];   //探测器序列号
    DWORD   dwAlarmIn;   //防区号
    WORD    wDetectorType;   // 探测器类型，DETECTOR_TYPE
    BYTE   	byRes[126];      //保留
}NET_DVR_ALARMHOST_DETECTOR_INFO, *LPNET_DVR_ALARMHOST_DETECTOR_INFO;

typedef struct tagNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40
{
    BYTE                       byEnable;// 0- 否，1- 是
    BYTE                       byRes1[3];
    NET_DVR_SCHEDDATE          struDate;
    NET_DVR_OUTPUT_SCHEDULE    struOutputSchedule[MAX_TIMESEGMENT_V30/*8*/];
    BYTE                       byTriggerIndex[MAX_ALARMHOST_ALARMOUT_NUM];//下标表示触发器号，值0-不启用，1-启用
    BYTE                       byRes2[64];
}NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40,*LPNET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40;

typedef struct tagNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40
{   
    DWORD  dwSize; //结构体大小
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule[MAX_RULE_NUM/*8*/]; //最多支持8个日期区段的规则配置，对于定时开/关触发器只需要使用一个日期区段就可以了
    BYTE   byRes[64];  //保留
}NET_DVR_OUTPUT_SCHEDULE_RULECFG_V40,*LPNET_DVR_OUTPUT_SCHEDULE_RULECFG_V40;

typedef struct tagNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40
{
    DWORD        dwSize; 
    NET_DVR_ONE_OUTPUT_SCHEDULE_RULE_V40 struOutputRule;
    BYTE        byRes[256];  //保留
}NET_DVR_ONE_OUTPUT_SCH_RULECFG_V40,*LPNET_DVR_ONE_OUTPUT_SCH_RULECFG_V40;

typedef struct tagNET_DVR_ALARM_CAPTRUE_CFG
{
    DWORD        dwSize;
    BYTE        byBeforeAlarmPic;    //对应分辨率下可设置报警前图片最大数4CIF：10张，2CIF：20张，CIF：40张，QCIF：80张；WD1:10张,XVGA:10张,720P:10张,1080P:10张
    BYTE        byAfterAlarmPic;    //对应分辨率下可设置报警后图片最大数 4CIF：10张，2CIF：20张，CIF：40张，QCIF：80张；WD1:10张,XVGA:10张,720P:10张,1080P:10张
    WORD          wInterval; //间隔时间 单位s
    BYTE        byResolution;    //图片分辨率1-CIF，2-2CIF，3-4CIF，4-QCIF，5-WD1，6-VGA,7-XVGA，8-720P，9-1080P
    BYTE           byRes[63];          // 保留字节
}NET_DVR_ALARM_CAPTRUE_CFG, *LPNET_DVR_ALARM_CAPTRUE_CFG;

typedef struct _NET_DVR_PRIOR_SCHEDTIME_
{
    DWORD dwSize;
    NET_DVR_SCHEDDATE struData;
    NET_DVR_NORMAL_SCHEDTIME struOneDayTime[8];
    BYTE    byEnable; //是否启用 0-不启用，1-启用
    BYTE byRes1[3];
    BYTE bySubSystem[32];//子系统，下标表示子系统号 0-不支持，1-支持
    BYTE byMandatoryAlarm;//0-非强制布防，1-强制布防 指当防区有问题是是否为旁路布防
    BYTE byRes[63];
}NET_DVR_PRIOR_SCHEDTIME,*LPNET_DVR_PRIOR_SCHEDTIME;

typedef struct tagNET_DVR_TAMPER_ALARMIN_PARAM
{
    DWORD   dwSize;
    BYTE    byTamperType;     // 0-无,1-常开，2-常闭
    BYTE    byUploadAlarmRecoveryReport;    //是否上传防区报警恢复报告，0-不上传，1-上传 
    BYTE    byRes1[2];
    BYTE    byAssociateAlarmOut[MAX_ALARMHOST_ALARMOUT_NUM];  //防区关联触发器    BYTE            byAssociateSirenOut[8];        //警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出 
    BYTE    byAssociateSirenOut[8];        //警号输出 数组0 表示警号1 值为1表示输出 0 表示不输出 
    BYTE    byTamperResistor;    //防拆电阻，单位千欧 ， 0-无效 1-2.2 ，2--3.3, 3-4.7 ，4-5.6 ， 5-8.2 ，0xff-自定义
    BYTE    byRes2[3];
    float    fTamperResistorManual;/*防拆手动电阻，1.0-10.0，精确到小数点后一位，单位千欧，byTamperResistor为0xff时有效*/
    BYTE    byRes3[36];            // 保留字节
}NET_DVR_TAMPER_ALARMIN_PARAM, *LPNET_DVR_TAMPER_ALARMIN_PARAM;

typedef struct tagNET_DVR_REMOTECONTROLLER_PERMISSION_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;
    BYTE    byAssociateNetUser;//关联的网络用户编号
    WORD    wRemoteCtrllerID;//遥控器号 从1开始
    BYTE    sDevSn[16];/*产品序列号*/
    BYTE    byArmRight;            /*0-无布防权限，1-有布防权限*/
    BYTE    byDisArmRight;        /*0-无撤防权限，1-有撤防权限*/
    BYTE    byArmReportRight;    /*0-无传布防报告权限，1-有传布防报告权限*/
    BYTE    byDisArmReportRight;/*0-无上传撤防报告权限，1-有上传撤防报告权限*/
    BYTE    byClearAlarmRight;    /*0-无消警权限，1-有消警权限*/
    BYTE    bySubSystemID;       /* 设备(遥控器)子系统号,1~8 */
    BYTE    byKeyboardAddr;      /* 接收键盘的地址,在配对时设置 */    
    BYTE    byEnableDel;   //删除遥控器用户，0-禁用删除，1-启用删除
    BYTE    byAlwaysOpenRight;   /*是否允许常开：0-无效，1-不允许，2-允许*/
    BYTE    byOpeningDirection;   /*开门方向：0-无效，1-进门方向，2-出门方向*/
    BYTE    byRes3[2];
    BYTE    byName[NAME_LEN];    //遥控器名称
    BYTE    byRes2[28];
}NET_DVR_REMOTECONTROLLER_PERMISSION_CFG, *LPNET_DVR_REMOTECONTROLLER_PERMISSION_CFG;

typedef struct tagNET_DVR_KEYBOARD_CFG
{
    DWORD    dwSize;
    BYTE    byEnableLock;        //是否启用键盘锁定,0--不启用, 1--启用
    BYTE    byErrorTimes;        //输入键盘用户密码错误次数（锁定键盘）
    WORD    wLockTime;            //锁定键盘时间，单位秒
    BYTE    byRes[128];
}NET_DVR_KEYBOARD_CFG, *LPNET_DVR_KEYBOARD_CFG;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND
{
    DWORD    dwSize;
    BYTE    byCommOperatorNum[NAME_LEN/*32*/];//通信运营商号码
    BYTE    byQueryCode[16];//业务查询代码
    BYTE    byBusinessType;//业务类型 0-话费，1-流量
    BYTE    byRes[35];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_COND;

typedef struct tagNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO
{
    DWORD    dwSize;
    BYTE    by3GBusiness[1024];//3G业务通过短信查询
    BYTE    byRes[32];
}NET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO, *LPNET_DVR_ALARMHOST_WIRELESS_BUSINESS_INFO;

typedef struct tagNET_DVR_PREVIEW_DELAY_CFG
{
    DWORD    dwSize;
    WORD    wdelayTime;//延迟预览时间，单位：秒
    BYTE    byRes[130];
}NET_DVR_PREVIEW_DELAY_CFG, *LPNET_DVR_PREVIEW_DELAY_CFG;

typedef struct tagNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM
{
    DWORD    dwSize;
    DWORD    dwDevNo;    //设备号
    BYTE    byDevType;    //升级设备类型 0-键盘,1-机芯,2-网络模块,3-路由器 ，4-防区，5-RS485无线扩展模块，6-温控模块，7-电锁模块,8-网口供电模块
    BYTE    byRes[131];
}NET_DVR_AUXILIARY_DEV_UPGRADE_PARAM,*LPNET_DVR_AUXILIARY_DEV_UPGRADE_PARAM;

typedef struct tagNET_DVR_CALL_ROOM_CFG
{
    DWORD    dwSize;
    SHORT   nFloorNumber;    //层号
    WORD    wRoomNumber;    //房间号
    BYTE    byManageCenter;    //是否呼叫管理中心
    BYTE  byRes1[3];
    BYTE  byCalledName[64];    //标准sip模式下有效，被叫用户名, 支持数字、字母、“@”和“.”
    BYTE  byRes[60];
}NET_DVR_CALL_ROOM_CFG,*LPNET_DVR_CALL_ROOM_CFG;

typedef struct tagNET_DVR_VIDEO_CALL_COND
{
    DWORD    dwSize;
    BYTE    byRes[128];
}NET_DVR_VIDEO_CALL_COND,*LPNET_DVR_VIDEO_CALL_COND;

typedef struct tagNET_DVR_INQUEST_CASE_INFO
{
    DWORD    dwSize;
    BYTE    sCaseNo[INQUEST_CASE_NO_LEN];        //案件编号
    BYTE    sCaseName[INQUEST_CASE_NAME_LEN];    //案件名称；
    BYTE    sCustomInfo1[CUSTOM_INFO_LEN];        //自定义信息1；
    BYTE    sCustomInfo2[CUSTOM_INFO_LEN];        //自定义信息2；
    BYTE    sCustomInfo3[CUSTOM_INFO_LEN];        //自定义信息3
    BYTE    byShowCaseInfoTime; /* 案件信息显示时间,单位秒, 取值范围1~60秒*/
    BYTE    byShowCaseInfo;    //案件开始是否显示案件信息，0-不显示，1-显示
    BYTE    byPosition;        //案件显示位置，0-左上，1-左下
    BYTE    byRes1; //保留
    BYTE    byCustomInfo4[CUSTOM_INFO_LEN];     //自定义信息4，案件编号有内容时该字段无效
    BYTE    byCustomInfo5[CUSTOM_INFO_LEN];     //自定义信息5，案件名称有内容时该字段无效
    BYTE    byRes[128]; //保留
}NET_DVR_INQUEST_CASE_INFO, *LPNET_DVR_INQUEST_CASE_INFO;

typedef struct tagNET_DVR_CASE_INFO_CTRL_PARA
{
    DWORD    dwSize;
    DWORD    dwChannel;//审讯通道号
    BYTE    byShowCaseInfoTime;    //显示持续时间
    BYTE    byRes[131];
}NET_DVR_CASE_INFO_CTRL_PARAM, *LPNET_DVR_CASE_INFO_CTRL_PARA;

typedef struct tagNET_DVR_INQUEST_USER_RIGHT_CFG
{
    DWORD    dwSize;
    /*数组0: 审讯记录删除权限*/
    BYTE    byLocalRight[MAX_RIGHT];    /* 本地权限 */
    /*数组0: 远程音频预览权限*/
    BYTE    byRemoteRight[MAX_RIGHT];/* 远程权限 */ 
    BYTE    byNetAudioRight[MAX_CHANNUM_V40];    /* 远程音频预览权限，数组下标表示通道，值表示有无权限，0-无权限，1-有权限*/
    BYTE    byRes[512*9];         //保留9种权限可扩展
}NET_DVR_INQUEST_USER_RIGHT_CFG, *LPNET_DVR_INQUEST_USER_RIGHT_CFG;

typedef struct tagNET_DVR_INQUEST_MIX_AUDIOIN_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;    //是否启用混音，0-不启用，1-启用
    BYTE    byRes1[3];    //保留
    DWORD    dwMixCnt;  /*混音的通道数*/
    BYTE    bySrcChan[MAX_MIX_CHAN_NUM];    /*数组下标表示混音通道号（模拟通道、IP通道）,数值0表示不混，数值1表示混入*/
    BYTE    byLineIn[MAX_LINE_IN_CHAN_NUM];    /*数组下标表示混入Line In通道号,数值0表示不混，数值1表示混入*/
    BYTE    byMic[MAX_MIC_CHAN_NUM];        /*数组下标表示混入Mic通道号,数值0表示不混，数值1表示混入*/
    BYTE    byMixAudioDelay;    //混音延迟，单位：帧，范围0-63
    BYTE    byRes2[127];    //保留
}NET_DVR_INQUEST_MIX_AUDIOIN_CFG, *LPNET_DVR_INQUEST_MIX_AUDIOIN_CFG;

typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_COND
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    NET_DVR_TIME_EX struStartTime; //开始时间
    BYTE   byReportType; //统计报表类型：1-日报表，2-周报表，3-月报表，4-年报表
    BYTE   byStatType; //数据类型统计：Bit0-年龄段，Bit1-性别，Bit2-人数
    BYTE   byEnableProgramStatistics; //是否按节目统计，0-否，1-是
    BYTE   byRes1;
    DWORD  dwPlayScheduleNo; //按节目统计时关联的日程号
    BYTE   byRes[120];
}NET_DVR_FACECAPTURE_STATISTICS_COND,*LPNET_DVR_FACECAPTURE_STATISTICS_COND;

typedef struct tagNET_DVR_AGEGROUP_PARAM_
{
    DWORD   dwTeenage;//少年（人数）
    DWORD    dwYouth;//青年（人数）
    DWORD    dwMidLife;//中年（人数）
    DWORD    dwElderly;//老年（人数）
    DWORD    dwChild;//儿童（人数）
    DWORD    dwAdolescent;//青少年（人数）
    DWORD    dwPrime;//壮年（人数）
    DWORD    dwMidage;//中老年（人数）
    BYTE   byRes[48];
}NET_DVR_AGEGROUP_PARAM, *LPNET_DVR_AGEGROUP_PARAM;    

typedef struct tagNET_DVR_FILECOND_MEDICAL
{
    LONG lChannel;//通道号
    DWORD dwFileType;//录象文件类型
    //不带卡号，0xff－全部，0－定时录像,1-移动侦测 ，2－报警触发，3-报警|移动侦测 4-报警&移动侦测 5-命令触发 6-手动录像,7-智能录像，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
    //带卡号，0xff－全部，0－定时录像，1-移动侦测，2－接近报警，3－出钞报警，4－进钞报警，5-命令触发，6－手动录像，7－震动报警，8-环境报警，9-智能报警，10-PIR报警，11-无线报警，12-呼救报警，13-全部事件，14-智能交通事件
    DWORD dwIsLocked;//是否锁定 0-正常文件,1-锁定文件, 0xff表示所有文件
    DWORD dwUseCardNo;//是否使用卡号
    BYTE sCardNumber[32];//卡号
    NET_DVR_TIME_SEARCH_COND struStartTime;//开始时间
    NET_DVR_TIME_SEARCH_COND struStopTime;//结束时间
    char            szPatientID[64];
    DWORD        dwBigFileType;  // 0为普通片段搜索，1为大文件搜索          
    BYTE          byRes[252];
}NET_DVR_FILECOND_MEDICAL, *LPNET_DVR_FILECOND_MEDICAL;

typedef struct tagNET_DVR_FIND_PICTURE_MEDICAL_PARAM
{
    DWORD  dwSize;         // 结构体大小 
    LONG   lChannel;       // 通道号
    /* 查找的图片类型:0定时抓图1 移动侦测抓图 2 报警抓图，
    3 报警 | 移动侦测抓图 4 报警 & 移动侦测抓图 6 手动抓图 ,
    9-智能图片,10- PIR报警，11- 无线报警，12- 呼救报警,
    0xa 预览时截图，0xd 人脸侦测, 0xe 越界侦测，0xf 入侵区域侦测，
    0x10 场景变更侦测, 0x11-设备本地回放时截图, 0x12-智能侦测,
    0x13-进入区域侦测,0x14-离开区域侦测,0x15-徘徊侦测,
    0x16-人员聚集侦测,0x17-快速运动侦测,0x18-停车侦测,
    0x19-物品遗留侦测,0x1a-物品拿取侦测, 0x1b-车牌侦测,
    0x1c-混行检测,0x1d-取证事件,0x1e-火点检测,0x1f-防破坏检测,
    0x20-船只检测，0x21-测温预警，0x22-测温报警, 0x23测差报警, 0x24违停检测,0x25-人脸抓拍,0x26-离线测温报警,0x2a-起身检测,0x2b-折线攀高,0x2c-如厕超时,0x2d-安全帽检测,0x2e-周界抓拍,0x2f-人体目标抓拍,0x30-人脸抓拍建模, 0x31-混合目标检测,0x32-防区报警, 0x33-紧急求助, 0x34-业务咨询,0x35-非法摆摊,0xff- 全部类型*/
    BYTE   byFileType;
    BYTE   byNeedCard;     // 是否需要卡号
    /*
    0-保留，1-澳，2-京，3-渝，4-闽，5-甘，6-粤，7-桂，
    8-贵，9-琼，10-冀，11-豫，12-黑，13-鄂，14-湘，
    15-吉，16-苏，17-赣，18-辽，19-蒙，20-宁，21-青，
    22-鲁，23-晋，24-陕，25-沪，26-川，27-台，28-津，
    29-藏，30-港，31-新，32-云，33-浙，34-皖，0xff-全部
    */
    BYTE   byProvince;     //省份索引值
    BYTE   byRes1;  //查找结果中是否要求返回人脸坐标信息，0-不返回，1-返回
    NET_DVR_TIME  struStartTime;//查找图片的开始时间
    NET_DVR_TIME  struStopTime;// 查找图片的结束时间
    char     szPatientID[64];
    BYTE     byRes[256];
}NET_DVR_FIND_PICTURE_MEDICAL_PARAM, *LPNET_DVR_FIND_PICTURE_MEDICAL_PARAM;

typedef struct tagNET_DVR_SEXGROUP_PARAM_
{
    DWORD   dwMale;//男（人数）
    DWORD    dwFemale;//女（人数）
    BYTE   byRes[64];
}NET_DVR_SEXGROUP_PARAM,*LPNET_DVR_SEXGROUP_PARAM;

typedef struct tagNET_DVR_FACECAPTURE_STATISTICS_RESULT_
{
    DWORD dwSize;
    NET_DVR_TIME_EX   struStartTime;/*间隔开始时间*/
    NET_DVR_TIME_EX   struEndTime;/*间隔结束时间*/
    BYTE   byStatType;//数据类型统计：Bit0-年龄段有效，Bit1-性别有效，Bit2-人数有效
    BYTE   byRes[7];
    DWORD  dwPeopleNum;//人数统计
    NET_DVR_AGEGROUP_PARAM  struAgeGroupParam;//年龄段人数统计
    NET_DVR_SEXGROUP_PARAM  struSexGroupParam;//性别人数统计
    NET_DVR_PROGRAM_INFO struProgramInfo;        //节目信息
    BYTE   byRes1[76];
}NET_DVR_FACECAPTURE_STATISTICS_RESULT,*LPNET_DVR_FACECAPTURE_STATISTICS_RESULT;

typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_COND_
{
    DWORD  dwSize;
    /*
    Bit0-通道有效 
    Bit1-时间有效
    Bit2-车牌号有效
    Bit3-车牌类型有效
    Bit4-车牌颜色有效
    Bit5-车身颜色有效
    Bit6-车辆类型有效
    Bit7-车辆品牌有效
    Bit8-车道号有效
    Bit9-监测方向有效
    Bit10-最低速度有效
    Bit11-最高速度有效
    Bit12-数据类型有效
    Bit13-布控方式类型有效
    Bit14-违法取证有效
    Bit15-事件类型有效
    Bit16-取证类型有效
    */
    DWORD  dwQueryCond;//查询条件 0表示无效，1表示有效
    DWORD  dwChannel;//默认是1（[1~32]，bit0表示通道1，依次类推bit31表示通道32）
    NET_DVR_TIME_V30 struStartTime;//开始时间
    NET_DVR_TIME_V30 struEndTime;//结束时间
    char  sLicense[MAX_LICENSE_LEN/*16*/];//(设备支持模糊查询, GB2312编码)
    /*
    Bit0-未知（其他）
    Bit1-标准民用车与军车 
    Bit2-02式民用车牌     
    Bit3-武警车           
    Bit4-警车             
    Bit5-民用车双行尾牌   
    Bit6-使馆车牌         
    Bit7-农用车           
    Bit8-摩托车    
    */
    DWORD  dwPlateType;//车牌类型（支持按位表示，可以复选）
    /*
    Bit0-未知（其他）
    Bit1-黄色
    Bit2-白色
    Bit3-黑色
    Bit4-绿色
    Bit5-蓝色    
    */
    DWORD  dwPlateColor;//车牌颜色（支持按位表示，可以复选）
    /*
    Bit0-未知（其他）
    Bit1-白色
    Bit2-银色
    Bit3-灰色
    Bit4-黑色
    Bit5-红色
    Bit6-深蓝色    
    Bit7-蓝色
    Bit8-黄色
    Bit9-绿色
    Bit10-棕色
    Bit11-粉色
    Bit12-紫色    
    Bit13-深灰色    
    */
    DWORD  dwVehicleColor;//车身颜色（支持按位表示，可以复选）
    /*
    Bit0-未知（其他）
    Bit1-客车
    Bit2-大货车
    Bit3-轿车
    Bit4-面包车
    Bit5-小货车
    Bit6-行人
    Bit7-二轮车
    Bit8-三轮车
    Bit9-SUV/MPV
    Bit10-中型客车
    */
    DWORD  dwVehicleType;//车辆类型（支持按位表示，可以复选）
     /**
    Bit0-其他（保留）
    Bit1-低速
    Bit2-超速
    Bit3-逆行
    Bit4-闯红灯
    Bit5-压车道线
    Bit6-不按导向
    Bit7-路口滞留
    Bit8-机占非
    Bit9-违法变道
    Bit10-不按车道
    Bit11-违反禁令
    Bit12-路口停车
    Bit13-绿灯停车
    Bit14-未礼让行人
    Bit15-违章停车
    Bit16-违章掉头
    Bit17-占用应急车道
    Bit18-未系安全带 
    */
    DWORD dwIllegalType;
    /**
    Bit0-其他（保留）
    Bit1-拥堵
    Bit2-停车
    Bit3-逆行
    Bit4-行人
    Bit5-抛洒物
    Bit6-烟雾
    Bit7-压线
    Bit8-禁止名单
    Bit9-超速
    Bit10-变道
    Bit11-掉头
    Bit12-机占非
    Bit13-加塞 
    */
    DWORD dwEventType;
    /**
    Bit0-其他（保留）
    Bit1-城市公路违法停车
    Bit2-高速公路违法停车
    Bit3-压线
    Bit4-逆行
    Bit5-违法变道
    Bit6-机占非
    */
    DWORD  dwForensiceType;
    WORD   wVehicleLogoRecog;  //车辆主品牌，参考"车辆主品牌.xlsx" （仅单选）
    BYTE   byLaneNo;//车道号（0~255,0号车道 表示 车道号未知）
    BYTE   byDirection;//监测方向，1-上行，2-下行，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南    
    WORD   wMinSpeed;//最低速度（0~999）单位km/h
    WORD   wMaxSpeed;//最高速度（0~999）单位km/h
    BYTE   byDataType;//数据类型 0-卡口数据，1-违法数据，2-交通事件，3-取证数据 （仅单选）
    BYTE   byExecuteCtrl;//布控 0-允许名单，1-禁止名单，0xff-其他
    BYTE   byRes[254];
}NET_DVR_TRAFFIC_DATA_QUERY_COND,*LPNET_DVR_TRAFFIC_DATA_QUERY_COND;

typedef struct tagNET_DVR_TRAFFIC_PICTURE_PARAM_
{
    NET_DVR_TIME_V30     struRelativeTime; //抓拍相对时标
    NET_DVR_TIME_V30    struAbsTime;  //抓拍绝对时标
    char szPicName[PICTURE_NAME_LEN/*64*/];
    BYTE  byPicType;//图片类型 0-车牌图，1-抓拍原图，2-合成图，3-特写图
    BYTE  byRes[63];
}NET_DVR_TRAFFIC_PICTURE_PARAM,*LPNET_DVR_TRAFFIC_PICTURE_PARAM;

typedef struct tagNET_DVR_TRAFFIC_DATA_QUERY_RESULT_
{
    DWORD  dwSize;
    DWORD  dwChannel;//默认是1（[1~32]）
    char  sLicense[MAX_LICENSE_LEN/*16*/];
    /*
    Bit0-未知（其他）
    Bit1-标准民用车与军车 
    Bit2-02式民用车牌     
    Bit3-武警车           
    Bit4-警车             
    Bit5-民用车双行尾牌   
    Bit6-使馆车牌         
    Bit7-农用车           
    Bit8-摩托车    
    */
    DWORD  dwPlateType;//车牌类型
    /*
    Bit0-未知（其他）
    Bit1-黄色
    Bit2-白色
    Bit3-黑色
    Bit4-绿色
    Bit5-蓝色    
    */
    DWORD  dwPlateColor;//车牌颜色
    /*
    Bit0-未知（其他）
    Bit1-白色
    Bit2-银色
    Bit3-灰色
    Bit4-黑色
    Bit5-红色
    Bit6-深蓝色    
    Bit7-蓝色
    Bit8-黄色
    Bit9-绿色
    Bit10-棕色
    Bit11-粉色
    Bit12-紫色    
    Bit13-深灰色    
    */
    DWORD  dwVehicleColor;//车身颜色
    /*
    Bit0-未知（其他）
    Bit1-客车
    Bit2-大货车
    Bit3-轿车
    Bit4-面包车
    Bit5-小货车
    Bit6-行人
    Bit7-二轮车
    Bit8-三轮车
    Bit9-SUV/MPV
    Bit10-中型客车
    Bit11-机动车
    Bit12-非机动车
    Bit13-小型轿车
    Bit14-微型轿车
    Bit15-皮卡车
    Bit16-集装箱卡车
    Bit17-微卡，栏板卡
    Bit18-渣土车
    Bit19-吊车，工程车
    Bit20-油罐车
    Bit21-混凝土搅拌车
    Bit22-平板拖车
    Bit23-两厢轿车
    Bit24-三厢轿车
    Bit25-轿跑
    Bit26-小型客车
    */
    DWORD  dwVehicleType;//车辆类型
    /**
    Bit0-其他（保留）
    Bit1-低速
    Bit2-超速
    Bit3-逆行
    Bit4-闯红灯
    Bit5-压车道线
    Bit6-不按导向
    Bit7-路口滞留
    Bit8-机占非
    Bit9-违法变道
    Bit10-不按车道
    Bit11-违反禁令
    Bit12-路口停车
    Bit13-绿灯停车
    Bit14-未礼让行人
    Bit15-违章停车
    Bit16-违章掉头
    Bit17-占用应急车道
    Bit18-未系安全带 
    */
    DWORD dwIllegalType;
    /**
    Bit0-其他（保留）
    Bit1-拥堵
    Bit2-停车
    Bit3-逆行
    Bit4-行人
    Bit5-抛洒物
    Bit6-烟雾
    Bit7-压线
    Bit8-禁止名单
    Bit9-超速
    Bit10-变道
    Bit11-掉头
    Bit12-机占非
    Bit13-加塞 
    */
    DWORD dwEventType;
    /**
    Bit0-其他（保留）
    Bit1-城市公路违法停车
    Bit2-高速公路违法停车
    Bit3-压线
    Bit4-逆行
    Bit5-违法变道
    Bit6-机占非
    */
    DWORD dwForensiceType;
    WORD  wVehicleLogoRecog;  //车辆主品牌，参考"车辆主品牌.xlsx" 
    BYTE  byLaneNo;//车道号（0~255,0号车道 表示 车道号未知）
    BYTE  byDirection;//监测方向，1-上行，2-下行，3-双向，4-由东向西，5-由南向北,6-由西向东，7-由北向南    
    WORD  wSpeed;//速度（0~999）单位km/h
    BYTE  byDataType;//数据类型: 0-卡口 1-违法 2-事件 3-取证
    BYTE  byRes[253];
    NET_DVR_TRAFFIC_PICTURE_PARAM struTrafficPic[MAX_TRAFFIC_PICTURE_NUM/*8*/];
}NET_DVR_TRAFFIC_DATA_QUERY_RESULT,*LPNET_DVR_TRAFFIC_DATA_QUERY_RESULT;

typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_COND_
{
    DWORD  dwSize;
    /**
    Bit0-通道有效
    Bit1-时间有效
    Bit2-车道号有效
    */
    DWORD  dwQueryCond;//查询条件 0-无条件
    DWORD  dwChannel;//默认是1（[1~32]，bit0表示通道1，依次类推bit31表示通道32）
    DWORD  dwResChan[10];//预留可扩展的通道号
    NET_DVR_TIME_V30 struStartTime;//开始时间
    NET_DVR_TIME_V30 struEndTime;//结束时间
    BYTE   byLaneNo;//车道号（0~255,0号车道 表示 车道号未知）
    BYTE   byRes[255];
}NET_DVR_TRAFFIC_FLOW_QUERY_COND,*LPNET_DVR_TRAFFIC_FLOW_QUERY_COND;

typedef struct tagNET_DVR_TRAFFIC_FLOW_QUERY_RESULT_
{
    DWORD  dwSize;
    NET_DVR_TIME_V30 struStartTime;//开始时间
    NET_DVR_TIME_V30 struEndTime;//结束时间
    DWORD  dwChannel;//默认是1（[1~32]）
    DWORD  dwFlow;//车流量
    BYTE   byLaneNo;//车道号（0~255,0号车道 表示 车道号未知）    
    BYTE   byRes[511];
}NET_DVR_TRAFFIC_FLOW_QUERY_RESULT,*LPNET_DVR_TRAFFIC_FLOW_QUERY_RESULT;

typedef struct tagNET_DVR_PIC_INFO
{
    BYTE   byPicType;        //图片类型，0-jpg
    BYTE   byRes1[3];        //保留
    DWORD  dwPicWidth;       //图片宽度
    DWORD  dwPicHeight;      //图片高度
    DWORD  dwPicDataLen;     //图片数据大小
    char*  byPicDataBuff;    //图片数据缓冲区
    BYTE   byRes2[32];       //保留
}NET_DVR_PIC_INFO,*LPNET_DVR_PIC_INFO;

typedef struct tagNET_DVR_VCA_RULE_COLOR_CFG
{
    DWORD       dwSize;//结构体大小
    BYTE       byEnable;       //规则是否启用， 0-不启用，1-启用
    BYTE       byRuleID;       //关联的规则ID
    BYTE       byColorBlockNo;  //颜色块序号，从1开始
    BYTE       byRes1;      //保留
    NET_DVR_PIC_INFO  struPicInfo;  //图片颜色信息
    BYTE     byRes[64];
}NET_DVR_VCA_RULE_COLOR_CFG,*LPNET_DVR_VCA_RULE_COLOR_CFG;

typedef struct tagNET_DVR_VCA_RULE_COLOR_COND
{
    DWORD        dwSize;//结构体大小
    DWORD     dwChannel;     //通道号
    BYTE        byRuleID;       //关联的规则ID  0表示不关联
    BYTE        byRes[127];
}NET_DVR_VCA_RULE_COLOR_COND,*LPNET_DVR_VCA_RULE_COLOR_COND;

typedef struct tagNET_DVR_LLDP_PORT_CFG
{
    BYTE byCardNo;      //卡号
    BYTE byPortNo;      //端口号
    BYTE byEnabledTx;   //使能发送lldp包，0-不使能，1-使能
    BYTE byEnabledRx;   //使能接收lldp包，0-不使能，1-使能
    BYTE byRes[12];
}NET_DVR_LLDP_PORT_CFG, *LPNET_DVR_LLDP_PORT_CFG;

typedef struct tagNET_DVR_LLDP_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //使能LLDP功能，0-不使能，1-使能
    BYTE  byRes1[3];
    DWORD dwHoldTime;   //保持时间，单位：秒
    DWORD dwReiniTime;  //重新初始化时间，单位：秒
    DWORD dwPacketTime; //打包时间，单位：秒
    NET_DVR_LLDP_PORT_CFG struLLDPPortCfg[MAX_PORT_NUM]; //各端口LLDP参数
    BYTE  byRes2[32];
}NET_DVR_LLDP_CFG, *LPNET_DVR_LLDP_CFG;

typedef struct tagNET_DVR_CARD_PORT_INFO
{
    DWORD dwPortNo;              //端口号，0-无效
    BYTE  byPortName[NAME_LEN];  //端口名
    BYTE  byWorkMode;            //工作模式，1-ACCESS，2-TRUNK，3-HYPRID
    BYTE  byBandWidth;           //带宽，1-100M，2-1G，3-10G
    BYTE  byPortType;            //端口类型，1-电口，2-光口，3-光电复用口
    BYTE  byRes[13];
}NET_DVR_CARD_PORT_INFO, *LPNET_DVR_CARD_PORT_INFO;

typedef struct tagNET_DVR_NETMGR_CARD_INFO
{
    BYTE  byTypeName[NAME_LEN];      //型号名称
    BYTE  bySerialNo[SERIALNO_LEN];  //序列号
    BYTE  bySoftwareVersion[VERSION_LEN]; //软件版本
    NET_DVR_IPADDR struIPAddr;           //IP地址
    DWORD dwSlotNo;    //网管卡槽位号（主槽位）
    BYTE  byStructureType;           //结构类型，1-2U，2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struNetPortInfo[MAX_SINGLE_CARD_PORT_NO]; //各网口信息
    BYTE  byRes2[32];    
}NET_DVR_NETMGR_CARD_INFO, *LPNET_DVR_NETMGR_CARD_INFO;

typedef struct tagNET_DVR_FUNC_CARD_INFO
{
    DWORD dwCardNo;                 //卡号，从1开始
    BYTE  byTypeName[NAME_LEN];     //型号名称
    BYTE  bySerialNo[SERIALNO_LEN]; //序列号
    BYTE  bySoftwareVersion[VERSION_LEN]; //软件版本
    DWORD dwMainSlot;               //主槽位，从1开始
    BYTE  byStructureType;          //结构类型，1-2U，2-4U
    BYTE  byRes1[3];
    NET_DVR_CARD_PORT_INFO struFuncPortInfo[MAX_SINGLE_CARD_PORT_NO]; //各端口参数
    BYTE  byRes2[32];
}NET_DVR_FUNC_CARD_INFO, *LPNET_DVR_FUNC_CARD_INFO;

typedef struct tagNET_DVR_FIBER_CONVERT_BASIC
{
    DWORD dwSize;
    BYTE  byPowerType;                                       //电源类型，1-单电源，2-双电源
    BYTE  byRes1[3];
    DWORD dwSlotNum;                                             //网管卡槽位号（主槽位）
    NET_DVR_NETMGR_CARD_INFO struNetCardInfo;                     //网管卡信息
    NET_DVR_FUNC_CARD_INFO   struFuncCardInfo[MAX_FUNC_CARD_NUM]; //功能卡信息
    BYTE  byRes2[64];
}NET_DVR_FIBER_CONVERT_BASIC, *LPNET_DVR_FIBER_CONVERT_BASIC;

typedef struct tagNET_DVR_CARD_PORT_STATE
{
    BYTE  byValid;                 //是否有效，0-无效，1-有效
    BYTE  byPortType;            //端口类型，1-电口，2-光口，3-光电复用口
    BYTE  byLinkState;           //连接状态，0-未连接，1-已连接
    BYTE  byRes1;
    DWORD dwSendBytes;           //发送的字节数
    DWORD dwRecvBytes;           //接收数据包数
    DWORD dwRecvLostPackets;     //接收丢包数
    DWORD dwRecvCrcErrPackets;   //接收CRC校验错误包数
    DWORD dwRecvFragmentPackets; //接收碎片、冲突及过短字节包数（包长度均小于64字节）
    BYTE  byRes2[16];
}NET_DVR_CARD_PORT_STATE, *LPNET_DVR_CARD_PORT_STATE;

typedef struct tagNET_DVR_NET_CARD_STATE
{
    NET_DVR_CARD_PORT_STATE struNetPortState[MAX_SINGLE_CARD_PORT_NO];    //各端口状态    
    BYTE byRes[64];
}NET_DVR_NET_CARD_STATE, *LPNET_DVR_NET_CARD_STATE;

typedef struct tagNET_DVR_FUNC_CARD_STATE
{
    BYTE  byEnabled;    //此结构是否有效，0-无效，1-有效
    BYTE  byRes1[3];
    DWORD dwCardNo; //卡号
    NET_DVR_CARD_PORT_STATE struFuncCardPortState[MAX_SINGLE_CARD_PORT_NO];
    BYTE  byRes[32];    
}NET_DVR_FUNC_CARD_STATE, *LPNET_DVR_FUNC_CARD_STATE;

typedef struct tagNET_DVR_FIBER_CONVERT_STATE
{
    DWORD dwSize;
    NET_DVR_NET_CARD_STATE struNetCardState;                      //网管卡状态
    NET_DVR_FUNC_CARD_STATE struFuncCardState[MAX_FUNC_CARD_NUM]; //功能卡状态
    BYTE  byRes[32];
}NET_DVR_FIBER_CONVERT_STATE, *LPNET_DVR_FIBER_CONVERT_STATE;

typedef struct tagNET_DVR_NETMGR_CARD_INFO_V50
{
    BYTE byMainSlotNo;                        //网管卡槽位号（主槽位）
    BYTE byRes1[3];
    BYTE byTypeName[NAME_LEN];            //型号名称
    BYTE bySerialNo[SERIALNO_LEN];            //序列号
    BYTE bySoftwareVersion[VERSION_LEN];    //软件版本
    BYTE byHardwareVersion[VERSION_LEN];    //硬件版本
    NET_DVR_IPADDR struIPAddr;                //IP地址
    NET_DVR_IPADDR struMask;                //子网掩码
    NET_DVR_IPADDR struGateway;                //默认网关
    BYTE byMacAddr[6];                        //MAC地址
    BYTE bySlotNums;                        //槽位数
    BYTE byStructureType;                       //结构类型，1-2U，2-4U
    NET_DVR_CARD_PORT_INFO struPortInfo[MAX_SINGLE_CARD_PORT_NO];    //各端口信息
    BYTE byRes2[64];
}NET_DVR_NETMGR_CARD_INFO_V50, *LPNET_DVR_NETMGR_CARD_INFO_V50;

typedef struct tagNET_DVR_FUNC_CARD_INFO_V50
{
    BYTE byCardNo;                          //接收卡卡号
    BYTE byMainSlotNo;						//接收卡槽位号（主槽位）
    BYTE byRes1[2];
    BYTE byTypeName[NAME_LEN];            //型号名称
    BYTE bySerialNo[SERIALNO_LEN];            //序列号
    BYTE bySoftwareVersion[VERSION_LEN];    //软件版本
    BYTE byIsVerMismatch;                    //软件版本与网管卡中本地存储的软件版本是否一致，0-匹配，!0-不匹配
    BYTE byRes2[3];
    BYTE byNewestSoftwareVersion[VERSION_LEN];    //最新的软件版本，版本不匹配时有效
    BYTE byHardwareVersion[VERSION_LEN];    //硬件版本
    BYTE bySlotNums;                        //槽位数
    BYTE byStructureType;                       //结构类型，1-2U，2-4U
    BYTE byRes3[2];
    NET_DVR_CARD_PORT_INFO struPortInfo[MAX_SINGLE_CARD_PORT_NO];    //各端口信息
    BYTE byRes4[64];
}NET_DVR_FUNC_CARD_INFO_V50, *LPNET_DVR_FUNC_CARD_INFO_V50;

typedef struct tagNET_DVR_REMOTE_SEND_CARD_INFO_V50
{
    BYTE byCardNo;                              //卡号，发送机连接的接收卡的卡号
    BYTE byMainSlotNo; 							//槽位号，发送机连接的接收卡的主槽位号
    BYTE byRes1[2];
    BYTE byTypeName[NAME_LEN];            //型号名称
    BYTE bySoftwareVersion[VERSION_LEN];    //软件版本
    BYTE byIsVerMismatch;                    //软件版本与网管卡中本地存储的软件版本是否一致，0-匹配，!0-不匹配
    BYTE byRes2[3];
    BYTE byNewestSoftwareVersion[VERSION_LEN];    //最新的软件版本，版本不匹配时有效
    BYTE byHardwareVersion[VERSION_LEN];    //硬件版本
    NET_DVR_CARD_PORT_INFO struPortInfo[MAX_SINGLE_CARD_PORT_NO];    //各端口信息
    BYTE byRes3[64];
}NET_DVR_REMOTE_SEND_CARD_INFO_V50, *LPNET_DVR_REMOTE_SEND_CARD_INFO_V50;

typedef struct tagNET_DVR_FIBER_CONVERT_BASIC_V50
{
    DWORD dwSize;
    BYTE byPowerType;    //电源类型，1-单电源，2-双电源
    BYTE byRes1[3];
    DWORD dwSlotNum;    //机箱总槽位数
    NET_DVR_NETMGR_CARD_INFO_V50 struNetCardInfo;    //网管卡信息
    NET_DVR_FUNC_CARD_INFO_V50 struFuncCardInfo[MAX_FUNC_CARD_NUM];    //接收卡信息
    NET_DVR_REMOTE_SEND_CARD_INFO_V50 struRemoteSendCardInfo[MAX_FUNC_CARD_NUM];    //发送机信息
    BYTE byRes2[64];
}NET_DVR_FIBER_CONVERT_BASIC_V50, *LPNET_DVR_FIBER_CONVERT_BASIC_V50;

typedef struct tagNET_DVR_CARD_PORT_STATE_V50
{
    BYTE byPortNo;                    //端口号，从1开始
    BYTE byPortType;                //端口类型，1-电口，2-光口，3-光电复用口
    BYTE byLinkState;               //连接状态，0-未连接，1-已连接
    BYTE byPortSpeed;                 //带宽，0-无效，1-自动，2-100M，3-1000M，4-10G
    BYTE byPortDuplexMode;             //端口双工模式，0-无效，1-自动，2-全双工，3-半双工
    BYTE byRes1[3];
    BYTE byPortName[NAME_LEN];         //端口名称
    DWORD dwSendBytes;              //发送的字节数
    DWORD dwSendByteSpeed;            //发送字节速率，单位：bps
    DWORD dwSendPackets;             //发送的字节数
    DWORD dwSendPacketSpeed;        //发包速率，单位：个/秒
    DWORD dwRecvBytes;              //接收的字节数
    DWORD dwRecvByteSpeed;            //接收字节速率，单位：bps
    DWORD dwRecvPackets;             //接收的包数
    DWORD dwRecvPacketSpeed;        //收包速率，单位：个/秒
    DWORD dwRecvLostPackets;        //接收丢包数
    DWORD dwRecvCrcErrPackets;         //接收CRC校验错误包数
    DWORD dwRecvFragmentPackets;    //接收碎片、冲突及过短字节包数（包长度均小于64字节）
    BYTE byRes2[48];
}NET_DVR_CARD_PORT_STATE_V50, *LPNET_DVR_CARD_PORT_STATE_V50;

typedef struct tagNET_DVR_NET_CARD_STATE_V50
{
    BYTE byMainSlotNo;     //网管卡主槽位号
    BYTE byRes1[3];
    NET_DVR_CARD_PORT_STATE_V50 struPortState[MAX_SINGLE_CARD_PORT_NO]; //网管卡端口状态
    BYTE byRes2[344];
}NET_DVR_NET_CARD_STATE_V50, *LPNET_DVR_NET_CARD_STATE_V50;

typedef struct tagNET_DVR_FUNC_CARD_STATE_V50
{
    BYTE byCardNo;      //接收卡卡号
    BYTE byMainSlotNo; 	//接收卡主槽位号
    BYTE byRes1[2];
    NET_DVR_CARD_PORT_STATE_V50 struPortState[MAX_SINGLE_CARD_PORT_NO];    //接收卡端口状态
    BYTE byRes2[64];
}NET_DVR_FUNC_CARD_STATE_V50, *LPNET_DVR_FUNC_CARD_STATE_V50;

typedef struct tagNET_DVR_REMOTE_SEND_CARD_STATE_V50
{
    BYTE byCardNo;	    //发送机连接的接收卡的卡号
    BYTE byMainSlotNo; 	//发送机连接的接收卡的主槽位号
    BYTE byRes1[2];
    NET_DVR_CARD_PORT_STATE_V50 struPortState[MAX_SINGLE_CARD_PORT_NO];    //接收卡端口状态
    BYTE byRes[64];
}NET_DVR_REMOTE_SEND_CARD_STATE_V50, *LPNET_DVR_REMOTE_SEND_CARD_STATE_V50;

typedef struct tagNET_DVR_FIBER_CONVERT_STATE_V50
{
    DWORD dwSize;
    NET_DVR_NET_CARD_STATE_V50 struNetCardState;    //网管卡状态
    NET_DVR_FUNC_CARD_STATE_V50 struFuncCardState[MAX_FUNC_CARD_NUM];    //接收卡状态  
    NET_DVR_REMOTE_SEND_CARD_STATE_V50 struRemoteSendCardState[MAX_FUNC_CARD_NUM];    //发送机状态
    BYTE  byRes[64];
}NET_DVR_FIBER_CONVERT_STATE_V50, *LPNET_DVR_FIBER_CONVERT_STATE_V50;

typedef struct tagNET_DVR_FC_PORT_TOPOLOGY
{
    DWORD dwPortNo;                 //端口号，0-无效，非0为功能卡端口号
    BYTE  byPortType;               //端口类型，1-电口，2-光口，3-光电复用口
    BYTE  byLocalWorkMode;          //本地工作模式，1-ACCESS，2-TRUNK，3-HYPRID
    BYTE  byLocalBandWidth;         //本地带宽，1-100M，2-1G，3-10G
    BYTE  byRes1[1];
    BYTE  byPeerTypeName[NAME_LEN]; //对端设备类型名称
    BYTE  byPeerMac[MACADDR_LEN];   //对端MAC地址
    DWORD dwPeerPortNo;             //对端端口号
    BYTE  byPeerWorkMode;           //对端工作模式，1-ACCESS，2-TRUNK，3-HYPRID
    BYTE  byPeerBandWidth;          //对端带宽，1-100M，2-1G，3-10G
    BYTE  byRes2[30];
}NET_DVR_FC_PORT_TOPOLOGY, *LPNET_DVR_FC_PORT_TOPOLOGY;

typedef struct tagNET_DVR_FC_CARD_TOPOLOGY
{
    BYTE  byEnable;                    //此结构体是否有效，0-无效，非0-有效
    BYTE  byRes1[3];
    DWORD dwCardNo;                 //卡号，0-网管卡，大于0-功能卡
    DWORD dwSlotNum;                //卡占用的槽位数
    BYTE  byTypeName[NAME_LEN];        //卡类型名称
    BYTE  byLocalMac[MACADDR_LEN];  //本地MAC地址
    NET_DVR_FC_PORT_TOPOLOGY struFCPortTopology[MAX_SINGLE_CARD_PORT_NO]; //各端口拓扑信息
    BYTE  byRes[32];
}NET_DVR_FC_CARD_TOPOLOGY, *LPNET_DVR_FC_CARD_TOPOLOGY;

typedef struct tagNET_DVR_FIBER_CONVERT_TOPOLOGY
{
    DWORD dwSize;
    NET_DVR_FC_CARD_TOPOLOGY struFCCardTopology[MAX_FC_CARD_NUM]; //各卡拓扑信息
    BYTE byRes[64];
}NET_DVR_FIBER_CONVERT_TOPOLOGY, *LPNET_DVR_FIBER_CONVERT_TOPOLOGY;

typedef struct tagNET_DVR_FC_COND
{
    DWORD dwSize;
    DWORD dwSlotNo; //槽位号
    DWORD dwPortNo; //端口号
    BYTE  byRes[32];
}NET_DVR_FC_COND, *LPNET_DVR_FC_COND;

typedef struct tagNET_DVR_FC_PORT_REMARKS
{
    DWORD dwSize;
    BYTE  byLocalRemarks[MAX_REMARKS_LEN]; //本地端口注释信息
    BYTE  byPeerRemarks[MAX_REMARKS_LEN]; //对端端口注释信息
    BYTE  byRes[32];
}NET_DVR_FC_PORT_REMARKS, *LPNET_DVR_FC_PORT_REMARKS;



typedef struct tagNET_DVR_FIBER_CONVERT_ALARM
{
    DWORD dwSize;
    DWORD dwEventType;        //事件类型，1-告警，2-通知
    DWORD dwEvent;          //具体事件，告警时参考枚举FIBER_CONVERT_ALARM，通知时参考枚举FIBER_CONVERT_NOTIFICATION
    BYTE bySlotNum;         //槽位号，当卡类型为发送机时，槽位号为该发送机连接的接收卡的槽位号，机箱告警及通知时无效
    BYTE byCardType;        //卡类型，0-无效，1-网管卡，2-接收卡，3-发送机，4-机箱
    BYTE byPortNo;          //端口号，从1开始，机箱告警及通知时无效
    BYTE byCurTemperature;  //触发事件的温度，温度告警及通知时有效，单位：摄氏度
    WORD wCurVoltage;      //触发事件的电压（实际电压*10），电压告警及通知时有效，单位：伏特
    BYTE byRes1[30];
}NET_DVR_FIBER_CONVERT_ALARM, *LPNET_DVR_FIBER_CONVERT_ALARM;



typedef struct tagNET_DVR_SWITCH_CONVERT_ALARM
{
    DWORD dwSize;
    BYTE  byPortNo;    //接口索引，从1开始，表示索引低8位
    BYTE  byPortNoEx;  //接口索引，索引大于255时，该字段表示索引的高8位
    BYTE  byRes1[2];
    DWORD dwEventType; //事件类型，1-告警，2-通知
    DWORD dwEvent;     //具体事件，告警时参考枚举EN_SWITCH_CONVERT_ALARM，通知时参考枚举EN_SWITCH_CONVERT_NOTIFICATION
    BYTE  byRes2[32];
}NET_DVR_SWITCH_CONVERT_ALARM, *LPNET_DVR_SWITCH_CONVERT_ALARM;

typedef struct tagNET_DVR_SWITCH_LAMP_CFG
{
    DWORD        dwSize;//结构体大小
    BYTE       byEnable;       //规则是否启用， 0-不启用，1-启用
    BYTE       byTriggerMode; // 1-持续触发，2-单次触发
    BYTE       byUploadPic;   //0-不上传图片，1-上传图片
    BYTE       byRes1;        //保留
    DWORD      dwTimeInterval; //持续触发报警时间间隔，范围[0,3600]，单位：秒
    NET_DVR_HANDLEEXCEPTION_V30 struHandleType;//处理方式
    BYTE       byRelRecordChan[MAX_IVMS_IP_CHANNEL];    //报警触发的录象通道：1表示触发该通道；0表示不触发
    NET_DVR_SCHEDTIME struAlarmTime[MAX_DAYS][MAX_TIMESEGMENT_V30];//检测时间
    BYTE       byRes[256];
}NET_DVR_SWITCH_LAMP_CFG,*LPNET_DVR_SWITCH_LAMP_CFG;

typedef struct tagNET_DVR_SWITCH_LAMP_ALARM
{
    DWORD        dwSize;//结构体大小
    NET_VCA_DEV_INFO    struDevInfo;        //设备信息
    NET_DVR_TIME_EX     struTime;           //报警时间
    BYTE                byLampStatus;       //开关灯状态，0-已关闭  1-已打开
    BYTE                byRes1[3];          //保留
    DWORD               dwPicDataLen;       //图片数据长度，非0表示有图片上传
    char*               pPicData;           //图片数据
    BYTE                byRes[64];
}NET_DVR_SWITCH_LAMP_ALARM,*LPNET_DVR_SWITCH_LAMP_ALARM;

typedef struct tagNET_DVR_RS485_CASCADE_CFG
{
    DWORD    dwSize; 
    BYTE    byDevAddr;    //设备地址，0-主机，1-15为从机
    BYTE    byRes[131];
}NET_DVR_RS485_CASCADE_CFG,*LPNET_DVR_RS485_CASCADE_CFG;

typedef struct tagNET_DVR_PRIVATE_PROTOCOL_CFG
{
    DWORD          dwSize;   
    NET_DVR_IPADDR     struIP; //消息上传的IP地址
    WORD          wPort;//消息上传的端口号
    BYTE          byEnable;//使能,  0-保留，1-不启用，2-启用
    BYTE        byRes;
    DWORD        dwInterval;//消息上传间隔(0-无时间间隔限制，以设备为准; >=0,以秒为单位的时间间隔)
    BYTE         byServerType;//服务类型 0-无，1-公安
    BYTE         byEcryptedSMSEnable;//0-不加密，1-加密
    BYTE         byAlgorithm;//加密算法，0-无，1-RSA
    BYTE         byAcauisitionMode;//采集模式，0-基本信息，1-虚拟身份信息，2-基本信息+虚拟身份信息
    DWORD        dwDistanceLimit;//距离限制，单位：m
    BYTE         byPKModeEnable;//PK模式使能,  0-保留，1-不启用，2-启用
    BYTE         byMACAddrReductionEnable;//MAC地址还原使能,  0-保留，1-不启用，2-启用
    BYTE         byRes1[214];
    char         szIndexCode[MAX_INDEX_CODE_LEN];
    DWORD        dwSecretKeyLen;//秘钥长度
    char         szSecretKey[MAX_SECRETKEY_LEN/*512*/];//秘钥
}NET_DVR_PRIVATE_PROTOCOL_CFG,*LPNET_DVR_PRIVATE_PROTOCOL_CFG;

typedef struct tagNET_DVR_DEBUG_CMD
{
    DWORD     dwSize;
    char  szDebugCMD[MAX_DEBUGCMD_LEN/*1024*/];
    BYTE  byRes[400];
}NET_DVR_DEBUG_CMD,*LPNET_DVR_DEBUG_CMD;

typedef struct tagNET_DVR_DEBUG_INFO
{
    DWORD     dwSize;
    char  szDebugInfo[MAX_DEBUGINFO_LEN/*1400*/];
    BYTE  byRes[32];
}NET_DVR_DEBUG_INFO,*LPNET_DVR_DEBUG_INFO;




typedef struct tagNET_DVR_GIS_SERVER_INFO
{
    BYTE  byUserName[NAME_LEN];
    BYTE  byPassword[PASSWD_LEN];
    NET_DVR_IPADDR struServerIP;     //GIS服务器IP地址
    WORD  wPort;    //GIS服务器端口
    BYTE  byRes[30];
}NET_DVR_GIS_SERVER_INFO, *LPNET_DVR_GIS_SERVER_INFO;

typedef struct tagNET_DVR_BASEMAP_CONTROL_CFG_V40
{
    DWORD dwSize;
    BYTE  byEnable;        //是否显示，1-显示，0-隐藏    
    BYTE  byBaseMapType;    //底图类型，1-图片底图，2-超高清输入底图，3-GIS底图
    BYTE  byRes1[2];
    DWORD dwBaseMapNo;     //底图号；底图类型为1时，此参数为图片序号，底图类型为2时此参数为超高清输入子系统输入口号（1字节矩阵号+1字节子板号+1字节输入口号+1字节保留）
    NET_DVR_GIS_SERVER_INFO struGisServer;    //GIS服务器信息,当底图类型为GIS底图时有效
    BYTE  byRes2[64];
}NET_DVR_BASEMAP_CONTROL_CFG_V40,*LPNET_DVR_BASEMAP_CONTROL_CFG_V40;

typedef struct tagNET_DVR_VIDEO_IMG_DB_CFG
{    
    DWORD        dwSize;                   //NET_DVR_VIDEO_IMG_DB_CFG结构体大小
    INT64       i64Capacity;             //视图库总容量，低位，单位：MB
    INT64        i64UsedSpace;            //只读，已用空间，低位，单位：MB
    INT64        i64AvailableSpace;        //只读，可用空间，低位，单位：MB
    BYTE          byRes[256];                //保留
}NET_DVR_VIDEO_IMG_DB_CFG, *LPNET_DVR_VIDEO_IMG_DB_CFG;

typedef struct tagNET_DVR_FILE_QUERY_INFO
{    
    DWORD        dwSize;                   //NET_DVR_FILE_QUERY_INFO结构体大小
    INT64       i64FileLen;             //文件大小
    BYTE          byRes[256];                //保留
}NET_DVR_FILE_QUERY_INFO, *LPNET_DVR_FILE_QUERY_INFO;

typedef struct tagNET_DVR_FILE_INFO_IN
{
    char        szFileID[MAX_FILE_ID_LEN];        //上传之后，设备分配的文件ID
    BYTE        byRes[256];
}NET_DVR_FILE_INFO_IN, *LPNET_DVR_FILE_INFO_IN;

typedef struct tagNET_DOWNLOAD_CB_INFO
{
    DWORD     dwType;            //类型, 0-数据信息,1-单个图片信息(云存储批量下载),2-图片总体信息(云存储批量下载)
    BYTE    *pData;            //数据指针
    DWORD   dwDataLen;        //数据长度
    void*   pFileInfo;        //文件信息结构体(云存储批量下载时有效)
    DWORD   dwFileInfoLen;    //文件信息结构体长度(云存储批量下载时有效)
    BYTE    byRes[120];        //保留
}NET_DOWNLOAD_CB_INFO, *LPNET_DOWNLOAD_CB_INFO;

typedef struct tagNET_DVR_DOWNLOAD_CB_PARAM
{
    DOWNLOAD_DATA_CB     fnDownloadDataCB;    //下载数据回调函数
    void                 *pUserData;            //用户参数, 在fnPreviewDataCB回调出来
    INT64                i64Offset;        //下载文件的偏移量，用于断点续传
    BYTE                   byRes[256];
}NET_DVR_DOWNLOAD_CB_PARAM, *LPNET_DVR_DOWNLOAD_CB_PARAM;

typedef struct tagNET_DVR_UPLOAD_DB_IN
{
    INT64    i64FileLen;             //上传新文件，需要给出文件长度，文件续传可以不给
    BYTE    byContinueUpload;     //0-新文件上传，1-老文件续传，文件名必须给出
    BYTE       byRes[255];
}NET_DVR_UPLOAD_DB_IN, *LPNET_DVR_UPLOAD_DB_IN;

typedef struct tagNET_DVR_UPLOAD_DB_OUT
{
    char    szFileID[MAX_FILE_ID_LEN];        //上传之后，设备分配的文件ID
    BYTE    byRes[256];
}NET_DVR_UPLOAD_DB_OUT, *LPNET_DVR_UPLOAD_DB_OUT;

typedef struct tagNET_DVR_SEND_PARAM_IN
{
    BYTE    *pSendData;             //发送的缓冲区,PicURL == 1 的时候，内存中存储的是 URL 字符串,byUploadModeling == 1 的时候，内存中存储的是 建模base64加密数据
    DWORD    dwSendDataLen;         //发送数据长度,PicURL == 1 的时候，表示的 URL 字符串的长度,byUploadModeling == 1 的时候，表示为建模数据base64后的加密长度
    NET_DVR_TIME_V30    struTime;   //图片时间
    BYTE    byPicType;              //图片格式,1-jpg,2-bmp,3-png,4-SWF,5-GIF
    BYTE    byPicURL;               //图片数据采用URL方式 0-二进制图片数据，1-图片数据走URL方式
    /*是否上传建模数据；
    0-	二进制图片数据方式(pSendData指向二进制图片数据, dwPicDataLen为图片二进制数据长度)，
    1-	直接上传建模数据(pSendData指向建模base64加密数据, dwPicDataLen为建模数据base64后的加密长度)。
    注：建模数据采用base64加密方式,选择为建模数据上传后，byPicURL 无需。
    当”/ISAPI/Intelligent/channels/<ID>/faceContrast/capabilities”能力中返回isSupportUploadModeling能力节点时，支持上传建模数据. */
    BYTE    byUploadModeling;
    BYTE    byRes1;
    DWORD   dwPicMangeNo;           //图片管理号
    BYTE    sPicName[NAME_LEN];     //图片名称
    DWORD   dwPicDisplayTime;       //图片播放时长，单位秒
    BYTE    *pSendAppendData;       //发送图片的附加信息缓冲区，对应FaceAppendData 的XML描述；
    DWORD   dwSendAppendDataLen;    //发送图片的附加信息数据长度  FaceAppendData  XML的长度；
    BYTE    byRes[192];
}NET_DVR_SEND_PARAM_IN, *LPNET_DVR_SEND_PARAM_IN;

typedef struct tagNET_DVR_DOWNLOAD_QOS
{
    DWORD    dwMaxSpeed;            //流控最大速度，单位kbps
    BYTE    byRes[256];
}NET_DVR_DOWNLOAD_QOS, *LPNET_DVR_DOWNLOAD_QOS;

typedef struct tagNET_DVR_UPLOAD_FILEVOLUME_PRARAM_
{
    DWORD   dwSize;
    BYTE    byFileType;  //文件类型 0-录像，1-音频
    BYTE    byFileVolnumeID;   //文件卷ID（可以通过NET_DVR_GET_HDVOLUME_CFG 获取）
    BYTE    byArchive;  //0-不归档，1-归档
    BYTE    byRes1;
    DWORD   dwFileSize;    //文件大小
    char    szFileName[NET_SDK_MAX_FILE_NAME/*100*/];   //文件名称
    BYTE    byRes[300];
}NET_DVR_UPLOAD_FILEVOLUME_PRARAM, *LPNET_DVR_UPLOAD_FILEVOLUME_PRARAM;

typedef struct tagNET_DVR_DOWNLOAD_FILEVOLUME_PARAM_
{
    DWORD     dwSize;
    BYTE      sUrl[MAX_UPLOADFILE_URL_LEN/*240*/];   //url
    BYTE      byRes[248];
    DOWNLOAD_DATA_CB     fnDownloadDataCB;    //下载数据回调函数
    void      *pUserData;            //用户参数, 在fnPreviewDataCB回调出来
}NET_DVR_DOWNLOAD_FILEVOLUME_PARAM, *LPNET_DVR_DOWNLOAD_FILEVOLUME_PARAM;

typedef struct tagNET_DVR_FILM_MODE_CFG
{
    DWORD    dwSize;          //结构体大小
    BYTE     byScreenType;     //画面类型，0-单画面，1-两画面，2-画中画
    BYTE     byRes[255];    //保留
}NET_DVR_FILM_MODE_CFG, *LPNET_DVR_FILM_MODE_CFG;

typedef struct tagNET_DVR_DIRECTED_STRATEGY_CFG
{
    DWORD    dwSize;  //结构体大小
    BYTE     byDirectedStrategyType; //导播策略类型，0-常态导播策略，1-精品导播策略,2-精品导播1替2,3-精品导播策略1替3
    BYTE     byRes[255];     //保留
}NET_DVR_DIRECTED_STRATEGY_CFG, *LPNET_DVR_DIRECTED_STRATEGY_CFG;

typedef struct NET_DVR_FRAME
{
    BYTE     byFrameWide; /*边框宽度合法取值范围为[0,14]，并且只能取偶数值*/
    BYTE     byRed;  /*边框颜色为RGB 模式，R，G，B，分别对应位于如下*/
    BYTE     byGreen;
    BYTE     byBlue;
    BYTE     byRes[256];
}NET_DVR_FRAME, *LPNET_DVR_FRAME;

typedef struct tagNET_DVR_FRAME_CFG
{
    DWORD           dwSize;          //结构体大小
    NET_DVR_FRAME    struTopFrame;    //上边框
    NET_DVR_FRAME    struBottomFrame;//下边框
    NET_DVR_FRAME    struLeftFrame;    //左边框
    NET_DVR_FRAME    struRightFrame;    //右边框
    BYTE            byFrameEnable;  //叠加边框0-不叠加1-叠加边框
    BYTE            byRes[256];     //保留
}NET_DVR_FRAME_CFG, *LPNET_DVR_FRAME_CFG;

typedef struct tagNET_DVR_FRAME_COND
{
    DWORD           dwSize;
    DWORD           dwPicNo;//画面编号
    BYTE            byRes[256];
}NET_DVR_FRAME_COND, *LPNET_DVR_FRAME_COND;

typedef struct tagNET_DVR_AUDIO_EFFECTIVE_CFG
{
    DWORD       dwSize;          //结构体大小
    DWORD       dwCheckDelay;    //检测时延，单位s，0表示不自动优化
    BYTE        byThreshold;     //阈值[0,100]
    BYTE        byVolumePercent;//音量 [0,100]
    BYTE        byPriority;     //等级，[0，100]
    BYTE        byRes[301];
}NET_DVR_AUDIO_EFFECTIVE_CFG, *LPNET_DVR_AUDIO_EFFECTIVE_CFG;

typedef struct tagNET_DVR_RECORD_VIDEO_CFG
{
    DWORD       dwSize;              //结构体大小
    BYTE        byExportType;         //阈值0-MP4 1-AVI
    BYTE        byRes[255];          //保留字节 
} NET_DVR_RECORD_VIDEO_CFG, *LPNET_DVR_RECORD_VIDEO_CFG;

typedef struct tagNET_DVR_RTMP_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byStreamType;  //码流类型，1-主码流，2-子码流，3-码流三
    BYTE             byRes[303];
}NET_DVR_RTMP_COND, *LPNET_DVR_RTMP_COND;

typedef struct tagNET_DVR_RTMP_CFG
{
    DWORD       dwSize;                          //结构体大小
    BYTE        byEnable;                        //是否启用RTMP，0-不启用，1-启用
    BYTE         byRes1[3];
    DWORD       dwPacketLen;                     //RTMP包长
    char        szURL[RTMP_URL_LEN];            //RTMP URL
    BYTE         byRes[256];                      //保留字节 
}NET_DVR_RTMP_CFG, *LPNET_DVR_RTMP_CFG;


typedef struct tagNET_DVR_PUBLISH_PROGRESS_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byFileID[MAX_ID_LEN_128/*128*/];  //发布文件ID
    BYTE             byRes[256];
}NET_DVR_PUBLISH_PROGRESS_COND, *LPNET_DVR_PUBLISH_PROGRESS_COND;

typedef struct tagNET_DVR_PUBLISH_PROGRESS_CFG
{
    DWORD    dwSize;          //结构体大小
    BYTE     byPublishPercent;     //发布百分比 0-100
    BYTE     byPublishStatus;     //发布状态  0-发布成功 1--正在发布 2--等待发布 3-连不上FTP  4--没有找到此文件 5--发布失败（其他错误）
    BYTE     byRes[302];
}NET_DVR_PUBLISH_PROGRESS_CFG, *LPNET_DVR_PUBLISH_PROGRESS_CFG;


typedef struct tagNET_DVR_BACKGROUND_PIC_CFG
{
    DWORD    dwSize;                         //结构体大小
    DWORD     dwPicSize;  //背景图片大小
    DWORD     dwPicType;   //图片类型，YUV:0 JPEG:1
    WORD     wPicWidth;   //图片宽
    WORD     wPicHeight;    //图片高
    BYTE          byPicName[MAX_PIC_NAME_LEN/*128*/];   //图片名称
    BYTE         byRes[128];
}NET_DVR_BACKGROUND_PIC_CFG,*LPNET_DVR_BACKGROUND_PIC_CFG;

typedef struct tagNET_DVR_BACKGROUND_PIC_INFO
{
    DWORD   dwSize;                              //结构体大小
    BYTE    byEnable;             //是否启用背景图片叠加，0-否，1-是
    BYTE    byRes1[3];
    BYTE    byPicID[MAX_ID_LEN_128/*128*/];
    BYTE    byRes[300];         //保留
}NET_DVR_BACKGROUND_PIC_INFO,*LPNET_DVR_BACKGROUND_PIC_INFO;

typedef struct tagNET_DVR_BACKGROUND_PIC_PRARAM
{
    DWORD       dwSize;
    DWORD        dwChannel; //导播通道
    DWORD        dwPicSize;  //背景图片大小
    WORD        wPicWidth;   //图片宽
    WORD           wPicHeight;    //图片高
    char          szPicName[MAX_PIC_NAME_LEN/*128*/];   //图片名称
    BYTE        byPicType;   //图片类型，YUV:0 JPEG:1
    BYTE        byRes[303];
}NET_DVR_BACKGROUND_PIC_PRARAM,*LPNET_DVR_BACKGROUND_PIC_PRARAM;


typedef struct tagNET_DVR_POINT
{
    DWORD dwX;    //X轴坐标
    DWORD dwY;    //Y坐标
}NET_DVR_POINT, *LPNET_DVR_POINT;


typedef struct tagNET_DVR_ONLINEUPGRADE_STATUS
{
    DWORD   dwSize;
    BYTE    byUpgradeStatus;//0-未开始升级,1-正在升级,2-升级成功,3-包语言不匹配,4-写falsh失败,5-包类型不匹配,6-包版本不匹配,7-网络不可达,8-升级服务器出错,
                            //9-读取升级包文件出错,10-没有找到升级文件,11-升级文件有错,12-设备内存不足,0xff-未知错误
    BYTE    byProgress; //升级进度,0~100
    BYTE    byRes[250];
}NET_DVR_ONLINEUPGRADE_STATUS,*LPNET_DVR_ONLINEUPGRADE_STATUS;




typedef struct tagNET_DVR_ONLINEUPGRADE_SERVER 
{
    DWORD  dwSize;
    BYTE   byConnectStatus;    //0-未连接,1-已连接
    BYTE   byRes[1019];
}NET_DVR_ONLINEUPGRADE_SERVER,*LPNET_DVR_ONLINEUPGRADE_SERVER;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byCheckFromSvr; //是否需要从服务器检测，0-不需要，仅返回设备周期性检查的结果;1-需要，设备会即时连接服务器检测是否有新版本
    BYTE   byRes[59];
}NET_DVR_ONLINEUPGRADE_VERSION_COND,*LPNET_DVR_ONLINEUPGRADE_VERSION_COND;

typedef struct tagNET_DVR_ONLINEUPGRADE_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byNewVersionAvailable;  //是否有新版本,0-否,1-是
    BYTE   byNewVersion[MAX_VERSIIN_LEN];  //新版本的版本号
    BYTE   byChangeLog[SDK_LEN_2048];  //新版本更新的内容
    BYTE   byRes[971];
}NET_DVR_ONLINEUPGRADE_VERSION_RET,*LPNET_DVR_ONLINEUPGRADE_VERSION_RET;

typedef struct tagNET_DVR_RECOMMEN_VERSION_COND
{
    DWORD  dwSize;
    BYTE   byFirmwareCode[MAX_IDCODE_LEN]; 
    BYTE   byFirmwareVersion[MAX_VERSIIN_LEN];
    BYTE   byRes[60];
}NET_DVR_RECOMMEN_VERSION_COND,*LPNET_DVR_RECOMMEN_VERSION_COND;

typedef struct tagNET_DVR_RECOMMEN_VERSION_RET
{
    DWORD  dwSize;
    BYTE   byRecommenUpgrade;  //推荐升级,0-否,1-是
    BYTE   byRes[123];
}NET_DVR_RECOMMEN_VERSION_RET,*LPNET_DVR_RECOMMEN_VERSION_RET;






typedef struct tagNET_DVR_RELOCATE_INFO
{
    DWORD        dwSize;//结构体大小
    BYTE        byTakeOverAddr[MAX_DOMAIN_NAME/*64*/];     //接管设备的地址 
    WORD        wPort ;                 //设备端口号
    BYTE        byRes[254] ;            //保留
}NET_DVR_RELOCATE_INFO, *LPNET_DVR_RELOCATE_INFO;

typedef struct tagNET_DVR_CONFERENCE_REGION
{
    DWORD dwSize;
    BYTE byEnabled;        //是否启用会议区域，0-否，1-是
    BYTE byRes1[3];
    NET_DVR_POINT struRegion[RECT_POINT_NUM];    //会议区域，矩形，起始点为左下角，顺时针方向
    DWORD dwOutputWidth;    //单输出口基准宽，只能获取
    DWORD dwOutputHeight;    //单输出口基准高，只能获取
    BYTE byRes2[32];
}NET_DVR_CONFERENCE_REGION, *LPNET_DVR_CONFERENCE_REGION;

typedef struct tagNET_DVR_TERMINAL_CALL_CFG
{
    DWORD dwSize;
    BYTE  byAnswerType; //会议呼叫响应方式，1-自动接听，2-自动拒接，3-手动接听
    BYTE  byProtocolType;    //使用的协议类型，1-SIP，2-H232
    BYTE byTransmissionProtocol; //传输协议类型，0-无效，1-TCP，2-UDP
    BYTE byRes[29];
}NET_DVR_TERMINAL_CALL_CFG, *LPNET_DVR_TERMINAL_CALL_CFG;

typedef struct tagNET_DVR_TERMINAL_CALL_INFO
{
    BYTE byTermianlURL[MAX_URL_LEN];
    DWORD dwCallRate;//呼叫速率，范围为：32~6144，单位Kbps  (连接速率)
    BYTE  byRes[124];
}NET_DVR_TERMINAL_CALL_INFO, *LPNET_DVR_TERMINAL_CALL_INFO;

typedef struct tagNET_DVR_TERMINAL_AUDIO_CTRL
{
    BYTE byMute;     //是否静音，0-否，1-是
    BYTE byVolume;   //音量，非静音时有效，1-100
    BYTE byAudioInputDisabled;  //禁止音频输入，0-允许音频输入，1-禁止音频输入
    BYTE byAudioInputVolume;    //音频输入音量，允许音频输入时有效，1-100
    BYTE byRes[636];
}NET_DVR_TERMINAL_AUDIO_CTRL, *LPNET_DVR_TERMINAL_AUDIO_CTRL;

typedef struct tagNET_DVR_HOWLING_SUPPRESSION
{
    BYTE    byEnabled;  //是否使能啸叫抑制
    BYTE    byHsSensibility;    //啸叫抑制灵敏度
    BYTE    byHsMode;   //啸叫抑制模式，0-默认，1-慢速，2-快速
    BYTE    byRes1;
    DWORD dwHsTime; //啸叫抑制时间，单位：ms
    BYTE    byRes2[16];
}NET_DVR_HOWLING_SUPPRESSION, *LPNET_DVR_HOWLING_SUPPRESSION;

typedef struct tagNET_DVR_TERMINAL_INPUT_AUDIO
{
    DWORD dwChannel; //通道号
    BYTE   byGainType; //增益类型，1-数字增益，2-模拟增益,3-两者
    BYTE   byEnableSimulate; //是否启用模拟增益，0-否，1-是
    BYTE   byVolumeSimulate;  //模拟音量，启用时有效，1-100
    BYTE   byEnableDigital; //是否启用数字增益，0-否，1-是
    BYTE   byVolumeDigital;  //数字音量，启用时有效，1-100
    BYTE   byRes1[3];
    NET_DVR_HOWLING_SUPPRESSION struHsParam;    //啸叫抑制参数
    BYTE   byRes[604];
}NET_DVR_TERMINAL_INPUT_AUDIO, *LPNET_DVR_TERMINAL_INPUT_AUDIO;


typedef struct tagNET_DVR_TERMINAL_CTRL_PARAM
{
    DWORD dwSize;
    BYTE byOperateType;    //操作类型，1-接听，2-拒接，3-呼叫，4-音频调节，5-挂断，6-双流开，7-双流关
    BYTE byRes1[3];
    NET_DVR_TERMINAL_DETAIL_CTRL_PARAM struCtrlParam;   //具体控制参数
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CTRL_PARAM, *LPNET_DVR_TERMINAL_CTRL_PARAM;

typedef struct tagNET_DVR_POS_INFO_OVERLAY
{
    DWORD   dwSize;
    BYTE    byPosInfoOverlayEnable;// Pos信息码流叠加控制，0-不叠加，1-叠加
    BYTE    byOverlayType;//0-叠加进入和离开，1-叠加进入、离开、PASS、ID、高度
    BYTE    byRes[126];
}NET_DVR_POS_INFO_OVERLAY, *LPNET_DVR_POS_INFO_OVERLAY;

typedef struct tagNET_DVR_CAMERA_WORK_MODE
{
    DWORD dwSize;
    BYTE  byWorkMode;//工作模式，0-正常模式，1-工厂标定模式
    BYTE  byPreviewImageMode;//预览图像模式，0-左眼图像，1-右眼图像，2-左右叠加图像
    BYTE byRes[126];
}NET_DVR_CAMERA_WORK_MODE, *LPNET_DVR_CAMERA_WORK_MODE;

typedef struct tagNET_DVR_VCA_VERSION_LIST
{
    DWORD    dwSize;        //结构体长度
    NET_DVR_VCA_VERSION  struVcaVersion[NET_SDK_VERSION_LIST_LEN/*64*/];//算法库版本信息
    BYTE    byRes[128];
}NET_DVR_VCA_VERSION_LIST, *LPNET_DVR_VCA_VERSION_LIST;

typedef struct tagNET_DVR_SETUP_CALIB_COND
{
    DWORD dwSize;
    BYTE  byCalibrateType;//标定类型，0-未进行标定，1-自动标定，2-手动标定,3-智能标定
    BYTE  byRes1[3];
    float fTiltAngle;//俯仰角,单位：度；俯仰角默认值：0；俯仰角范围：0-180度,当byCalibrateType为2时有效
    float fHeelAngle;//倾斜角,单位：度；倾斜角默认值：0；倾斜角范围：-90-90度,当byCalibrateType为2时有效
    float fHeight;//高度，高度单位：厘米；高度默认值300厘米：高度范围：200-500厘米,当byCalibrateType为2时有效
    NET_VCA_POLYGON struAutoCalibPolygon;//自动标定区域，当byCalibrateType为1时有效
    BYTE byIntelligentType;//标定的智能类型，0-保留， 1-客流，2-人体属性，3-行为分析；只有在标定客流时NET_DVR_SETUP_CALIB_RESULT返回的数据才有效
    BYTE byRes[127];
}NET_DVR_SETUP_CALIB_COND, *LPNET_DVR_SETUP_CALIB_COND;

typedef struct tagNET_DVR_SETUP_CALIB_RESULT
{
    DWORD dwSize;
    BYTE  byCalibrateType;//标定类型，0-未进行标定，1-自动标定，2-手动标定,3-智能标定
    BYTE  byRes1[3];
    float fTiltAngle;//俯仰角,单位：度；俯仰角默认值：0；俯仰角范围：0-180度,当byCalibrateType为2时有效
    float fHeelAngle;//倾斜角,单位：度；倾斜角默认值：0；倾斜角范围：-90-90度,当byCalibrateType为2时有效
    float fHeight;//高度，高度单位：厘米；高度默认值300厘米：高度范围：200-500厘米,当byCalibrateType为2时有效
    NET_VCA_POLYGON struCountPolygon;//计数区域
    NET_DVR_PDC_ENTER_DIRECTION  struEnterDirection; // 流量进入方向
    NET_VCA_LINE  struLine;//检测线
    BYTE byRes[128];
}NET_DVR_SETUP_CALIB_RESULT, *LPNET_DVR_SETUP_CALIB_RESULT;

typedef struct tagNET_DVR_CALL_QUERY_COND
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN]; //搜索标识符
    NET_DVR_TIME struStartTime; //搜索起始时间
    NET_DVR_TIME struEndTime;   //搜索结束时间
    BYTE byCallType;    //呼叫类型，1-已接，2-未接，3-已拨，4-所有类型
    BYTE byRes1[3];
    DWORD dwMaxResults; //本次查找最多返回个数
    DWORD dwSearchPos;  //查找起始索引
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_COND, *LPNET_DVR_CALL_QUERY_COND;

typedef struct tagNET_DVR_CALL_QUERY_SINGLE
{
    DWORD dwSize;
    BYTE byCallType;    //呼叫类型，1-已接，2-未接，3-已拨
    BYTE byRes1[3];
    BYTE byTerminalName[TERMINAL_NAME_LEN]; //终端名
    BYTE byAddressURL[MAX_URL_LEN]; //对端URL地址
    NET_DVR_TIME struStartTime; //呼叫开始时间
    NET_DVR_TIME struEndTime;   //呼叫结束时间
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_SINGLE, *LPNET_DVR_CALL_QUERY_SINGLE;


typedef struct tagNET_DVR_CALL_QUERY_RESULT
{
    DWORD dwSize;
    BYTE bySearchID[MAX_SEARCH_ID_LEN]; //搜索标识符
    BYTE   byStatus;  //查询状态  参考CALL_QUERY_RESULT_STATUS结构体
    BYTE   byRes[3];  //保留 
    DWORD dwCount; //实际查询到的结果个数
    BYTE *pResults; //结果内容，dwCount个NET_DVR_CALL_QUERY_SINGLE,需要调用者预先分屏好内存
    BYTE byRes2[32];
}NET_DVR_CALL_QUERY_RESULT, *LPNET_DVR_CALL_QUERY_RESULT;

typedef struct tagNET_DVR_CONFERENCE_CALL_INFO
{
    BYTE byConferenceID[MAX_ID_LEN]; //会议ID
    BYTE byConferenceName[NAME_LEN];    //会议名称     
    NET_DVR_TIME struStartTime;        //会议开始时间
    NET_DVR_TIME struEndTime;        //会议结束时间
    BYTE byRes[512];
}NET_DVR_CONFERENCE_CALL_INFO, *LPNET_DVR_CONFERENCE_CALL_INFO;


typedef struct tagNET_DVR_CONFERENCE_CALL_ALARM
{
    DWORD dwSize;
    BYTE  byAlarmType;              //报警类型，1-会议呼叫， 2-呼叫状态切换，3-终端提问
    BYTE  byCallType;               //呼叫类型，报警类型为1时有效，1-终端点对点呼叫，2-会议呼叫
    BYTE  byAutoAnswer;                //是否已自动接听，0-否，1-是
    BYTE  byCallStatusSwitch;       //呼叫状态切换类型，当报警类型为2时有效，1-开始呼叫，2-呼叫成功，3-呼叫结束，4-对端挂断
    NET_DVR_CALL_INFO struCallInfo; //呼叫信息
    BYTE  byRes2[32];    
}NET_DVR_CONFERENCE_CALL_ALARM, *LPNET_DVR_CONFERENCE_CALL_ALARM;

typedef struct tagNET_DVR_TERMINAL_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwInputNo;    //作为视频会议输入的输入口编号
    BYTE  byStreamType;//码流类型：0-主码流，1-子码流，2-三码流
    BYTE  byRes[31];
}NET_DVR_TERMINAL_INPUT_CFG, *LPNET_DVR_TERMINAL_INPUT_CFG;

typedef struct tagNET_DVR_AUDIO_STATUS
{
    BYTE byMute;    //是否静音，0-否，1-是
    BYTE byVolume;  //会议音量，1-100，非静音时有效
    BYTE byAudioInputDisabled;  //禁用音频输入，0-否，1-是
    BYTE byAudioInputVolume; //音频输入音量，1-100，允许音频输入时有效
    BYTE byRes[32];
}NET_DVR_AUDIO_STATUS, *LPNET_DVR_AUDIO_STATUS;

typedef struct tagNET_DVR_TERMINAL_CONFERENCE_STATUS
{
    DWORD dwSize;
    BYTE byConferenceState; //会议状态，0-空闲，1-忙碌（会议中），2-呼叫中，3-被呼叫中
    BYTE byConferenceType;  //会议类型，1-点对点，2-MCU发起会议
    BYTE byDualStreamEnabled;    //是否开启双流，0-未开启，1-开启
    BYTE byMicPowerEnabled;    //麦克风电源是否开启，0-未开启，1-开启
    DWORD dwInputNo;   //使用的音频输入口号
    NET_DVR_CALL_INFO struCallInfo; //会议信息
    NET_DVR_AUDIO_STATUS struAudioStatus;   //音频相关状态
    BYTE byRes2[32];
}NET_DVR_TERMINAL_CONFERENCE_STATUS, *LPNET_DVR_TERMINAL_CONFERENCE_STATUS;

typedef struct tagNET_DVR_TERMINAL_GK_CFG
{
    DWORD dwSize;
    BYTE  byEnable; //是否启用
    BYTE  byRegisterState;    //注册状态，0-未注册，1-已注册，只读
    BYTE  byRes1[2];
    NET_DVR_IPADDR struGKIP; //GK IP
    WORD wGKPort; //GK端口号
    BYTE byRes2[2];
    BYTE byRegisterName[REGISTER_NAME_LEN]; //终端注册到GK的名字
    BYTE byPassword[PASSWD_LEN];    //终端注册到GK的密码
    BYTE byRes3[16];
}NET_DVR_TERMINAL_GK_CFG, *LPNET_DVR_TERMINAL_GK_CFG;

typedef struct tagNET_DVR_WIN_ROAM_SWITCH_CFG
{
    DWORD dwSize;
    BYTE  byEnableRoam;    //是否允许窗口漫游，0-否，非0-是
    BYTE  byRes[31];
}NET_DVR_WIN_ROAM_SWITCH_CFG,*LPNET_DVR_WIN_ROAM_SWITCH_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_CFG
{
    DWORD dwSize;
    BYTE byEnableZoom;  //是否缩放，0-否，1-是
    BYTE byAutoCutBlackEdge;  //是否自动裁剪黑边，0-否，1-是
    BYTE byRes1[2];
    WORD wLEDWidth;     //分辨率宽
    WORD wLEDHeight;    //分辨率高
    DWORD dwRefreshRate;    //刷新频率
    DWORD dwInputNO;    //关联的输入通道号
    BYTE byRes2[32];
}NET_DVR_LED_OUTPUT_CFG, *LPNET_DVR_LED_OUTPUT_CFG;

typedef struct tagNET_DVR_LED_OUTPUT_PORT_CFG
{
    DWORD dwSize;
    BYTE  byEnabled;    //是否使能，0-否，1-是
    BYTE  byRes1[3];
    DWORD dwPortNum;    //包含的端口个数
    DWORD dwPortNo[MAX_OUTPUT_PORT_NUM];     //包含的端口号
    BYTE  byRes2[64];
}NET_DVR_LED_OUTPUT_PORT_CFG, *LPNET_DVR_LED_OUTPUT_PORT_CFG;

typedef struct tagNET_DVR_LINE_COLUMN_INFO
{
    WORD wLine;   //行号
    WORD wColumn; //列号
}NET_DVR_LINE_COLUMN_INFO, *LPNET_DVR_LINE_COLUMN_INFO;

typedef struct tagNET_DVR_LED_DISPLAY_AREA
{
    DWORD dwSize;
    NET_DVR_LINE_COLUMN_INFO struLCInfo;  //显示区域的起始位置(接收卡行列号)
    WORD    wWidth;     //横向接收卡数
    WORD    wHeight;    //竖向接收卡数
    WORD     wRecvCardWidth;   //接收卡宽度大小，为0则使用端口参数中接收卡大小参数
    WORD    wRecvCardHeigt;   //接收卡高度大小，为0则使用端口参数中接收卡大小参数
    BYTE    byRes[32];
}NET_DVR_LED_DISPLAY_AREA, *LPNET_DVR_LED_DISPLAY_AREA;

typedef struct tagNET_DVR_LED_RECV_CARD_INFO
{
    NET_DVR_LINE_COLUMN_INFO struPos; //接收卡位置
    WORD wRecvCardWidth;   //接收卡宽度大小
    WORD wRecvCardHeigt;   //接收卡高度大小
}NET_DVR_LED_RECV_CARD_INFO, *LPNET_DVR_LED_RECV_CARD_INFO;

typedef struct tagNET_DVR_LED_PORT_BACKUP
{
    BYTE byEnabled;    //是否启用端口备份，0-否，1-是
    BYTE byPortMode; //端口模式，1-主口，2-备份口
    BYTE byRes1[2];
    DWORD dwPairPort; //配对端口号，当端口为主口时，此参数为备份口端口号，当端口为备份口时，此参数为主口端口号
    BYTE byRes2[16];
}NET_DVR_LED_PORT_BACKUP, *LPNET_DVR_LED_PORT_BACKUP;

typedef struct tagNET_DVR_LED_PORT_CFG
{
    DWORD dwSize;
    BYTE byEnabled; //是否启用该端口，0-否，1-是
    BYTE byRes1[3];
    NET_DVR_LED_PORT_BACKUP struLedPortBackup;    //端口备份参数
    DWORD dwRecvCardNum;   //本端口连接的接收卡数
    NET_DVR_LED_RECV_CARD_INFO struRecvCard[MAX_SINGLE_PORT_RECVCARD_NUM];   //各接收卡的信息
    DWORD dwPortNo; //端口号，获取所有端口参数时有效
    BYTE byRes2[64];
}NET_DVR_LED_PORT_CFG, *LPNET_DVR_LED_PORT_CFG;

typedef struct tagNET_DVR_LED_DISPLAY_CFG
{
    DWORD dwSize;
    NET_DVR_COLOR_TEMPERATURE_CFG struColorTemp;    //色温参数
    NET_DVR_VIDEO_OUT_CFG struVoutCfg;        //显示效果参数
    BYTE byRes[32];
}NET_DVR_LED_DISPLAY_CFG, *LPNET_DVR_LED_DISPLAY_CFG;

typedef struct tagNET_DVR_LED_TEST_SIGNAL_CFG
{
    DWORD dwSize;
    BYTE byEnabled;        //是否启用测试信号，0-不启用，1-启用
    BYTE bySignalType;    //测试信号类型，1-彩条，2-波纹，3-格状彩条，4-方格，5-水平和垂直灰阶联合体，6-棋盘，0xff-自定义颜色
    BYTE byRes1[2];
    NET_DVR_RGB_COLOR struSignalColor;    //测试信号颜色，测试信号类型为0xff时有效
    BYTE byRes[32];
}NET_DVR_LED_TEST_SIGNAL_CFG, *LPNET_DVR_LED_TEST_SIGNAL_CFG;

typedef struct tagNET_DVR_LED_NOSIGNAL_CFG
{
    DWORD dwSize;
    BYTE byNoSignalMode;    //无信号显示模式，1-黑屏，2-显示厂家LOGO，3-显示自定义图片
    BYTE byRes[63];
}NET_DVR_LED_NOSIGNAL_CFG, *LPNET_DVR_LED_NOSIGNAL_CFG;

typedef struct tagNET_DVR_LED_INPUT_CFG
{
    DWORD dwSize;
    DWORD dwResolutionWidth;    //输入分辨率宽，只读
    DWORD dwResolutionHeight;    //输入分辨率高，只读
    DWORD dwRefreshRate;        //输入信号刷新频率，只读
    NET_DVR_SCREEN_VGA_CFG struVgaCfg;    //VGA信号调整参数，VGA输入时可调
    BYTE  byRes[32];
}NET_DVR_LED_INPUT_CFG, *LPNET_DVR_LED_INPUT_CFG;

typedef struct tagNET_DVR_LED_RECV_CARD_CFG_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;    //输出编号
    NET_DVR_LINE_COLUMN_INFO struPosStart; //接收卡起始位置
    NET_DVR_LINE_COLUMN_INFO struPosEnd;   //接收卡结束位置
    BYTE byRes[32];
}NET_DVR_LED_RECV_CARD_CFG_COND, *LPNET_DVR_LED_RECV_CARD_CFG_COND;

typedef struct tagNET_DVR_LED_GAMMA_CFG_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;    //输出编号;
    NET_DVR_LINE_COLUMN_INFO struPosStart; //接收卡起始位置
    NET_DVR_LINE_COLUMN_INFO struPosEnd; //接收卡结束位置
    BYTE byGammaType; //Gamma表类型，Gamma表配置时有效，0-RGB混合Gamma表，1-红色Gamma表，2-绿色Gamma表，3-蓝色Gamma表
    BYTE byRes[31];
}NET_DVR_LED_GAMMA_CFG_COND, *LPNET_DVR_LED_GAMMA_CFG_COND;

typedef struct tagNET_DVR_LED_GAMMA_CFG
{
    DWORD dwSize;
    WORD wGammaValue[MAX_GAMMA_X_VALUE];    //GAMMA表Y取值，每个元素取值0-65535，自定义模式时有效
    BYTE byGammaModel; //GAMMA表模式，0-自定义模式，1-夜模式1，2-夜模式2，3-正常模式，4-日照模式1，5-日照模式2
    BYTE byRes[127];
}NET_DVR_LED_GAMMA_CFG, *LPNET_DVR_LED_GAMMA_CFG;

typedef struct tagNET_DVR_LED_CLOCK_CFG
{
    DWORD dwDclkRate;    //传输时钟dclk频率，实际值乘10，单位：MHz，实际值范围1.0-31.3
    DWORD dwGclkRate;    //刷新时钟gclk频率，实际值乘10，单位：MHz，实际值范围1.0-31.3
    DWORD dwGclkCountNum;    //300ns gclk计数值
    BYTE  byDclkDutyRatio;    //dclk时钟占空比，取值：25，50，75
    BYTE  byDclkPhase;    //dclk相位，取值：0,1,2,3
    BYTE  byGclkNum;    //刷新1行需要的有效gclk个数，0-255
    BYTE  byRes[17];
}NET_DVR_LED_CLOCK_CFG, *LPNET_DVR_LED_CLOCK_CFG;

typedef struct tagNET_DVR_LED_RECV_CFG
{
    DWORD dwSize;
    NET_DVR_LED_CLOCK_CFG struClockCfg;    //时钟相关参数
    BYTE byGrayLevel;    //灰度等级，取值13，14
    BYTE byRefreshRate;    //刷新倍率，取值1-6
    BYTE byLineScanNum;    //行扫数，0-255
    BYTE byRefreshCompleteGrayNum; //刷新完整灰阶数，0-255
    DWORD dwHBlank;        //行消隐时间，单位：gclk时钟个数，取值1-65535
    DWORD dwAfterglowCtrl;    //余晖控制结束时间，单位：gclk时钟个数，取值1-65535
    DWORD dwLineFeedTime;    //换行时间，单位：gclk时钟个数，取值1-65535
    BYTE byRes[128];
}NET_DVR_LED_RECV_CFG, *LPNET_DVR_LED_RECV_CFG;

typedef struct tagNET_DVR_LED_REGISTOR_VALUE
{
    BYTE byChip1High;        //芯片1高字节
    BYTE byChip1Low;        //芯片1低字节
    BYTE byChip2High;        //芯片2高字节
    BYTE byChip2Low;        //芯片2低字节
    BYTE byChip3High;        //芯片3高字节
    BYTE byChip3Low;        //芯片3低字节
    BYTE byChip4High;       //芯片4高字节
    BYTE byChip4Low;        //芯片4低字节
    BYTE byChip5High;       //芯片5高字节
    BYTE byChip5Low;        //芯片5低字节
    BYTE byChip6High;       //芯片6高字节
    BYTE byChip6Low;        //芯片6低字节
    BYTE byRes[4];
}NET_DVR_LED_REGISTOR_VALUE, *LPNET_DVR_LED_REGISTOR_VALUE;

typedef struct tagNET_DVR_LED_RECV_REGISTOR
{
    BYTE byEliminateGhostShadowLevel;    //下鬼影消除等级，0-5
    BYTE byEliminateShadowy;            //第一扫偏暗消除等级，0-15
    BYTE byGrayEqualize1;                //低灰偏色补偿1，0-3
    BYTE byGrayEqualize2;                //低灰偏色补偿2，0-15
    BYTE byEnableGrayUniformity;        //低灰均匀性提升是否开启，0-关，1-开
    BYTE byDisableHGrayStripes;            //低灰横条纹消除是否开启，0-关，1-开
    BYTE byGhostShadowEnhancedMode1;    //下鬼影消除增强模式1是否开启，0-关，1-开
    BYTE byGhostShadowEnhancedMode2;    //下鬼影消除增强模式2是否开启，0-关，1-开
    BYTE byClearBadPoint;                //去除坏点使能，0-非使能，1-使能
    BYTE byEnableSelfDefineRegistor;    //是否启用自定义寄存器值，0-否，1-是
    BYTE byRes1[2];
    NET_DVR_LED_REGISTOR_VALUE struRegistorValue;    //自定义寄存器参数    
    BYTE    byEnabledExGradientOptimition;	//渐变过度优化开关，0-关闭，!0-开启
    BYTE    byDummyGClockCycle;     //Dummy GClock周期，开启渐变过度优化时有效，单位：个gclk
    BYTE    byDummyGClockHighTime;      //Dummy GClock高电平时间，开启渐变过度优化时有效，单位：8ns
    BYTE    byFirstGClockExtendedTime;  //第一个GClock展宽时间，开启渐变过度优化时有效，单位：8ns
    BYTE byRes[28];
}NET_DVR_LED_RECV_REGISTOR, *LPNET_DVR_LED_RECV_REGISTOR;

typedef struct tagNET_DVR_LED_RECV_ADVANCED_CFG
{
    DWORD dwSize;
    NET_DVR_LED_RECV_REGISTOR struFirstRegistor;    //第一组接收卡高级参数，自定义寄存器值为红芯片寄存器值
    NET_DVR_LED_RECV_REGISTOR struSecondRegistor;    //第二组接收卡高级参数，自定义寄存器值为绿芯片寄存器值
    NET_DVR_LED_RECV_REGISTOR struThirdRegistor;    //第三组接收卡高级参数，自定义寄存器值为蓝芯片寄存器值
    BYTE byRes2[64];
}NET_DVR_LED_RECV_ADVANCED_CFG,*LPNET_DVR_LED_RECV_ADVANCED_CFG;

typedef struct tagNET_DVR_LED_CHECK_COND
{
    DWORD dwSize;
    DWORD dwOutputNo;   //输入编号
    NET_DVR_LINE_COLUMN_INFO struPosStart; //接收卡起始位置
    BYTE byStartPosType; //起始位置类型，0-使用接收卡起始位置，1-使用坐标位置
    BYTE byRes1[3];
    DWORD dwXCoordinate;    /*矩形左上角起始点X坐标*/
    DWORD dwYCoordinate;    /*矩形左上角Y坐标*/
    DWORD dwWidth;          /*区域宽度*/
    DWORD dwHeight;          /*区域高度*/
    BYTE  byRes[8];
}NET_DVR_LED_CHECK_COND, *LPNET_DVR_LED_CHECK_COND;


typedef struct tagNET_DVR_QUERY_COUNTRYID_COND
{
    WORD    wCountryID;    //国家编号,取值详见附件一
    char    szSvrAddr[MAX_DOMAIN_NAME];//服务器地址,表示去哪个服务器上查询目标服务器的信息
    char    szClientVersion[CLIENT_VERSION_LEN];//客户端版本信息,例如:iVMS4500 V4.0.0.0 build20150112
    BYTE    byRes[382];
}NET_DVR_QUERY_COUNTRYID_COND,*LPNET_DVR_QUERY_COUNTRYID_COND;

typedef struct tagNET_DVR_QUERY_COUNTRYID_RET
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//解析服务器地址(即设备注册服务器)
    char    szAlarmSvrAddr[MAX_DOMAIN_NAME];//报警服务器地址
    BYTE    byRes[1024];
}NET_DVR_QUERY_COUNTRYID_RET,*LPNET_DVR_QUERY_COUNTRYID_RET;

typedef struct tagNET_DVR_QUERY_SERVERTYPE_COND
{
    WORD    wSvrType;    //服务器类型, 6-手机推送服务器
    char    szSvrAddr[MAX_DOMAIN_NAME];//服务器地址,表示去哪个服务器上查询目标服务器的信息
    char    szClientVersion[CLIENT_VERSION_LEN];//客户端版本信息
    BYTE    byRes[382];
}NET_DVR_QUERY_SERVERTYPE_COND, *LPNET_DVR_QUERY_SERVERTYPE_COND;

typedef struct tagNET_DVR_QUERY_SERVERTYPE_RET
{
    char    szSvrAddr[MAX_DOMAIN_NAME];    //服务器地址
    WORD    wSvrPort;    //服务器端口
    BYTE    byRes[446];
}NET_DVR_QUERY_SERVERTYPE_RET, *LPNET_DVR_QUERY_SERVERTYPE_RET;

typedef struct tagNET_DVR_QUERY_DDNS_COND
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//解析服务器地址
    char    szDevNickName[MAX_DOMAIN_NAME];    //设备在解析服务器上的别名
    char    szDevSerial[SERIALNO_LEN];    //设备序列号
    char    szClientVersion[CLIENT_VERSION_LEN];//客户端版本信息,例如:iVMS4500 V4.0.0.0 build20150112
    BYTE    byRes[272];        //保留
}NET_DVR_QUERY_DDNS_COND,*LPNET_DVR_QUERY_DDNS_COND;

typedef struct tagNET_DVR_QUERY_DDNS_RET
{
    char    szDevIP[SDK_MAX_IP_LEN];    //设备IP地址
    WORD    wCmdPort;        //控制端口（SDK连接端口）
    WORD    wHttpPort;        //http端口
    BYTE    byRes[460];
}NET_DVR_QUERY_DDNS_RET,*LPNET_DVR_QUERY_DDNS_RET;

typedef struct tagNET_DVR_CHECK_DDNS_RET
{
    BYTE    byDevStatus;        //设备状态,0-正常,1-找不到,2-设备不在线,3-设备不在当前区域
    BYTE    byRes1;
    NET_DVR_QUERY_DDNS_RET    struQueryRet;    //地址信息
    WORD    wRegionID;        //当前设备注册区域编号[1美国,2南美,3亚太,4中国,5欧洲,6其它] 
    BYTE    byRes2[508];
}NET_DVR_CHECK_DDNS_RET,*LPNET_DVR_CHECK_DDNS_RET;

typedef struct tagNET_DVR_QUERY_IPSERVER_COND
{
    char    szResolveSvrAddr[MAX_DOMAIN_NAME];//解析服务器地址
    WORD    wResolveSvrPort;    //解析服务器端口
    char    szDevNickName[MAX_DOMAIN_NAME];    //设备在解析服务器上的别名
    char    szDevSerial[SERIALNO_LEN];    //设备序列号
    BYTE    byRes[334];        //保留
}NET_DVR_QUERY_IPSERVER_COND,*LPNET_DVR_QUERY_IPSERVER_COND;

typedef struct tagNET_DVR_QUERY_IPSERVER_RET
{
    char    szDevIP[SDK_MAX_IP_LEN];    //设备IP地址
    WORD    wCmdPort;        //控制端口（SDK连接端口）
    BYTE    byRes[462];
}NET_DVR_QUERY_IPSERVER_RET,*LPNET_DVR_QUERY_IPSERVER_RET;

typedef struct tagNET_DVR_CURRENT_VALID_PORT
{
    DWORD  dwSize;
    WORD   wHTTPPort;
    BYTE   byRes[122];
}NET_DVR_CURRENT_VALID_PORT,*LPNET_DVR_CURRENT_VALID_PORT;

typedef struct tagNET_DVR_AUDIO_CHANNEL
{
    DWORD  dwChannelNum;                //通道号
    BYTE   byres[32];                    //保留
}NET_DVR_AUDIO_CHANNEL, *LPNET_DVR_AUDIO_CHANNEL;






typedef struct tagNET_DVR_PARKING_CARD
{
    DWORD  dwSize;
    DWORD  dwChannel;//默认是1（后续兼容多通道设备）
    char  szCardNo[MAX_CARDNO_LEN/*48*/];//卡号
    BYTE  byCardType;//卡片类型 0-临时卡，1-固定卡
    BYTE  byCardStatus;//卡片状态 0-正常，1-挂失，2-注销
    BYTE  byChargeRuleID;//收费规则ID
    BYTE  byDelete;//是否删除 0-不删除，1-删除
    NET_DVR_TIME_V30 struStartTime;//有效开始时间
    NET_DVR_TIME_V30 struEndTime;//有效结束时间
    BYTE  byRes[128];
}NET_DVR_PARKING_CARD,*LPNET_DVR_PARKING_CARD;

typedef struct tagNET_DVR_GATE_CARDINFO
{
    DWORD     dwSize;
    NET_VCA_DEV_INFO struDevInfo;
    DWORD dwRelativeTime; //相对时标
    DWORD dwAbsTime; //绝对时标
    char    szCardNo[MAX_CARDNO_LEN/*48*/];//卡号
    char    szPassVehicleID[MAX_VEHICLE_ID_LEN];//唯一标识
    char    szInVehicleID[MAX_VEHICLE_ID_LEN];//出口时的入口唯一标识
    NET_DVR_TIME_V30  struSwipeTime;//刷卡时间
    NET_DVR_TIME_V30  struCardTime;//卡片存的时间，即入场时写入的时间，只对出口票箱有用，0表示无入场时间
    BYTE    byLetPass;//出入口放行方式 0-不放行(当CardType == 纸票)需要收费，1-放行，2-中心收费放行
    BYTE     byCardType;//卡类型 0-固定卡，1-临时卡，2-纸票
    BYTE    byRes[126];
}NET_DVR_GATE_CARDINFO, *LPNET_DVR_GATE_CARDINFO;

typedef struct _tagNET_LOADING_DOCK_OPERATEINFO_
{
    DWORD   dwSize; //结构长度
    BYTE    byAbsTime[32];        //绝对时间点,yyyymmddhhmmssxxx,e.g.20090810235959999  最后三位为毫秒数
    BYTE    byParkingNo[MAX_PARKNO_LEN/*16*/];//车位编号
    DWORD   dwIndex;          //车辆序号
    char    sLicense[MAX_LICENSE_LEN/*16*/];        //车牌号码,注：中东车牌需求把小字也纳入车牌号码，小字和车牌号中间用空格分隔
    BYTE    byCurrentWorkerNumber;//当前作业人数
    BYTE    byCurrentGoodsLoadingRate;//当前货物装载率 0-空 1-少 2-中 3-多 4-满
    BYTE    byDoorsStatus;//车门状态 0-车门关闭 1-车门开启
    BYTE    byRes1;    //保留字节
    DWORD   dwBackPicDataLength;//背景图片长度
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64)) //win64及linux64下指针为8字节
    BYTE    *pBackPicDataBuffer; //背景图片数据指针
#else
    BYTE*   pBackPicDataBuffer; // 背景图片数据指针
    BYTE  byRes2[4];
#endif 
    DWORD   dwChannel;          //通道号，0-不支持（存在老的设备不支持通道号返回）
    BYTE    byRes[508];
}NET_LOADING_DOCK_OPERATEINFO, *LPNET_LOADING_DOCK_OPERATEINFO;

typedef struct tagNET_DVR_GATE_CHARGEINFO
{
    DWORD dwSize;
    NET_VCA_DEV_INFO struDevInfo;
    DWORD dwRelativeTime; //相对时标
    DWORD dwAbsTime; //绝对时标
    char  sLicense[MAX_LICENSE_LEN];        //车牌
    char  szCardNo[48];
    NET_DVR_TIME_V30 struEntranceTime;
    NET_DVR_TIME_V30 struDepartureTime;
    char  szDepartureID[32];  //出场唯一过车标示
    char  szEntranceID[32];  //入场唯一过车标示
    DWORD dwTotalCost;   //实际收费金额*100
    char  szOperateName[32]; //脱机下为"offline"
    BYTE  byChargeRuleId; //收费规则centerId
    BYTE  byVehicleType;//车辆类型，0-其他车辆，1-小型车，2-大型车
    BYTE  byRes[127];//预留
}NET_DVR_GATE_CHARGEINFO,*LPNET_DVR_GATE_CHARGEINFO;

typedef struct tagNET_DVR_PARKING_CARD_CTRL_PARAM
{
    DWORD  dwSize;
    DWORD  dwChannel; //通道号
    BYTE  byCardType;//卡片类型 0-临时卡
    BYTE  byDeleteALL;//是否全部删除 0-不删除，1-删除
    BYTE  byRes[62];
}NET_DVR_PARKING_CARD_CTRL_PARAM,*LPNET_DVR_PARKING_CARD_CTRL_PARAM;

typedef struct tagNET_DVR_TME_VEHICLE_RESULT_
{
    DWORD   dwSize;
    WORD    wLaneid; //车道号1～32（索引车道号，可以跳跃）
    BYTE    byCamLaneId; //对应相机车道号1～16（相机配置的车道号，可以跳跃，可以相同）
    BYTE    byRes1; //保留
    DWORD   dwChanIndex; //通道号
    NET_DVR_PLATE_INFO  struPlateInfo; //车牌信息结构
    NET_DVR_VEHICLE_INFO struVehicleInfo; //车辆信息
    BYTE    byMonitoringSiteID[48]; //监测点编号
    BYTE    byDeviceID[48]; //设备编号
    BYTE    byDir;     //监测方向，0-其它 1 入场，2 出场 
    BYTE    byRes2; 
    WORD    wBackList; //标记为是否报警数据 0 表示为正常过车数据  1 表示禁止名单
    DWORD   dwPicNum; //图片数量（与picGroupNum不同，代表本条信息附带的图片数量，图片信息由struVehicleInfoEx定义 
    NET_ITS_PICTURE_INFO struPicInfo[4];  //图片信息,暂定最多4张图
    BYTE    byPassVehicleID[32];    //车辆唯一ID 
    BYTE    byCardNo[48]; // 卡号
    BYTE    bySwipeTime[32];//增加刷卡时间  时间格式为yyyymmddhh24missfff
    DWORD   dwCharge;      //收费金额 （分）
    BYTE    byHistory;     //是否是历史数据  0-否  1-是
    BYTE    byLetPass;     //是否已放行，0-未放行，1-放行  2-未知
    BYTE    byRes3[186];
} NET_DVR_TME_VEHICLE_RESULT, *LPNET_DVR_TME_VEHICLE_RESULT;

typedef struct tagNET_DVR_MVMRegisterInfo_
{
    DWORD  dwSize;         //结构体大小
    char   sDetectorID[16];   //检测器ID
    char   sManagerID[16];    //管理器ID
    char   sSim[20];       //卡号信息
    DWORD  dwLocalIP;      //本地IPv4地址，例如dwLocalIP=0x01020304,则IP地址为1.2.3.4
    DWORD  dwLocalIPMask;  //本地网络子网掩码，格式同dwLocalIP
    DWORD  dwLocalGateway; //本地网关，格式同dwLocalIP
    DWORD  dwDstIP;        //目标IP，格式同dwLocalIP
    BYTE   byMACAddr[6];   //本地mac地址
    WORD  wLocalPort;     //本地端口
    WORD  wFirmwareYear;  //软件版本年份
    BYTE   byFirmwareMonth;    //软件版本月份
    BYTE   byFirmwareDay;  //软件版本日
    BYTE   byMajorVersion; //版本小数点前
    BYTE   byMinorVersion; //版本小数点后
    BYTE   byRes[170];
}NET_DVR_MVMRegisterInfo, *LPNET_DVR_MVMRegisterInfo;

typedef struct tagNET_DVR_SingleMagneticStatus_
{
    DWORD  dwSize;             //结构体大小
    char   sDetectorID[16];       //检测器ID
    char   sManagerID[16];        //管理器ID
    char   sParkNum[16];       //车位编号
    NET_DVR_TIME_V30 struDetectorTime;  //检测时间
    DWORD  dwRssi;             //接收信号强度，实际值范围-137~0dbm，此处没有符号，为实际值的绝对值
    BYTE   byParkinglotState;  //车位状态，0-无车，1-有车
    BYTE   byBatteryState;     //电池状态，0-100%，1-75%，2-50%，3-25%，4-小于5%
    BYTE   byDeviceState;      //设备状态	0-正常，1-故障
    BYTE   byCMD;              //0-车位变化报警，1-检测器心跳报警
    BYTE   byRes[184];
}NET_DVR_SingleMagneticStatus, *LPNET_DVR_SingleMagneticStatus;

typedef struct tagNET_DVR_PARKING_VEHICLE
{
    DWORD   dwSize;
    DWORD   dwChannel;//默认是1（后续兼容多通道设备）
    char    szLicense[MAX_LICENSE_LEN/*16*/];//车牌号码
    char    szRelateCardNo[MAX_CARDNO_LEN/*48*/];//关联卡号
    NET_DVR_TIME_V30 struStartTime;//有效开始时间
    NET_DVR_TIME_V30 struEndTime;//有效结束时间
    BYTE    byVehicleType;//车辆类型：0-其他车辆，1-小型车，2-大型车
    BYTE    byPlateColor;//车牌颜色，参考 VCA_PLATE_COLOR
    BYTE    byRes[126];
}NET_DVR_PARKING_VEHICLE,*LPNET_DVR_PARKING_VEHICLE;







typedef struct tagNET_DVR_TME_CHARGERULE_COND
{
    DWORD   dwSize; 
    DWORD   dwChannel;  //通道号 
    char    szCardNo[32];//卡号
    BYTE    byRes[128];
}NET_DVR_TME_CHARGERULE_COND, *LPNET_DVR_TME_CHARGERULE_COND;






typedef struct NET_DVR_PARKING_DATASTATE_INFO
{
    DWORD   dwSize;
    char    szAppSerialNum [MAX_APP_SERIALNUM_LEN/*32*/];//应用序列号, 代表当前所连接的应用
    DWORD   dwParkingNum; //当前停车场号
    DWORD   dwUpdataSerialNum; //更新序列号; 代表最后更新的序列号。
    BYTE    byRes[256];
} NET_DVR_PARKING_DATASTATE_INFO,*LPNET_DVR_PARKING_DATASTATE_INFO;



typedef struct tagNET_DVR_FTPUPLOAD_PARAM
{
    char szRuleTypeItem[MAX_SINGLE_FTPPICNAME_LEN/*20*/];
    char szCameraName[MAX_CAMNAME_LEN/*32*/];
    BYTE byRes[64];
}NET_DVR_FTPUPLOAD_PARAM, *LPNET_DVR_FTPUPLOAD_PARAM;

typedef struct tagNET_DVR_FTPUPLOADCFG
{
    DWORD dwSize;
    BYTE byEventType; //事件类型，0-默认，1-车辆检测
    BYTE byMode; //图片命名模式，0-默认，1-自定义
    BYTE byRes[62];
    NET_DVR_FTPUPLOAD_PARAM  struCustomVehicle[MAX_FTPNAME_NUM/*12*/];
    BYTE byRes1[1024] ;
}NET_DVR_FTPUPLOADCFG, *LPNET_DVR_FTPUPLOADCFG;

typedef struct tagNET_DVR_PUBLISH_UPGRADE_COND
{
    DWORD dwSize;
    DWORD dwUpgradeType;    //升级类型，1-按终端升级，2-按终端组升级
    DWORD dwTerminalNum;    //升级的终端格式，按终端升级时有效
    DWORD *pTerminalNo;     //需要升级的终端号，按终端升级时有效
    DWORD dwGroupNo;        //终端组号，按终端组升级时有效
    BYTE  byRes[32];
}NET_DVR_PUBLISH_UPGRADE_COND, *LPNET_DVR_PUBLISH_UPGRADE_COND;

typedef struct tagNET_DVR_WEP_KEY_CFG
{
    char   csWEPKey[WEP_KEY_MAX_SIZE/*32*/];//加密密钥， 
    BYTE    byRes[64];
}NET_DVR_WEP_KEY_CFG, *LPNET_DVR_WEP_KEY_CFG;

typedef struct tagNET_DVR_SUB_UPGRADE_PROGRESS
{
    DWORD dwTerminalNo; //终端号
    DWORD dwProgress;   //终端升级进度，0-100，101表示此终端升级出现异常,,102-终端解压失败，103-升级包版本不匹配，104-非升级文件，105-非法签名升级包
}NET_DVR_SUB_UPGRADE_PROGRESS, *LPNET_DVR_SUB_UPGRADE_PROGRESS;

typedef struct tagNET_DVR_UPGRADE_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //主进度，0-100
    DWORD  dwSubProgressNum;    //子进度个数
    LPNET_DVR_SUB_UPGRADE_PROGRESS  lpStruSubProgress; //各终端升级的子进度，dwSubProgressNum个NET_DVR_SUB_UPGRADE_PROGRESS内容
    BYTE   byRes[32];
}NET_DVR_UPGRADE_PROGRESS_RESULT, *LPNET_DVR_UPGRADE_PROGRESS_RESULT;

typedef struct tagNET_DVR_SCHEDULE_PROGRESS_COND
{
    DWORD dwSize;
    DWORD dwScheduleNo;     //日程号
    BYTE  byProgressType;   //获取的进度类型，1-按组获取进度，2-按终端获取进度，3-按组织获取进度
    BYTE  byRes1[3];
    DWORD dwGroupNo;        //终端组号或组织，进度类型为1，3时有效
    DWORD dwTerminalNo;     //终端号，进度类型为2时有效
    BYTE  byRes2[32];
}NET_DVR_SCHEDULE_PROGRESS_COND, *LPNET_DVR_SCHEDULE_PROGRESS_COND;

typedef struct tagNET_DVR_SUB_SCHEDULE_PROGRESS
{
    DWORD dwTerminalNo; //终端号
    DWORD dwProgress;   //终端日程发布进度，0-100，101表示此终端日程发布出现异常,102表示此终端存储空间不足,103-终端不在线，104-终端拒绝，105-服务器和终端网络中断
}NET_DVR_SUB_SCHEDULE_PROGRESS, *LPNET_DVR_SUB_SCHEDULE_PROGRESS;

typedef struct tagNET_DVR_SCHEDULE_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //主进度，0-100，按组获取进度时为整组日程发布进度，按终端获取进度时为单个终端日程发布进度
    DWORD  dwSubProgressNum;    //子进度个数，按组获取时有效，表示组下各终端进度个数
    LPNET_DVR_SUB_SCHEDULE_PROGRESS  lpStruSubProgress; //各终端日程发布的子进度，按组获取时有效，dwSubProgressNum个NET_DVR_SUB_SCHEDULE_PROGRESS内容
    BYTE   byRes[32];
}NET_DVR_SCHEDULE_PROGRESS_RESULT, *LPNET_DVR_SCHEDULE_PROGRESS_RESULT;

typedef struct tagNET_DVR_INSERTPLAY_PROGRESS_COND
{
    DWORD dwSize;
    BYTE   byInsertType;    //插播类型，1-素材，2-节目
    BYTE   byRes3[3];
    DWORD dwInsertNo;        //如果插播类型是素材，为素材编号，如果插播类型是节目，为节目编号
    BYTE  byProgressType;   //获取的进度类型，1-按组获取进度，2-按终端获取进度
    BYTE  byRes1[3];
    DWORD dwGroupNo;        //终端组号，进度类型为1时有效
    DWORD dwTerminalNo;     //终端号，进度类型为2时有效
    BYTE  byRes2[32];
}NET_DVR_INSERTPLAY_PROGRESS_COND, *LPNET_DVR_INSERTPLAY_PROGRESS_COND;

typedef struct tagNET_DVR_SUB_INSERTPLAY_PROGRESS
{
    DWORD dwTerminalNo; //终端号
    DWORD dwProgress;   //终端插播进度，0-100，101表示此终端插播出现异常,102表示此终端存储空间不足,103表示取消插播,104插播素材被替换
}NET_DVR_SUB_INSERTPLAY_PROGRESS, *LPNET_DVR_SUB_INSERTPLAY_PROGRESS;

typedef struct tagNET_DVR_INSERTPLAY_PROGRESS_RESULT
{
    DWORD  dwSize;
    DWORD  dwMainProgress;      //主进度，0-100，按组获取进度时为整组插播进度，按终端获取进度时为单个终端插播进度
    DWORD  dwSubProgressNum;    //子进度个数，按组获取时有效，表示组下各终端进度个数
    LPNET_DVR_SUB_INSERTPLAY_PROGRESS  lpStruSubProgress; //各终端插播的子进度，按组获取时有效，dwSubProgressNum个NET_DVR_SUB_INSERTPLAY_PROGRESS内容
    BYTE   byRes[32];
}NET_DVR_INSERTPLAY_PROGRESS_RESULT, *LPNET_DVR_INSERTPLAY_PROGRESS_RESULT;

typedef struct tagNET_DVR_WEP_CFG
{
    BYTE   byAuthenticationType;//身份验证类型；0~开启验证；1~共享密钥；2~自动验证
    BYTE   byDefaultTransmitKeyIndex;//默认传输密钥个数，1~4个。对应到struEncryptionKeyCfg加密密钥的个数。
    /*
    当为64位密钥时，ASCII码密钥字符长度为5个。
    当为128位密钥时，ASCII码密钥字符长度为13个。
    */
    BYTE   byWepKeyLenType;//密钥类型；0~   64位密钥，1~  128位密钥。
    BYTE   byKeyType;// 密钥类型；0~   ASCII码，1~  16进制。
    NET_DVR_WEP_KEY_CFG struWEPKeyCfg[WEP_KEY_MAX_NUM/*4*/];// WEP加密密钥，最大支持4个。
    BYTE   byRes[128];
}NET_DVR_WEP_CFG, *LPNET_DVR_WEP_CFG;

typedef struct tagNET_DVR_WPA_CFG
{
    BYTE   byAlgorithmType; //算法类型；0~TKIP, 1~AES, 2~TKIP/AES
    BYTE   byWPAKeyLen;// WPA共享密钥长度，区间为8~63，对应到csSharedKey参数的字符长度
    BYTE   byDefaultPassword;//是否启用默认WPA密钥
    BYTE   byRes1;
    char   csSharedKey[WPA_KEY_MAX_SIZE/*64*/];//WPA共享密钥,为8-63个ASCII字符
    BYTE   byRes[128];
}NET_DVR_WPA_CFG, *LPNET_DVR_WPA_CFG;

typedef struct tagNET_DVR_WIRELESS_SECURITY_CFG
{
    BYTE   bySecurityMode; //安全模式；0~禁用,1~WEP,2~WPA-personal, 3~WPA2-personal
    NET_DVR_WEP_CFG  struWEPCfg; //当安全模式选择为WEP时生效。
    NET_DVR_WPA_CFG  struWPACfg; //当安全模式选择为WPA-personal、WPA2-personal时生效。
    BYTE    byRes[256];
} NET_DVR_WIRELESS_SECURITY_CFG,*LPNET_DVR_WIRELESS_SECURITY_CFG;

typedef struct tagNET_DVR_WIRELESSSERVER_FULLVERSION_CFG
{
    DWORD    dwSize;//结构体大小
    BYTE    byWifiAPEnabled;  //是否启用无线AP：0-否，1- 是
    BYTE    byBroadcastEnabled; // 是否启用广播，0-否，1-是
    BYTE    byWlanShareEnabled; //是否启用共享，0-否，1-是
    BYTE    byDHCPEnabled; //是否启用DHCP，0-否，1-是
    BYTE    bySSID[IW_ESSID_MAX_SIZE]; //SSID
    BYTE    byRes1[11];
    BYTE    byIPType; //IP地址类型，0-IPv4,1-IPv6
    NET_DVR_IPADDR    struIPAddr;  //IP地址
    NET_DVR_IPADDR    struIPMask;  //掩码地址
    NET_DVR_IPADDR    struGatewayIPMask;  //网关地址
    NET_DVR_IPADDR    struStartIPAddrPool;  //IP段起始地址
    NET_DVR_IPADDR    struEndIPAddrPool;  // IP段结束地址
    NET_DVR_IPADDR    struDNSServerIpAddr[MAX_DNS_SERVER_NUM]; //DNS地址
    NET_DVR_WIRELESS_SECURITY_CFG struWirelessSecurityCfg;//无线安全加密参数
    BYTE    byRes[256];
}NET_DVR_WIRELESSSERVER_FULLVERSION_CFG, *LPNET_DVR_WIRELESSSERVER_FULLVERSION_CFG;

typedef struct tagNET_DVR_OPTICAL_DEV_CHAN_INFO
{
    DWORD dwChannel;    //通道号，0为无效
    BYTE byChannelName[NAME_LEN];
    BYTE bySignal;  //是否有信号，0-无，1-有，只读
    BYTE bySignalType;  //信号源类型，1-标清，2-高清，有信号时有效，只读
    BYTE byRes[10];
}NET_DVR_OPTICAL_DEV_CHAN_INFO, *LPNET_DVR_OPTICAL_DEV_CHAN_INFO;

typedef struct tagNET_DVR_OPTICAL_DEV_NODE
{
    BYTE  byValid;    //是否有效，0-无效，1-有效
    BYTE  byRes1[3];
    DWORD dwDevNo;    //光端机号
    BYTE  byDevName[NAME_LEN];   //节点光端机名称
    BYTE  byDevID[MAX_ID_LEN];   //光端机物理ID，设备唯一标识，只读
    NET_DVR_OPTICAL_DEV_CHAN_INFO struChannel[MAX_CHANNUM];
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_DEV_NODE, *LPNET_DVR_OPTICAL_DEV_NODE;

typedef struct tagNET_DVR_OPTICAL_PORT_INFO
{
    DWORD dwSize;
    BYTE  byValid;   //是否有信号接入，0-无，1-有，只读
    BYTE  byLinkType;    //链路类型，1-环网，2-链网，只读
    BYTE  byPortWorkMode;    //端口工作模式，0-无效，1-主口，2-辅口，当链路类型为环网时有效，只读
    BYTE  byRes1[1];
    DWORD dwPairPort;    //配对光口号，链路类型为环网时有效，主口时此参数为辅口号，辅口时，此参数为主口号
    NET_DVR_OPTICAL_DEV_NODE struDevInfo[MAX_OPTICAL_DEV_NODE]; //节点光端机设备信息
    BYTE  byRes2[32];
}NET_DVR_OPTICAL_PORT_INFO, *LPNET_DVR_OPTICAL_PORT_INFO;

typedef struct tagNET_DVR_OPTICAL_CHAN_RELATE_CFG
{
    DWORD dwSize;
    BYTE  byEnable;    //是否关联光端机输入，0-否，非0-是
    BYTE  byRes1[3];
    DWORD dwDevNo;    //光端机号
    DWORD dwOpticalPort;  //光口号
    BYTE  byDevID[MAX_ID_LEN];   //光端机物理ID
    DWORD dwInputChanNo;  //光端机输入通道号
    BYTE  byRes2[64];
}NET_DVR_OPTICAL_CHAN_RELATE_CFG, *LPNET_DVR_OPTICAL_CHAN_RELATE_CFG;





typedef struct tagNET_DVR_ACS_EXTERNAL_DEV_CFG
{
    DWORD dwSize;
    BYTE byIDCardUpMode;  //身份证信息上报，0：上传18位身份证号；1：上传全部信息
    BYTE byRes1;
    BYTE byCardVerifyMode; //刷卡认证模式，0：远程中心认证；1：客户端平台认证；2：刷卡开门
    BYTE byACSDevType; //设备型号，1：身份证读卡器，2：IC读卡器，3：二维码读卡器，4：指纹读卡器，5：字符屏+二维码读卡器，6：收卡器，7：字符屏，8：指纹头，9：语音模块；10：人证设备
    BYTE byDoorMode; //门出入类型，0：进门，1：出门；
    BYTE byRes2;
    WORD wDevDetailType; //外设的具体设备型号，0-iDR210，1-IDM10，2-私有身份证阅读器
    BYTE byRes[300];
}NET_DVR_ACS_EXTERNAL_DEV_CFG, *LPNET_DVR_ACS_EXTERNAL_DEV_CFG;

typedef struct tagNET_DVR_PERSONNEL_CHANNEL_CFG
{
    DWORD dwSize;
    BYTE byInMode;            //进门模式，0受控；1禁止；2自由；
    BYTE byOutMode;         //出门模式，0受控；1禁止；2自由；
    BYTE byWorkMode;        //工作模式，0紧急；1维护；2常闭；3常开； 
    BYTE byRes[301];
}NET_DVR_PERSONNEL_CHANNEL_CFG, *LPNET_DVR_PERSONNEL_CHANNEL_CFG;

typedef struct tagNET_DVR_ID_CARD_INFO
{
    DWORD  dwSize;        //结构长度
    BYTE  byName[MAX_ID_NAME_LEN];   //姓名
    NET_DVR_DATE struBirth; //出生日期
    BYTE byAddr[MAX_ID_ADDR_LEN];  //住址
    BYTE byIDNum[MAX_ID_NUM_LEN];   //身份证号码
    BYTE byIssuingAuthority[MAX_ID_ISSUING_AUTHORITY_LEN];  //签发机关
    NET_DVR_DATE struStartDate;  //有效开始日期
    NET_DVR_DATE struEndDate;  //有效截止日期
    BYTE byTermOfValidity;  //是否长期有效， 0-否，1-是（有效截止日期无效）
    BYTE   bySex;  //性别，1-男，2-女
    BYTE  byNation;
    BYTE byRes[101];
}NET_DVR_ID_CARD_INFO, *LPNET_DVR_ID_CARD_INFO;

typedef struct tagNET_DVR_ID_CARD_INFO_ALARM
{
    DWORD  dwSize;        //结构长度
    NET_DVR_ID_CARD_INFO    struIDCardCfg ;//身份证信息
    DWORD dwMajor; //报警主类型，参考宏定义
    DWORD dwMinor; //报警次类型，参考宏定义
    NET_DVR_TIME_V30  struSwipeTime; //时间
    BYTE    byNetUser[MAX_NAMELEN] ;//网络操作的用户名
    NET_DVR_IPADDR    struRemoteHostAddr ;//远程主机地址
    DWORD dwCardReaderNo; //读卡器编号，为0无效
    DWORD dwDoorNo; //门编号，为0无效
    DWORD dwPicDataLen;   //图片数据大小，不为0是表示后面带数据
    char    *pPicData;
    BYTE byCardType; //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
    BYTE byDeviceNo;                             // 设备编号，为0时无效（有效范围1-255）
    BYTE byMask; //是否带口罩：0-保留，1-未知，2-不戴口罩，3-戴口罩
    BYTE byCurrentEvent; //是否为实时事件：0-无效，1-是（实时事件），2-否（离线事件）
    DWORD dwFingerPrintDataLen;                  // 指纹数据大小，不为0是表示后面带数据
    char *pFingerPrintData;
    DWORD dwCapturePicDataLen;                   // 抓拍图片数据大小，不为0是表示后面带数据
    char *pCapturePicData;
    DWORD dwCertificatePicDataLen;   //证件抓拍图片数据大小，不为0是表示后面带数据
    char    *pCertificatePicData;
    BYTE byCardReaderKind; //读卡器属于哪一类，0-无效，1-IC读卡器，2-身份证读卡器，3-二维码读卡器,4-指纹头
    BYTE byHelmet;//可选，是否戴安全帽：0-保留，1-未知，2-不戴安全, 3-戴安全帽
    BYTE byRes3;
    BYTE    byIDCardInfoExtend;    //pIDCardInfoExtend是否有效：0-无效，1-有效
    char    *pIDCardInfoExtend;    //byIDCardInfoExtend为1时，表示指向一个NET_DVR_ID_CARD_INFO_EXTEND结构体
    DWORD dwSerialNo; //事件流水号，为0无效
    BYTE byRes[168];
}NET_DVR_ID_CARD_INFO_ALARM, *LPNET_DVR_ID_CARD_INFO_ALARM;

typedef struct tagNET_DVR_ID_CARD_INFO_EXTEND
{
    BYTE byRemoteCheck; //是否需要远程核验（0-无效，1-不需要（默认），2-需要）
    BYTE byThermometryUnit; //测温单位（0-摄氏度（默认），1-华氏度，2-开尔文）
    BYTE byIsAbnomalTemperature; //人脸抓拍测温是否温度异常：1-是，0-否
    BYTE byRes2;
    float fCurrTemperature; //人脸温度（精确到小数点后一位）
    NET_VCA_POINT struRegionCoordinates; //人脸温度坐标
    DWORD dwQRCodeInfoLen; //二维码信息长度，不为0是表示后面带数据
    DWORD dwVisibleLightDataLen; //热成像相机可见光图片长度，不为0是表示后面带数据
    DWORD dwThermalDataLen; //热成像图片长度，不为0是表示后面带数据
    char *pQRCodeInfo; //二维码信息指针
    char *pVisibleLightData; //热成像相机可见光图片指针
    char *pThermalData; //热成像图片指针
    BYTE  byRes[1024];
}NET_DVR_ID_CARD_INFO_EXTEND, *LPNET_DVR_ID_CARD_INFO_EXTEND;

typedef struct tagNET_DVR_ID_CARD_BLOCKLIST_COND
{
    DWORD       dwSize;
    BYTE        byRes[256];          //保留
}NET_DVR_ID_CARD_BLOCKLIST_COND, *LPNET_DVR_ID_CARD_BLOCKLIST_COND;

typedef struct tagNET_DVR_ID_CARD_BLOCKLIST_CFG
{
    DWORD                     dwSize;
    NET_DVR_ID_CARD_INFO      struIDCardCfg;          // 身份证信息
    DWORD                     dwFingerPrintDataLen;   // 身份证指纹数据大小，不为0是表示后面带数据
    char                      *pFingerPrintData;
    DWORD                     dwPicDataLen;           // 身份证图片数据大小，不为0是表示后面带数据
    char                      *pPicData;
    BYTE                      byRes[128];
}NET_DVR_ID_CARD_BLOCKLIST_CFG, *LPNET_DVR_ID_CARD_BLOCKLIST_CFG;

typedef struct tagNET_DVR_PASSPORT_INFO
{
    DWORD  dwSize;           //结构长度
    BYTE    byOCR;             //0-电子护照数据，1- OCR识别数据，
    BYTE    byRes1[3];           //保留
    BYTE    byType[MAX_PASSPORT_TYPE_LEN];         //证件类型，数据类型A，S
    BYTE    byCountryIssue[MAX_PASSPORT_INFO_LEN];  //签发国或签发机构，数据类型A，S
    BYTE    byName[MAX_PASSPORT_NAME_LEN];       //姓名，数据类型A，S
    BYTE    byPassportNo[MAX_PASSPORT_NUM_LEN];    //证件号码，数据类型A，N，S
    BYTE    byNationality[MAX_NATIONALITY_LEN];    //国籍 ，数据类型A，S
    NET_DVR_DATE struBirth;       //出生日期
    NET_DVR_DATE struExpireDate;  //有效截止日期
    BYTE  bySex;                  //性别，1-男，2-女
    BYTE  byRes2[35];              //保留
    BYTE  byLocalName[MAX_PASSPORT_INFO_LEN];      //本国姓名，数据类型B
    BYTE  byNumber[MAX_PASSPORT_INFO_LEN];         //个人号码，数据类型A，N，S
    BYTE  byPlaceOfBirth[MAX_PASSPORT_INFO_LEN];     //出生地，数据类型B
    BYTE  byAddr[MAX_PASSPORT_INFO_LEN];           //地址，数据类型A，N，S，B
    BYTE  byPhone[MAX_PASSPORT_INFO_LEN];          //电话，数据类型N，S
    BYTE  byJob[MAX_PASSPORT_INFO_LEN];             //职业，数据类型B
    BYTE  byTitle[MAX_PASSPORT_INFO_LEN];            //职衔，数据类型B
    BYTE  byResume[MAX_PASSPORT_INFO_LEN];         //简历，数据类型B
    BYTE  byOtherNumber[MAX_PASSPORT_INFO_LEN];         //其他旅行证件号码，数据类型A，N，S，B
    BYTE  byMonitoring[MAX_PASSPORT_MONITOR_LEN];         //监护信息，数据类型B
    BYTE  byRes[128];
}NET_DVR_PASSPORT_INFO, *LPNET_DVR_PASSPORT_INFO;

typedef struct tagNET_DVR_PASSPORT_ALARM
{
    DWORD  dwSize;        //结构长度
    DWORD dwMajor; //报警主类型，参考宏定义
    DWORD dwMinor; //报警次类型，参考宏定义
    NET_DVR_TIME_V30  struSwipeTime; //时间
    BYTE	byNetUser[MAX_NAMELEN];//网络操作的用户名
    NET_DVR_IPADDR	struRemoteHostAddr;//远程主机地址
    DWORD dwCardReaderNo; //读卡器编号，为0无效
    BYTE  byCardType; //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，为0无效
    BYTE byRes2[11];
    NET_DVR_PASSPORT_INFO struPassportInfo;//护照信息
    DWORD dwFaceDataLen;     //人脸数据大小，不为0是表示后面带数据
    char    *pFaceData;
    DWORD dwPicDataLen;      //公民证件图片数据大小，不为0是表示后面带数据
    char    *pPicData;          //按照 [ISO/IEC 10918-1] 格式化的公民证件图像
    DWORD dwCapturePicDataLen;   //抓拍图片数据大小，不为0是表示后面带数据
    char    *pCapturePicData;
    BYTE byRes[128];
}NET_DVR_PASSPORT_ALARM, *LPNET_DVR_PASSPORT_ALARM;

typedef struct tagNET_DVR_PASSNUM_INFO_ALARM
{
    DWORD  dwSize;        //结构长度
    DWORD  dwAccessChannel;    //人员通道号
    NET_DVR_TIME_V30  struSwipeTime; //时间
    BYTE    byNetUser[MAX_NAMELEN] ;//网络操作的用户名
    NET_DVR_IPADDR    struRemoteHostAddr ;//远程主机地址
    DWORD    dwEntryTimes;    //人员入次数；
    DWORD    dwExitTimes;        //人员出次数；
    DWORD    dwTotalTimes;        //人员出入总次数； 
    BYTE byRes[300];
}NET_DVR_PASSNUM_INFO_ALARM, *LPNET_DVR_PASSNUM_INFO_ALARM;

typedef struct tagNET_DVR_UPLOAD_VIDEO_INFO
{
    DWORD   dwSize;
    DWORD   dwVideoMangeNo;  //视频管理号
    BYTE    byVideoType;  //视频格式 0-AVI 1-WMV 2-MP4 3-FLV 3-VOD 4-MKV 5-RMVB 
    BYTE    byRes1[3];  //保留
    BYTE    sVideoName[NAME_LEN];  //视频名称 
    NET_DVR_TIME_V30 struTime;  //图片上传时间
    BYTE     byRes[132];
} NET_DVR_UPLOAD_VIDEO_INFO, *LPNET_DVR_UPLOAD_VIDEO_INFO;

typedef struct tagNET_DVR_DEVICE_FILE_INFO
{
    DWORD   dwSize;
    BYTE    sFileName[NAME_LEN];  //文件名称
    DWORD    dwManageNo;     //(只能获取)
    NET_DVR_TIME_EX  struTime;    //文档上传时间 
    BYTE    byUsed;          //是否已存在，0-不存在，1-存在 （只能获取）
    BYTE    byRes[127];
} NET_DVR_DEVICE_FILE_INFO, *LPNET_DVR_DEVICE_FILE_INFO;

typedef struct  tagNET_DVR_PLAY_ITEM
{
    DWORD    dwSize;
    BYTE    byItemType;  //播放项类型，1-图片 2-视频 3-播放列表 
    BYTE    byRes[3];    //保留
    DWORD    dwPlayManageNo;   //播放管理号
    DWORD    dwPlayPicTime; //播放图片时间，单位秒, (类型为图片有效) 
    BYTE    byRes2[64]; 
} NET_DVR_PLAY_ITEM, *LPNET_DVR_PLAY_ITEM; 

typedef struct tagNET_DVR_DEVICE_PLAYLIST
{
    DWORD    dwSize;
    BYTE    byEnable;  //是否有效， 0-无效  !0-有效
    BYTE    byPlayType;  //播放模式，1-循环播放
    BYTE    byVaildItemNum;    //有效播放项数量
    BYTE    byRes[1]; 
    NET_DVR_PLAY_ITEM struPlayItem[PLAYLIST_ITEM_NUM]; //播放项，前byVaildItemNum有效
    BYTE     byPlaylistName[PLAYLIST_NAME_LEN];  //播放列表名称   
    DWORD   dwPlaylistNo;    //播放列表号（获取有效）
    BYTE     byRes2[128];
} NET_DVR_DEVICE_PLAYLIST, *LPNET_DVR_DEVICE_PLAYLIST;

typedef struct tagNET_DVR_PLAYLIST_ITEM_CTRL
{
    DWORD    dwSize;   
    BYTE    byCtrlType;  //操作类型， 1-添加播放项  2-删除播放项  3-移动播放项位置
    BYTE    byPlayIndex;  //播放序号， 从1开始
    NET_DVR_PLAY_ITEM struPlayItem;    //播放项
    BYTE   byNewPlayIndex;   //新播放序号，0无效
    BYTE   byRes[63]; 
}NET_DVR_PLAYLIST_ITEM_CTRL, *LPNET_DVR_PLAYLIST_ITEM_CTRL; 

typedef struct tagNET_DVR_PLAN_ITEM
{
    NET_DVR_PLAY_ITEM struPlanPlayItem;       //播放项    
    NET_DVR_TIME_SEGMENT struTimeSegment;     //时间段参数
    BYTE  byRes[16]; 
} NET_DVR_PLAN_ITEM, *LPNET_DVR_PLAN_ITEM;

typedef struct tagNET_DVR_PLAYPLAN_CFG
{
    DWORD    dwSize;   
    BYTE    byEnable;  //是否使能,  0-不使能 !0-使能
    BYTE    byPlanMode;   //计划模式，1-周计划  2-日计划
    BYTE    byRes[2];
    NET_DVR_PLAN_ITEM struPlanItem[MAX_DAYS][MAX_TIMESEGMENT_V30];
    DWORD    dwPlayPlanNo;   //播放计划号（获取时有效）
    BYTE    byPlayPlanName[NAME_LEN]; //播放计划名称
    BYTE    byRes2[32];
} NET_DVR_PLAYPLAN_CFG, *LPNET_DVR_PLAYPLAN_CFG;

typedef struct tagNET_DVR_WINDOW_PLAYPLAN_CFG
{
    DWORD dwSize;
    BYTE byEnable;    //是否启用播放计划， 0-不启用 !0-启用
    BYTE byRes[3];
    DWORD dwPlayPlanNo;   //播放计划号
    BYTE byRes2[32]; 
} NET_DVR_WINDOW_PLAYPLAN_CFG, *LPNET_DVR_WINDOW_PLAYPLAN_CFG; 

typedef struct tagNET_DVR_DEV_PLAYCTRL
{
    DWORD   dwSize;
    BYTE    byControlType;  //控制类型，1-音频开，2-音频关，3-停止播放，4-暂停播放，恢复播放 
    BYTE    byRes[131];
} NET_DVR_DEV_PLAYCTRL, *LPNET_DVR_DEV_PLAYCTRL;


typedef struct tagNET_DVR_PLAYING_INFO
{
    DWORD    dwSize;
    BYTE    byPlayWay;   //播放方式， 1-单项播放  2-播放列表  3-播放计划 4-动态解码 5-紧急插播
    BYTE    byCurPlayType; //正在播放素材类型， 1-图片 2-视频，动态解码和紧急插播时无效
    BYTE    byPlayState;    //播放状态，1-正在播放，2-播放停止，3-播放暂停
    BYTE    byAudioState;    //音频开关状态，0-关，1-开
    NET_DVR_PLAYITEM_INFO  struPlayItemInfo;  //播放项信息
    BYTE    byRes2[16];
} NET_DVR_PLAYING_INFO, *LPNET_DVR_PLAYING_INFO;

typedef struct tagNET_DVR_ONLINEUSER_COND //条件结构
{
    DWORD   dwSize; 
    DWORD  dwChannel;//通道号（前端默认是1）
    BYTE   byRes [128];
}NET_DVR_ONLINEUSER_COND,*LPNET_DVR_ONLINEUSER_COND;

typedef struct tagNET_DVR_ONLINEUSER_CFG //配置结构
{
    DWORD   dwSize; 
    BYTE   byID;//用户序列号
    BYTE   byUserType;//用户类型 0-普通用户，1-操作员，2-超级用户
    BYTE   byDataType;//数据状态类型:0-检测中，1-开始，2-结束
    BYTE   byRes;
    NET_DVR_IPADDR  struIpAddr;//IP地址    
    NET_DVR_TIME_V30  struLoginTime;//登陆时间
    char   szUserName[NAME_LEN/*32*/];//用户名
    BYTE   byRes1[128];
}NET_DVR_ONLINEUSER_CFG,*LPNET_DVR_ONLINEUSER_CFG;


typedef struct tagNET_DVR_STORAGE_DETECTION_ALARM
{
    DWORD   dwSize;
    DWORD     dwRelativeTime; //相对时标
    DWORD    dwAbsTime; //绝对时标
    NET_VCA_DEV_INFO  struDevInfo;   //前端设备信息
    DWORD   dwCardID;   //卡ID
    WORD    wAbnormalPowerLoss;//异常掉电数
    WORD    wBadBlocks;//坏块数
    BYTE    byHealthState;//健康状态0-良好，1-差，2-损坏，3-未知
    BYTE    byRes1[3];
    float   fResidualLife; //SD卡 预计剩余寿命
    BYTE    byRes[118];
}NET_DVR_STORAGE_DETECTION_ALARM,*LPNET_DVR_STORAGE_DETECTION_ALARM;




typedef struct tagNET_DVR_SOCKS_PROXY_PARA
{
    BYTE  byIP[129];  //代理服务器地址
    BYTE  byAuthType; //认证方式，暂时先不使用该字段 
    WORD  wPort;      //代理服务器端口
    BYTE  byRes2[64]; //如果要使用认证方式，必然需要一些保留字节，先留一些
}NET_DVR_SOCKS_PROXY_PARA, *LPNET_DVR_SOCKS_PROXY_PARA;

typedef struct tagNET_DVR_SOCKS_PROXYS
{
    NET_DVR_SOCKS_PROXY_PARA struProxy[MAX_PROXY_COUNT];
}NET_DVR_SOCKS_PROXYS, *LPNET_DVR_SOCKS_PROXYS;

typedef struct tagNET_DVR_GET_FIGURE_COND
{
    DWORD                     dwLength;         //结构长度
    DWORD                    dwChannel;         //通道
    NET_DVR_TIME_V30        struTimePoint;    //时间点
    BYTE  byID[STREAM_ID_LEN/*32*/];      //ID数据
    BYTE                      byRes[32];
}NET_DVR_GET_FIGURE_COND, *LPNET_DVR_GET_FIGURE_COND;

typedef struct tagNET_DVR_FIGURE_INFO
{
    DWORD   dwPicLen;     //图片长度
    char     *pPicBuf;     //图片数据
}NET_DVR_FIGURE_INFO, *LPNET_DVR_FIGURE_INFO;


typedef struct tagNET_DVR_VIDEO_INTERCOM_ALARM_CFG
{
    DWORD           dwSize;            //结构体大小
    BYTE           byDoorNotCloseAlarm;   //是否上传门未关报警，0-不上传，1-上传
    BYTE            byRes[603];         //保留
}NET_DVR_VIDEO_INTERCOM_ALARM_CFG, *LPNET_DVR_VIDEO_INTERCOM_ALARM_CFG;

typedef struct tagNET_DVR_PACKET_INFO_EX
{
    WORD     wWidth;         //width
    WORD     wHeight;        //height
    DWORD    dwTimeStamp;    //lower time stamp
    DWORD    dwTimeStampHigh;//higher time stamp 
    DWORD    dwYear;            //year
    DWORD    dwMonth;         //month
    DWORD    dwDay;           //day
    DWORD    dwHour;          //hour
    DWORD    dwMinute;        //minute
    DWORD    dwSecond;        //second
    DWORD    dwMillisecond;   //millisecond
    DWORD    dwFrameNum;     //frame num
    DWORD    dwFrameRate;    //frame rate,当帧率小于0时，0x80000002:表示1/2帧率，同理可推0x80000010为1/16帧率
    DWORD    dwFlag;         //flag E帧标记
    DWORD    dwFilePos;      //file pos
    DWORD     dwPacketType;    //Packet type:0 -file head，1 -video I frame，2- video B frame， 3- video P frame， 10- audio packet， 11- private packet
    DWORD     dwPacketSize;   //packet size
    unsigned char*    pPacketBuffer;  //packet buffer
    BYTE     byRes1[4];
    DWORD    dwPacketMode;   //打包方式:0-保留，1-FU_A打包方式
    BYTE     byRes2[16];
    DWORD    dwReserved[6];    //reserved[0] 表示私有数据类型 
    //reserved[1] 表示私有裸数据地址高位
    //reserved[2] 表示私有裸数据地址低位
    //reserved[3] 表示私有裸数据长度
    //reserved[4] 私有帧/包的时间间隔\时间戳
    //reserved[5].一bit位标记是否为深P帧，深P：1，不为深P：0;     lizhonghu 20150203
}NET_DVR_PACKET_INFO_EX, *LPNET_DVR_PACKET_INFO_EX;

typedef struct tagNetDVRCheckDevState
{
    DWORD                dwTimeout;      //定时检测设备工作状态，单位ms，为0时，表示使用默认值(30000)。最小值为1000
    DEV_WORK_STATE_CB    fnStateCB;
    void*                pUserData;
    BYTE                byRes[60];
}NET_DVR_CHECK_DEV_STATE,*LPNET_DVR_CHECK_DEV_STATE;


typedef struct  tagNET_DVR_COURSE_CFG
{
    DWORD            dwSize;
    NET_DVR_TIME_V30        struStartTime;   //课程开始时间
    NET_DVR_TIME_V30        struEndTime;   //课程开始时间
    BYTE            byCourseName[COURSE_NAME_LEN_128];
    BYTE            byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE            byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE            byRecUUID[MAX_UUID_LEN/*64*/];  //手动课表UUID
    BYTE           byCourseType;//课表类型，0-全部，1-手动课表
    BYTE            byRes[303];
}NET_DVR_COURSE_CFG, *LPNET_DVR_COURSE_CFG;

typedef struct tagNET_DVR_RECORD_STATUS
{
    DWORD       dwSize;              //结构体大小
    BYTE        byRecUUID[MAX_UUID_LEN/*64*/];  //手动课表UUID
    BYTE        byRecordStatus;         //录播状态，0-暂停，1-屏蔽,2-正在录像，3-空闲
    BYTE        byRes1[3];              //保留字节
    DWORD       dwRecordingTime;      //已录制时长，单位：秒，最大为12*60*60
    BYTE        byRes[596];              //保留字节 
}NET_DVR_RECORD_STATUS, *LPNET_DVR_RECORD_STATUS;

typedef struct tagNET_DVR_MANUAL_CURRICULUM_CFG
{
    DWORD       dwSize;              //结构体大小
    BYTE        byRecUUID[MAX_UUID_LEN/*64*/];  //手动课表UUID
    BYTE           byCourseName[COURSE_NAME_LEN_128];  //课程名称
    BYTE           byInstructorName[INSTRUCTOR_NAME_LEN_64]; //授课老师
    BYTE        byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE        byCmdType;            //命令，0-开始录像 1-结束 2-暂停 3-继续,4-开始屏蔽，5-结束屏蔽
    BYTE         byRes[303];              //保留字节
}NET_DVR_MANUAL_CURRICULUM_CFG, *LPNET_DVR_MANUAL_CURRICULUM_CFG;

typedef struct tagNET_DVR_IMAGE_DIFF_DETECTION_CFG
{
    DWORD       dwSize;              //结构体大小
    NET_VCA_POLYGON struRegion;    //区域范围
    BYTE       byEnabled;    //是否启用，0-不启用，1-启用
    BYTE        byThreshold;             //阈值[0,100]
    BYTE         bySensitivity;        //灵敏度 [0,100]
    BYTE        byVideoInputType;  //视频输入口类型，0-自动，1-HDMI，2-VGA
    BYTE     byRes[300];              //保留字节 
}NET_DVR_IMAGE_DIFF_DETECTION_CFG, *LPNET_DVR_IMAGE_DIFF_DETECTION_CFG;

typedef struct tagNET_DVR_RECORDING_PUBLISH_FILE_COND
{
    DWORD            dwSize;
    DWORD            dwChannel;
    BYTE             byFileID[MAX_ID_LEN_128/*128*/];  //发布文件ID
    BYTE             byRes[300];
}NET_DVR_RECORDING_PUBLISH_FILE_COND, *LPNET_DVR_RECORDING_PUBLISH_FILE_COND;

typedef struct tagNET_DVR_RECORDING_PUBLISH_FILE_INFO
{
    DWORD            dwSize;
    NET_DVR_TIME_V30        struStartTime;   //课程开始时间
    NET_DVR_TIME_V30        struEndTime;   //课程开始时间
    BYTE            byCourseName[COURSE_NAME_LEN_128];
    BYTE            byInstructorName[INSTRUCTOR_NAME_LEN_64];
    BYTE            byCourseDescription[COURSE_DESCRIPTION_LEN /*256*/];
    BYTE     byRes[300];              //保留字节 
}NET_DVR_RECORDING_PUBLISH_FILE_INFO, *LPNET_DVR_RECORDING_PUBLISH_FILE_INFO;

typedef struct tagNET_DVR_SCREEN_POINT
{
    WORD wX; //X坐标
    WORD wY; //Y坐标
}NET_DVR_SCREEN_POINT,*LPNET_DVR_SCREEN_POINT;

typedef struct tagNET_DVR_MOUSE_PARAM
{
    BYTE byMouseEvent;                   //鼠标事件，1-鼠标左键按下，2-鼠标左键松开，3-鼠标右键按下，4-鼠标右键松开，
                                         //5-鼠标移动，6-鼠标左键单击，7-鼠标左键双击，8-鼠标右键单击，9-滚轮按下，
                                         //10-滚轮松开，11-滚轮向下，12-滚轮向上
    BYTE byRes1[3];
    NET_DVR_SCREEN_POINT struMousePoint; //鼠标坐标信息
    BYTE byRes2[8];
}NET_DVR_MOUSE_PARAM, *LPNET_DVR_MOUSE_PARAM;

typedef struct tagNET_DVR_MARK_PARAM
{
    BYTE byMarkEvent;           //标注事件，1-正常标注，2-标注结束，3-更新标注工具状态
    BYTE byMarkTool;           //标注工具，0-无效，1-画笔，2-橡皮擦，标注事件为1时有效
    BYTE byLineWidth;          //线条粗细，0-无效，1-细，2-中，3-粗，标注事件为1时有效
    BYTE byMouseEvent;         //鼠标事件，标注事件为1时有效，0-无效，1-鼠标左键按下，2-鼠标左键松开，3-鼠标移动
    NET_DVR_RGB_COLOR struColor;    //标注颜色，标注工具为画笔时有效
    NET_DVR_SCREEN_POINT struPoint; //标注坐标信息
    BYTE byRes[4];
}NET_DVR_MARK_PARAM, *LPNET_DVR_MARK_PARAM;

typedef struct tagNET_DVR_KEYBOARD_PARM
{
    DWORD dwKeyValue; //符号使用ASCII表中的值，特殊按键待确定
    BYTE  byRes[12];
}NET_DVR_KEYBOARD_PARAM, *LPNET_DVR_KEYBOARD_PARAM;

typedef struct tagNET_DVR_PPT_PARAM
{
    BYTE  byPPTAction;              //PPT动作，1-打开放映，2-停止放映，3-上一个动画，4-下一个动画，
                                    //5-上一页，6-下一页，7-跳到X页，8-激光笔开，9-激光笔关，10-激光笔移动
    BYTE  byRes1[3];
    NET_DVR_SCREEN_POINT struPoint; //激光笔坐标信息，PPT动作为10时有效
    DWORD dwPPTNo;                  //PPT页码数，PPT动作为7时有效
    BYTE  byRes2[4];
}NET_DVR_PPT_PARAM, *LPNET_DVR_PPT_PARAM;

typedef struct tagNET_DVR_REMOTE_CTRL_PARAM
{
    BYTE byRemoteCtrlCmd;   //远程控制命令，1-切换置顶窗口，2-关闭屏幕当前窗口，3-打开文件，4-关闭文件，5-删除文件，6-关机，7-显示桌面，8-表扬
    BYTE byRes1[3];
    DWORD dwCtrlParam;    //操作参数，当byRemoteCtrlCmd为3、4、5时，表示操作的文件索引；当byRemoteCtrlCmd为8时表示表扬类型，0-无效，1-表扬
    BYTE byRes2[8];
}NET_DVR_REMOTE_CTRL_PARAM, *LPNET_DVR_REMOTE_CTRL_PARAM;

typedef struct tagNET_DVR_SPOTLIGHT_PARAM
{
    BYTE  byCmd;                    //聚光灯命令，0-关闭聚光灯，1-开启聚光灯，2-聚光灯位置移动
    BYTE  byRes1[3];
    NET_DVR_SCREEN_POINT struPoint; //聚光灯中心点坐标，聚光灯位置移动时有效
    DWORD dwRadius;                 //聚光灯半径
    BYTE  byRes2[4];
} NET_DVR_SPOTLIGHT_PARAM, *LPNET_DVR_SPOTLIGHT_PARAM;

typedef struct tagNET_DVR_TOUCHPAD_PARAM
{
    BYTE byMouseEvent;  //鼠标事件，1-鼠标左键按下，2-鼠标左键松开，3-鼠标右键按下，4-鼠标右键松开，
                        //5-鼠标移动，6-鼠标左键单击，7-鼠标左键双击，8-鼠标右键单击，9-滚轮按下，
                        //10-滚轮松开，11-滚轮向下，12-滚轮向上
    BYTE byRes1[3];
    int iXDisplacement; //X轴位移，正数表示向右移动，负数表示向左移动，鼠标移动时有效
    int iYDisplacement; //Y轴位移，正数表示向上移动，负数表示向下移动，鼠标移动时有效
    BYTE byRes2[4];
}NET_DVR_TOUCHPAD_PARAM, *LPNET_DVR_TOUCHPAD_PARAM;

typedef struct tagNET_DVR_MEDIA_LIST_PARAM
{
    BYTE byOperateCmd;     //操作命令，1-显示图片素材，2-显示视频素材，3-显示ppt素材，4-关闭多媒体文件夹
    BYTE byRes[15];
}NET_DVR_MEDIA_LIST_PARAM, *LPNET_DVR_MEDIA_LIST_PARAM;


typedef struct tagNET_DVR_SCREEN_CTRL_CMD
{
    DWORD dwSize;
    BYTE  byCmdType;                               //命令类型，1-鼠标，2-标注，3-键盘，4-PPT，5-远程操作，6-聚光灯，7-触控板，8-显示多媒体材料
    BYTE  byRes1[3];
    NET_DVR_SCREEN_CTRL_PARAM struScreenCtrlParam; //屏幕控制参数
}NET_DVR_SCREEN_CTRL_CMD, *LPNET_DVR_SCREEN_CTRL_CMD;

typedef struct tagNET_DVR_FILE_RESPONSE_PARAM
{
    BYTE byFileState;       //文件操作状态，1-文件不存在，2-打开文件失败，3-打开文件成功
    BYTE byRes1[3];
    DWORD dwErrorFileIndex; //文件操作的文件索引值
    BYTE byRes2[24];
} NET_DVR_FILE_RESPONSE_PARAM, *LPNET_DVR_FILE_RESPONSE_PARAM;

typedef struct tagNET_DVR_PPT_RESPONSE_PARAM
{
    BYTE  byCurrentState;   //当前PPT状态，1 - 正在放映，2 - 放映停止，3 - PPT已关闭，4 - ppt受保护或生产预览图失败，5 - 打开放映成功，6 - 打开放映失败，7 - ppt内容为空，8 - 缩略图生成失败，9 - 缩略图生成成功
    BYTE  byRes1[3];
    DWORD dwCurrentPage;    //PPT的页数，PPT状态为1,7,8时有效
    DWORD dwFileIndex;        //PPT文件索引值
    DWORD dwTotalPageNum;    //PPT总页数，PPT状态为5时有效
    BYTE  byRes2[16];
}NET_DVR_PPT_RESPONSE_PARAM, *LPNET_DVR_PPT_RESPONSE_PARAM;


typedef struct tagNET_DVR_SCREEN_RESPONSE_CMD
{
    DWORD dwSize;
    BYTE  byResponseCmd; //屏幕响应命令类型，1-PPT，2-文件操作
    BYTE  byRes1[3];
    NET_DVR_SCREEN_RESPONSE_PARAM struResonseParam; //屏幕响应参数
    BYTE  byRes2[16];
}NET_DVR_SCREEN_RESPONSE_CMD, *LPNET_DVR_SCREEN_RESPONSE_CMD;

typedef struct tagNET_DVR_SCREEN_FILE_COND
{
    DWORD dwSize;
    BYTE  byFileType; //文件类型，1-图片，2-视频，3-文档，0xff-所有文件类型
    BYTE  byRes[127];
}NET_DVR_SCREEN_FILE_COND, *LPNET_DVR_SCREEN_FILE_COND;

typedef struct tagNET_DVR_SCREEN_FILE_INFO
{
    DWORD dwSize;
    DWORD dwFileIndex;     //文件索引，全局唯一
    BYTE  byFileType;      //文件类型，1-图片，2-视频，3-文档，4-其他
    BYTE  byPictureFormat; //图片格式，文件类型为图片时有效，1-bmp,2-jpeg,3-png,4-swf,5-gif 
    BYTE  byVideoFormat;   //视频格式，文件类型为视频时有效，1-avi,2-wmv,3-mp4,4-flv,5-vod,6-mkv,7-rmvb
    BYTE  byDocumentFormat; //文档格式，0-ppt，1-txt，2-doc，3-xls，文件类型为3时有效
    BYTE  byFileName[NET_SDK_MAX_FILE_PATH]; //屏幕文件名
    DWORD dwFileSize;     //文件大小，单位：字节
    DWORD dwPPTPage;      //ppt页码值，仅当获取已打开的PPT文件信息时有效
    BYTE byOtherFileFormat[8]; //其他类型的文件的格式（例如.dat、.dll等），文件类型为4时有效
    BYTE byRes1[56];
}NET_DVR_SCREEN_FILE_INFO, *LPNET_DVR_SCREEN_FILE_INFO;

typedef struct tagNET_DVR_SCREEN_CONFIG
{
    DWORD dwSize;
    BYTE  byVolume;             //音量，0-100
    BYTE  byContrast;           //对比度，0-100
    BYTE  byBrightness;         //亮度，0-100
    BYTE  byScreenShowEnabled;  //开启屏幕显示，0-关，非0-开
    BYTE  byScreenLocked;       //锁定屏幕，0-解锁，非0-锁定
    BYTE  byBlackScreenEnabled; //屏幕黑屏，0-取消黑屏，非0-黑屏
    BYTE  byRes[30];
}NET_DVR_SCREEN_CONFIG, *LPNET_DVR_SCREEN_CONFIG;

typedef struct tagNET_DVR_SCREEM_FILE_UPLOAD_PARAM
{
    DWORD dwSize;
    BYTE  byFileType;      //文件类型，1-图片，2-视频，3-文档，4-其他
    BYTE  byPictureFormat; //图片格式，1-BMP，2-JPEG，3-PNG，4-SWF，5-GIF，文件类型为1时有效
    BYTE  byVideoFormat;   //视频格式，1-AVI，2-WMV，3-MP4，4-FLV，5-VOD，6-MKV，7-RMVB，文件类型为2时有效
    BYTE  byDocumentFormat; //文档格式，0-ppt，1-txt，2-doc，3-xls，文件类型为3时有效
    BYTE  byFileName[NET_SDK_MAX_FILE_PATH]; //文件名称
    BYTE  byOtherFileFormat[8]; //其他类型的文件的格式（例如.dat、.dll等），文件类型为4时有效
    BYTE  byRes1[56];
}NET_DVR_SCREEM_FILE_UPLOAD_PARAM, *LPNET_DVR_SCREEM_FILE_UPLOAD_PARAM;

typedef struct tagNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM
{
    DWORD dwSize;
    DWORD dwFileIndex;  //文件索引
    DWORD dwPPTPageNo;  //下载PPT页面图片时有效，为0表示下载PPT本身，其他值表示PPT页码值
    BYTE  byRes2[64];
}NET_DVR_SCREEM_FILE_DOWNLOAD_PARAM, *LPNET_DVR_SCREEM_FILE_DOWNLOAD_PARAM;

typedef struct tagNET_DVR_TV_SCREEN_COND
{
    DWORD  dwSize;//结构长度
    DWORD    dwChannel;//通道号
    WORD    wTVScreenNo;//导播屏编号 0-全部导播屏
    BYTE     byRes[62];     //保留
}NET_DVR_TV_SCREEN_COND, *LPNET_DVR_TV_SCREEN_COND;

typedef struct tagNET_DVR_TV_SCREEN_CFG
{
    DWORD    dwSize;//结构长度
    DWORD    dwPicStayTime;//画面停留时间 （0~255s）
    BYTE     byRes[256];     //保留
}NET_DVR_TV_SCREEN_CFG, *LPNET_DVR_TV_SCREEN_CFG;

typedef struct tagNET_DVR_BV_CALIB_COND
{
    DWORD  dwSize;  //结构长度
    DWORD dwChannels;  //通道号
    BYTE  byRes[300]; //保留
}NET_DVR_BV_CALIB_COND, *LPNET_DVR_BV_CALIB_COND;

typedef struct tagNET_DVR_BV_CALIB_PIC
{
    DWORD  dwSize;  //结构长度
    DWORD  dwPicID;
    DWORD dwPicLen1;//图片1长度
    DWORD dwPicLen2;//图片2长度
    char*   pPicBuffer1;//图片缓存
    char*   pPicBuffer2;//图片缓存
    BYTE  byRes[600]; //保留
}NET_DVR_BV_CALIB_PIC, *LPNET_DVR_BV_CALIB_PIC;

typedef struct tagNET_DVR_BV_CALIB_PARAM
{
    DWORD  dwPicID;
    NET_VCA_POINT struPoint;//眉心坐标
    BYTE  byRes[32]; //保留
}NET_DVR_BV_CALIB_PARAM, *LPNET_DVR_BV_CALIB_PARAM;

typedef struct tagNET_DVR_BV_CALIB_INFO
{
    DWORD  dwSize;  //结构长度
    DWORD  dwBVCalibNumber; //样本个数
    NET_DVR_BV_CALIB_PARAM struBVCalibParam[12];
    DWORD  dwHumanHeight;  //人体真实身高，单位cm
    DWORD  dwChannel;  //通道号
    BYTE  byRes[300]; //保留
}NET_DVR_BV_CALIB_INFO, *LPNET_DVR_BV_CALIB_INFO;

typedef struct tagNET_DVR_BV_CALIB_RESULT
{
    DWORD  dwSize;  //结构长度
    DWORD dwCameraHeight;  //摄像机高度，单位cm
    float fPitchAngle;    //摄像机俯视角度[0°, 60°], （浮点数 + 360）* 1000
    float fInclineAngle;   //摄像机斜角度[-20°,20°]，（浮点数 + 360） * 1000
    BYTE  byRes[300]; //保留
}NET_DVR_BV_CALIB_RESULT, *LPNET_DVR_BV_CALIB_RESULT;

typedef struct tagNET_DVR_BV_HCORRECTION_COND
{
    DWORD  dwSize;  //结构长度
    DWORD dwChannels;  //通道号
    DWORD  dwPicID;
    BYTE  byRes[300]; //保留
}NET_DVR_BV_HCORRECTION_COND, *LPNET_DVR_BV_HCORRECTION_COND;

typedef struct tagNET_DVR_BV_HCORRECTION_CFG
{
    DWORD  dwSize;  //结构长度
    DWORD  dwHumanHeight;  //人体真实身高，单位cm
    BYTE  byRes[300]; //保留
}NET_DVR_BV_HCORRECTION_CFG, *LPNET_DVR_BV_HCORRECTION_CFG;


typedef struct tagNET_DVR_INPUT_BOARD_CFG
{
    DWORD    dwSize;
    DWORD    dwSlotNo;           //输入板槽位号
    BYTE    byFullFrameEnable;  //是否开启全帧率畅显，0-不开启，1-开启
    BYTE    byRes[3];           //四字节对齐
    BYTE    byRes1[64];         //保留
}NET_DVR_INPUT_BOARD_CFG, *LPNET_DVR_INPUT_BOARD_CFG;

typedef struct tagNET_DVR_INPUT_BOARD_CFG_LIST
{
    DWORD    dwSize;
    NET_DVR_INPUT_BOARD_CFG struBoardList[MAX_NUM_INPUT_BOARD]; //输入板配置信息列表
}NET_DVR_INPUT_BOARD_CFG_LIST, *LPNET_DVR_INPUT_BOARD_CFG_LIST;

typedef struct _NET_DVR_ENCRYPT_DEVICE_COND
{
    DWORD  dwSize;     //结构体大小
    DWORD  dwChannel;     //通道号
    BYTE   byAlgorithm; //加密算法，0-保留，1-RSA,2-SM2
    BYTE   byModelLen; //模长，0-保留，1-1024位,2-2048位,3-256位
    BYTE   byCERTSaveLocation; //证书保存位置，根据设备返回的能力集来选择，0-保留，1-加密芯片中(通过USB插入设备),2-设备中
    BYTE   byRes[29];
}NET_DVR_ENCRYPT_DEVICE_COND, *LPNET_DVR_ENCRYPT_DEVICE_COND;

typedef struct _NET_DVR_ENCRYPT_DEVICE_INFO
{
    DWORD  dwSize;     //结构体大小
    BYTE   byAlgorithm; //加密算法，0-保留，1-RSA,2-SM2
    BYTE   byModelLen; //模长，0-保留，1-1024位,2-2048位,3-256位
    BYTE   byRes1[30];  //保留
    DWORD  dwPublicKeyLen;        //公钥长度
    char   szPublicKey[MAX_PUBLIC_KEY_LEN];       //公钥 
    char   szChipSerialNumber[CHIP_SERIALNO_LEN];   //芯片序列号
    char   szDeviceID[ENCRYPT_DEV_ID_LEN];     //设备ID
    BYTE   byRes2[128];
}NET_DVR_ENCRYPT_DEVICE_INFO, *LPNET_DVR_ENCRYPT_DEVICE_INFO;

typedef struct _NET_DVR_ENCRYPT_CERT_PARAM
{
    DWORD dwSize;
    WORD wCertType; //证书类型，0-CA根证书，1-签名证书,2-加密证书，3- SM2加密密钥对
    BYTE byRes1[2]; //保留
    DWORD dwCertLen; //证书长度
    BYTE  byRes2[32]; 
    char* pCertBuf;  //证书缓冲区
}NET_DVR_ENCRYPT_CERT_PARAM, *LPNET_DVR_ENCRYPT_CERT_PARAM;

typedef struct tagNET_DVR_RING_UPLOAD_CFG
{
    DWORD        dwSize;
    DWORD        dwRingID; //铃音序号，[1,8]
    BYTE     byRingName[MAX_RING_NAME_LEN_128/*128*/];   //铃音名称
    DWORD     dwRingSize;   //文件大小
    BYTE        byRingType;   //铃音类型，0-wav
    BYTE        byRes[363];
}NET_DVR_RING_UPLOAD_CFG,*LPNET_DVR_RING_UPLOAD_CFG;

typedef struct tagNET_DVR_RING_SEARCH_COND
{
    DWORD        dwSize;
    DWORD        dwRingID; //铃音序号，傻瓜式查找，不设置此参数（设为0）表示无视序号查找
    BYTE        byRes[300];
}NET_DVR_RING_SEARCH_COND,*LPNET_DVR_RING_SEARCH_COND;

typedef struct tagNET_DVR_RING_SEARCH_CFG
{
    DWORD        dwSize;
    DWORD        dwRingID; //铃音序号，[1,8]
    BYTE     byRingName[MAX_RING_NAME_LEN_128/*128*/];   //铃音名称
    DWORD     dwRingSize;   //文件大小
    BYTE        byRingType;   //铃音类型，0-wav
    BYTE        byRes[303];
}NET_DVR_RING_SEARCH_CFG,*LPNET_DVR_RING_SEARCH_CFG;

typedef struct tagNET_DVR_ALARMCTRL_CFG
{
    DWORD   dwSize;
    BYTE    byListenPicUploadEnabled;//监听图片上传使能
    BYTE    byRes [259];
}NET_DVR_ALARMCTRL_CFG,*LPNET_DVR_ALARMCTRL_CFG;

typedef struct tagNET_DVR_VEHICLEFLOW_COND
{
    DWORD dwSize;
    DWORD dwChannel;//通道号
    BYTE   byLane;//车道号，1~6车道,0为所有车道。
    BYTE   byRes1[3];
    NET_DVR_TIME_V30 struStartTime;//开始时间
    NET_DVR_TIME_V30 struEndTime;//结束时间
    BYTE   byRes[256];
}NET_DVR_VEHICLEFLOW_COND, *LPNET_DVR_VEHICLEFLOW_COND;

typedef struct tagNET_DVR_VEHICLEFLOW_INFO
{
    DWORD dwVehicleFlowValue;//为一个时间段内的流量
    BYTE   byRes[64];
}NET_DVR_VEHICLEFLOW_INFO, *LPNET_DVR_VEHICLEFLOW_INFO;

typedef struct tagNET_DVR_VEHICLEFLOW_CFG
{
    DWORD dwSize;
    NET_DVR_VEHICLEFLOW_INFO struVehFlow[MAX_VEHICLEFLOW_INFO/*24*/];
    BYTE   byRes[512];
}NET_DVR_VEHICLEFLOW_CFG, *LPNET_DVR_VEHICLEFLOW_CFG;

typedef struct tagNET_DVR_IPADDR_FILTER_COND
{
    DWORD dwSize;
    DWORD dwChannel;//通道号
    BYTE  byRes[64];
}NET_DVR_IPADDR_FILTER_COND, *LPNET_DVR_IPADDR_FILTER_COND;


typedef struct tagNET_DVR_POSTRADARSPEED_CFG
{
    DWORD   dwSize;//结构体大小
    BYTE    byLaneType; //道路类型；0~未配置,1~高速公路,2~城市快速路,0xff~其他道路
    BYTE    byRes1[3];
    DWORD   dwInterval; //超速抓拍间隔，单位：ms
    DWORD   dwSignSpeed;//标志限速(小车)，单位km/h
    DWORD   dwSpeedLimit;//限速值(小车)，单位km/h
    DWORD   dwBigCarSignSpeed;//标志限速(大车)，单位km/h
    DWORD   dwBigCarSpeedLimit;//限速值（大车），单位km/h
    DWORD   dwLowSpeedLimit;// 小车限低速，单位km/h
    DWORD   dwBigCarLowSpeedLimit;// 大车限低速，单位km/h
    BYTE    byCheckPostEnabled; //启用卡口抓拍
    BYTE    byOverSpeedEnabled; //启用超速抓拍
    BYTE    byRes[246];
}NET_DVR_POSTRADARSPEED_CFG, *LPNET_DVR_POSTRADARSPEED_CFG;

typedef struct tagNET_DVR_POSTRADARPARAM_CFG
{
    DWORD   dwSize;//结构体大小
    BYTE    bySoftWareVersion[32];//软件版本号 只读参数
    BYTE    byID; //串口号
    BYTE    byWorkMode; //工作模式，0~持续,1~触头,2~触尾,3~巡逻车触尾,4~双触,0xff~其他
    BYTE    bySpeedType; //速度格式，0~单字节,1~双字节,2~四字节,0xff~其他
    BYTE    byDirectionFilter; //方向过滤，0~不过滤,1~输出来向,2~输出去向
    DWORD   dwAngleCorrect;//角度修正[0,70]
    DWORD   dwSensitivity;// 灵敏度[11,240]
    DWORD   dwSpeedLowLimit;// 测速下限[1,150km/h]
    DWORD   dwTrigDistance;// 触发距离[0,40m]
    BYTE    byRes[256];
}NET_DVR_POSTRADARPARAM_CFG, *LPNET_DVR_POSTRADARPARAM_CFG;

typedef struct tagNET_DVR_CLOUD_URL_COND
{
    DWORD   dwSize;
    BYTE    byType;     //云类型0-保留，1- OneDrive  2-GoogleDrive 3-DropBox
    BYTE    byRes[63];
}NET_DVR_CLOUD_URL_COND, *LPNET_DVR_CLOUD_URL_COND;

typedef struct tagNET_DVR_CLOUD_URL
{
    DWORD   dwSize;
    char    szURL[256]; //云存储URL
    BYTE    byRes[256];
}NET_DVR_CLOUD_URL, *LPNET_DVR_CLOUD_URL;

typedef struct tagNET_DVR_CLOUD_CFG
{
    DWORD    dwSize;
    BYTE    byEnable;    //0-不开启，1-开启
    BYTE    byType;        //云类型0-保留，1- OneDrive  2-GoogleDrive 3-DropBox
    BYTE    byStatus;    //状态，只读 0-保留 1-在线 2-不在线
    BYTE    byRes1;
    char    szAuthCode[CODE_LEN]; //授权码
    char    szAlias[ALIAS_LEN];    //别名，只读
    INT64    i64TotalCapability;            //总容量，只读，单位：MB
    INT64    i64UsedSpace;                //已用容量，只读，单位：MB
    BYTE    byRes2[256];
}NET_DVR_CLOUD_CFG, *LPNET_DVR_CLOUD_CFG;

typedef struct tagNET_DVR_CLOUD_UPLOADSTRATEGY_COND
{
    DWORD    dwSize;
    DWORD    dwChannel;    //通道号
    BYTE    byRes[254];    //为将来使用流ID做保留
}NET_DVR_CLOUD_UPLOADSTRATEGY_COND, *LPNET_DVR_CLOUD_UPLOADSTRATEGY_COND;

typedef struct tagNET_DVR_CLOUD_UPLOADSTRATEGY
{
    DWORD      dwSize;
    BYTE    byStrategyType;    //策略类型0-无意义，1-录像，2-图片
    BYTE    byRes1[3];
    DWORD    dwRecordType;    //策略类型byStrategyType 为1时有效，按位表示
    /*0x00: 无意义*/
    /*0x01: 全部事件*/
    /*0x02: 移动侦测*/
    /*0x04: 信号量报警类型*/
    /*0x08: 智能类型*/
    BYTE    byRes[256];
}NET_DVR_CLOUD_UPLOADSTRATEGY, *LPNET_DVR_CLOUD_UPLOADSTRATEGY;






typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    BYTE    byType;     //获取方式,0--获取全部剩余任务，1--根据流ID获取剩余任务, 2--获取全部任务，3--根据流ID获取任务，4—根据任务ID获取任务
    BYTE    byTimeSegmentQuety; //是否启用时间范围查询，0-不启用，1-启用
    BYTE    byRes1[2];  //保留
    NET_DVR_STREAM_INFO    struStreamInfo; //流id信息（72字节），根据流ID获取剩余任务时有效
    NET_DVR_TIME_EX struBeginTime;      //查询开始时间，byTimeSegmentQuety启用时有效
    NET_DVR_TIME_EX struEndTime;        //查询结束时间，byTimeSegmentQuety启用时有效
    DWORD dwTaskID;        //任务ID, byType等于4时有效
    BYTE    byRes[108];                //保留
}NET_DVR_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_RECORD_PASSBACK_MANUAL_COND;

typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET
{
    DWORD        dwSize;
    NET_DVR_STREAM_INFO    struStreamInfo;    //流id信息（72字节），根据流ID获取剩余任务时有效
    DWORD        dwTaskID;        //任务ID
    NET_DVR_TIME_EX    struStartTime;  //回传的录像开始时间
    NET_DVR_TIME_EX    struStopTime;   //回传的录像结束时间
    BYTE        byTaskStatus;    //任务状态，0--未执行，1--暂停中，2--已执行, 3--回传中, 4--回传失败, 5--执行成功，但只回传了部分录像, 6--执行成功，但前端无录像
    BYTE        byRes1[3];
    NET_DVR_TIME_EX    struExecuteStartTime;//任务实际执行开始时间，byTaskStatus为1和2有效
    NET_DVR_TIME_EX    struExecuteStopTime;//任务实际执行结束时间，byTaskStatus为2有效
    BYTE        byRes[128];        //保留
}NET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET, *LPNET_DVR_RECORD_PASSBACK_MANUAL_TASK_RET;

typedef struct tagNET_DVR_RECORD_PASSBACK_MANUAL_CTRL
{
    DWORD    dwSize;
    BYTE    byControlType;    //控制方式,0--暂停所有手动任务，1--恢复所有手动任务
    BYTE    byRes[131];        //保留
}NET_DVR_RECORD_PASSBACK_MANUAL_CTRL, *LPNET_DVR_RECORD_PASSBACK_MANUAL_CTRL;

typedef struct tagNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND
{
    DWORD    dwSize;
    BYTE    byDelType;    //删除方式,0--根据任务ID删除，1--根据流ID删除任务，2--删除全部任务
    BYTE    byRes[131];    //保留
}NET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND, *LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_COND;

typedef struct tagNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG
{
    DWORD    dwSize;
    DWORD    dwTaskID;    //手动回传任务ID，根据任务ID删除任务时有效
    NET_DVR_STREAM_INFO    struStreamInfo;    //流id信息（72字节），根据流ID删除任务时有效
    BYTE    byRes[128];    //保留
}NET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG, *LPNET_DVR_DEL_RECORD_PASSBACK_MANUAL_CFG;

typedef struct tagNET_DVR_PASSBACK_DAY
{
    BYTE    byAllDay;    //是否启用全天回传
    BYTE    byRes[3];    //保留
}NET_DVR_PASSBACK_DAY, *LPNET_DVR_PASSBACK_DAY;

typedef struct tagNET_DVR_PASSBACK_SCHED
{
    NET_DVR_SCHEDTIME    struPassBackTime;    //回传任务时间段，开始时间-结束时间
    BYTE        byRes[4];        //保留
}NET_DVR_PASSBACK_SCHED, *LPNET_DVR_PASSBACK_SCHED;

typedef struct tagNET_DVR_RECORD_PASSBACK_SCH_CFG_
{
    DWORD    dwSize;
    BYTE    byEnable;        //是否启用，0--不启用，1--启用
    BYTE    byPassBackWeek;    //是否按周回传，0--否，1--是，值为1时struPassBackDay、struPassBackSched无效
    BYTE    byRes1[2];            //保留
    NET_DVR_PASSBACK_DAY    struPassBackDay[MAX_DAYS];  //全天回传计划
    NET_DVR_PASSBACK_SCHED    struPassBackSched[MAX_DAYS][MAX_TIMESEGMENT_V30];    //时间段回传计划
    BYTE   byRes[128];        //保留
}NET_DVR_RECORD_PASSBACK_SCH_CFG, *LPNET_DVR_RECORD_PASSBACK_SCH_CFG;

typedef struct tagNET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG_
{
    DWORD    dwSize;    //版本头
    BYTE    byEnable;        //是否启用，0--不启用，1--启用
    BYTE    byRes1[3];            //保留
    NET_DVR_PASSBACK_DAY        struPassBackDay[MAX_DAYS];  //全天回传计划
    NET_DVR_PASSBACK_SCHED    struPassBackSched[MAX_DAYS][MAX_TIMESEGMENT_V30];    //时间段回传计划
    BYTE   byRes[256];        //保留
}NET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG, *LPNET_DVR_RECORD_PASSBACK_HISTORY_PLAN_CFG;

typedef struct tagNET_DVR_DEV_STORAGE_CFG
{
    DWORD    dwSize;
    DWORD    dwCapacityTotal;        //设备存储(CVR表示录像卷)总容量(只读)，单位MB
    DWORD    dwFreeSpaceTotal;        //设备存储(CVR表示录像卷)剩余总空间(只读)，单位MB
    DWORD    dwLockedRecordSpace;    //设备已加锁录像存储(CVR表示录像卷)总容量(只读)，单位MB
    DWORD    dwUnLockedSpace;        //设备未加锁存储(CVR表示录像卷)总容量(只读),包含未加锁录像和剩余存储空间，单位MB
    BYTE    byRes[512];                //保留
}NET_DVR_DEV_STORAGE_CFG, *LPNET_DVR_DEV_STORAGE_CFG;

typedef struct tagNET_DVR_ONE_KEY_CFG_V50
{
    DWORD   dwSize;//结构体大小
    BYTE    byRaidType;   //RAID类型：0-raid5,1-raid6,2-raid95（Vraid）,3-单盘模式，即不创建raid
    BYTE    bySpareRaidProportion;   //热备盘：raid（阵列）的比例,0--（0:1）,1--（1:1）,2--（1:2）,3--（1:3）,4--（1:4）,5--（1:5）,6--（1:6）,7--（6:1）,8--（5:1）,9--（4:1）,10--（3:1）,11--（2:1）
    BYTE    byPicQuota;   //图片卷比例：范围0~100
    BYTE    byRes[257];
}NET_DVR_ONE_KEY_CFG_V50, *LPNET_DVR_ONE_KEY_CFG_V50;

typedef struct tagNET_DVR_ONE_KEY_RESULT_V51
{
    DWORD   dwState;    //状态值，详见备注的状态值
    BYTE    byProgress;   //操作进度，0~100
    BYTE    byRes[259];
}NET_DVR_ONE_KEY_RESULT_V51, *LPNET_DVR_ONE_KEY_RESULT_V51;

typedef struct tagNET_DVR_ONE_KEY_CFG_SAN_V50
{
    DWORD   dwSize;//结构体大小
    BYTE    byRaidType;   //RAID类型：0-raid5,1-raid6
    BYTE    bySpareRaidProportion;   //热备盘：raid（阵列）的比例,0--（0:1）,1--（1:1）,2--（1:2）,3--（1:3）,4--（1:4）,5--（1:5）,6--（1:6）,7--（6:1）,8--（5:1）,9--（4:1）,10--（3:1）,11--（2:1）    
    BYTE    byRes[254];
}NET_DVR_ONE_KEY_CFG_SAN_V50, *LPNET_DVR_ONE_KEY_CFG_SAN_V50;


typedef struct tagNET_DVR_ONLINE_USER_INFO_
{
    DWORD    dwSize;
    WORD    wOnlineUserCount;    //登录设备的用户数
    BYTE   byRes[514];    //保留
}NET_DVR_ONLINE_USER_INFO, *LPNET_DVR_ONLINE_USER_INFO;

typedef struct tagNET_DVR_RECORD_SEGMENT_COND_
{
    DWORD        dwSize;
    NET_DVR_STREAM_INFO    struStreanInfo;
    NET_DVR_TIME_EX    struStartTime;  //开始时间
    NET_DVR_TIME_EX    struStopTime;    //结束时间
    BYTE        byRes[256];        //保留
}NET_DVR_RECORD_SEGMENT_COND, *LPNET_DVR_RECORD_SEGMENT_COND;

typedef struct tagNET_DVR_RECORD_SEGMENT_RET_
{
    DWORD    dwSize;
    DWORD    dwRecordTotalSize;    //录像总大小，单位MB
    BYTE    byRes[256];        //保留
}NET_DVR_RECORD_SEGMENT_RET, *LPNET_DVR_RECORD_SEGMENT_RET;

typedef struct tagNET_DVR_ACCESSORY_CARD_INFO
{
    DWORD   dwSize;
    BYTE    szAccessoryCardInfo[MAX_ACCESSORY_CARD/*256*/];//配件板(智能板和拼控板)型号信息
    BYTE    byRes[512];
}NET_DVR_ACCESSORY_CARD_INFO, *LPNET_DVR_ACCESSORY_CARD_INFO;

typedef struct tagNET_DVR_SEARCH_INFO_COND
{
    DWORD                   dwSize;
    BYTE                    byCommand;    //查询条件，0-个人，1-所有
    BYTE                    byRes1[3];
    DWORD                   dwEmployeeNo; //工号（查询条件配置为0-个人时有效）
    BYTE                    byName[NAME_LEN];   //姓名（查询条件配置为0-个人时有效）
    NET_DVR_TIME_V30        struStartTime;      //开始时间
    NET_DVR_TIME_V30        struEndTime;        //结束时间
    BYTE                    byRes[128];            //保留
}NET_DVR_SEARCH_INFO_COND, *LPNET_DVR_SEARCH_INFO_COND;

typedef struct tagNET_DVR_SCHEDULE_CHOICE
{
    BYTE                    byScheduleType;        //班次类型，0-不排班、1-普通班、2-工时班
    BYTE                    byScheduleNo;       //班次编号
    BYTE                    byRes[14];          //保留
}NET_DVR_SCHEDULE_CHOICE, *LPNET_DVR_SCHEDULE_CHOICE;

typedef struct tagNET_DVR_DISPINPUT_CFG
{
    DWORD  dwSize;
    DWORD  dwDispInputNo; //显示输入号
    DWORD  dwEDIDFileNo; //关联的EDID文件编号
    BYTE   byRes[32];
}NET_DVR_DISPINPUT_CFG, *LPNET_DVR_DISPINPUT_CFG;

typedef struct tagNET_DVR_SCHEDULE_PLAN
{
    DWORD                   dwSize;
    BYTE                    bySchedulePlanNo;   //排班计划编号,起始范围根据能力集返回
    BYTE                    bySchedulePlanType; //排班计划类型，0-个人、1-部门
    BYTE                    byEnable;           //使能
    BYTE                    byRes1;
    NET_DVR_SCHEDULE_CHOICE struScheduleChoice[DAYS_A_WEEK];  //班次选择
    NET_DVR_TIME_V30        struStartTime;      //开始时间
    NET_DVR_TIME_V30        struEndTime;        //结束时间
    BYTE                    byHolidayNo;        //假日组编号
    BYTE                    byRes[63];          //保留
}NET_DVR_SCHEDULE_PLAN, *LPNET_DVR_SCHEDULE_PLAN;

typedef struct tagNET_DVR_DISPINPUT_CFG_LIST
{
    DWORD  dwSize;
    DWORD  dwDispInputNum; //返回的NET_DVR_DISPINPUT_CFG结构的个数
    LPNET_DVR_DISPINPUT_CFG lpstruBuffer; //缓冲区指针
    DWORD  dwBufferSize; //缓冲区大小
    BYTE   byRes[32];
}NET_DVR_DISPINPUT_CFG_LIST, *LPNET_DVR_DISPINPUT_CFG_LIST;

typedef struct tagNET_DVR_SCHEDULE_INFO_CFG
{
    DWORD                  dwSize;
    DWORD                  dwEmployeeNo;        //工号
    BYTE                   byName[NAME_LEN];    //姓名
    BYTE                   byDepartmentName[NAME_LEN];   //部门名称
    NET_DVR_SCHEDULE_PLAN  struSchedulePlan;    //排班计划
    BYTE                   byRes[128];          //保留
}NET_DVR_SCHEDULE_INFO_CFG, *LPNET_DVR_SCHEDULE_INFO_CFG;

typedef struct tagNET_DVR_ATTENDANCE_SUMMARY_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo; //工号
    BYTE                  byName[NAME_LEN];  //姓名
    BYTE                  byDepartmentName[NAME_LEN];  //部门名称
    DWORD                 dwWorkStandard;    //标准工作时间（分钟）
    DWORD                 dwWorkActual; //实际工作时间（分钟）
    DWORD                 dwLateTimes;  //迟到次数
    DWORD                 dwLateMinutes;//迟到累计时间（分钟）
    DWORD                 dwLeaveEarlyTimes;    //早退次数
    DWORD                 dwLeaveEarlyMinutes;  //早退累计时间（分钟）
    DWORD                 dwOvertimeStandard;   //标准加班时间（分钟）
    DWORD                 dwOvertimeActual;     //实际加班时间（分钟）
    DWORD                 dwAttendanceStandard; //标准出勤天数（天）
    DWORD                 dwAttendanceActual;   //实际出勤天数（天）
    DWORD                 dwAbsentDays;         //旷工天数（天）
    BYTE                  byRes[128];           //保留
}NET_DVR_ATTENDANCE_SUMMARY_CFG, *LPNET_DVR_ATTENDANCE_SUMMARY_CFG;

typedef struct tagNET_DVR_ATTENDANCE_RECORD_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo; //工号
    BYTE                  byName[NAME_LEN];     //姓名
    BYTE                  byDepartmentName[NAME_LEN];  //部门名称
    NET_DVR_TIME_V30      struAttendanceTime;   //考勤时间
    BYTE                  byRes[128];   //保留
}NET_DVR_ATTENDANCE_RECORD_CFG, *LPNET_DVR_ATTENDANCE_RECORD_CFG;

typedef struct tagNET_DVR_ATTENDANCE_TIME
{
    NET_DVR_TIME_V30      struOnDutyTime;   //上班时间
    NET_DVR_TIME_V30      struOffDutyTime;  //下班时间
}NET_DVR_ATTENDANCE_TIME, *LPNET_DVR_ATTENDANCE_TIME;

typedef struct tagNET_DVR_ABNORMAL_CFG
{
    DWORD                 dwSize;
    DWORD                 dwEmployeeNo;     //工号
    BYTE                  byName[NAME_LEN]; //姓名
    BYTE                  byDepartmentName[NAME_LEN];  //部门名称
    NET_DVR_ATTENDANCE_TIME struAttendanceTime[ABNORMAL_INFO_NUM]; //异常时间段
    DWORD                 dwLateMinutes;    //迟到时间（分钟）
    DWORD                 dwLeaveEarlyMinutes; //早退时间（分钟）
    DWORD                 dwAbsenceMinutes; //缺勤时间（分钟）
    DWORD                 dwTotalMinutes;   //合计时间（分钟）
    BYTE                  byRes[128];     //保留
}NET_DVR_ABNORMAL_CFG, *LPNET_DVR_ABNORMAL_CFG;

typedef struct tagNET_DVR_CARD_CFG_V50
{
    DWORD dwSize;
    DWORD dwModifyParamType;
    // 需要修改的卡参数，设置卡参数时有效，按位表示，每位代表一种参数，1为需要修改，0为不修改
    // #define CARD_PARAM_CARD_VALID       0x00000001 //卡是否有效参数
    // #define CARD_PARAM_VALID            0x00000002  //有效期参数
    // #define CARD_PARAM_CARD_TYPE        0x00000004  //卡类型参数
    // #define CARD_PARAM_DOOR_RIGHT       0x00000008  //门权限参数
    // #define CARD_PARAM_LEADER_CARD      0x00000010  //首卡参数
    // #define CARD_PARAM_SWIPE_NUM        0x00000020  //最大刷卡次数参数
    // #define CARD_PARAM_GROUP            0x00000040  //所属群组参数
    // #define CARD_PARAM_PASSWORD         0x00000080  //卡密码参数
    // #define CARD_PARAM_RIGHT_PLAN       0x00000100  //卡权限计划参数
    // #define CARD_PARAM_SWIPED_NUM       0x00000200  //已刷卡次数
    // #define CARD_PARAM_EMPLOYEE_NO      0x00000400  //工号
    // #define CARD_PARAM_NAME             0x00000800  //姓名
    // #define CARD_PARAM_DEPARTMENT_NO    0x00001000  //部门编号
    // #define CARD_SCHEDULE_PLAN_NO       0x00002000  //排班计划编号
    // #define CARD_SCHEDULE_PLAN_TYPE     0x00004000  //排班计划类型
    // #define CARD_ROOM_NUMBER            0x00008000  //房间号
    // #define CARD_SIM_NO                 0x00010000  //SIM卡号（手机号）
    // #define CARD_FLOOR_NUMBER           0x00020000  //楼层号
    // #define CARD_USER_TYPE              0x00040000  //用户类型
    BYTE byCardNo[ACS_CARD_NO_LEN]; //卡号
    BYTE byCardValid; //卡是否有效，0-无效，1-有效（用于删除卡，设置时置为0进行删除，获取时此字段始终为1）
    BYTE byCardType; //卡类型，1-普通卡，2-特殊群体卡，3-禁止名单卡，4-巡更卡，5-胁迫卡，6-超级卡，7-来宾卡，8-解除卡，9-员工卡，10-应急卡，11-应急管理卡（用于授权临时卡权限，本身不能开门），默认普通卡
    BYTE byLeaderCard; //是否为首卡，1-是，0-否
    BYTE byUserType; // 0 – 普通用户1 - 管理员用户;
    BYTE byDoorRight[MAX_DOOR_NUM_256]; //门权限(楼层权限、锁权限)，按位表示，1为有权限，0为无权限，从低位到高位表示对门（锁）1-N是否有权限
    NET_DVR_VALID_PERIOD_CFG struValid; //有效期参数
    BYTE  byBelongGroup[MAX_GROUP_NUM_128]; //所属群组，按字节表示，1-属于，0-不属于
    BYTE byCardPassword[CARD_PASSWORD_LEN]; //卡密码
    WORD wCardRightPlan[MAX_DOOR_NUM_256][MAX_CARD_RIGHT_PLAN_NUM]; //卡权限计划，取值为计划模板编号，同个门（锁）不同计划模板采用权限或的方式处理
    DWORD dwMaxSwipeTime; //最大刷卡次数，0为无次数限制（开锁次数）
    DWORD dwSwipeTime; //已刷卡次数
    WORD wRoomNumber;  //房间号
    SHORT wFloorNumber;   //层号
    DWORD dwEmployeeNo;   //工号（用户ID）
    BYTE byName[NAME_LEN];   //姓名
    WORD wDepartmentNo;   //部门编号
    WORD wSchedulePlanNo;   //排班计划编号
    BYTE bySchedulePlanType;  //排班计划类型：0-无意义、1-个人、2-部门
    BYTE byRightType;  //下发权限类型：0-普通发卡权限、1-二维码权限、2-蓝牙权限（可视对讲设备二维码权限配置项：房间号、卡号（虚拟卡号）、最大刷卡次数（开锁次数）、有效期参数；蓝牙权限：卡号（萤石APP账号）、其他参数配置与普通发卡权限一致）
    BYTE byRes2[2];
    DWORD dwLockID;  //锁ID
    BYTE byLockCode[MAX_LOCK_CODE_LEN];    //锁代码
    BYTE byRoomCode[MAX_DOOR_CODE_LEN];  //房间代码
    //按位表示，0-无权限，1-有权限
    //第0位表示：弱电报警
    //第1位表示：开门提示音
    //第2位表示：限制客卡
    //第3位表示：通道
    //第4位表示：反锁开门
    //第5位表示：巡更功能
    DWORD dwCardRight;      //卡权限
    DWORD dwPlanTemplate;   //计划模板(每天)各时间段是否启用，按位表示，0--不启用，1-启用
    DWORD dwCardUserId;    //持卡人ID
    BYTE byCardModelType;  //0-空，1- MIFARE S50，2- MIFARE S70，3- FM1208 CPU卡，4- FM1216 CPU卡，5-国密CPU卡，6-身份证，7- NFC
    BYTE byRes3[51];
    BYTE bySIMNum[NAME_LEN/*32*/]; //SIM卡号（手机号）
}NET_DVR_CARD_CFG_V50, *LPNET_DVR_CARD_CFG_V50;




typedef struct tagNET_DVR_FACE_FEATURE
{
    NET_VCA_RECT struFace; //人脸子图区域
    NET_VCA_POINT    struLeftEye;    // 左眼坐标
    NET_VCA_POINT    struRightEye;   // 右眼坐标
    NET_VCA_POINT    struLeftMouth;  // 嘴左边坐标
    NET_VCA_POINT    struRightMouth; // 嘴右边坐标
    NET_VCA_POINT    struNoseTip;   // 鼻子坐标
}NET_DVR_FACE_FEATURE, *LPNET_DVR_FACE_FEATURE;


typedef struct tagNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND
{
    DWORD   dwSize;
    NET_DVR_STREAM_INFO struStreamInfo; //流id信息（72字节）
    BYTE    byRes[128];                 //保留
}NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND, *LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_SEND;

typedef struct tagNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET
{
    DWORD   dwSize;
    NET_DVR_STREAM_INFO struStreamInfo; //流id信息（72字节）
    BYTE    byExecutable;           //0-不可立即回传，1-可立即执行回传
    BYTE    byUnexecutableReason;   //不可立即回传原因, 0-需要排队，1-编码器无连接，2-流ID不存在，3-CVR异常，4-无输入视频, 5-编码器用户名或密码错, 6-前端设备不兼容, 7-其他原因
    BYTE    byRes[254];             //保留
}NET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET, *LPNET_DVR_REC_PASSBACK_MANUAL_EXECUTABLE_RET;

typedef struct tagNET_DVR_STREAM_MEDIA_CFG
{
    DWORD   dwSize;
    BYTE    sUrl[MAX_URL_LEN];
    NET_DVR_IPADDR   struDMSIP; /* dms IP地址 */
    WORD    wDMSPort;  /*dms 端口号 */
    BYTE    byRes1[2];
    DWORD   dwDomainID; /*域ID，用来支持多网域，由平台管理*/
    BYTE    byRes[360]; //保留
}NET_DVR_STREAM_MEDIA_CFG, *LPNET_DVR_STREAM_MEDIA_CFG;

typedef struct tagNET_DVR_SHIPSDETECTION_REGION_CFG
{

    BYTE    byRuleID;
    BYTE    byEnable;     //使能
    BYTE    bySensitivity;  //灵敏度参数，范围[1,100]
    BYTE    byFrameOverlayEnabled;//视频是否叠加检测框
    BYTE   byRes[36];
    NET_ITC_POLYGON struPolygon; //触发区域
    NET_VCA_LINE struTriggerLine;  //触发线
}NET_DVR_SHIPSDETECTION_REGION_CFG, *LPNET_DVR_SHIPSDETECTION_REGION_CFG;

typedef struct tagNET_DVR_SHIPSDETECTION_CFG
{
    DWORD dwSize;
    BYTE    byEnable;//使能
    BYTE   byRes1[3];
    float    fLookDownUpAngle;//设备俯仰角度，精确到小数点后一位
    float    fHorizontalHeight;//设备水平高度，精确到小数点后一位
    NET_DVR_SHIPSDETECTION_REGION_CFG struShipsDetectionRegion[MAX_SHIPSDETE_REGION_NUM];//船只检测单个区域配置
    BYTE   byRes[256];
}NET_DVR_SHIPSDETECTION_CFG, *LPNET_DVR_SHIPSDETECTION_CFG;






typedef struct tagNET_DVR_BASE_STATION_INFO_ALARM
{
    DWORD        dwSize;
    DWORD        dwChannel;//通道号
    char         sNetBarWaCode[16];//场所编号
    char         sCollectionEquipmentID[24];//采集设备编号
    char         sMCC[4];//移动国家码
    char         sMNC[4];//移动网络码
    char         sLAC[36];//位置区码
    char         sCI[36];//小区识别码
    char         sBSCI[36];//基站识别码
    char         sBCCH[36];//公共广播信道
    char         sLEV[36];//接收报告电平
    char         sCollectionEquipmentLongitude[12];//采集设备经度
    char         sCollectionEquipmentLatitude[12];//采集设备纬度
    char         sCaptureTime[20];//采集时间 时间格式yyyy-MM-dd hh:mm:ss
    BYTE         byRes[256];
}NET_DVR_BASE_STATION_INFO_ALARM, *LPNET_DVR_BASE_STATION_INFO_ALARM;





typedef struct tagNET_DVR_REALTIME_THERMOMETRY_COND
{
    DWORD       dwSize;
    DWORD       dwChan;//通道号，从1开始，0xffffffff代表获取全部通道
    BYTE        byRuleID; //规则ID 0-代表获取全部规则，具体规则ID从1开始 
    /*
    1-定时模式：设备每隔一秒上传各个规则测温数据的最高温、最低温和平均温度值、温差
    2-温差模式：若上一秒与下一秒的最高温或者最低温或者平均温或者温差值的温差大于等于2摄氏度，则上传最高温、最低温和平均温度值。若大于等于一个小时温差值均小于2摄氏度，则上传最高温、最低温、平均温和温差值
    */
    BYTE        byMode; //长连接模式， 0-保留（为兼容老设备），1-定时模式，2-温差模式
    WORD        wInterval; //上传间隔，仅温差模式支持，1~3600S，填0则默认3600S上传一次
    float       fTemperatureDiff;//温差
    BYTE        byRes[56]; //保留
}NET_DVR_REALTIME_THERMOMETRY_COND, *LPNET_DVR_REALTIME_THERMOMETRY_COND;

typedef struct tagNET_DVR_POINT_THERM_CFG
{
    float        fTemperature;//当前温度
    NET_VCA_POINT struPoint;//点测温坐标（当规则标定类型为点的时候生效）
    BYTE    byRes[120];
}NET_DVR_POINT_THERM_CFG, *LPNET_DVR_POINT_THERM_CFG;

typedef struct tagNET_DVR_LINEPOLYGON_THERM_CFG
{
    float       fMaxTemperature;//最高温
    float        fMinTemperature;//最低温
    float       fAverageTemperature;//平均温
    float        fTemperatureDiff;//温差
    NET_VCA_POLYGON struRegion;//区域（当规则标定类型为框/线的时候生效）
    BYTE    byRes[32];
}NET_DVR_LINEPOLYGON_THERM_CFG, *LPNET_DVR_LINEPOLYGON_THERM_CFG;

typedef struct tagNET_DVR_THERMOMETRY_UPLOAD
{
    DWORD       dwSize;
    DWORD       dwRelativeTime;     // 相对时标
    DWORD       dwAbsTime;            // 绝对时标
    char        szRuleName[NAME_LEN/*32*/];//规则名称
    BYTE        byRuleID;//规则ID号
    BYTE        byRuleCalibType;//规则标定类型 0-点，1-框，2-线
    WORD        wPresetNo; //预置点号
    NET_DVR_POINT_THERM_CFG struPointThermCfg;
    NET_DVR_LINEPOLYGON_THERM_CFG struLinePolygonThermCfg;
    BYTE        byThermometryUnit;//测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
    BYTE        byDataType;//数据状态类型:0-检测中，1-开始，2-结束
    BYTE		byRes1;
    /*
    bit0-中心点测温：0-不支持，1-支持；
    bit1-最高点测温：0-不支持，1-支持；
    bit2-最低点测温：0-不支持，1-支持；
    */
    BYTE      bySpecialPointThermType;// 是否支持特殊点测温
    float	   fCenterPointTemperature;//中心点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10 （由bySpecialPointThermType判断是否支持中心点）
    float	   fHighestPointTemperature;//最高点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10（由bySpecialPointThermType判断是否支持最高点）
    float	   fLowestPointTemperature;//最低点温度,精确到小数点后一位(-40-1500),（浮点数+100）*10（由bySpecialPointThermType判断是否支持最低点）
    NET_VCA_POINT struHighestPoint;//线、框测温最高温度位置坐标（当规则标定类型为线、框的时候生效）
    NET_VCA_POINT struLowestPoint;//线、框测温最低温度位置坐标（当规则标定类型为线、框的时候生效）
	BYTE       byIsFreezedata;//是否数据冻结 0-否 1-是
    BYTE       byFaceSnapThermometryEnabled;//人脸抓拍测温使能 1-开启 0-关闭
    BYTE        byRes2[2];
    DWORD       dwChan; //通道号，查询条件中通道号为0xffffffff时该字段生效
    NET_VCA_RECT         struFaceRect;      //人脸子图区域
    DWORD       dwTimestamp;//DSP时间戳
    BYTE          byRes[68];
}NET_DVR_THERMOMETRY_UPLOAD, *LPNET_DVR_THERMOMETRY_UPLOAD;

typedef struct tagNET_DVR_THERMOMETRY_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//通道号
    BYTE    byRuleID;//规则ID
    BYTE    byThermometryUnit;//测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
    WORD    wPresetNo; //预置点号
    NET_PTZ_INFO  struPtzInfo;//ptz坐标信息
    BYTE    byAlarmLevel;//0-预警 1-报警
    BYTE    byAlarmType;/*报警类型 0-最高温度 1-最低温度 2-平均温度 3-温差 4-温度突升 5-温度突降*/
    BYTE    byAlarmRule;//0-大于，1-小于
    BYTE    byRuleCalibType;//规则标定类型 0-点，1-框，2线
    NET_VCA_POINT struPoint;//点测温坐标（当规则标定类型为点的时候生效）
    NET_VCA_POLYGON struRegion;//区域（当规则标定类型为框的时候生效）
    float   fRuleTemperature;/*配置规则温度,精确到小数点后一位(-40-1000),（浮点数+100） */
    float   fCurrTemperature;/*当前温度,精确到小数点后一位(-40-1000),（浮点数+100） */
    DWORD   dwPicLen;//可见光图片长度
    DWORD   dwThermalPicLen;//热成像图片长度
    DWORD   dwThermalInfoLen;//热成像附加信息长度
    char*   pPicBuff; ///可见光图片指针
    char*   pThermalPicBuff;// 热成像图片指针
    char*   pThermalInfoBuff; //热成像附加信息指针
    NET_VCA_POINT struHighestPoint;//线、框测温最高温度位置坐标（当规则标定类型为线、框的时候生效）
    float   fToleranceTemperature;/* 容差温度,精确到小数点后一位(-40-1000),（浮点数+100） */
    DWORD   dwAlertFilteringTime;//温度预警等待时间 单位秒 范围为0-200秒，默认为0秒
    DWORD   dwAlarmFilteringTime;//温度报警等待时间 单位秒 范围为0-200秒，默认为0秒
    DWORD   dwTemperatureSuddenChangeCycle;//温度突变记录周期，单位秒
    float   fTemperatureSuddenChangeValue;//温度突变值,精确到小数点后一位(大于0)
    BYTE    byPicTransType;        //图片数据传输方式: 0-二进制；1-url
    BYTE    byRes1[3];
    DWORD   dwVisibleChannel; //可见光通道通道号
    DWORD   dwRelativeTime;     // 相对时标
    DWORD   dwAbsTime;          // 绝对时标
    float   fAlarmRuleTemperature;/* TMA测温配置规则温度,精确到小数点后一位(-40-1000),（浮点数+100） */
    BYTE    byRes[20];
}NET_DVR_THERMOMETRY_ALARM, *LPNET_DVR_THERMOMETRY_ALARM;

typedef struct tagNET_DVR_THERMOMETRY_DIFF_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//通道号
    BYTE    byAlarmID1;//规则AlarmID1
    BYTE    byAlarmID2;//规则AlarmID2
    WORD    wPresetNo; //预置点号
    BYTE    byAlarmLevel;//0-预警 1-报警
    BYTE    byAlarmType;/*报警类型 0-最高温度 1-最低温度 2-平均温度*/
    BYTE    byAlarmRule;//0-大于，1-小于
    BYTE    byRuleCalibType;//规则标定类型 0-点，1-框，2线
    NET_VCA_POINT struPoint[2];//点测温坐标（当规则标定类型为点的时候生效）数组下标0代表着AlarmID1，数组下标1代表着AlarmID2.
    NET_VCA_POLYGON struRegion[2];//区域（当规则标定类型为框的时候生效）数组下标0代表着AlarmID1，数组下标1代表着AlarmID2.
    float   fRuleTemperatureDiff;/*配置规则温差,精确到小数点后一位(-40-1000)）*/
    float   fCurTemperatureDiff;/*当前温差,精确到小数点后一位(-40-1000),（浮点数+100） */
    NET_PTZ_INFO  struPtzInfo;//ptz坐标信息
    DWORD   dwPicLen;//可见光图片长度
    DWORD   dwThermalPicLen;//热成像图片长度
    DWORD   dwThermalInfoLen;//热成像附加信息长度
    char*   pPicBuff; ///可见光图片指针
    char*   pThermalPicBuff;// 热成像图片指针
    char*   pThermalInfoBuff; //热成像附加信息指针
    BYTE    byThermometryUnit;//测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
    BYTE    byPicTransType;        //图片数据传输方式: 0-二进制；1-url
    BYTE    byRes1[2];
    float   fToleranceTemperature;/*容差温度,精确到小数点后一位(-40-1000),（浮点数+100） */
    DWORD   dwAlarmFilteringTime;//温度报警等待时间 单位秒 范围为0-200秒，默认为0秒
    DWORD   dwVisibleChannel; //可见光通道通道号
    BYTE    byRes[48];
}NET_DVR_THERMOMETRY_DIFF_ALARM, *LPNET_DVR_THERMOMETRY_DIFF_ALARM;


typedef struct tagNET_DVR_SHIPSCOUNT_CFG
{
    DWORD dwSize;
    DWORD dwUpShipsCount; //上行船只数
    DWORD dwDownShipsCount; //下行船只数
    DWORD dwLeftShipsCount; //左行船只数
    DWORD dwRightShipsCount; //右行船只数
    DWORD dwTotalCount;//船只总计数
    DWORD dwRelativeTime; //设备侧计数开始计数的相对时标
    DWORD dwAbsTime; //设备侧计数开始计数的绝对时标
    BYTE   byDataType;//数据状态类型:0-检测中，1-开始，2-结束
    BYTE   byRes[255];
}NET_DVR_SHIPSCOUNT_CFG, *LPNET_DVR_SHIPSCOUNT_CFG;

typedef struct tagNET_DVR_SHIPSINFO
{
    float     fShipsLength; //船只长度；1~1000.0m，精确到小数点后一位
    float     fShipsHeight; //船只高度；1~1000.0m，精确到小数点后一位
    float     fShipsWidth;  //船只宽度；1~1000.0m，精确到小数点后一位
    float     fShipsSpeed;  //船只速度；1~1000.0m/s，精确到小数点后一位
    BYTE      byShipsDirection;//船只方向；0~up,1~down,2~left,3~right
    BYTE      byShipsDetState;//船只检测状态；0~正跨越检测线，1~船头检测，2~船尾检测
    BYTE      byTriggerLineID;//检测线ID
    BYTE      byRes[61];
    NET_VCA_POLYGON  struShipsRect; //船只区域，归一化值，相对于大图（可见光图、热成像图)的分辨率
} NET_DVR_SHIPSINFO, *LPNET_DVR_SHIPSINFO;

typedef struct tagNET_DVR_SHIPIMAGE_INFO
{
    DWORD   dwShipImageLen;//船只抓拍图片二进制数据长度
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    char*   pXmlBuf;  //船只抓拍图片二进制数据指针
#else
    char*   pXmlBuf;  //船只抓拍图片二进制数据指针
    BYTE    byRes[4];
#endif
}NET_DVR_SHIPIMAGE_INFO, *LPNET_DVR_SHIPIMAGE_INFO;

typedef struct tagNET_DVR_SHIPSDETECTION_ALARM
{
    DWORD   dwSize;
    NET_VCA_DEV_INFO  struDevInfo;   //设备信息
    DWORD   dwRelativeTime; //相对时标
    DWORD   dwAbsTime; //绝对时标
    BYTE    byShipsNum; //船只数；(正跨越检测线的船只数)
    BYTE    byShipsNumHead;//船只数；(船头检测船只数)
    BYTE    byShipsNumEnd; //船只数；(船尾检测船只数)
    BYTE    byPicTransType;        //图片数据传输方式: 0-二进制；1-url
    NET_DVR_SHIPSINFO struShipInfo[MAX_SHIPS_NUM/*20*/];//船只信息；最大支持20艘
    DWORD   dwPicLen;//可见光图片长度
    DWORD   dwThermalPicLen;//热成像图片长度
    BYTE*   pPicBuffer;    //可见光图片数据指针
    BYTE*   pThermalPicBuffer;    //热成像图片数据指针
    WORD    wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    BYTE    byTimeDiffFlag;      /*时差字段是否有效  0-时差无效， 1-时差有效 */
    char    cTimeDifferenceH;         /*与UTC的时差（小时），-12 ... +14， +表示东区,，byTimeDiffFlag为1时有效*/
    char    cTimeDifferenceM;      	/*与UTC的时差（分钟），-30, 30, 45， +表示东区，byTimeDiffFlag为1时有效*/
    BYTE    bySID;//场景ID
    BYTE    byRes1[2];
    char    szSceneName[NAME_LEN];//场景名称，不超过32字符
    BYTE    byRes[132];
    DWORD   dwXmlLen;//XML透传数据长度, 即EventNotificationAlert XML Block的数据长度
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    char*   pXmlBuf; // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
#else
    char*   pXmlBuf; // XML报警信息指针,其XML对应到EventNotificationAlert XML Block
    BYTE    byRes2[4];
#endif
    NET_DVR_SHIPIMAGE_INFO  struShipImageInfo[MAX_SHIPIMAGE_NUM/*6*/];//船只抓拍图片信息,数组下标为0时代表为第一张船只抓拍图片，以此类推；最大支持6张图片。
}NET_DVR_SHIPSDETECTION_ALARM, *LPNET_DVR_SHIPSDETECTION_ALARM;




typedef struct tagNET_DVR_BAREDATAOVERLAY_CFG
{
    DWORD   dwSize;
    BYTE    byEnable;//使能
    BYTE    byIntervalTime;// 上传的时间间隔可配置：1 2 3 4 5.单位为秒，默认为3秒
    BYTE    byRes[258];
}NET_DVR_BAREDATAOVERLAY_CFG, *LPNET_DVR_BAREDATAOVERLAY_CFG;



typedef struct tagNET_DVR_INPUT_SOURCE_TEXT_COND
{
    DWORD    dwSize;
    DWORD    dwInputSourceNo;    //输入源编号
    DWORD    dwTextNo;        //文本编号
    BYTE    byRes[32];
}NET_DVR_INPUT_SOURCE_TEXT_COND, *LPNET_DVR_INPUT_SOURCE_TEXT_COND;

typedef struct tagNET_DVR_INPUT_SOURCE_TEXT
{
    DWORD        dwSize;
    DWORD        dwTextNo;            //文本编号
    BYTE        byEnable;            //是否使能，0-不使能，1-使能
    BYTE        byFontSize;            //字体大小
    BYTE        byBkGroudMode;        //背景模式，1-透明，2-覆盖
    BYTE        byRes[1];
    DWORD        dwXPosition;            //字符显示位置的左上角X坐标，输入源相对坐标
    DWORD        dwYPosition;            //字符显示位置的左上角Y坐标，输入源相对坐标
    NET_DVR_RGB_COLOR struForegroudColor;    //字符前景色
    NET_DVR_RGB_COLOR struBackgroudColor; //字符背景色
    BYTE        byTextContent[MAX_LEN_TEXT_CONTENT];    //字符内容
    BYTE        byRes1[64];
}NET_DVR_INPUT_SOURCE_TEXT, *LPNET_DVR_INPUT_SOURCE_TEXT;

typedef struct tagNET_DVR_INPUT_SOURCE_TEXT_LIST
{
    DWORD    dwSize;
    NET_DVR_INPUT_SOURCE_TEXT struTextList[MAX_NUM_INPUT_SOURCE_TEXT]; //文本列表
    BYTE    byRes[64];
}NET_DVR_INPUT_SOURCE_TEXT_LIST, *LPNET_DVR_INPUT_SOURCE_TEXT_LIST;

typedef struct  tagNET_DVR_INPUT_SOURCE_RESOLUTION
{
    DWORD  dwSize;
    DWORD  dwInputSignalNo;  //输入源编号
    BYTE  byEnabled;  //自定义分辨率是否使能
    BYTE  byRes;
    WORD  wImageWidth;     //图像宽度
    WORD  wImageHeight;  //图像高度
    WORD  wRefreshRate;     //刷新频率
    BYTE    byColorDepth;  //颜色深度，32位、16位、8位三种可选
    BYTE    byScanType;  //扫描类型，1-逐行扫描，2-间隔扫描
    BYTE    byRes1[62];
}NET_DVR_INPUT_SOURCE_RESOLUTION, *LPNET_DVR_INPUT_SOURCE_RESOLUTION;

typedef struct tagNET_DVR_INPUT_SOURCE_RESOLUTION_LIST
{
    DWORD dwSize;
    DWORD dwInputSignalCnt; //设备输入信号源数量
    LPNET_DVR_INPUT_SOURCE_RESOLUTION lpstruBuffer; //缓冲区指针
    DWORD dwBufferSize; //缓冲区大小
    BYTE  byRes[32];
}NET_DVR_INPUT_SOURCE_RESOLUTION_LIST, *LPNET_DVR_INPUT_SOURCE_RESOLUTION_LIST;

typedef struct tagNET_DVR_LED_AREA_COND
{
    DWORD dwSize;
    DWORD dwVideoWallNo; //电视墙编号
    DWORD dwLEDAreaNo; //LED区域编号
    BYTE   byRes[32];
}NET_DVR_LED_AREA_COND, *LPNET_DVR_LED_AREA_COND;

typedef struct tagNET_DVR_LED_AREA_INFO
{
    DWORD dwSize;
    DWORD dwLEDAreaNo; //LED区域编号
    NET_DVR_RECTCFG_EX struRect; //矩形区域
    DWORD dwaOutputNo[MAX_NUM_OUTPUT_CHANNEL]; //输出口列表
    BYTE  byAreaType; //区域类型，0-LED区域，1-LCD区域
    BYTE  byRes[31];
}NET_DVR_LED_AREA_INFO, *LPNET_DVR_LED_AREA_INFO;

typedef struct tagNET_DVR_LED_AREA_INFO_LIST
{
    DWORD dwSize;
    DWORD dwLEDAreaNum; //LED区域数量
    LPNET_DVR_LED_AREA_INFO lpstruBuffer; //缓冲区指针
    DWORD dwBufferSize; //缓冲区大小
    BYTE   byRes[32];
}NET_DVR_LED_AREA_INFO_LIST, *LPNET_DVR_LED_AREA_INFO_LIST;

typedef struct tagNET_DVR_CALL_WAITTING_CFG
{
    DWORD   dwSize;    //结构体大小
    BYTE    byEnable;    //是否启用呼叫等待, 0--不启用，1--启用
    BYTE    byRes1;
    WORD    wWaitTime;//呼叫等待时间，单位秒
    WORD   wCalledWaitTime;/*单位秒，被呼叫等待时间*/
    BYTE    byRes[510];
}NET_DVR_CALL_WAITTING_CFG, *LPNET_DVR_CALL_WAITTING_CFG;

typedef struct tagNET_DVR_ALARM_LAMP_CFG
{
    DWORD   dwSize;    //结构体大小
    BYTE    byEnable;    //是否启用警灯定时闪烁, 0--不启用，1--启用
    BYTE    byRes1;
    WORD   wFlashDuration;//警灯定时闪烁持续时间，单位秒
    WORD   wFlashIntervalTime;//警灯闪烁间隔时间，单位秒
    BYTE    byRes[510];
}NET_DVR_ALARM_LAMP_CFG, *LPNET_DVR_ALARM_LAMP_CFG;

typedef struct tagNET_DVR_VOICE_PROMPTION_CFG
{
    DWORD   dwSize;    //结构体大小
    BYTE    byEnable;    //是否启用语音提示, 0--不启用，1--启用
    BYTE    byRes1[3];
    BYTE    byCenterBusyFile[NAME_LEN];//中心繁忙提示语音文件名
    BYTE    byRefusedFile[NAME_LEN];//拒绝提示语音文件名
    BYTE    byHangUpFile[NAME_LEN];//对讲结束提示语音文件名
    BYTE    byCallWaittingFile[NAME_LEN];//呼叫等候音文件名
    BYTE    byConsultWaittingFile[NAME_LEN];//业务咨询等候音文件名
    BYTE    byWelcomeFile[NAME_LEN];//欢迎提示语音文件名
    BYTE    byFarewellFile[NAME_LEN];//欢送语音文件
    BYTE    byCalledVoicePromptName[NAME_LEN];//被呼叫语音提示名
    BYTE    byRes[384];
}NET_DVR_VOICE_PROMPTION_CFG, *LPNET_DVR_VOICE_PROMPTION_CFG;

typedef struct tagNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG
{
    DWORD   dwSize;        //结构体大小
    BYTE    byCommand;    //控制命令，0--centerbusy，1--refuse
    BYTE    byType;        //处理类型，0—紧急报警，1—业务咨询
    BYTE    byRes[510];
}NET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG, *LPNET_DVR_EMERGENCE_ALARM_RSP_CTRL_CFG;

typedef struct _tagNET_DVR_ALARMHOST_NETPARAM_V50
{
    DWORD     dwSize;
    NET_DVR_IPADDR  struIP;
    WORD     wPort;
    BYTE    byAddressType;    //0 - 无意义, 1 - ipv4/ipv6地址，2 - 域名
    BYTE    byEnable; //使能，0-不启用，1-启用
    BYTE    byDomainName[MAX_DOMAIN_NAME/*64*/]; //域名，GPRS参数配置、网络参数配置时该字段均有效
    BYTE    byReportProtocol;        //1-private 2-NAL2300, 3-Ehome
    BYTE    byDevID[ACCOUNTNUM_LEN_32/*32*/]; //协议为NAL2300时有效
    BYTE    byProtocolVersion;            //EHome协议版本，0-无意义,1–v2.0，2–v4.0，3-v5.0
    BYTE    byRes1[3];
    BYTE    byEHomeKey[NET_SDK_EHOME_KEY_LEN];            //EHome Key（用于EHome 5.0版本）
    BYTE    byRes2[28]; //GPRS的域名解析是在固定的服务器上进行的，所以不需要给解析服务器的信息预留一些字段
} NET_DVR_ALARMHOST_NETPARAM_V50, *LPNET_DVR_ALARMHOST_NETPARAM_V50;

typedef struct _tagNET_DVR_ALARMHOST_NETCFG_V50
{
    DWORD dwSize;
    NET_DVR_ALARMHOST_NETPARAM_V50   struNetCenter[MAX_CENTERNUM];
    BYTE        byRes1[128];
} NET_DVR_ALARMHOST_NETCFG_V50, *LPNET_DVR_ALARMHOST_NETCFG_V50;



typedef struct tagNET_DVR_INIT_CHECK_MODULE_COM
{
    BYTE byEnable; //启用必须库检查机制 0-不启用，1-启用
    BYTE byRes[255];
}NET_DVR_INIT_CHECK_MODULE_COM, *LPNET_DVR_INIT_CHECK_MODULE_COM;


typedef struct tagNET_DVR_INIT_CFG_ABILITY
{
    INIT_CFG_MAX_NUM    enumMaxLoginUsersNum;                //最多允许的注册用户个数。
    INIT_CFG_MAX_NUM   enumMaxAlarmNum;                      //最大的告警路数
    BYTE    byRes[64];
}NET_DVR_INIT_CFG_ABILITY, *LPNET_DVR_INIT_CFG_ABILITY;

typedef struct tagNET_DVR_LOCAL_SDK_PATH
{
    char sPath[NET_SDK_MAX_FILE_PATH];//组件库地址
    BYTE byRes[128];
}NET_DVR_LOCAL_SDK_PATH, *LPNET_DVR_LOCAL_SDK_PATH;

typedef struct tagNET_DVR_SDKMEMPOOL_CFG
{
    BYTE byRes[256];
}NET_DVR_SDKMEMPOOL_CFG, *LPNET_DVR_SDKMEMPOOL_CFG;

typedef struct tagNET_DVR_RES_INFO
{
    DWORD dwImageWidth; //图像宽度
    DWORD dwImageHeight; //图像高度
}NET_DVR_RES_INFO, *LPNET_DVR_RES_INFO;

typedef struct tagNET_DVR_VS_INPUT_CHAN_INIT
{
    DWORD dwSize;
    DWORD dwVSInputChan; //虚拟屏输入通道号
    DWORD dwResNums; //分辨率的个数
    NET_DVR_RES_INFO struResList[MAX_RES_NUM_ONE_VS_INPUT_CHAN]; //分辨率列表
    BYTE byRes[32];
}NET_DVR_VS_INPUT_CHAN_INIT, *LPNET_DVR_VS_INPUT_CHAN_INIT;

typedef struct tagNET_DVR_VS_INPUT_CHAN_INIT_LIST
{
    DWORD dwSize;
    NET_DVR_VS_INPUT_CHAN_INIT struChanList[MAX_VS_INPUT_CHAN_NUM]; //通道列表
    BYTE byRes[32];
}NET_DVR_VS_INPUT_CHAN_INIT_LIST, *LPNET_DVR_VS_INPUT_CHAN_INIT_LIST;

typedef struct tagNET_DVR_VS_INPUT_CHAN_CFG
{
    DWORD dwSize;
    DWORD dwVSInputChan; //虚拟屏输入通道号
    NET_DVR_RES_INFO struResolutin; //分辨率
    BYTE byRes[64];
}NET_DVR_VS_INPUT_CHAN_CFG, *LPNET_DVR_VS_INPUT_CHAN_CFG;

typedef struct tagNET_DVR_VS_NETSRC_CFG
{
    DWORD dwSize;
    DWORD dwVSInputChan; //虚拟屏输入通道号
    BYTE byDispUrl[MAX_URL_LEN]; //显示URL
    BYTE byEnabled; //是否启用URL
    BYTE byRes[127];
}NET_DVR_VS_NETSRC_CFG, *LPNET_DVR_VS_NETSRC_CFG;

typedef struct tagNET_DVR_EDID_FILE_INFO
{
    DWORD   dwSize;
    DWORD   dwEDIDFileNo; //EDID文件编号，从1开始
    BYTE    byFileName[FILE_NAME_LEN]; //EDID文件名称
    BYTE    byRes[32];
}NET_DVR_EDID_FILE_INFO, *LPNET_DVR_EDID_FILE_INFO;

typedef struct tagNET_DVR_EDID_FILE_INFO_LIST
{
    DWORD   dwSize;
    DWORD   dwEDIDFileNum; //返回的NET_DVR_EDID_FILE_INFO个数
    LPNET_DVR_EDID_FILE_INFO lpstruBuffer; //缓冲区指针
    DWORD   dwBufferSize; //缓冲区大小
    BYTE    byRes[32];
}NET_DVR_EDID_FILE_INFO_LIST, *LPNET_DVR_EDID_FILE_INFO_LIST;

typedef struct tagNET_DVR_OSD_INFO
{
    BYTE byEnabled;  //是否使能，零-不使能，非零-使能
    BYTE byEnabledFlash;  //是否闪烁，零-不闪烁，非零-闪烁
    BYTE byFontSize;  //字体大小，1-大，2-中，3-小
    BYTE byTransparent;  //透明度，取值范围0-100
    NET_DVR_RGB_COLOR struColor;  //字体颜色
    WORD wCoordinateX;  //OSD左上角X坐标
    WORD wCoordinateY;  //OSD左上角Y坐标
    BYTE byContent[MAX_LEN_OSD_CONTENT];  //OSD信息
    BYTE byRes[32];
}NET_DVR_OSD_INFO, *LPNET_DVR_OSD_INFO;

typedef struct tagNET_DVR_SUBWND_DECODE_OSD
{
    DWORD dwSize;
    DWORD dwSubWndNo;  //子窗口号（4字节组合方式）
    DWORD dwOSDNums;  //该子窗口配置的OSD信息的个数
    NET_DVR_OSD_INFO struOSDList[MAX_NUM_OSD_ONE_SUBWND];  //OSD信息列表
    BYTE byRes[32];
}NET_DVR_SUBWND_DECODE_OSD, *LPNET_DVR_SUBWND_DECODE_OSD;

typedef struct tagNET_DVR_SUBWND_DECODE_OSD_LIST
{
    DWORD dwSize;
    NET_DVR_SUBWND_DECODE_OSD struSubWndList[MAX_NUM_SPLIT_WND];  //所有子窗口的解码OSD
    BYTE byRes[32];
}NET_DVR_SUBWND_DECODE_OSD_LIST, *LPNET_DVR_SUBWND_DECODE_OSD_LIST;

typedef struct tagNET_DVR_DECODE_CHANNEL_OSD
{
    DWORD dwSize;
    NET_DVR_OSD_INFO struOSDInfo[MAX_NUM_OSD];  //OSD信息列表
    BYTE byRes[32];
}NET_DVR_DECODE_CHANNEL_OSD, *LPNET_DVR_DECODE_CHANNEL_OSD;


typedef struct tagNET_DVR_FACE_THERMOMETRY_ALARM
{
    DWORD   dwSize;
    DWORD   dwChannel;//通道号
    BYTE    byRuleID;                //人脸测温规则ID:1-40
    BYTE    byRes1[3];
    BYTE    byRuleName[NAME_LEN];    //规则名称
    DWORD   dwRelativeTime; //相对时标
    DWORD   dwAbsTime; //绝对时标
    BYTE    byFaceDetectionState;//人脸检测状态；0~未检测到人脸，1~已检测到人脸
    BYTE    byThermometryUnit;//测温单位: 0-摄氏度（℃），1-华氏度（℉），2-开尔文(K)
    BYTE    byAlarmRule;//报警规则；0-最高温大于，1-最高温小于
    BYTE    byRes2[1];
    float   fAlarmTemperature;//触发报警温度（-20.0~120.0℃，精确到小数点后1位）
    float   fRuleTemperature;// 规则配置报警温度（-20.0~60.0℃，精确到小数点后1位）
    DWORD   dwVisibleLightImageLen;// 可见光图片长度
    BYTE    *pVisibleLightImage;  //可见光图片指针
    DWORD   dwFaceImageLen;// 人脸子图长度
    BYTE     *pFaceImage;  //人脸子图指针
    NET_VCA_RECT  struFaceRegion;//人脸目标边界框，设备识别抓拍图片中，人脸子图坐标
    float         fMinTemperature;// 最低温度（-20.0~120.0℃，精确到小数点后1位）
    float         fAverageTemperature;//平均温（-20.0~120.0℃，精确到小数点后1位）
    NET_VCA_POINT struMinTemperaturePoint; //最低温度位置坐标
    NET_VCA_POINT struMaxTemperaturePoint;//最高温度位置坐标
    BYTE     byRes[720];
}NET_DVR_FACE_THERMOMETRY_ALARM, *LPNET_DVR_FACE_THERMOMETRY_ALARM;

typedef struct tagNET_DVR_GUID_FILE_EXPORT
{
    DWORD   dwSize;
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];    //用户登录密码
    BYTE    byRes[128];
}NET_DVR_GUID_FILE_EXPORT, *LPNET_DVR_GUID_FILE_EXPORT;

typedef struct tagNET_DVR_LOGIN_PASSWORDCFG
{
    DWORD   dwSize;
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];    //用户登录密码
    BYTE    byRes[256];
}NET_DVR_LOGIN_PASSWORDCFG, *LPNET_DVR_LOGIN_PASSWORDCFG;

typedef struct tagNET_DVR_SINGLE_SECURITY_QUESTION_CFG
{
    DWORD   dwSize;
    DWORD   dwId;//序号（安全问题序号，只读）
    char    sAnswer[NET_SDK_MAX_ANSWER_LEN/*256*/];//答案（获取时只读）
    BYTE    byMark;//标记  0-未设置 1-已设置
    BYTE    byRes[127];
}NET_DVR_SINGLE_SECURITY_QUESTION_CFG, *LPNET_DVR_SINGLE_SECURITY_QUESTION_CFG;

typedef struct tagNET_DVR_SECURITY_QUESTION_CFG
{
    DWORD   dwSize;
    NET_DVR_SINGLE_SECURITY_QUESTION_CFG  struSecurityQuestion[NET_SDK_MAX_QUESTION_LIST_LEN/*32*/];//安全问题列表
    char    sLoginPassWord[NET_SDK_MAX_LOGIN_PASSWORD_LEN/*128*/];//admin用户登录密码
    BYTE    byRes[512];
}NET_DVR_SECURITY_QUESTION_CFG, *LPNET_DVR_SECURITY_QUESTION_CFG;



typedef struct tagNET_DVR_GUID_FILE_STATUS_INFO
{
    DWORD   dwSize;
    BYTE    byLockStatus; //0：未锁定，1：锁定
    BYTE    byPasswd;     //0:密码错误，1：密码正确。注:该值未锁定时有效。
    BYTE    byRetryNum;   //剩余尝试次数。注:该值未锁定时有效
    BYTE    byRes1;
    DWORD   dwLockTime;   //剩余锁定时间：单位秒。注:该值锁定时有效
    BYTE    byRes[128];
}NET_DVR_GUID_FILE_STATUS_INFO, *LPNET_DVR_GUID_FILE_STATUS_INFO;




typedef struct tagNET_VCA_FACESNAP_RAWDATA_ALARM_
{
    DWORD  dwSize;   //结构大小
    DWORD  dwRelativeTime;       // 相对时标
    DWORD  dwAbsTime;            // 绝对时标
    NET_VCA_DEV_INFO struDevInfo;  //前端设备信息
    DWORD  dwJsonDataLen;        //json数据定义信息，0-没有数据，非0表示有数据（即结构体后跟着的json数据长度）
    BYTE*  pJsonBuff;// json数据指针
    BYTE   byRes[256];           // 保留字节
}NET_VCA_FACESNAP_RAWDATA_ALARM, *LPNET_VCA_FACESNAP_RAWDATA_ALARM;

typedef struct tagNET_DVR_ADVANCE_SCREEN_CHECK_PARAM
{
    BYTE byDelFullScreenGamut;	/*是否删除整屏色域参数,0-否,1-是，byOperateType 为3-删除校正数据时有效*/
    BYTE byDelLightPanelGamut;	/*是否删除灯板色域参数,0-否,1-是，byOperateType 为3-删除校正数据时有效*/
    BYTE byDelLightPanelWhiteBalance;	/*是否删除灯板白平衡参数,0-否,1-是，byOperateType 为3-删除校正数据时有效*/
    BYTE byRes[13];
}NET_DVR_ADVANCE_SCREEN_CHECK_PARAM, *LPNET_DVR_ADVANCE_SCREEN_CHECK_PARAM;

typedef struct tagNET_SDK_LED_SCREEN_CHECK_PARAM
{
    DWORD dwSize;
    BYTE byOperateType; //操作类型，1-写入校正数据，2-校正预览，3-删除校正数据，4-加载原始数据，5-校正原始数据预览
    BYTE byIsRGBSynChk;	//RGB是否同步调整，0-不支持，!0-支持，byOperateType为1、2时有效
    BYTE byScreenCheckType;  //屏幕校正类型,0-普通校正,1-高级校正
    BYTE byRes1;
    WORD wRgbPermil;    //RGB同步调整的千分比，byOperateType为1、2且byIsRGBSynChk非零时有效
    WORD wRedPermil;    //红色调整的千分比，byOperateType为1、2且byIsRGBSynChk为零时有效
    WORD wGreenPermil;  //绿色调整的千分比，byOperateType为1、2且byIsRGBSynChk为零时有效
    WORD wBluePermil;   //蓝色调整的千分比，byOperateType为1、2且byIsRGBSynChk为零时有效
    DWORD dwRectCount;  //矩形区域的数量
    NET_DVR_RECTCFG_EX struRectList[MAX_SCREEN_AREA_NUM];   //矩形区域列表，顺序存放
    NET_DVR_ADVANCE_SCREEN_CHECK_PARAM struAdvanceScreenCheckParam;//高级校正参数,仅byScreenCheckType为1时生效
    BYTE byRes2[48];
}NET_SDK_LED_SCREEN_CHECK_PARAM, *LPNET_SDK_LED_SCREEN_CHECK_PARAM;

typedef struct tagNET_SDK_SCREEN_CHECK_RESPONSE_DATA
{
    DWORD dwSize;
    BYTE byDataType;                //数据类型，1-进度（整体进度），2-状态
    BYTE byOperateType;             //操作类型，1-写入校正数据，2-校正预览，3-删除校正数据
    BYTE byProgress;                //进度，byDataType为1时有效，0-100
    BYTE byStatus;                  //状态，byDataType为2时有效，1-LED屏幕区域校正失败，2-LED屏幕区域对应的接收卡不存在，3-加载校正数据失败（原始数据异常）
    //4-该屏幕型号不支持校正，5-设备忙（正在校正），6-设备内存不足
    NET_DVR_RECTCFG_EX struRect;    //LED屏幕区域，byDataType为2时有效
    BYTE byRes[64];
}NET_SDK_SCREEN_CHECK_RESPONSE_DATA, *LPNET_SDK_SCREEN_CHECK_RESPONSE_DATA;

typedef struct tagNET_DVR_PLAY_BY_NAME_PARA
{
    char szFileName[100]; //回放文件名
    BYTE byDownload;    //是否下载 0-否，1-是
    BYTE byRes1[127];
    HWND hWnd;  //回放的窗口句柄，若置为空，SDK仍能收到码流数据，但不解码显示
    NET_DVR_ADDRESS struAddr; //文件所在集群中CS地址信息，该信息文件查找时会返回
    //如果为空表示本登录地址
    BYTE byRes2[256];
}NET_DVR_PLAY_BY_NAME_PARA, *LPNET_DVR_PLAY_BY_NAME_PARA;

typedef struct tagNET_DVR_PLAYBCK_BYTIME_COND_PCNVR
{
    DWORD           dwSize;   
    NET_DVR_IPADDR  struIpAddr;
    WORD            wIpPort;
    BYTE            byRes[2];
    char            sDomainName[MAX_DOMAIN_NAME];
    char            sSerial[SERIALNO_LEN];  
    LONG            iChannel;
    NET_DVR_TIME    struStartTime;
    NET_DVR_TIME    struStopTime;
    HWND            hWnd;
}NET_DVR_PLAYBCK_BYTIME_COND_PCNVR, *LPNET_DVR_PLAYBCK_BYTIME_COND_PCNVR;

typedef struct tagNET_DVR_DOWNLOAD_BY_NAME_COND
{
    char *pFileName; //回放文件名，包含\0，最大100字节
    char *pSavedFileName;//文件保存位置
    NET_DVR_ADDRESS struAddr; //文件所在集群中CS地址信息，该信息文件查找时会返回
    //如果为空表示本登录地址
    BYTE byRes[256];
}NET_DVR_DOWNLOAD_BY_NAME_COND, *LPNET_DVR_DOWNLOAD_BY_NAME_COND;

typedef struct tagNET_DVR_PIC_PARAM   //查找结果结构体
{
    char *pDVRFileName;  //图片名，包含\0，最大64字节
    char *pSavedFileBuf; //保存图片的缓冲区，内存外部申请释放
    DWORD dwBufLen; //缓冲区大小
    DWORD *lpdwRetLen; //实际收到的数据长度指针，不能为NULL
    NET_DVR_ADDRESS struAddr; //图片所在的地址信息，图片查找时会返回
    BYTE byRes[256];   //保留字节
}NET_DVR_PIC_PARAM, *LPNET_DVR_PIC_PARAM;

typedef struct tagNET_DVR_FACELIB_COND
{
    DWORD       dwSize;
    char        szFDID[NET_SDK_MAX_FDID_LEN/*256*/];//人脸库ID
    BYTE        byConcurrent;//设备并发处理 0-不开启，1-开始
    BYTE        byCover;//是否覆盖式导入 0-否，1-是
    BYTE        byCustomFaceLibID;//FDID是否是自定义，0-不是，1-是；
    /*当”/ISAPI/Intelligent/channels/<ID>/faceContrast/capabilities”能力中返回isSupportNoSaveUploadPicture能力节点时，
    代表非并发处理模式下，支持不保存上传原图的操作:当上传成功图片并设备建模成功后，会将上传的原图进行删除。
    注：该操作无法与并发处理同时进行。*/
    BYTE        byPictureSaveMode;//上传原图保存模式，0-保存，1-不保存;
    BYTE        byIdentityKey[NET_SDK_MAX_INDENTITY_KEY_LEN/*64*/];//交互操作口令
    BYTE        byRes[60];
}NET_DVR_FACELIB_COND, *LPNET_DVR_FACELIB_COND;

typedef struct tagNET_DVR_HBDLIB_COND
{
    DWORD       dwSize;
    char        szHBDID[NET_SDK_MAX_HBDID_LEN/*256*/];//人体库ID
    BYTE        byConcurrent;//设备并发处理 0-不开启，1-开始
    BYTE        byCover;//是否覆盖式导入 0-否，1-是
    BYTE        byCustomHBDID;// HBDID是否是自定义，0-不是，1-是；
    BYTE        byRes[125];
}NET_DVR_HBDLIB_COND, *LPNET_DVR_HBDLIB_COND;


typedef struct tagNET_DVR_GBT28181_AUDIO_OUTPUT_COND
{
    DWORD dwSize;
    DWORD  dwAudioChannel;//语音对讲通道号
    BYTE   byRes[128];
}NET_DVR_GBT28181_AUDIO_OUTPUT_COND, *LPNET_DVR_GBT28181_AUDIO_OUTPUT_COND;

typedef struct tagNET_DVR_GBT28181_AUDIO_OUTPUT_CFG
{
    DWORD                   dwSize;
    char    szAudioOutNumID[MAX_COMPRESSIONID_LEN];//设备语音输出编码ID
    BYTE             byRes[256];
}NET_DVR_GBT28181_AUDIO_OUTPUT_CFG, *LPNET_DVR_GBT28181_AUDIO_OUTPUT_CFG;

typedef struct tagNET_DVR_NOTICE_VIDEO_DATA
{
    DWORD dwSize;
    DWORD dwFileSize;     //文件大小，单位：字节
    BYTE  byNoticeNumber[MAX_NOTICE_NUMBER_LEN]; //公告编号
    BYTE  byRes[2016];
}NET_DVR_NOTICE_VIDEO_DATA, *LPNET_DVR_NOTICE_VIDEO_DATA;

typedef struct tagNET_DVR_NOTICE_VIDEO_DATA_COND
{
    DWORD       dwSize;
    BYTE  byRes[256];          //保留
}NET_DVR_NOTICE_VIDEO_DATA_COND, *LPNET_DVR_NOTICE_VIDEO_DATA_COND;

typedef struct tagNET_DVR_NOTICE_VIDEO_DATA_CFG
{
    DWORD    dwSize;
    DWORD dwDataLen;     //数据长度
    char*  pDataBuffer;     //数据指针
    BYTE  byDataType;      //数据类型：0-无效，1-结构体数据（NET_DVR_NOTICE_VIDEO_DATA），2-视频数据
    BYTE  byRes[63];
}NET_DVR_NOTICE_VIDEO_DATA_CFG, *LPNET_DVR_NOTICE_VIDEO_DATA_CFG;

typedef struct tagNET_DVR_UPGRADE_FIRMWARE_INFO
{
    DWORD dwMagicNumber;    /* 魔术字段，固定值0x484b5753 */
    DWORD dwCheckSum;       /* 文件头校验和 */
    DWORD dwHeadLen;        /* 文件头长度 */
    DWORD dwFileNums;       /* 文件个数 */
    DWORD dwLanguage;       /* 语言，1-英文或多语言，2-中文 */
    DWORD dwDeviceClassID;  /* 1 – DS9000 DVR */
    DWORD dwOemCode;        /* 1 – private  */
    BYTE  byUpgradeVersion; /* 升级版本: 0xFE - 需判断flash, ram, DSP ram 的容量*/
    BYTE  byResFeature[15]; /* 保留字段 */
    BYTE  byFlashSize;      /* 0 - do not need check; 1 - 16M; 2 - 32M; 3 - 64M  */
    BYTE  byRamSize;        /* 0 - do not need check; 1 - 128M; 2 - 256M; 3 - 512M; 4 - 1024M*/
    BYTE  byDspRamSize;     /* 0 - do not need check; 1 - 64M; 2 - 128M; 3 - 256M */
    BYTE  byRes[17];        /* 保留 */
}NET_DVR_UPGRADE_FIRMWARE_INFO, *LPNET_DVR_UPGRADE_FIRMWARE_INFO;

typedef struct tagNET_DVR_SCHEDULE_FILE_RET
{
    DWORD   dwSize;
    char   szFileName[32];    //文件名
    DWORD   dwFileLen;  //文件长度
    BYTE    byRes[64];
}NET_DVR_SCHEDULE_FILE_RET, *LPNET_DVR_SCHEDULE_FILE_RET;

typedef struct tagNET_DVR_EXAM_INFO_COND
{
    DWORD dwSize;
    DWORD dwExamNumber; //考试信息数目
    BYTE  byRes[128];
}NET_DVR_EXAM_INFO_COND, *LPNET_DVR_EXAM_INFO_COND;

typedef struct tagNET_DVR_EXAM_INFO_CFG
{
    DWORD dwSize;
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //考试场次编号（某堂具体考试）
    BYTE  byExamNo[NET_SDK_MAX_EXAM_NO/*64*/]; //考试编号（某次考试，包含多场考试）
    BYTE  byExamSubject[NET_SDK_MAX_EXAM_SUBJECT/*64*/]; //考试科目
    BYTE  byTeacherNo[NET_SDK_MAX_TEACHER_NO/*64*/]; //监考老师编号
    BYTE  byTeacherName[NET_SDK_MAX_TEACHER_NAME/*64*/]; //监考老师姓名
    NET_DVR_TIME    struStartTime; //考试开始时间
    NET_DVR_TIME    struEndTime; //考试结束时间
    BYTE  byExamInfoValid; //考试信息是否有效：0-无效，1-有效（用于考试场次编号删除考试信息，该字段为0时代表删除）
    BYTE  byRes[127];
}NET_DVR_EXAM_INFO_CFG, *LPNET_DVR_EXAM_INFO_CFG;

typedef struct tagNET_DVR_EXAM_INFO_STATUS
{
    DWORD dwSize;
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //考试场次编号（某堂具体考试）
    BYTE  byStatus;  //下发状态：0-无效，1-失败，2-成功（代表该考试场次下发是否成功）
    BYTE  byRes[127];
}NET_DVR_EXAM_INFO_STATUS, *LPNET_DVR_EXAM_INFO_STATUS;

typedef struct tagNET_DVR_EXAMINEE_INFO_COND
{
    DWORD dwSize;
    DWORD dwExamineeNumber; //考生信息数目
    BYTE  byRes[128];
}NET_DVR_EXAMINEE_INFO_COND, *LPNET_DVR_EXAMINEE_INFO_COND;

typedef struct tagNET_DVR_EXAMINEE_INFO_CFG
{
    DWORD dwSize;
    BYTE  byExamineeNo[NET_SDK_MAX_EXAMINEE_NO/*64*/]; //考生编号
    BYTE  byAdmissionTicket[NET_SDK_MAX_ADMISSION_TICKET/*64*/]; //准考证号
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //考试场次编号（某堂具体考试）
    BYTE  byName[NAME_LEN/*32*/]; //姓名
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //考生关联的卡号
    BYTE  bySex; //性别：0-无效，1-男，2-女
    BYTE  byExamineeInfoValid; //考生信息是否有效：0-无效，1-有效（用于考生编号和考试场次编号删除考生信息，该字段为0时代表删除）
    BYTE  byRes[126];
}NET_DVR_EXAMINEE_INFO_CFG, *LPNET_DVR_EXAMINEE_INFO_CFG;

typedef struct tagNET_DVR_EXAMINEE_INFO_STATUS
{
    DWORD dwSize;
    BYTE  byExamineeNo[NET_SDK_MAX_EXAMINEE_NO/*64*/]; //考生编号
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //考试场次编号（某堂具体考试）
    BYTE  byStatus;  //下发状态：0-无效，1-失败，2-成功（代表该考生信息下发是否成功）
    BYTE  byRes[127];
}NET_DVR_EXAMINEE_INFO_STATUS, *LPNET_DVR_EXAMINEE_INFO_STATUS;

typedef struct tagNET_DVR_EXAM_COMPARE_RESULT_COND
{
    DWORD dwSize;
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //考试场次编号（某堂具体考试）
    BYTE  byExamNo[NET_SDK_MAX_EXAM_NO/*64*/]; //考试编号（某次考试，包含多场考试）
    NET_DVR_TIME    struStartTime; //开始时间
    NET_DVR_TIME    struEndTime; //结束时间
    BYTE  byRes[512];
}NET_DVR_EXAM_COMPARE_RESULT_COND, *LPNET_DVR_EXAM_COMPARE_RESULT_COND;

typedef struct tagNET_DVR_EXAM_COMPARE_RESULT_CFG
{
    DWORD dwSize;
    NET_DVR_TIME    struTime; //时间
    BYTE  byExamineeNo[NET_SDK_MAX_EXAMINEE_NO/*64*/]; //考生编号
    BYTE  byAdmissionTicket[NET_SDK_MAX_ADMISSION_TICKET/*64*/]; //准考证号
    BYTE  byExamNo[NET_SDK_MAX_EXAM_NO/*64*/]; //考试编号（某次考试，包含多场考试）
    BYTE  byExamRoundNo[NET_SDK_MAX_EXAM_ROUND_NO/*64*/]; //考试场次编号（某堂具体考试）
    BYTE  byName[NAME_LEN/*32*/]; //姓名
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //考生关联的卡号
    DWORD dwPicDataLen; //比对抓拍图片数据大小，不为0是表示后面带数据
    char  *pPicData; //比对抓拍图片指针
    BYTE  byRes[256];
}NET_DVR_EXAM_COMPARE_RESULT_CFG, *LPNET_DVR_EXAM_COMPARE_RESULT_CFG;

typedef struct tagNET_DVR_BLOCKLIST_PICTURE_COND
{
    DWORD       dwSize;
    DWORD       dwPictureNum; //图片数量
    BYTE  byRes[128];
}NET_DVR_BLOCKLIST_PICTURE_COND, *LPNET_DVR_BLOCKLIST_PICTURE_COND;

typedef struct tagNET_DVR_BLOCKLIST_PICTURE_STATUS
{
    DWORD       dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN/*32*/]; //卡号
    BYTE  byStatus; //状态：0-无效，，1-处理中，2-上传失败，3-成功
    BYTE  byRes[63];
}NET_DVR_BLOCKLIST_PICTURE_STATUS, *LPNET_DVR_BLOCKLIST_PICTURE_STATUS;

typedef struct tagNET_DVR_BLOCKLIST_PICTURE_CFG
{
    DWORD  dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN/*32*/]; //卡号
    BYTE  byName[NAME_LEN/*32*/]; //姓名
    BYTE  bySex; //性别：0-无效，1-男，2-女
    BYTE  byPictureValid; //禁止名单图片是否有效：0-无效，1-有效（用于按卡号删除禁止名单图片，该字段为0时代表删除，删除时不传递禁止名单图片）
    BYTE  byRes1[2];
    DWORD dwPictureLen; //禁止名单图片长度（图片大小不超过1M）
    char*  pPictureBuffer; //禁止名单图片指针
    BYTE  byRes[128];
}NET_DVR_BLOCKLIST_PICTURE_CFG, *LPNET_DVR_BLOCKLIST_PICTURE_CFG;

typedef struct tagNET_DVR_UPLOAD_ID_BLOCKLIST_COND
{
    DWORD       dwSize;
    DWORD       dwBlockListNum; //禁止名单数量
    BYTE  byRes[128];
}NET_DVR_UPLOAD_ID_BLOCKLIST_COND, *LPNET_DVR_UPLOAD_ID_BLOCKLIST_COND;

typedef struct tagNET_DVR_UPLOAD_ID_BLOCKLIST_CFG
{
    DWORD       dwSize;
    NET_DVR_ID_CARD_INFO  struIDCardCfg;//身份证信息（该结构体中姓名和身份证号码为必填项，其他字段为选填项）
    BYTE  byBlockListValid; //身份证禁止名单是否有效：0-无效，1-有效（用于按身份证号码删除身份证禁止名单，该字段为0时代表删除）
    BYTE  byRes[127];
}NET_DVR_UPLOAD_ID_BLOCKLIST_CFG, *LPNET_DVR_UPLOAD_ID_BLOCKLIST_CFG;

typedef struct tagNET_DVR_UPLOAD_ID_BLOCKLIST_STATUS
{
    DWORD       dwSize;
    BYTE  byIDNum[MAX_ID_NUM_LEN];   //身份证号码
    BYTE  byStatus; //状态：0-无效，1-处理中，2-上传失败，3-成功
    BYTE  byRes[63];
}NET_DVR_UPLOAD_ID_BLOCKLIST_STATUS, *LPNET_DVR_UPLOAD_ID_BLOCKLIST_STATUS;

typedef struct tagNET_DVR_ALARM_ISAPI_INFO
{
    char * pAlarmData;           // 报警数据
    DWORD dwAlarmDataLen;   // 报警数据长度
    BYTE byDataType;        // 0-invalid,1-xml,2-json
    BYTE byPicturesNumber;  // 图片数量
    BYTE byRes[2];
    void * pPicPackData;         // 图片变长部分
    BYTE byRes1[32];
}NET_DVR_ALARM_ISAPI_INFO, *LPNET_DVR_ALARM_ISAPI_INFO;

typedef struct tagNET_DVR_ALARM_ISAPI_PICDATA
{
    DWORD dwPicLen;
    BYTE byPicType;  //图片格式: 1- jpg
    BYTE byRes[3];
    char szFilename[MAX_FILE_PATH_LEN];
    BYTE *pPicData;
}NET_DVR_ALARM_ISAPI_PICDATA, *LPNET_DVR_ALARM_ISAPI_PICDATA;

typedef struct tagNET_DVR_FORMAT_HDD
{
    DWORD dwSize;//结构体长度
    DWORD dwDiskNo;//硬盘号，从0开始，0xff表示对所有硬盘有效（不包括只读硬盘）
    NET_DVR_IPADDR struLocateIP;//该硬盘所在设备的IP（对应硬盘管理参数V50中获取到的szHDLocateIP信息）
    BYTE byRes[16];
}NET_DVR_FORMAT_HDD, *LPNET_DVR_FORMAT_HDD;

typedef struct tagNET_DVR_CHECK_FACE_PICTURE_COND
{
    DWORD       dwSize;
    DWORD       dwPictureNum; //图片数量
    BYTE  byCheckTemplate; //0-校验图片是否合法（默认），1-校验图片和建模数据是否匹配
    BYTE  byRes[127];
}NET_DVR_CHECK_FACE_PICTURE_COND, *LPNET_DVR_CHECK_FACE_PICTURE_COND;

typedef struct tagNET_DVR_CHECK_FACE_PICTURE_CFG
{
    DWORD       dwSize;
    DWORD dwPictureNo; //图片编号
    DWORD dwPictureLen; //图片长度（图片大小不超过200k）
    char*  pPictureBuffer; //图片指针
    DWORD dwFaceTemplateLen;  //人脸建模数据长度
    char*  pFaceTemplateBuffer;   //人脸建模数据指针
    BYTE  byRes[248];
}NET_DVR_CHECK_FACE_PICTURE_CFG, *LPNET_DVR_CHECK_FACE_PICTURE_CFG;

typedef struct tagNET_DVR_CHECK_FACE_PICTURE_STATUS
{
    DWORD       dwSize;
    DWORD dwPictureNo; //图片编号
    BYTE  byCheckStatus; //校验结果：0-无效，1-建模成功，2-建模失败，3-人脸模块通讯异常，4-图像无人脸，5-人脸朝上，6-人脸朝下，7-人脸偏左，8-人脸偏右，9-人脸顺时旋转，
    //10 - 人脸逆时旋转，11-人眼间距小，12-人脸和模板匹配，13-人脸和模板不匹配,14-传输数据有误
    BYTE  byRes[127];
}NET_DVR_CHECK_FACE_PICTURE_STATUS, *LPNET_DVR_CHECK_FACE_PICTURE_STATUS;

typedef struct tagNET_SDK_NPQ_STATE_SINGLE
{
    DWORD  dwRttUs;			//rtt，单位us
    DWORD  dwRealRttUs;		//实时rtt，单位us
    DWORD  dwBitRate;        //码率，单位bps
    BYTE   byLossFraction;	//丢包率，单位1/256
    BYTE   byLossFraction2;	//经过恢复之后的丢包率，只能在接收端获取，单位1/256
    BYTE   byRes[126];
}NET_SDK_NPQ_STATE_SINGLE, *LPNET_SDK_NPQ_STATE_SINGLE;

typedef struct tagNET_SDK_NPQ_STATE
{
    DWORD                       dwSize;
    NET_SDK_NPQ_STATE_SINGLE    struAudioState;  //音频传输状态
    NET_SDK_NPQ_STATE_SINGLE    struVideoState;  //视频传输状态
    BYTE                        byRes[256];
}NET_SDK_NPQ_STATE, *LPNET_SDK_NPQ_STATE;

typedef struct tagNET_SDK_NPQ_NOTIFY_PARAM
{
    LONG   iVersion;				//结构体版本，用于以后兼容
    DWORD dwBitRate;		//码率 单位bps
    BOOL   bHaveBitrate;			//码率字段是否有效标志
    BOOL   bHaveForceIframe;		//强制I帧字段是否有效标志
    BOOL   bForceIframe;			//强制I帧
    BOOL   bHaveScale;			    //scale字段是否有效标志,回放时此字段无效,请通过SDK快放接口实现
    float  fScale;				    //scale信息  1、2、4、8,回放时此字段无效,请通过SDK快放接口实现
    BYTE   res[240];
}NET_SDK_NPQ_NOTIFY_PARAM, *LPNET_SDK_NPQ_NOTIFY_PARAM;



typedef struct tagNET_DVR_FACE_AND_TEMPLATE_COND
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //人脸关联的卡号（设置时该参数不设置）
    DWORD dwFaceNum; //设置或获取人脸数量，获取时置为0xffffffff表示获取所有人脸信息
    BYTE  byRes[128];          //保留
}NET_DVR_FACE_AND_TEMPLATE_COND, *LPNET_DVR_FACE_AND_TEMPLATE_COND;

typedef struct tagNET_DVR_FACE_AND_TEMPLATE_CFG
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //人脸关联的卡号 
    DWORD dwFaceLen;  //人脸图片长度（图片大小不超过200k）
    char*  pFaceBuffer;   //人脸图片指针
    DWORD dwFaceTemplateLen;  //人脸建模数据长度
    char*  pFaceTemplateBuffer;   //人脸建模数据指针
    BYTE  byRes[116];
}NET_DVR_FACE_AND_TEMPLATE_CFG, *LPNET_DVR_FACE_AND_TEMPLATE_CFG;

typedef struct tagNET_DVR_FACE_AND_TEMPLATE_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //人脸关联的卡号
    BYTE  byRecvStatus;//人脸下发状态，按字节表示，0-失败，1-成功，2-内存已满（人脸数据满）
    BYTE  byRes[131];
}NET_DVR_FACE_AND_TEMPLATE_STATUS, *LPNET_DVR_FACE_AND_TEMPLATE_STATUS;

typedef struct tagNET_DVR_SINGLE_HEATMAP_RESULT_PDC
{
    DWORD  dwMaxHeatMapValue;//最大热度值
    DWORD  dwMinHeatMapValue;//最小热度值
    DWORD  dwTimeHeatMapValue;// (时间热度值)平均热度值
    WORD   wArrayLine;//图片像素点行值 
    WORD   wArrayColumn;//图片像素点列值 （当行列值为0的时候，像素点值内存信息不存在）
    BYTE*  pBuffer;  //热度图片像素点数据信息
    BYTE   byRes[32];
}NET_DVR_SINGLE_HEATMAP_RESULT_PDC, *LPNET_DVR_SINGLE_HEATMAP_RESULT_PDC;

typedef struct tagNET_DVR_HEATMAP_RESULT_PDC
{
    DWORD  dwSize;
    NET_DVR_TIME_EX   struStartTime;/*开始时间*/
    NET_DVR_TIME_EX   struEndTime;/*结束时间*/
    NET_VCA_DEV_INFO  struDevInfo;/*设备信息*/
    WORD   wDevInfoIvmsChannelEx;     //与NET_VCA_DEV_INFO里的byIvmsChannel含义相同，能表示更大的值。老客户端用byIvmsChannel能继续兼容，但是最大到255。新客户端版本请使用wDevInfoIvmsChannelEx。
    BYTE   byBrokenNetHttp;     //断网续传标志位，0-不是重传数据，1-重传数据
    BYTE   byArrayUnitType;//矩阵单元数据类型（矩阵信息中每个像素点数据的数据类型）,1-byte, 2-short,4- int
    /*
    struSingleHeatMap[0]:表示按人数统计中的画面中停留人数的热度值；
    struSingleHeatMap[1]:表示按人数统计中的画面中离开人数的热度值；
    */
    NET_DVR_SINGLE_HEATMAP_RESULT_PDC struSingleHeatMap[2];
    WORD   wCurNumber;//当前人数
    WORD   wLeaveNumber;//离开人数
	#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    char*   pEventNotificationAlertBuff; //其Buff对应EventNotificationAlert JSON Block("eventType":  "heatmap")
#else
    char*   pEventNotificationAlertBuff; //其Buff对应EventNotificationAlert JSON Block("eventType":  "heatmap")
    BYTE    byRes2[4];
#endif
    DWORD   dwEventNotificationAlertLen;//长度对应EventNotificationAlert JSON Block("eventType":  "heatmap")数据长度
    BYTE    byRes1[48];
}NET_DVR_HEATMAP_RESULT_PDC, *LPNET_DVR_HEATMAP_RESULT_PDC;

typedef struct _NET_AIOP_VIDEO_HEAD_
{
    DWORD dwSize;      //dwSize = sizeof(NET_AIOP_VIDEO_HEAD)
    DWORD dwChannel;    //设备分析通道的通道号；
    NET_DVR_SYSTEM_TIME     struTime; 	//时间
    char  szTaskID[64];     //视频任务ID，来自于视频任务派发
    DWORD dwAIOPDataSize;   //对应AIOPDdata数据长度
    DWORD dwPictureSize;    //对应分析图片长度
    char  szMPID[64];        //检测模型包ID，用于匹配AIOP的检测数据解析；可以通过URI(GET /ISAPI/Intelligent/AIOpenPlatform/algorithmModel/management?format=json)获取当前设备加载的模型包的label description信息；
    BYTE  *pBufferAIOPData;  //AIOPDdata数据
    BYTE  *pBufferPicture;//对应分析图片数据
    BYTE  byPictureMode;//图片数据传输模式 0-二进制，1-武汉云云存储，当byPictureMode为0时pBufferPicture为二进制数据，当byPictureMode为1时pBufferPicture为武汉云URL
    BYTE  byRes2[3];//保留字节
    DWORD dwPresetIndex; //预置点序号
    DWORD dwAddInfoPictureSize;	//对应分析的附加图片长度
    BYTE *pAddInfoPictureBuffer;//对应分析的附加图片数据(对于热成像双通道设备，该节点表示非报警通道的图片)
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    char* pFacePicBuff; //人脸小图图片指针
#else
    char* pFacePicBuff; //人脸小图图片指针
    BYTE  byRes3[4];
#endif
    DWORD dwFacePicBuffLen;//长度对应pFacePicBuff数据长度
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    char* pComparisonPicBuff; //底库比对图图片指针
#else
    char* pComparisonPicBuff; //底库比对图图片指针
    BYTE  byRes4[4];
#endif
    DWORD dwComparisonPicBuffLen;//长度对应pComparisonPicBuff数据长度
    BYTE  byRes[144];
}NET_AIOP_VIDEO_HEAD, *LPNET_AIOP_VIDEO_HEAD;

typedef struct _NET_AIOP_PICTURE_HEAD_
{
    DWORD dwSize;           //dwSize = sizeof(NET_AIOP_PICTURE_HEAD)
    NET_DVR_SYSTEM_TIME    struTime; 	//时间
    char  szPID[64];        //透传下发的图片ID，来自于图片任务派发
    DWORD dwAIOPDataSize;   //对应AIOPDdata数据长度
    BYTE  byStatus;         //状态值：0-成功，1-图片大小错误
    BYTE byPictureMode;//图片数据传输模式(当dwPictureSize>0时有效) 0-二进制，1-武汉云云存储，当byPictureMode为0时pBufferPicture为二进制数据，当byPictureMode为1时pBufferPicture为武汉云URL
    BYTE byRes1[2];
    char szMPID[64]; //检测模型包ID，用于匹配AIOP的检测数据解析；
    BYTE *pBufferAIOPData;//AIOPDdata数据
    DWORD dwPresetIndex; //预置点序号
    DWORD dwPictureSize;   //图片或URL长度
#if (defined(OS_WINDOWS64) || defined(OS_POSIX64))//win64及linux64下指针为8字节
    BYTE *pBufferPicture;//对应分析图片数据或URL
#else
    BYTE *pBufferPicture;//对应分析图片数据或URL
    BYTE  byRes2[4];
#endif
    char szTaskID[64]; //任务ID, 数据中心图片任务分析结果上报携带此字段
    BYTE byRes[104];
}NET_AIOP_PICTURE_HEAD, *LPNET_AIOP_PICTURE_HEAD;

typedef struct tagNET_DVR_DOOR_FILE_UPLOAD_PARAM
{
    DWORD dwSize;
    DWORD dwFileSize;     //文件大小，单位：字节
    BYTE  byFileName[MAX_FILE_NAME_LEN]; //文件名称
    BYTE  byRes1[256];
}NET_DVR_DOOR_FILE_UPLOAD_PARAM, *LPNET_DVR_DOOR_FILE_UPLOAD_PARAM;

typedef struct tagNET_DVR_TRANS_AUDIO_INFO
{
    DWORD  dwSize;                        //结构体大小
    char   sAudioName[AUDIO_FILE_NAME_LEN];  //音频文件名称
    BYTE   byAudioFormat;	               //音频数据格式：0-wav
    BYTE   byRes[127];
}NET_DVR_TRANS_AUDIO_INFO,*LPNET_DVR_TRANS_AUDIO_INFO;

typedef struct _NET_AIOP_POLLING_VIDEO_HEAD_
{
    DWORD dwSize;			//dwSize = sizeof(NET_AIOP_POLLING_VIDEO_HEAD)		
    DWORD dwChannel;      //设备分析通道的通道号(走SDK协议)；
    NET_DVR_SYSTEM_TIME     struTime; 	//时间
    char  szTaskID[64];    //轮询抓图任务ID，来自于轮询抓图任务派发
    DWORD dwAIOPDataSize;	//对应AIOPDdata数据长度
    DWORD dwPictureSize;	//对应分析图片长度
    char  szMPID[64]; //检测模型包ID，用于匹配AIOP的检测数据解析；
    BYTE  *pBufferAIOPData;//AIOPDdata数据
    BYTE  *pBufferPicture;//对应分析图片数据
    BYTE  byPictureMode;//图片数据传输模式 0-二进制，1-武汉云云存储，当byPictureMode为0时pBufferPicture为二进制数据，当byPictureMode为1时pBufferPicture为武汉云URL
    BYTE  byRes2[3];//保留字节
    DWORD dwPresetIndex; //预置点序号
    BYTE  byRes[176];
} NET_AIOP_POLLING_VIDEO_HEAD, *LPNET_AIOP_POLLING_VIDEO_HEAD;

typedef struct _NET_AIOP_HISTORY_VIDEO_HEAD_
{
	DWORD dwSize;			//dwSize = sizeof(_NET_AIOP_HISTORY_VIDEO_HEAD_)		
	DWORD dwChannel;      //设备分析通道的通道号(走SDK协议)；
	NET_DVR_SYSTEM_TIME     struTime; 	//时间
	char  szTaskID[64];    //历史视频任务ID，来自于视频任务派发
	DWORD dwAIOPDataSize;	//AIOP data数据长度
	DWORD dwPictureSize;	//对应分析图片长度
	char szMPID[64]; //检测模型包ID，用于匹配AIOP的检测数据解析；可以通过URI(GET /ISAPI/Intelligent/AIOpenPlatform/algorithmModel/management?format=json)获取当前设备加载的模型包的label description信息；
	BYTE *pBufferAIOPData;//AIOPDdata数据
	BYTE *pBufferPicture;//对应分析图片数据
	BYTE  byPictureMode;//图片数据传输模式 0-二进制，1-武汉云云存储，当byPictureMode为0时pBufferPicture为二进制数据，当byPictureMode为1时pBufferPicture为武汉云URL
	BYTE  byRes[183];
}NET_AIOP_HISTORY_VIDEO_HEAD, *LPNET_AIOP_HISTORY_VIDEO_HEAD;

typedef struct _NET_AIOP_POLLING_SNAP_HEAD_
{
    DWORD dwSize;			//dwSize = sizeof(NET_AIOP_POLLING_SNAP_HEAD)		
    DWORD dwChannel;      //设备分析通道的通道号(走SDK协议)；
    NET_DVR_SYSTEM_TIME     struTime; 	//时间
    char  szTaskID[64];    //轮询抓图任务ID，来自于轮询抓图任务派发
    DWORD dwAIOPDataSize;	//对应AIOPDdata数据长度
    DWORD dwPictureSize;	//对应分析图片长度
    char  szMPID[64];       //检测模型包ID，用于匹配AIOP的检测数据解析；
    BYTE  *pBufferAIOPData;//AIOPDdata数据
    BYTE  *pBufferPicture;//分析图片数据
    BYTE  byPictureMode;//图片数据传输模式 0-二进制，1-武汉云云存储，当byPictureMode为0时pBufferPicture为二进制数据，当byPictureMode为1时pBufferPicture为武汉云URL
    BYTE  byRes2[3];//保留字节
    DWORD dwPresetIndex; //预置点序号
	DWORD dwAddInfoPictureSize;	//对应分析的附加图片长度
	BYTE *pAddInfoPictureBuffer;//对应分析的附加图片数据(对于热成像双通道设备，该节点表示非报警通道的图片)
	BYTE  byRes[168];
} NET_AIOP_POLLING_SNAP_HEAD, *LPNET_AIOP_POLLING_SNAP_HEAD;

typedef struct tagNET_DVR_AI_ALGORITHM_MODEL
{
    DWORD dwSize;
    DWORD dwDescribeLength;  //{AlgorithmModel} 文件长度
    char* pDescribeBuffer; //{AlgorithmModel}文件
    BYTE byRes1[3];//保留字节，使四字节对齐
    DWORD dwLicenseKeyLength; //licenseKey文件长度
    char* pLicenseKeyBuffer;  //licenseKey文件
    BYTE byRes[120];
}NET_DVR_AI_ALGORITHM_MODEL, *LPNET_DVR_AI_ALGORITHM_MODEL;

typedef struct tagNET_DVR_AI_PICTUR_UPLOAD
{
    DWORD       dwSize;
    char         szTaskID[64];   //任务id，strlen.max = 64,业务平台统一维护管理
    char         szPID[64];   //图片id，strlen.max = 64，业务平台统一维护管理
    BYTE        byRes[128];
}NET_DVR_AI_PICTUR_UPLOAD, *LPNET_DVR_AI_PICTUR_UPLOAD;

typedef struct _NET_DVR_CARD_RECORD
{
    DWORD                      dwSize;
    BYTE                        byCardNo[ACS_CARD_NO_LEN];
    BYTE                        byCardType;
    BYTE                        byLeaderCard;
    BYTE                        byUserType;
    BYTE                        byRes1;
    BYTE                        byDoorRight[MAX_DOOR_NUM_256];
    NET_DVR_VALID_PERIOD_CFG    struValid;
    BYTE                        byBelongGroup[MAX_GROUP_NUM_128];
    BYTE                        byCardPassword[CARD_PASSWORD_LEN];
    WORD                        wCardRightPlan[MAX_DOOR_NUM_256];
    DWORD                       dwMaxSwipeTimes;
    DWORD                       dwSwipeTimes;
    DWORD                       dwEmployeeNo;
    BYTE                        byName[NAME_LEN];
    //按位表示，0-无权限，1-有权限
    //第0位表示：弱电报警
    //第1位表示：开门提示音
    //第2位表示：限制客卡
    //第3位表示：通道
    //第4位表示：反锁开门
    //第5位表示：巡更功能
    DWORD                      dwCardRight;
    BYTE                       byRes[256];
}NET_DVR_CARD_RECORD, *LPNET_DVR_CARD_RECORD;

typedef struct _NET_DVR_CARD_COND
{
    DWORD dwSize;
    DWORD dwCardNum; //设置或获取卡数量，获取时置为0xffffffff表示获取所有卡信息
    BYTE  byRes[64];
}NET_DVR_CARD_COND, *LPNET_DVR_CARD_COND;

typedef struct _NET_DVR_CARD_SEND_DATA
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //卡号
    BYTE  byRes[16];
}NET_DVR_CARD_SEND_DATA, *LPNET_DVR_CARD_SEND_DATA;

typedef struct _NET_DVR_CARD_STATUS
{
    DWORD   dwSize;
    BYTE    byCardNo[ACS_CARD_NO_LEN];
    DWORD   dwErrorCode;
    BYTE    byStatus; // 状态：0-失败，1-成功
    BYTE    byRes[23];
}NET_DVR_CARD_STATUS, *LPNET_DVR_CARD_STATUS;

typedef struct  _NET_DVR_FACE_RECORD
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];    //人脸关联的卡号 
    DWORD dwFaceLen;    //人脸数据长度
    BYTE* pFaceBuffer;  //人脸数据指针
    BYTE  byRes[128];
}NET_DVR_FACE_RECORD, *LPNET_DVR_FACE_RECORD;

typedef struct _NET_DVR_FACE_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //人脸关联的卡号
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //下发错误信息，当byCardReaderRecvStatus为4时，表示已存在人脸对应的卡号
    DWORD  dwReaderNo;  //人脸读卡器编号，可用于下发错误返回
    BYTE  byRecvStatus;  //人脸读卡器状态，按字节表示，0-失败，1-成功，2-重试或人脸质量差，3-内存已满(人脸数据满)，4-已存在该人脸，5-非法人脸ID
    //,6-算法建模失败，7-未下发卡权限，8-未定义（保留），9-人眼间距小距小，10-图片数据长度小于1KB，11-图片格式不符（png/jpg/bmp）,12-图片像素数量超过上限，13-图片像素数量低于下限，14-图片信息校验失败，15-图片解码失败，16-人脸检测失败，17-人脸评分失败
    BYTE  byRes[131];
}NET_DVR_FACE_STATUS, *LPNET_DVR_FACE_STATUS;

typedef struct _NET_DVR_FACE_COND
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN];    //人脸关联的卡号（设置时该参数可不设置）
    DWORD dwFaceNum;    // 设置或获取人脸数量，获取时置为0xffffffff表示获取所有人脸信息
    DWORD dwEnableReaderNo;   // 人脸读卡器编号
    BYTE  byRes[124];   // 保留
}NET_DVR_FACE_COND, *LPNET_DVR_FACE_COND;

typedef struct _NET_DVR_FINGERPRINT_RECORD
{
    DWORD  dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号 
    DWORD dwFingerPrintLen;     //指纹数据长度
    DWORD  dwEnableReaderNo;     //需要下发指纹的读卡器编号
    BYTE  byFingerPrintID;      //手指编号，有效值范围为1-10
    BYTE  byFingerType;         //指纹类型  0-普通指纹，1-胁迫指纹
    BYTE  byRes1[30];
    BYTE  byFingerData[MAX_FINGER_PRINT_LEN];        //指纹数据内容
    BYTE  byRes[96];
}NET_DVR_FINGERPRINT_RECORD, *LPNET_DVR_FINGERPRINT_RECORD;

typedef struct _NET_DVR_FINGERPRINT_STATUS
{
    DWORD dwSize;
    BYTE  byCardNo[ACS_CARD_NO_LEN]; //指纹关联的卡号
    BYTE  byCardReaderRecvStatus;  //指纹读卡器状态，按字节表示，0-失败，1-成功，2-该指纹模组不在线，3-重试或指纹质量差，4-内存已满，5-已存在该指纹，6-已存在该指纹ID，7-非法指纹ID，8-该指纹模组无需配置
    BYTE  byFingerPrintID;     //手指编号，有效值范围为1-10
    BYTE  byFingerType;       //指纹类型  0-普通指纹，1-胁迫指纹
    BYTE  byRecvStatus;    //主机错误状态：0-成功，1-手指编号错误，2-指纹类型错误，3-卡号错误（卡号规格不符合设备要求），4-指纹未关联工号或卡号（工号或卡号字段为空），5-工号不存在，6-指纹数据长度为0，7-读卡器编号错误，8-工号错误
    BYTE  byErrorMsg[ERROR_MSG_LEN]; //下发错误信息，当byCardReaderRecvStatus为5时，表示已存在指纹对应的卡号
    DWORD dwCardReaderNo;   //当byCardReaderRecvStatus为5时，表示已存在指纹对应的指纹读卡器编号，可用于下发错误返回。0时表示无错误信息
    BYTE  byRes[20];
}NET_DVR_FINGERPRINT_STATUS, *LPNET_DVR_FINGERPRINT_STATUS;

typedef struct tagNET_DVR_FINGERPRINT_COND
{
    DWORD   dwSize;
    DWORD   dwFingerprintNum;
    BYTE    byCardNo[ACS_CARD_NO_LEN];
    DWORD   dwEnableReaderNo;
    BYTE    byFingerPrintID;
    BYTE    byRes[131];
}NET_DVR_FINGERPRINT_COND, *LPNET_DVR_FINGERPRINT_COND;

typedef struct tagNET_DVR_CAPTURE_DATA_COND
{
    DWORD  dwSize;
    char   szPassword[128];   //秘钥，字符串
    BYTE   byRes[128];
}NET_DVR_CAPTURE_DATA_COND, *LPNET_DVR_CAPTURE_DATA_COND;

typedef struct  tagNET_DVR_EZVIZ_USER_LOGIN_INFO
{
    char sEzvizServerAddress[NET_DVR_DEV_ADDRESS_MAX_LEN]; //云服务器地址 
    WORD wPort;       //云服务器端口
    BYTE byLogin;
    BYTE byRes1[1];
    char sClassSession[EZVIZ_CLASSSESSION_LEN];  //ClassSession, 服务器分配的一个字符串，每次通信时需要发送给服务器
    char sDeviceID[EZVIZ_DEVICEID_LEN];          //设备ID， 由服务器分配的     
    BYTE byRes2[128];
}NET_DVR_EZVIZ_USER_LOGIN_INFO, *LPNET_DVR_EZVIZ_USER_LOGIN_INFO;

typedef struct  tagNET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO
{
    char sEzvizServerAddress[NET_DVR_DEV_ADDRESS_MAX_LEN]; //云服务器地址
    BYTE byRes1[3];
    WORD wPort;       //云服务器端口
    BYTE byRes2[2];
    char sUrl[EZVIZ_REQURL_LEN];
    char sAccessToken[EZVIZ_ACCESSTOKEN_LEN];    //accessToken, 服务器分配的一个字符串，每次通信时需要发送给服务器
    char sDeviceID[EZVIZ_DEVICEID_LEN];            //设备ID， 由服务器分配的
    char sClientType[EZVIZ_CLIENTTYPE_LEN];        //客户端类型: 0: PC-控件 1: ios 2: android
    char sFeatureCode[EZVIZ_FEATURECODE_LEN];    //硬件特征码
    char sOsVersion[EZVIZ_OSVERSION_LEN];        //终端系统版本, 例如: IOS 7.0.4, Android 2.3.
    char sNetType[EZVIZ_NETTYPE_LEN];            //网络类型, UNKNOWN GPRS EDGE UMTS HSDPA HSUPA HSPA CDMAEVDO_0 EVDO_A EVDO_B 1xRTT IDEN WIFI
    char sSdkVersion[EZVIZ_SDKVERSION_LEN];        //Sdk版本号, v.1.0.20140720.45xx
    char sAppID[EZVIZ_APPID_LEN];                //AppID，ios上报BundleID，Android上报包名
    BYTE byRes3[512];
}NET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO, *LPNET_DVR_OPEN_EZVIZ_USER_LOGIN_INFO;


typedef struct tagNET_ALARM_EXCEPTION
{
    DWORD dwAlarmType;                    //报警类型
    BYTE byExceptionType;                 //报警异常类型,参见 ALARM_EXCEPTION_ERROR_ENUM
    BYTE byRes[3];                        //
    char szErrMsg[MAX_ERROR_MSG_LEN];     //错误信息描述
    BYTE byRes1[248];                     //
}NET_ALARM_EXCEPTION, *LPNET_ALARM_EXCEPTION;


typedef struct tagNET_DVR_AUTOTEST_CFG_HEAD
{
    DWORD   dwSize;
    DWORD   dwInfoType;         //1表示视频测试，3表示语音对讲测试
    DWORD   dwRetResult;
    DWORD   dwDataBodySize;     //后面跟随的结构体内容大小
    void*   lpDataBody;         //后面跟随的结构体
    BYTE    byRes[32];
}NET_DVR_AUTOTEST_CFG_HEAD,*LPNET_DVR_AUTOTEST_CFG_HEAD;

typedef struct tagNET_DVR_AUTOTEST_VIDEO_CFG
{
    DWORD  dwSplitScreenNums;  //分屏数，支持1、4、9
    DWORD  dwVoCh;             //默认填写1
    DWORD  dwInterface;         //1表示CVBS、2表示HDMI、3表示VGA、4表示辅口HDMI
}NET_DVR_AUTOTEST_VIDEO_CFG,*LPNET_DVR_AUTOTEST_VIDEO_CFG;

typedef struct tagNET_DVR_AUTOTEST_AUDIO_CFG
{
    DWORD  dwVoCh;            //默认填写2
    DWORD  dwOpen;            //1开启，0不开启
}NET_DVR_AUTOTEST_AUDIO_CFG, *LPNET_DVR_AUTOTEST_AUDIO_CFG;

typedef struct _NET_DVR_AUDIOENCInfo                     /* 信息 */
{
    DWORD            in_frame_size;                /* 输入一帧数据大小(BYTES)，由GetInfoParam函数返回         */
    int            reserved[16];                 /* 保留 */
} NET_DVR_AUDIOENC_INFO;


typedef struct _NET_DVR_AUDIOENC_PROCESS_PARAM_
{
    unsigned char		*in_buf;                      /* 输入buf */
    unsigned char		*out_buf;                     /* 输出buf */
    DWORD			out_frame_size;               /* 编码一帧后的BYTE数 */

    int				g726enc_reset;                /* 重置开关 */
    int				g711_type;                    /* g711编码类型,0 - U law, 1- A law */
    ENUM_AUDIO_ENC_MODE	enc_mode;                     /* 音频编码模式，AMR编码配置 */
    int				reserved[16];                 /* 保留 */
}NET_DVR_AUDIOENC_PROCESS_PARAM;

typedef struct _NET_DVR_AUDIODECInfo                     /* 信息 */
{
    int            nchans;                         /* 声道数 */
    int            sample_rate;                  /* 采样率 */
    int            aacdec_profile;               /* 编码用的框架 */
    int            reserved[16];                 /* 保留 */
} NET_DVR_AUDIODEC_INFO;

typedef struct _NET_DVR_AUDIODEC_PROCESS_PARAM
{
    unsigned char		*in_buf;                      /* 输入数据buf */
    unsigned char		*out_buf;                     /* 输出数据buf */
    DWORD			in_data_size;                 /* 输入in_buf内数据byte数 */
    DWORD			proc_data_size;               /* 输出解码库处理in_buf中数据大小bytes */
    DWORD			out_frame_size;               /* 解码一帧后数据BYTE数 */
    NET_DVR_AUDIODEC_INFO		dec_info;                     /* 输出解码信息 */

    int				g726dec_reset;                /* 重置开关 */
    int				g711_type;                    /* g711编码类型,0 - U law, 1- A law */
    int				reserved[16];                 /* 保留 */
} NET_DVR_AUDIODEC_PROCESS_PARAM;

